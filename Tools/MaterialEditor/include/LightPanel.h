
#pragma once

#include "Autogenerated/MaterialEditorBaseAutogen.h"

#include "MaterialEditorCommon.h"

class MainWindow;

OGRE_ASSUME_NONNULL_BEGIN

// Forward declaration for |Document|.
namespace rapidjson
{
    class CrtAllocator;
    template <typename>
    class MemoryPoolAllocator;
    template <typename>
    struct UTF8;
    template <typename, typename, typename>
    class GenericDocument;
    typedef GenericDocument<UTF8<char>, MemoryPoolAllocator<CrtAllocator>, CrtAllocator> Document;

    template <typename BaseAllocator>
    class MemoryPoolAllocator;
    template <typename Encoding, typename>
    class GenericValue;
    typedef GenericValue<UTF8<char>, MemoryPoolAllocator<CrtAllocator> > Value;
}  // namespace rapidjson

class LightPanel final : public LightPanelBase
{
    MainWindow *m_mainWindow;

    Ogre::SceneNode              *m_masterNode;
    Ogre::SceneNode              *m_secondaryNode;
    Ogre::SceneNode *ogre_nonnull m_lightNodes[3];

    double   m_eulerAngles[3];
    uint32_t m_currPresetIdx;

    bool m_editing;
    bool m_ignoreUndo;
    /// wxWidgets emits UndoMouseUp() then OnSlider(). Thus if we set m_ignoreUndo = false in UndoMouseUp
    /// we'll push the current datablock.
    /// This doesn't happen with keyboard because it emits OnSlider() then UndoKeyUp().
    bool m_undoMouseUp;

    void reorientLights();

    SliderTextWidgetAngle getEulerSliders( size_t idx );

protected:
    // Handlers for LightPanelBase events.
    void OnPresetChoice( wxCommandEvent &event ) override;
    void OnCheckbox( wxCommandEvent &event ) override;
    void OnEulerText( wxCommandEvent &event ) override;
    void OnSlider( wxCommandEvent &event ) override;
    void OnText( wxCommandEvent &event ) override;

    void UndoMouseUp( wxMouseEvent &event ) override;
    void UndoKeyUp( wxKeyEvent &event ) override;
    void UndoKillFocus( wxFocusEvent &event ) override;

public:
    LightPanel( MainWindow *parent );

    void setCoordinateConvention( CoordinateConvention::CoordinateConvention newConvention );
    void setCameraRelative( const bool bCameraRelative );
    bool isCameraRelative() const;
    void notifyMeshChanged();

    void setPreset( const uint32_t preset );

    void loadProject( const rapidjson::Document &d );
    void saveProject( Ogre::String &jsonString );
};

OGRE_ASSUME_NONNULL_END
