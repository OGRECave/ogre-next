<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::PsoCacheHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_pso_cache_helper.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_pso_cache_helper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::PsoCacheHelper Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Utility class to cache PSOs.  
 <a href="class_ogre_1_1_pso_cache_helper.html#details">More...</a></p>

<p><code>#include &lt;OgrePsoCacheHelper.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::PsoCacheHelper:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_pso_cache_helper__inherit__graph.svg" width="186" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2cf5647fb77ed43b8246af90ed80665b" id="r_a2cf5647fb77ed43b8246af90ed80665b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a2cf5647fb77ed43b8246af90ed80665b">PsoCacheHelper</a> (<a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *renderSystem)</td></tr>
<tr class="separator:a2cf5647fb77ed43b8246af90ed80665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6c46d268ae457843aa10aac3a2fa1f" id="r_a2e6c46d268ae457843aa10aac3a2fa1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a2e6c46d268ae457843aa10aac3a2fa1f">~PsoCacheHelper</a> ()</td></tr>
<tr class="separator:a2e6c46d268ae457843aa10aac3a2fa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457666e62277abc364179e399c2c1391" id="r_a457666e62277abc364179e399c2c1391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a457666e62277abc364179e399c2c1391">clearState</a> ()</td></tr>
<tr class="separator:a457666e62277abc364179e399c2c1391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b63b354ebf78153c5783142a0805994" id="r_a2b63b354ebf78153c5783142a0805994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_hlms_pso.html">HlmsPso</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a2b63b354ebf78153c5783142a0805994">getPso</a> ()</td></tr>
<tr class="memdesc:a2b63b354ebf78153c5783142a0805994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> you can set via renderSystem-&gt;_setPipelineStateObject based on all past calls to setRenderTarget + setVertexFormat + setMacroblock + etc.  <br /></td></tr>
<tr class="separator:a2b63b354ebf78153c5783142a0805994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e47255d7cbcac1ab8fb9a5e0912b4c0" id="r_a8e47255d7cbcac1ab8fb9a5e0912b4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_hlms_pso.html">HlmsPso</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a8e47255d7cbcac1ab8fb9a5e0912b4c0">getPso</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> renderableHash, bool renderableCacheAlreadySet=false)</td></tr>
<tr class="memdesc:a8e47255d7cbcac1ab8fb9a5e0912b4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> you can set via renderSystem-&gt;_setPipelineStateObject based on the input hash calculated via getRenderableHash.  <br /></td></tr>
<tr class="separator:a8e47255d7cbcac1ab8fb9a5e0912b4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf12fa0ee660d9b12afd903c63e6db0" id="r_a7bf12fa0ee660d9b12afd903c63e6db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a7bf12fa0ee660d9b12afd903c63e6db0">getRenderableHash</a> ()</td></tr>
<tr class="memdesc:a7bf12fa0ee660d9b12afd903c63e6db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash value you can cache into a <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> (or whatever you're rendering).  <br /></td></tr>
<tr class="separator:a7bf12fa0ee660d9b12afd903c63e6db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241dc6283b69aff14cb6cac0a94a8e9b" id="r_a241dc6283b69aff14cb6cac0a94a8e9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a241dc6283b69aff14cb6cac0a94a8e9b">setBlendblock</a> (const <a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> *blendblock)</td></tr>
<tr class="memdesc:a241dc6283b69aff14cb6cac0a94a8e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls to this function cannot be skipped unless you have a renderableHash.    <br /></td></tr>
<tr class="separator:a241dc6283b69aff14cb6cac0a94a8e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c42036817973cdf31f0007beda3426b" id="r_a2c42036817973cdf31f0007beda3426b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a2c42036817973cdf31f0007beda3426b">setMacroblock</a> (const <a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> *macroblock)</td></tr>
<tr class="memdesc:a2c42036817973cdf31f0007beda3426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls to this function cannot be skipped unless you have a renderableHash.  <br /></td></tr>
<tr class="separator:a2c42036817973cdf31f0007beda3426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6cde2771419d0e7add22c9062726ce" id="r_aec6cde2771419d0e7add22c9062726ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#aec6cde2771419d0e7add22c9062726ce">setPixelShader</a> (<a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;shader)</td></tr>
<tr class="memdesc:aec6cde2771419d0e7add22c9062726ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls to this function can be skipped if it's valid to not have a shader set at this stage, or if you have a renderableHash.    <br /></td></tr>
<tr class="separator:aec6cde2771419d0e7add22c9062726ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae3346100de461609296b037e92fe42" id="r_a7ae3346100de461609296b037e92fe42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a7ae3346100de461609296b037e92fe42">setRenderTarget</a> (const <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a> *renderPassDesc)</td></tr>
<tr class="memdesc:a7ae3346100de461609296b037e92fe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">You must call this function every frame, and every time the RenderTarget changes.  <br /></td></tr>
<tr class="separator:a7ae3346100de461609296b037e92fe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18fbff8dd7393c89fdb1c3412d3525c" id="r_ae18fbff8dd7393c89fdb1c3412d3525c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#ae18fbff8dd7393c89fdb1c3412d3525c">setVertexFormat</a> (const <a class="el" href="namespace_ogre.html#abdf543378d3741e0b20039e582e55a16">VertexElement2VecVec</a> &amp;vertexElements, <a class="el" href="group___general.html#ga0ef99399e9e670e7bb69dc373968a666">OperationType</a> operationType, bool enablePrimitiveRestart)</td></tr>
<tr class="memdesc:ae18fbff8dd7393c89fdb1c3412d3525c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be skipped if no vertex buffer is used (e.g.  <br /></td></tr>
<tr class="separator:ae18fbff8dd7393c89fdb1c3412d3525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c3710135758e86e41a407a1440789e" id="r_a50c3710135758e86e41a407a1440789e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pso_cache_helper.html#a50c3710135758e86e41a407a1440789e">setVertexShader</a> (<a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;shader)</td></tr>
<tr class="memdesc:a50c3710135758e86e41a407a1440789e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls to this function can be skipped if it's valid to not have a shader set at this stage, or if you have a renderableHash.  <br /></td></tr>
<tr class="separator:a50c3710135758e86e41a407a1440789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility class to cache PSOs. </p>
<p>Useful for porting <a class="el" href="namespace_ogre_1_1v1.html">v1</a> libraries (eg. Gorilla) that render in "immediate mode" style and weren't build with PSOs in mind. Ideally a PSO would be created ahead of time and its pointer stored alongside the renderable you need to render. </p><dl class="section user"><dt></dt><dd>Almost all functions already do redundant state checking unless explicitly stated, thus there is no need for you to do it yourself. </dd></dl>
<dl class="section user"><dt></dt><dd>Usage (example) "OK": <a class="el" href="class_ogre_1_1_pso_cache_helper.html" title="Utility class to cache PSOs.">PsoCacheHelper</a> psoCache( renderSystem ); //Save this variable (i.e. per class)</dd></dl>
<p>void render() { psoCache.clearState(); psoCache.setRenderTarget( renderTarget ); for( int i=0; i&lt;numMaterials; ++i ) { psoCache.setMacroblock( material[i].macroblock ); psoCache.setBlendblock( material[i].blendblock ); psoCache.setVertexShader( material[i].vertexShader ); psoCache.setPixelShader( material[i].pixelShader ); for( int j=0; j&lt;numThingsToRenderPerMaterial; ++j ) { <a class="el" href="class_ogre_1_1v1_1_1_render_operation.html" title="&#39;New&#39; rendering operation using vertex buffers.">v1::RenderOperation</a> renderOp = renderables[j].renderOp; Consider caching 'vertexElements' somewhere as convertToV2 involves allocations VertexElement2VecVec vertexElements = renderOp.vertexData-&gt; vertexDeclaration-&gt;convertToV2(); psoCache.setVertexFormat( vertexElements, renderOp.operationType, enablePrimitiveRestart );</p>
<p><a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> *pso = psoCache.getPso(); renderSystem-&gt;_setPipelineStateObject( pso ); } } }</p>
<p>Usage "MUCH better": <a class="el" href="class_ogre_1_1_pso_cache_helper.html" title="Utility class to cache PSOs.">PsoCacheHelper</a> psoCache( renderSystem ); //Save this variable (i.e. per class)</p>
<p>Outside rendering, just ONCE at loading time or when the material changes (or the vertex layout changes): psoCache.clearState(); psoCache.setMacroblock( material[i].macroblock ); psoCache.setBlendblock( material[i].blendblock ); psoCache.setVertexShader( material[i].vertexShader ); psoCache.setPixelShader( material[i].pixelShader ); for( int j=0; j&lt;numThingsToRenderPerMaterial; ++j ) { <a class="el" href="class_ogre_1_1v1_1_1_render_operation.html" title="&#39;New&#39; rendering operation using vertex buffers.">v1::RenderOperation</a> renderOp = renderables[j].renderOp; Consider caching 'vertexElements' somewhere as convertToV2 involves allocations VertexElement2VecVec vertexElements = renderOp.vertexData-&gt; vertexDeclaration-&gt;convertToV2(); psoCache.setVertexFormat( vertexElements, renderOp.operationType, enablePrimitiveRestart );</p>
<p>renderables[j].customSavedValue = psoCache.getRenderableHash(); }</p>
<p>During render: void render() { psoCache.clearState(); setRenderTarget still needs to be called. psoCache.setRenderTarget( renderTarget ); for( int i=0; i&lt;numMaterials; ++i ) { for( int j=0; j&lt;numThingsToRenderPerMaterial; ++j ) { <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> *pso = psoCache.getPso( renderables[j].customSavedValue ); renderSystem-&gt;_setPipelineStateObject( pso ); } } } </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2cf5647fb77ed43b8246af90ed80665b" name="a2cf5647fb77ed43b8246af90ed80665b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf5647fb77ed43b8246af90ed80665b">&#9670;&#160;</a></span>PsoCacheHelper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::PsoCacheHelper::PsoCacheHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>renderSystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e6c46d268ae457843aa10aac3a2fa1f" name="a2e6c46d268ae457843aa10aac3a2fa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6c46d268ae457843aa10aac3a2fa1f">&#9670;&#160;</a></span>~PsoCacheHelper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::PsoCacheHelper::~PsoCacheHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a457666e62277abc364179e399c2c1391" name="a457666e62277abc364179e399c2c1391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457666e62277abc364179e399c2c1391">&#9670;&#160;</a></span>clearState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PsoCacheHelper::clearState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b63b354ebf78153c5783142a0805994" name="a2b63b354ebf78153c5783142a0805994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b63b354ebf78153c5783142a0805994">&#9670;&#160;</a></span>getPso() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_hlms_pso.html">HlmsPso</a> * Ogre::PsoCacheHelper::getPso </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> you can set via renderSystem-&gt;_setPipelineStateObject based on all past calls to setRenderTarget + setVertexFormat + setMacroblock + etc. </p>
<p>Use this version if for architecture reasons (i.e. legacy code, time constraints) you can't store the hash at loading time into the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> for later reuse. </p><dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> to use. Do NOT persistently store this pointer. It may be invalidated if the next getPso call needs to create a new PSO. </dd></dl>

</div>
</div>
<a id="a8e47255d7cbcac1ab8fb9a5e0912b4c0" name="a8e47255d7cbcac1ab8fb9a5e0912b4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e47255d7cbcac1ab8fb9a5e0912b4c0">&#9670;&#160;</a></span>getPso() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_hlms_pso.html">HlmsPso</a> * Ogre::PsoCacheHelper::getPso </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>renderableHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>renderableCacheAlreadySet</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> you can set via renderSystem-&gt;_setPipelineStateObject based on the input hash calculated via getRenderableHash. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Don't call getRenderableHash for every object every frame and then this function. That's inefficient. If you can't save the hash at loading time / when materials are set, just call the other getPso overload directly. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderableHash</td><td>The hash obtained from getRenderableHash which you should've saved in the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a>. </td></tr>
    <tr><td class="paramname">renderableCacheAlreadySet</td><td>Internal parameter. Leave the default. Used by the other getPso overload to tell there is no need to perform a linear O(N) search in mRenderableCache because mCurrentState is up to date (this search only happens if the PSO hadn't been already cached). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> to use. Do NOT persistently store this pointer. It may be invalidated if the next getPso call needs to create a new PSO. </dd></dl>

</div>
</div>
<a id="a7bf12fa0ee660d9b12afd903c63e6db0" name="a7bf12fa0ee660d9b12afd903c63e6db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf12fa0ee660d9b12afd903c63e6db0">&#9670;&#160;</a></span>getRenderableHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::PsoCacheHelper::getRenderableHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash value you can cache into a <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> (or whatever you're rendering). </p>
<p>This hash will contain VertexFormat, Macroblock, Blendblock information and shaders set, but nothing that is part of the pass (RenderTargets attached, RTT formats, stencil parameters, etc). You would later insert this value to getPso( renderableHash ); See examples in the class description. </p><dl class="section remark"><dt>Remarks</dt><dd>The hash is deterministic, but depends on the order in which they're created. The hash is immune to collisions (unless you overflow 2^RenderableBits). </dd></dl>
<dl class="section user"><dt></dt><dd>Do NOT call this function every frame per object. The goal is that you only call this function when the object is being loaded (i.e. once) or when the object has changed (e.g. new material, vertex definition information was changed). </dd></dl>
<dl class="section user"><dt></dt><dd>If you can't perform this optimization, just set every state for every object every frame (like in the first example) and call getPso. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The hash containing all the information. </dd></dl>

</div>
</div>
<a id="a241dc6283b69aff14cb6cac0a94a8e9b" name="a241dc6283b69aff14cb6cac0a94a8e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241dc6283b69aff14cb6cac0a94a8e9b">&#9670;&#160;</a></span>setBlendblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PsoCacheHelper::setBlendblock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> *&#160;</td>
          <td class="paramname"><em>blendblock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls to this function cannot be skipped unless you have a renderableHash.   </p>

</div>
</div>
<a id="a2c42036817973cdf31f0007beda3426b" name="a2c42036817973cdf31f0007beda3426b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c42036817973cdf31f0007beda3426b">&#9670;&#160;</a></span>setMacroblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PsoCacheHelper::setMacroblock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> *&#160;</td>
          <td class="paramname"><em>macroblock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls to this function cannot be skipped unless you have a renderableHash. </p>

</div>
</div>
<a id="aec6cde2771419d0e7add22c9062726ce" name="aec6cde2771419d0e7add22c9062726ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6cde2771419d0e7add22c9062726ce">&#9670;&#160;</a></span>setPixelShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PsoCacheHelper::setPixelShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls to this function can be skipped if it's valid to not have a shader set at this stage, or if you have a renderableHash.   </p>

</div>
</div>
<a id="a7ae3346100de461609296b037e92fe42" name="a7ae3346100de461609296b037e92fe42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae3346100de461609296b037e92fe42">&#9670;&#160;</a></span>setRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PsoCacheHelper::setRenderTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a> *&#160;</td>
          <td class="paramname"><em>renderPassDesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You must call this function every frame, and every time the RenderTarget changes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Warning: This function will not check for redundant state changes (there's a lot that could've changed: stencil settings, depth buffer, etc)</dd></dl>
<p>This function is a PASS state changing function, and its information is not part of getRenderableHash. </p>

</div>
</div>
<a id="ae18fbff8dd7393c89fdb1c3412d3525c" name="ae18fbff8dd7393c89fdb1c3412d3525c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18fbff8dd7393c89fdb1c3412d3525c">&#9670;&#160;</a></span>setVertexFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PsoCacheHelper::setVertexFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#abdf543378d3741e0b20039e582e55a16">VertexElement2VecVec</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga0ef99399e9e670e7bb69dc373968a666">OperationType</a>&#160;</td>
          <td class="paramname"><em>operationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enablePrimitiveRestart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can be skipped if no vertex buffer is used (e.g. </p>
<p>you use gl_VertexID or other trickery) or if you have a renderableHash. </p>

</div>
</div>
<a id="a50c3710135758e86e41a407a1440789e" name="a50c3710135758e86e41a407a1440789e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c3710135758e86e41a407a1440789e">&#9670;&#160;</a></span>setVertexShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PsoCacheHelper::setVertexShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls to this function can be skipped if it's valid to not have a shader set at this stage, or if you have a renderableHash. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_pso_cache_helper_8h.html">OgrePsoCacheHelper.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_pso_cache_helper.html">PsoCacheHelper</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
