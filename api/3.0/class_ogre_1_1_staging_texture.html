<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::StagingTexture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE-Next
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_staging_texture.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_staging_texture-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::StagingTexture Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> is an intermediate texture that can be read and be written from both CPU &amp; GPU.  
 <a href="class_ogre_1_1_staging_texture.html#details">More...</a></p>

<p><code>#include &lt;OgreStagingTexture.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::StagingTexture:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_staging_texture__inherit__graph.svg" width="887" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a42f8c5ea7655620d3c4594a60da8706b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a42f8c5ea7655620d3c4594a60da8706b">StagingTexture</a> (<a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> formatFamily)</td></tr>
<tr class="separator:a42f8c5ea7655620d3c4594a60da8706b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82ed990ee417cb7aabea60909c1bf78"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#ae82ed990ee417cb7aabea60909c1bf78">~StagingTexture</a> ()</td></tr>
<tr class="separator:ae82ed990ee417cb7aabea60909c1bf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f86b602c961f86724e3eb6dce3220b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a63f86b602c961f86724e3eb6dce3220b">_getSizeBytes</a> ()=0</td></tr>
<tr class="memdesc:a63f86b602c961f86724e3eb6dce3220b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size in bytes.  <a href="class_ogre_1_1_staging_texture.html#a63f86b602c961f86724e3eb6dce3220b">More...</a><br /></td></tr>
<tr class="separator:a63f86b602c961f86724e3eb6dce3220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b8938d61a62eb3c88df9f5d8c21185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a78b8938d61a62eb3c88df9f5d8c21185">getFormatFamily</a> () const</td></tr>
<tr class="memdesc:a78b8938d61a62eb3c88df9f5d8c21185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the format family it was requested.  <a href="class_ogre_1_1_staging_texture.html#a78b8938d61a62eb3c88df9f5d8c21185">More...</a><br /></td></tr>
<tr class="separator:a78b8938d61a62eb3c88df9f5d8c21185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe93b933ced83f7467ef8c6040a2236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a3fe93b933ced83f7467ef8c6040a2236">getLastFrameUsed</a> () const</td></tr>
<tr class="separator:a3fe93b933ced83f7467ef8c6040a2236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10407890613a334a7f35466d6c1840ec"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a10407890613a334a7f35466d6c1840ec">isSmallerThan</a> (const <a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> *other) const =0</td></tr>
<tr class="separator:a10407890613a334a7f35466d6c1840ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5cc3adc54a4ab2ea4e83cde01b3398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#adf5cc3adc54a4ab2ea4e83cde01b3398">mapRegion</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> depth, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> slices, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat)</td></tr>
<tr class="memdesc:adf5cc3adc54a4ab2ea4e83cde01b3398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be called from worker thread, but not from multiple threads at the same time, also you can't call anything else either.  <a href="class_ogre_1_1_staging_texture.html#adf5cc3adc54a4ab2ea4e83cde01b3398">More...</a><br /></td></tr>
<tr class="separator:adf5cc3adc54a4ab2ea4e83cde01b3398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c5ae43d118dd5db9ac65ca65a5e75e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#af5c5ae43d118dd5db9ac65ca65a5e75e">startMapRegion</a> ()</td></tr>
<tr class="memdesc:af5c5ae43d118dd5db9ac65ca65a5e75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called from main thread when the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> is grabbed.  <a href="class_ogre_1_1_staging_texture.html#af5c5ae43d118dd5db9ac65ca65a5e75e">More...</a><br /></td></tr>
<tr class="separator:af5c5ae43d118dd5db9ac65ca65a5e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d9e53f8a991cbd1c030264d01aa53a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a22d9e53f8a991cbd1c030264d01aa53a">stopMapRegion</a> ()</td></tr>
<tr class="memdesc:a22d9e53f8a991cbd1c030264d01aa53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called from main thread when the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> is released.  <a href="class_ogre_1_1_staging_texture.html#a22d9e53f8a991cbd1c030264d01aa53a">More...</a><br /></td></tr>
<tr class="separator:a22d9e53f8a991cbd1c030264d01aa53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e784259cec0438f0d14574d5cdba5a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a16e784259cec0438f0d14574d5cdba5a">supportsFormat</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> depth, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> slices, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat) const =0</td></tr>
<tr class="memdesc:a16e784259cec0438f0d14574d5cdba5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">D3D11 has restrictions about which StagingTextures can be uploaded to which textures based on texture families (for example all PFG_RGBA32_* belong to the same family).  <a href="class_ogre_1_1_staging_texture.html#a16e784259cec0438f0d14574d5cdba5a">More...</a><br /></td></tr>
<tr class="separator:a16e784259cec0438f0d14574d5cdba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6c47d59940659d0b23c2979582c9b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a3e6c47d59940659d0b23c2979582c9b6">upload</a> (const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;srcBox, <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *dstTexture, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> mipLevel, const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> *cpuSrcBox=0, const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> *dstBox=0, bool skipSysRamCopy=false)</td></tr>
<tr class="memdesc:a3e6c47d59940659d0b23c2979582c9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a region of data in srcBox (which must have been created with mapRegion) into dstTexture.  <a href="class_ogre_1_1_staging_texture.html#a3e6c47d59940659d0b23c2979582c9b6">More...</a><br /></td></tr>
<tr class="separator:a3e6c47d59940659d0b23c2979582c9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803494151c79852ce3afaaa8a76059f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_texture.html#a803494151c79852ce3afaaa8a76059f3">uploadWillStall</a> ()</td></tr>
<tr class="memdesc:a803494151c79852ce3afaaa8a76059f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If it returns true, startMapRegion will stall.  <a href="class_ogre_1_1_staging_texture.html#a803494151c79852ce3afaaa8a76059f3">More...</a><br /></td></tr>
<tr class="separator:a803494151c79852ce3afaaa8a76059f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> is an intermediate texture that can be read and be written from both CPU &amp; GPU. </p>
<p>However the access in both cases is limited. GPUs can only copy (i.e. memcpy) to another real texture (can't be used directly as a texture or render target) and CPUs can only map it. In other words, a staging texture is an intermediate to transfer data between CPU &amp; GPU </p><dl class="section user"><dt></dt><dd>How to write to 2 textures (texture0 &amp; texture1; we pass twice the amount of slices to getStagingTexture): <a class="el" href="class_ogre_1_1_texture_gpu_manager.html" title="This class manages all textures (i.e.">TextureGpuManager</a> &amp;textureManager = ...; <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> *stagingTexture = textureManager.getStagingTexture( width, height, depth, slices * 2, pixelFormat ); stagingTexture-&gt;<a class="el" href="class_ogre_1_1_staging_texture.html#af5c5ae43d118dd5db9ac65ca65a5e75e" title="Must be called from main thread when the StagingBuffer is grabbed.">startMapRegion()</a>; <a class="el" href="struct_ogre_1_1_texture_box.html" title="For cubemaps, the face is in sliceStart, (see CubemapSide::CubemapSide) For cubemap arrays,...">TextureBox</a> box0 = stagingTexture-&gt;mapRegion( width, height, depth, slices, pixelFormat ); ... write to box0.data ... <a class="el" href="struct_ogre_1_1_texture_box.html" title="For cubemaps, the face is in sliceStart, (see CubemapSide::CubemapSide) For cubemap arrays,...">TextureBox</a> box1 = stagingTexture-&gt;mapRegion( width, height, depth, slices, pixelFormat ); ... write to box1.data ... stagingTexture-&gt;<a class="el" href="class_ogre_1_1_staging_texture.html#a22d9e53f8a991cbd1c030264d01aa53a" title="Must be called from main thread when the StagingBuffer is released.">stopMapRegion()</a>; stagingTexture-&gt;upload( box0, texture0 ); stagingTexture-&gt;upload( box1, texture1 ); textureManager.removeStagingTexture( stagingTexture ); </dd></dl>
<dl class="section user"><dt></dt><dd>There are other possibilities, as you can request a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> with twice the width &amp; height and then start calling mapRegion with smaller textures and we'll handle the packing. However you have to check mapRegion doesn't return nullptr in <a class="el" href="struct_ogre_1_1_texture_box.html#abd49325e3605351af777bfea9b56ba24" title="Pointer is never owned by us.">TextureBox::data</a>. If so, that means we have ran out of space. </dd></dl>
<dl class="section user"><dt></dt><dd>Notably derived classes are:<ul>
<li><a class="el" href="class_ogre_1_1_staging_texture_buffer_impl.html" title="This implementation can be used by all RenderSystem APIs except D3D11, which is why this implementati...">StagingTextureBufferImpl</a><ul>
<li><a class="el" href="class_ogre_1_1_g_l3_plus_staging_texture.html">GL3PlusStagingTexture</a></li>
<li><a class="el" href="class_ogre_1_1_metal_staging_texture.html">MetalStagingTexture</a></li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_d3_d11_staging_texture.html">D3D11StagingTexture</a> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a42f8c5ea7655620d3c4594a60da8706b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f8c5ea7655620d3c4594a60da8706b">&#9670;&nbsp;</a></span>StagingTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::StagingTexture::StagingTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>formatFamily</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae82ed990ee417cb7aabea60909c1bf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82ed990ee417cb7aabea60909c1bf78">&#9670;&nbsp;</a></span>~StagingTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::StagingTexture::~StagingTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a63f86b602c961f86724e3eb6dce3220b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f86b602c961f86724e3eb6dce3220b">&#9670;&nbsp;</a></span>_getSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::StagingTexture::_getSizeBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns size in bytes. </p>
<p>Note it's tagged as advanced use (via _underscore) because Just because a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> has enough available size, does not mean it can hold the data you'll want (a D3D11 <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> of 256x512 cannot hold 1024x1 texture data even though it has the available capacity) </p><dl class="section return"><dt>Returns</dt><dd>Size in bytes of this staging texture. </dd></dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_d3_d11_staging_texture.html#a57364f5b8524a794a4a0847a5be52f8f">Ogre::D3D11StagingTexture</a>, and <a class="el" href="class_ogre_1_1_staging_texture_buffer_impl.html#a66652b86a402a48e391102d99d497a04">Ogre::StagingTextureBufferImpl</a>.</p>

</div>
</div>
<a id="a78b8938d61a62eb3c88df9f5d8c21185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b8938d61a62eb3c88df9f5d8c21185">&#9670;&nbsp;</a></span>getFormatFamily()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::StagingTexture::getFormatFamily </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the format family it was requested. </p>
<p>Note that in non-D3D11 RenderSystems, supportsFormat may return true despite a format not being from the same family. This information is mostly useful for keeping memory budgets consistent between different APIs (e.g. on D3D11 two StagingTextures, one that supports RGB8, another for BC1 of 64 MB each; on OpenGL we need to request two textures of 64MB each, and not just one because the first one can fulfill every request) </p>

</div>
</div>
<a id="a3fe93b933ced83f7467ef8c6040a2236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe93b933ced83f7467ef8c6040a2236">&#9670;&nbsp;</a></span>getLastFrameUsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::StagingTexture::getLastFrameUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10407890613a334a7f35466d6c1840ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10407890613a334a7f35466d6c1840ec">&#9670;&nbsp;</a></span>isSmallerThan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::StagingTexture::isSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_d3_d11_staging_texture.html#ae6144acde0c2668cfaca32f9fb2b73f9">Ogre::D3D11StagingTexture</a>, and <a class="el" href="class_ogre_1_1_staging_texture_buffer_impl.html#a5b39fb9deb55940b70a26f2fa4b965fd">Ogre::StagingTextureBufferImpl</a>.</p>

</div>
</div>
<a id="adf5cc3adc54a4ab2ea4e83cde01b3398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5cc3adc54a4ab2ea4e83cde01b3398">&#9670;&nbsp;</a></span>mapRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> Ogre::StagingTexture::mapRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can be called from worker thread, but not from multiple threads at the same time, also you can't call anything else either. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You must have called startMapRegion before. Textures that are bigger than 2048x2048 can only map one slice at a time due to limitations in the D3D11 API. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ogre_1_1_texture_box.html" title="For cubemaps, the face is in sliceStart, (see CubemapSide::CubemapSide) For cubemap arrays,...">TextureBox</a> to write to. Please note <a class="el" href="struct_ogre_1_1_texture_box.html#abd49325e3605351af777bfea9b56ba24" title="Pointer is never owned by us.">TextureBox::data</a> may be null. If so, that means we don't have enough space to fulfill your request.</dd></dl>
<p>You MUST use <a class="el" href="struct_ogre_1_1_texture_box.html#ad847c9af8c06cb208dfed687440d336e">TextureBox::atFromOffsettedOrigin</a> rather than <a class="el" href="struct_ogre_1_1_texture_box.html#aaf292792396ed63db078a51909579468" title="x, y &amp; z are in pixels.">TextureBox::at</a> (or account for the offset at some point)</p>
<p>Most APIs will return the value starting at 0 0 0 But D3D11 will NOT. </p>

</div>
</div>
<a id="af5c5ae43d118dd5db9ac65ca65a5e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c5ae43d118dd5db9ac65ca65a5e75e">&#9670;&nbsp;</a></span>startMapRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StagingTexture::startMapRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be called from main thread when the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> is grabbed. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Calling this function if you've already called <a class="el" href="class_ogre_1_1_staging_texture.html#a3e6c47d59940659d0b23c2979582c9b6" title="Uploads a region of data in srcBox (which must have been created with mapRegion) into dstTexture.">upload()</a> may stall. Grab another <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> to prevent stall. See uploadWillStall. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_staging_texture.html#a2c573cac40239aaf12890ddd316514f6">Ogre::VulkanStagingTexture</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_staging_texture.html#afe825cd5e2312ffbc5ef503151e9bd77">Ogre::GL3PlusStagingTexture</a>, <a class="el" href="class_ogre_1_1_d3_d11_staging_texture.html#ad6bb2b8856e79260d691991fbccd0d1b">Ogre::D3D11StagingTexture</a>, and <a class="el" href="class_ogre_1_1_staging_texture_buffer_impl.html#ad2f3c66603fc7e844e0b45c52b1ca5ef">Ogre::StagingTextureBufferImpl</a>.</p>

</div>
</div>
<a id="a22d9e53f8a991cbd1c030264d01aa53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d9e53f8a991cbd1c030264d01aa53a">&#9670;&nbsp;</a></span>stopMapRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StagingTexture::stopMapRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be called from main thread when the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> is released. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_staging_texture.html#a2cfba3cf4d4e23ad8b9884cac4b72a79">Ogre::VulkanStagingTexture</a>, <a class="el" href="class_ogre_1_1_metal_staging_texture.html#a737dd5124bba6b1083ab8a737b28bcc3">Ogre::MetalStagingTexture</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_staging_texture.html#aa2afd3731d89d2705f0b55c9d7f59d9b">Ogre::GL3PlusStagingTexture</a>, and <a class="el" href="class_ogre_1_1_d3_d11_staging_texture.html#a2f6407f45a232f30920e8ce9c70265a5">Ogre::D3D11StagingTexture</a>.</p>

</div>
</div>
<a id="a16e784259cec0438f0d14574d5cdba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e784259cec0438f0d14574d5cdba5a">&#9670;&nbsp;</a></span>supportsFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::StagingTexture::supportsFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>D3D11 has restrictions about which StagingTextures can be uploaded to which textures based on texture families (for example all PFG_RGBA32_* belong to the same family). </p>
<p>This function will return true if the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> can be used with the given format. On all the other RenderSystems, this nonsense does not exist thus it returns always true unless the request is so big it could never be fullfilled (it's larger than our maximum capacity) </p>

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_staging_texture.html#a1222239903b0e8eb98eab7223ba72c8f">Ogre::VulkanStagingTexture</a>, <a class="el" href="class_ogre_1_1_d3_d11_staging_texture.html#ade1f544ee2421c1aeea6069b84bfb974">Ogre::D3D11StagingTexture</a>, and <a class="el" href="class_ogre_1_1_staging_texture_buffer_impl.html#a14459e2078a9025553c4876fd2caa87c">Ogre::StagingTextureBufferImpl</a>.</p>

</div>
</div>
<a id="a3e6c47d59940659d0b23c2979582c9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6c47d59940659d0b23c2979582c9b6">&#9670;&nbsp;</a></span>upload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StagingTexture::upload </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> *&#160;</td>
          <td class="paramname"><em>cpuSrcBox</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> *&#160;</td>
          <td class="paramname"><em>dstBox</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipSysRamCopy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uploads a region of data in srcBox (which must have been created with mapRegion) into dstTexture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBox</td><td>The source data to copy from. Must have been created from mapRegion and must not have been altered (i.e. changed its internal variables) Values inside srcBox such as x, y, z &amp; sliceStart will be ignored. </td></tr>
    <tr><td class="paramname">dstTexture</td><td>The destination texture. If dstBox is a null pointer, srcBox must match the texture dimensions exactly (x,y,z = 0; same resolution) </td></tr>
    <tr><td class="paramname">cpuSrcBox</td><td>A CPU-based copy that we can copy CPU -&gt; CPU to our System RAM copy. This parameters must be present if skipSysRamCopy is false and the dstTexture strategy is <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65a154441f49638a86fc2da0e1a712fc614" title="Always keep a copy on system RAM, even when resident.">GpuPageOutStrategy::AlwaysKeepSystemRamCopy</a> or it is in OnSystemRam state. </td></tr>
    <tr><td class="paramname">mipLevel</td><td>Destination mipmap. </td></tr>
    <tr><td class="paramname">dstBox</td><td>Optional. Region inside dstTexture to copy to. Must have the same dimensions as srcBox. Values inside dstBox such as bytesPerRow, bytesPerImage &amp; data will be ignored. </td></tr>
    <tr><td class="paramname">skipSysRamCopy</td><td>Whether to skip the copy to system RAM. Should only be used if the System RAM copy is already up to date, which is often the case when you're transitioning to Resident while loading at the same time. If misused, readbacks will be incorrect as data in CPU won't mirror that of the data in GPU, and possibly other bugs too. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_staging_texture.html#ad100e5a4bba138fa86e945ee8eaaf3ed">Ogre::VulkanStagingTexture</a>, <a class="el" href="class_ogre_1_1_metal_staging_texture.html#a8d2258b530b5e2b54249eb8ccbfd97da">Ogre::MetalStagingTexture</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_staging_texture.html#a9546cee55055a40a1e5e486326415122">Ogre::GL3PlusStagingTexture</a>, and <a class="el" href="class_ogre_1_1_d3_d11_staging_texture.html#afa222859113b1ed8d68ff8c0ca19da37">Ogre::D3D11StagingTexture</a>.</p>

</div>
</div>
<a id="a803494151c79852ce3afaaa8a76059f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803494151c79852ce3afaaa8a76059f3">&#9670;&nbsp;</a></span>uploadWillStall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::StagingTexture::uploadWillStall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If it returns true, startMapRegion will stall. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_staging_texture_8h.html">OgreStagingTexture.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
