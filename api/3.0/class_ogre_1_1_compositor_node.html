<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::CompositorNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_compositor_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_compositor_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::CompositorNode Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___effects.html">Effects</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Compositor nodes are the core subject of compositing.  
 <a href="class_ogre_1_1_compositor_node.html#details">More...</a></p>

<p><code>#include &lt;OgreCompositorNode.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::CompositorNode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_compositor_node__inherit__graph.svg" width="326" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8184bf04d1229243b121a3c1f1f080b7" id="r_a8184bf04d1229243b121a3c1f1f080b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a8184bf04d1229243b121a3c1f1f080b7">CompositorNode</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> *definition, <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *workspace, <a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *renderSys, <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *finalTarget)</td></tr>
<tr class="memdesc:a8184bf04d1229243b121a3c1f1f080b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_ogre_1_1_id.html" title="Usage: OGRE_NEW SceneNode( Id::generateNewId&lt; Node &gt;() )">Id</a> must be unique across all engine so we can create unique named textures.  <br /></td></tr>
<tr class="separator:a8184bf04d1229243b121a3c1f1f080b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958b95a5fd93b1fbbf93e68795590274" id="r_a958b95a5fd93b1fbbf93e68795590274"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a958b95a5fd93b1fbbf93e68795590274">~CompositorNode</a> ()</td></tr>
<tr class="separator:a958b95a5fd93b1fbbf93e68795590274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5de14c9d267e93cd9c0adadba4052b" id="r_abc5de14c9d267e93cd9c0adadba4052b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa09712589d0e729a928ed664b98e30a7">CompositorPassVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#abc5de14c9d267e93cd9c0adadba4052b">_getPasses</a> () const</td></tr>
<tr class="separator:abc5de14c9d267e93cd9c0adadba4052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6ad71b3359a4bc626aacfb034557dc" id="r_aff6ad71b3359a4bc626aacfb034557dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aff6ad71b3359a4bc626aacfb034557dc">_notifyCleared</a> ()</td></tr>
<tr class="memdesc:aff6ad71b3359a4bc626aacfb034557dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Use.  <br /></td></tr>
<tr class="separator:aff6ad71b3359a4bc626aacfb034557dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4e112618b5ed2936391b2bfc45d224" id="r_aad4e112618b5ed2936391b2bfc45d224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aad4e112618b5ed2936391b2bfc45d224">_update</a> (const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager)</td></tr>
<tr class="memdesc:aad4e112618b5ed2936391b2bfc45d224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this function every frame will cause us to execute all our passes (ie.  <br /></td></tr>
<tr class="separator:aad4e112618b5ed2936391b2bfc45d224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183e74226d1c4fe91e2a2886459aba8a" id="r_a183e74226d1c4fe91e2a2886459aba8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a183e74226d1c4fe91e2a2886459aba8a">areAllInputsConnected</a> () const</td></tr>
<tr class="separator:a183e74226d1c4fe91e2a2886459aba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd2960e9ca1de509c9c3ff36d847997" id="r_a5dd2960e9ca1de509c9c3ff36d847997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a5dd2960e9ca1de509c9c3ff36d847997">connectBufferTo</a> (size_t outChannelA, <a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *nodeB, size_t inChannelB)</td></tr>
<tr class="memdesc:a5dd2960e9ca1de509c9c3ff36d847997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (buffer version)  <br /></td></tr>
<tr class="separator:a5dd2960e9ca1de509c9c3ff36d847997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed3172d72e30cbd79ef663c8c1adfd7" id="r_aeed3172d72e30cbd79ef663c8c1adfd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aeed3172d72e30cbd79ef663c8c1adfd7">connectExternalBuffer</a> (<a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *buffer, size_t inChannelA)</td></tr>
<tr class="memdesc:aeed3172d72e30cbd79ef663c8c1adfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects (injects) an external buffer into the given channel.  <br /></td></tr>
<tr class="separator:aeed3172d72e30cbd79ef663c8c1adfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e812a39d91f5d59b335b81cc45d81a0" id="r_a6e812a39d91f5d59b335b81cc45d81a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a6e812a39d91f5d59b335b81cc45d81a0">connectExternalRT</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *externalTexture, size_t inChannelA)</td></tr>
<tr class="memdesc:a6e812a39d91f5d59b335b81cc45d81a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects (injects) an external RT into the given channel.  <br /></td></tr>
<tr class="separator:a6e812a39d91f5d59b335b81cc45d81a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfd8041dbce265afd92ac9c11769fbb" id="r_a0bfd8041dbce265afd92ac9c11769fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a0bfd8041dbce265afd92ac9c11769fbb">connectTo</a> (size_t outChannelA, <a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *nodeB, size_t inChannelB)</td></tr>
<tr class="memdesc:a0bfd8041dbce265afd92ac9c11769fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (texture version)  <br /></td></tr>
<tr class="separator:a0bfd8041dbce265afd92ac9c11769fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fce9ec85e8404ae2f0855e05f32afce" id="r_a5fce9ec85e8404ae2f0855e05f32afce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a5fce9ec85e8404ae2f0855e05f32afce">createPasses</a> ()</td></tr>
<tr class="memdesc:a5fce9ec85e8404ae2f0855e05f32afce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all passes based on our definition.  <br /></td></tr>
<tr class="separator:a5fce9ec85e8404ae2f0855e05f32afce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dac90cc026287b9b0aee9264e9059f" id="r_a53dac90cc026287b9b0aee9264e9059f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a53dac90cc026287b9b0aee9264e9059f">destroyAllPasses</a> ()</td></tr>
<tr class="separator:a53dac90cc026287b9b0aee9264e9059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c743a62e8a202dc5816f0bd01fe8b9" id="r_ab5c743a62e8a202dc5816f0bd01fe8b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ab5c743a62e8a202dc5816f0bd01fe8b9">finalTargetResized01</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *finalTarget)</td></tr>
<tr class="memdesc:ab5c743a62e8a202dc5816f0bd01fe8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> when (i.e.) the RenderWindow was resized, thus our RTs that depend on their resolution need to be recreated.  <br /></td></tr>
<tr class="separator:ab5c743a62e8a202dc5816f0bd01fe8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44e15ffbff3bd7006aa45a6676d47f" id="r_a9b44e15ffbff3bd7006aa45a6676d47f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a9b44e15ffbff3bd7006aa45a6676d47f">finalTargetResized02</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *finalTarget)</td></tr>
<tr class="separator:a9b44e15ffbff3bd7006aa45a6676d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf10368c90e6df3f77b60d8c14cd7310" id="r_abf10368c90e6df3f77b60d8c14cd7310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#abf10368c90e6df3f77b60d8c14cd7310">getDefinedBuffer</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> bufferName) const</td></tr>
<tr class="memdesc:abf10368c90e6df3f77b60d8c14cd7310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer pointer of a buffer based on it's name.  <br /></td></tr>
<tr class="separator:abf10368c90e6df3f77b60d8c14cd7310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee31fc5aa0dd3ceaca3b2a5dcf817922" id="r_aee31fc5aa0dd3ceaca3b2a5dcf817922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aee31fc5aa0dd3ceaca3b2a5dcf817922">getDefinedBufferNoThrow</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> bufferName) const</td></tr>
<tr class="separator:aee31fc5aa0dd3ceaca3b2a5dcf817922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af990864da9638f9a535514ef9eaa631a" id="r_af990864da9638f9a535514ef9eaa631a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#af990864da9638f9a535514ef9eaa631a">getDefinedTexture</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> textureName) const</td></tr>
<tr class="memdesc:af990864da9638f9a535514ef9eaa631a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture pointer of a texture based on it's name &amp; mrt index.  <br /></td></tr>
<tr class="separator:af990864da9638f9a535514ef9eaa631a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860defea61122d7d8d4dc278c1a876c8" id="r_a860defea61122d7d8d4dc278c1a876c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a860defea61122d7d8d4dc278c1a876c8">getDefinition</a> () const</td></tr>
<tr class="separator:a860defea61122d7d8d4dc278c1a876c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7282de98f052c046880aefb7a838e760" id="r_a7282de98f052c046880aefb7a838e760"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a7282de98f052c046880aefb7a838e760">getEnabled</a> () const</td></tr>
<tr class="memdesc:a7282de98f052c046880aefb7a838e760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this instance is enabled.  <br /></td></tr>
<tr class="separator:a7282de98f052c046880aefb7a838e760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77dd0b2b1cd5e8f3951a111596dbf14" id="r_ab77dd0b2b1cd5e8f3951a111596dbf14"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ab77dd0b2b1cd5e8f3951a111596dbf14">getInputChannel</a> () const</td></tr>
<tr class="separator:ab77dd0b2b1cd5e8f3951a111596dbf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff30ffaedc5a0fb7beabf21641a5109" id="r_aeff30ffaedc5a0fb7beabf21641a5109"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aeff30ffaedc5a0fb7beabf21641a5109">getLocalTextures</a> () const</td></tr>
<tr class="separator:aeff30ffaedc5a0fb7beabf21641a5109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c98f58d980e3c3c628fd13de14e580" id="r_a98c98f58d980e3c3c628fd13de14e580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a98c98f58d980e3c3c628fd13de14e580">getName</a> () const</td></tr>
<tr class="separator:a98c98f58d980e3c3c628fd13de14e580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329444d41283a85be5e6191c525aedef" id="r_a329444d41283a85be5e6191c525aedef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a329444d41283a85be5e6191c525aedef">getPassNumber</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass) const</td></tr>
<tr class="memdesc:a329444d41283a85be5e6191c525aedef"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_compositor_node_def.html#a6fa98a167d723f5296d48926980aa4f6" title="Returns the pass # of the given pass definition in this node.">CompositorNodeDef::getPassNumber</a>.  <br /></td></tr>
<tr class="separator:a329444d41283a85be5e6191c525aedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9116602d558b892c1cfb3a0e177274fb" id="r_a9116602d558b892c1cfb3a0e177274fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a9116602d558b892c1cfb3a0e177274fb">getRenderSystem</a> () const</td></tr>
<tr class="separator:a9116602d558b892c1cfb3a0e177274fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7759ee5abdd3a3b2009a531a6916bb" id="r_a4e7759ee5abdd3a3b2009a531a6916bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a4e7759ee5abdd3a3b2009a531a6916bb">getWorkspace</a> ()</td></tr>
<tr class="memdesc:a4e7759ee5abdd3a3b2009a531a6916bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our parent workspace.  <br /></td></tr>
<tr class="separator:a4e7759ee5abdd3a3b2009a531a6916bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc50bf597fa82a60d6dd1be25ea8500f" id="r_acc50bf597fa82a60d6dd1be25ea8500f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#acc50bf597fa82a60d6dd1be25ea8500f">getWorkspace</a> () const</td></tr>
<tr class="memdesc:acc50bf597fa82a60d6dd1be25ea8500f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our parent workspace.  <br /></td></tr>
<tr class="separator:acc50bf597fa82a60d6dd1be25ea8500f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9edc7379e9c8759de9abb0baaf2135" id="r_a6e9edc7379e9c8759de9abb0baaf2135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a6e9edc7379e9c8759de9abb0baaf2135">notifyDestroyed</a> (const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *buffer)</td></tr>
<tr class="separator:a6e9edc7379e9c8759de9abb0baaf2135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72f2d56524f23dc474d2634b06aeeeb" id="r_ae72f2d56524f23dc474d2634b06aeeeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ae72f2d56524f23dc474d2634b06aeeeb">notifyDestroyed</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *channel)</td></tr>
<tr class="memdesc:ae72f2d56524f23dc474d2634b06aeeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when caller has destroyed a RenderTarget in which the callee may have a reference to that pointer, so that we can clean it up.  <br /></td></tr>
<tr class="separator:ae72f2d56524f23dc474d2634b06aeeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e7c49813462a88761ff73f514d7ce8" id="r_a01e7c49813462a88761ff73f514d7ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a01e7c49813462a88761ff73f514d7ce8">notifyRecreated</a> (const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *oldBuffer, <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *newBuffer)</td></tr>
<tr class="separator:a01e7c49813462a88761ff73f514d7ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e701215d769e1890329c6e3e4a4ac9" id="r_a17e701215d769e1890329c6e3e4a4ac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a17e701215d769e1890329c6e3e4a4ac9">notifyRecreated</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *channel)</td></tr>
<tr class="memdesc:a17e701215d769e1890329c6e3e4a4ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you're replacing the textures from oldChannel with the ones in newChannel.  <br /></td></tr>
<tr class="separator:a17e701215d769e1890329c6e3e4a4ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b216e017d9aa22718a5419a1e98a2a" id="r_a07b216e017d9aa22718a5419a1e98a2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a07b216e017d9aa22718a5419a1e98a2a">resetAllNumPassesLeft</a> ()</td></tr>
<tr class="memdesc:a07b216e017d9aa22718a5419a1e98a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of passes left for every pass (see <a class="el" href="class_ogre_1_1_compositor_pass_def.html#a70ba2384e061021d6eceb5dd20b66d47" title="Number of times to perform the pass before stopping. -1 to never stop.">CompositorPassDef::mNumInitialPasses</a>) Useful when you have a few starting 'initialization' passes and you want to reset them.    <br /></td></tr>
<tr class="separator:a07b216e017d9aa22718a5419a1e98a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817bc10dbf5427a77912ab3bcd391f69" id="r_a817bc10dbf5427a77912ab3bcd391f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a817bc10dbf5427a77912ab3bcd391f69">setEnabled</a> (bool bEnabled)</td></tr>
<tr class="memdesc:a817bc10dbf5427a77912ab3bcd391f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables all instances of this node.  <br /></td></tr>
<tr class="separator:a817bc10dbf5427a77912ab3bcd391f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_ogre_1_1_id_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_ogre_1_1_id_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_ogre_1_1_id_object.html">Ogre::IdObject</a></td></tr>
<tr class="memitem:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object" id="r_a7884ec3abf1ed8c1b1514d3bda918370"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a7884ec3abf1ed8c1b1514d3bda918370">IdObject</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id)</td></tr>
<tr class="memdesc:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">We don't call generateNewId() here, to prevent objects in the stack (i.e.  <br /></td></tr>
<tr class="separator:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object" id="r_ab152c8f646a835c2f88585ad4fe0413a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#ab152c8f646a835c2f88585ad4fe0413a">getId</a> () const</td></tr>
<tr class="memdesc:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique id of this object.  <br /></td></tr>
<tr class="separator:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0523432c6e5133ff4fc251111a60e inherit pub_methods_class_ogre_1_1_id_object" id="r_a57e0523432c6e5133ff4fc251111a60e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a57e0523432c6e5133ff4fc251111a60e">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;right)</td></tr>
<tr class="separator:a57e0523432c6e5133ff4fc251111a60e inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae22596b5bd2a3faf2958ab3d109d1f inherit pub_methods_class_ogre_1_1_id_object" id="r_a0ae22596b5bd2a3faf2958ab3d109d1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a0ae22596b5bd2a3faf2958ab3d109d1f">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *right)</td></tr>
<tr class="separator:a0ae22596b5bd2a3faf2958ab3d109d1f inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compositor nodes are the core subject of compositing. </p>
<p>This is an instantiation. All const, shared parameters are in the definition (<a class="el" href="class_ogre_1_1_compositor_node_def.html" title="Compositor nodes are the core subject of compositing.">CompositorNodeDef</a>) and we assume they don't change throughout the lifetime of our instance. </p><dl class="section user"><dt></dt><dd>The textures in mLocalTextures are managed by us and we're responsible for freeing them when they're no longer needed. </dd></dl>
<dl class="section user"><dt></dt><dd>Before nodes can be used, they have to be connected between each other, followed by a call to routeOutputs() Connections must be done in a very specific order, so let the manager take care of solving the dependencies. Basically the problem is that if the chain is like this: A -&gt; B -&gt; C; if we connect node B to C first, then there's a chance of giving null pointers to C instead of the valid ones that belong to A. </dd></dl>
<dl class="section user"><dt></dt><dd>To solve this problem, we first start with nodes that have no input, and then continue with those who have all of their input set; then repeat until there are no nodes to be processed. If there's still nodes with input left open; then those nodes can't be activated and the workspace is invalid. </dd></dl>
<dl class="section user"><dt></dt><dd>No <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> can be valid if it has disconnected input channels left. Nodes can have no input because they either use passes that don't need it (eg. scene pass) or use global textures as means for sharing their work Similarly, Nodes may have no output because they use global textures. </dd></dl>
<dl class="section user"><dt></dt><dd>Nodes with feedback loops are not supported and may or may not work. A feedback loop is when A's output is used in B, B to C, then C is plugged back into A. </dd></dl>
<dl class="section user"><dt></dt><dd>It's possible to assign the same output to two different input channels, though it could work very unintuitively... (because two textures that may be intended to be hard copies are actually sharing the same memory) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>We own the local textures, so it's our job to destroy them </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matias N. Goldberg </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8184bf04d1229243b121a3c1f1f080b7" name="a8184bf04d1229243b121a3c1f1f080b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8184bf04d1229243b121a3c1f1f080b7">&#9670;&#160;</a></span>CompositorNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::CompositorNode::CompositorNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> *&#160;</td>
          <td class="paramname"><em>definition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>renderSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="class_ogre_1_1_id.html" title="Usage: OGRE_NEW SceneNode( Id::generateNewId&lt; Node &gt;() )">Id</a> must be unique across all engine so we can create unique named textures. </p>
<p>The name is only unique across the workspace </p>

</div>
</div>
<a id="a958b95a5fd93b1fbbf93e68795590274" name="a958b95a5fd93b1fbbf93e68795590274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958b95a5fd93b1fbbf93e68795590274">&#9670;&#160;</a></span>~CompositorNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::CompositorNode::~CompositorNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abc5de14c9d267e93cd9c0adadba4052b" name="abc5de14c9d267e93cd9c0adadba4052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5de14c9d267e93cd9c0adadba4052b">&#9670;&#160;</a></span>_getPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa09712589d0e729a928ed664b98e30a7">CompositorPassVec</a> &amp; Ogre::CompositorNode::_getPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff6ad71b3359a4bc626aacfb034557dc" name="aff6ad71b3359a4bc626aacfb034557dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6ad71b3359a4bc626aacfb034557dc">&#9670;&#160;</a></span>_notifyCleared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_notifyCleared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal Use. </p>
<p>Called when connections are all being zero'ed. We rely our caller is doing this to all nodes, hence we do not notify our CompositorNode::mConnectedNodes nodes. Failing to clear them too may leave dangling pointers or graphical glitches </p><dl class="section remark"><dt>Remarks</dt><dd>Destroys all of our passes. </dd></dl>

</div>
</div>
<a id="aad4e112618b5ed2936391b2bfc45d224" name="aad4e112618b5ed2936391b2bfc45d224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4e112618b5ed2936391b2bfc45d224">&#9670;&#160;</a></span>_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling this function every frame will cause us to execute all our passes (ie. </p>
<p>render) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodCamera</td><td>LOD <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> to be used by our passes. Pointer can be null, and note however passes can ignore this hint and use their own camera pointer for LOD (this parameter is mostly used for syncing shadow mapping). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a183e74226d1c4fe91e2a2886459aba8a" name="a183e74226d1c4fe91e2a2886459aba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183e74226d1c4fe91e2a2886459aba8a">&#9670;&#160;</a></span>areAllInputsConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorNode::areAllInputsConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dd2960e9ca1de509c9c3ff36d847997" name="a5dd2960e9ca1de509c9c3ff36d847997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd2960e9ca1de509c9c3ff36d847997">&#9670;&#160;</a></span>connectBufferTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectBufferTo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannelA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *&#160;</td>
          <td class="paramname"><em>nodeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (buffer version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outChannelA</td><td>Output to use from node A. </td></tr>
    <tr><td class="paramname">inChannelB</td><td>Input to connect the output from A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeed3172d72e30cbd79ef663c8c1adfd7" name="aeed3172d72e30cbd79ef663c8c1adfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed3172d72e30cbd79ef663c8c1adfd7">&#9670;&#160;</a></span>connectExternalBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectExternalBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects (injects) an external buffer into the given channel. </p>
<p>Usually used for the 'connect_buffer_external' directive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer. </td></tr>
    <tr><td class="paramname">inChannelA</td><td>In which channel number to inject to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e812a39d91f5d59b335b81cc45d81a0" name="a6e812a39d91f5d59b335b81cc45d81a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e812a39d91f5d59b335b81cc45d81a0">&#9670;&#160;</a></span>connectExternalRT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectExternalRT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>externalTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects (injects) an external RT into the given channel. </p>
<p>Usually used for the "connect_output" / "connect_external" directive for the RenderWindow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The RenderTarget. </td></tr>
    <tr><td class="paramname">textures</td><td>The Textures associated with the RT. Can be empty (eg. RenderWindow) but could cause crashes/exceptions if tried to use in PASS_QUAD passes. </td></tr>
    <tr><td class="paramname">inChannelA</td><td>In which channel number to inject to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bfd8041dbce265afd92ac9c11769fbb" name="a0bfd8041dbce265afd92ac9c11769fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfd8041dbce265afd92ac9c11769fbb">&#9670;&#160;</a></span>connectTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectTo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannelA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *&#160;</td>
          <td class="paramname"><em>nodeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (texture version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outChannelA</td><td>Output to use from node A. </td></tr>
    <tr><td class="paramname">inChannelB</td><td>Input to connect the output from A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fce9ec85e8404ae2f0855e05f32afce" name="a5fce9ec85e8404ae2f0855e05f32afce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fce9ec85e8404ae2f0855e05f32afce">&#9670;&#160;</a></span>createPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::createPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates all passes based on our definition. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Call this function after connecting all channels (at least our input) otherwise we may bind null pointer RTs to the passes (and then crash) See <a class="el" href="class_ogre_1_1_compositor_node.html#a0bfd8041dbce265afd92ac9c11769fbb" title="Connects this node (let&#39;s call it node &#39;A&#39;) to node &#39;B&#39;, mapping the output channel from A into the i...">connectTo()</a> and connectFinalRT(). </dd></dl>

</div>
</div>
<a id="a53dac90cc026287b9b0aee9264e9059f" name="a53dac90cc026287b9b0aee9264e9059f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dac90cc026287b9b0aee9264e9059f">&#9670;&#160;</a></span>destroyAllPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::destroyAllPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5c743a62e8a202dc5816f0bd01fe8b9" name="ab5c743a62e8a202dc5816f0bd01fe8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c743a62e8a202dc5816f0bd01fe8b9">&#9670;&#160;</a></span>finalTargetResized01()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorNode::finalTargetResized01 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> when (i.e.) the RenderWindow was resized, thus our RTs that depend on their resolution need to be recreated. </p>
<dl class="section remark"><dt>Remarks</dt><dd>We inform all connected nodes and passes related to us of RenderTargets/Textures that may have been recreated (pointers could become danlging otherwise). </dd></dl>
<dl class="section user"><dt></dt><dd>This is divided in two steps: recreateResizableTextures01 &amp; recreateResizableTextures02 since in some cases in <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a>, setting up MRT and depth textures requires all textures to be up to date, otherwise validation errors would occur since we'll have partial data (e.g. MRT 0 is 1024x768 while MRT 1 is 800x600) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finalTarget</td><td>The Final Target (i.e. RenderWindow) from which we'll base our local textures' resolution. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a5e91b900d7e9d85bafd312929f4724d4">Ogre::CompositorShadowNode</a>.</p>

</div>
</div>
<a id="a9b44e15ffbff3bd7006aa45a6676d47f" name="a9b44e15ffbff3bd7006aa45a6676d47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b44e15ffbff3bd7006aa45a6676d47f">&#9670;&#160;</a></span>finalTargetResized02()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorNode::finalTargetResized02 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf10368c90e6df3f77b60d8c14cd7310" name="abf10368c90e6df3f77b60d8c14cd7310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf10368c90e6df3f77b60d8c14cd7310">&#9670;&#160;</a></span>getDefinedBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> * Ogre::CompositorNode::getDefinedBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>bufferName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer pointer of a buffer based on it's name. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The buffer may come from a local buffer, an input buffer, or global (workspace). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferName</td><td>The name of the buffer. This name may only be valid at node scope. It can refer to an input buffer, a local buffer, or a global one. If a local or input buffer has the same name as a global one, the global one is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Regular: The buffer. Throws if buffer wasn't found. No throw version: Null if not found. The buffer otherwise </dd></dl>

</div>
</div>
<a id="aee31fc5aa0dd3ceaca3b2a5dcf817922" name="aee31fc5aa0dd3ceaca3b2a5dcf817922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee31fc5aa0dd3ceaca3b2a5dcf817922">&#9670;&#160;</a></span>getDefinedBufferNoThrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> * Ogre::CompositorNode::getDefinedBufferNoThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>bufferName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af990864da9638f9a535514ef9eaa631a" name="af990864da9638f9a535514ef9eaa631a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af990864da9638f9a535514ef9eaa631a">&#9670;&#160;</a></span>getDefinedTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::CompositorNode::getDefinedTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>textureName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture pointer of a texture based on it's name &amp; mrt index. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The texture name must have been registered with <a class="el" href="class_ogre_1_1_texture_definition_base.html#a02ec073273bf07eb78122ddb2a4606f1" title="Adds a texture name, whether a real one or an alias, and where to grab it from.">CompositorNodeDef::addTextureSourceName</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureName</td><td>The name of the texture. This name may only be valid at node scope. It can refer to an input texture, a local texture, or a global one. If the global texture wasn't registered with addTextureSourceName, it will fail. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null if not found (or global texture not registered). The texture otherwise </dd></dl>

</div>
</div>
<a id="a860defea61122d7d8d4dc278c1a876c8" name="a860defea61122d7d8d4dc278c1a876c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860defea61122d7d8d4dc278c1a876c8">&#9670;&#160;</a></span>getDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> * Ogre::CompositorNode::getDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7282de98f052c046880aefb7a838e760" name="a7282de98f052c046880aefb7a838e760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7282de98f052c046880aefb7a838e760">&#9670;&#160;</a></span>getEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorNode::getEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this instance is enabled. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_node.html#a817bc10dbf5427a77912ab3bcd391f69" title="Enables or disables all instances of this node.">setEnabled</a> </dd></dl>

</div>
</div>
<a id="ab77dd0b2b1cd5e8f3951a111596dbf14" name="ab77dd0b2b1cd5e8f3951a111596dbf14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77dd0b2b1cd5e8f3951a111596dbf14">&#9670;&#160;</a></span>getInputChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp; Ogre::CompositorNode::getInputChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeff30ffaedc5a0fb7beabf21641a5109" name="aeff30ffaedc5a0fb7beabf21641a5109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff30ffaedc5a0fb7beabf21641a5109">&#9670;&#160;</a></span>getLocalTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp; Ogre::CompositorNode::getLocalTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98c98f58d980e3c3c628fd13de14e580" name="a98c98f58d980e3c3c628fd13de14e580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c98f58d980e3c3c628fd13de14e580">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::CompositorNode::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a329444d41283a85be5e6191c525aedef" name="a329444d41283a85be5e6191c525aedef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329444d41283a85be5e6191c525aedef">&#9670;&#160;</a></span>getPassNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::CompositorNode::getPassNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_compositor_node_def.html#a6fa98a167d723f5296d48926980aa4f6" title="Returns the pass # of the given pass definition in this node.">CompositorNodeDef::getPassNumber</a>. </p>

</div>
</div>
<a id="a9116602d558b892c1cfb3a0e177274fb" name="a9116602d558b892c1cfb3a0e177274fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9116602d558b892c1cfb3a0e177274fb">&#9670;&#160;</a></span>getRenderSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> * Ogre::CompositorNode::getRenderSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e7759ee5abdd3a3b2009a531a6916bb" name="a4e7759ee5abdd3a3b2009a531a6916bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7759ee5abdd3a3b2009a531a6916bb">&#9670;&#160;</a></span>getWorkspace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> * Ogre::CompositorNode::getWorkspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our parent workspace. </p>

</div>
</div>
<a id="acc50bf597fa82a60d6dd1be25ea8500f" name="acc50bf597fa82a60d6dd1be25ea8500f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc50bf597fa82a60d6dd1be25ea8500f">&#9670;&#160;</a></span>getWorkspace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> * Ogre::CompositorNode::getWorkspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our parent workspace. </p>

</div>
</div>
<a id="a6e9edc7379e9c8759de9abb0baaf2135" name="a6e9edc7379e9c8759de9abb0baaf2135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9edc7379e9c8759de9abb0baaf2135">&#9670;&#160;</a></span>notifyDestroyed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyDestroyed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae72f2d56524f23dc474d2634b06aeeeb" name="ae72f2d56524f23dc474d2634b06aeeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72f2d56524f23dc474d2634b06aeeeb">&#9670;&#160;</a></span>notifyDestroyed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function when caller has destroyed a RenderTarget in which the callee may have a reference to that pointer, so that we can clean it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel containing the pointer about to be destroyed (must still be valid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01e7c49813462a88761ff73f514d7ce8" name="a01e7c49813462a88761ff73f514d7ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e7c49813462a88761ff73f514d7ce8">&#9670;&#160;</a></span>notifyRecreated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyRecreated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>oldBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>newBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17e701215d769e1890329c6e3e4a4ac9" name="a17e701215d769e1890329c6e3e4a4ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e701215d769e1890329c6e3e4a4ac9">&#9670;&#160;</a></span>notifyRecreated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyRecreated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function when you're replacing the textures from oldChannel with the ones in newChannel. </p>
<p>Useful when recreating textures (i.e. resolution changed) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldChannel</td><td>The old textures that are going to be removed. Pointers in it must be still valid </td></tr>
    <tr><td class="paramname">newChannel</td><td>The new replacement textures </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07b216e017d9aa22718a5419a1e98a2a" name="a07b216e017d9aa22718a5419a1e98a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b216e017d9aa22718a5419a1e98a2a">&#9670;&#160;</a></span>resetAllNumPassesLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::resetAllNumPassesLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the number of passes left for every pass (see <a class="el" href="class_ogre_1_1_compositor_pass_def.html#a70ba2384e061021d6eceb5dd20b66d47" title="Number of times to perform the pass before stopping. -1 to never stop.">CompositorPassDef::mNumInitialPasses</a>) Useful when you have a few starting 'initialization' passes and you want to reset them.   </p>

</div>
</div>
<a id="a817bc10dbf5427a77912ab3bcd391f69" name="a817bc10dbf5427a77912ab3bcd391f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817bc10dbf5427a77912ab3bcd391f69">&#9670;&#160;</a></span>setEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::setEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables all instances of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that we just won't execute our passes. It's your job to change the channel connections accordingly if you have to. A disabled node won't complain when its connections are incomplete in a workspace. </dd></dl>
<dl class="section user"><dt></dt><dd>This function is useful frequently toggling a compositor effect without having to recreate any API resource (which often would involve stalls). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_compositor_node_8h.html">OgreCompositorNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
