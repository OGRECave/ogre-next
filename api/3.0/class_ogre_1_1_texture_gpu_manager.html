<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::TextureGpuManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_texture_gpu_manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_ogre_1_1_texture_gpu_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::TextureGpuManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This class manages all textures (i.e.  
 <a href="class_ogre_1_1_texture_gpu_manager.html#details">More...</a></p>

<p><code>#include &lt;OgreTextureGpuManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::TextureGpuManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_texture_gpu_manager__inherit__graph.svg" width="730" height="234"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_budget_entry.html">BudgetEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the minimum squared resolution &amp; number of slices to keep around all the for time StagingTextures.  <a href="struct_ogre_1_1_texture_gpu_manager_1_1_budget_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_metadata_cache_entry.html">MetadataCacheEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_resource_entry.html">ResourceEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a243112239378b673ba9f1df5e7abdbf3" id="r_a243112239378b673ba9f1df5e7abdbf3"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_budget_entry.html">BudgetEntry</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a></td></tr>
<tr class="separator:a243112239378b673ba9f1df5e7abdbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e42d75a1eae1a28e52e4613832edb3" id="r_a75e42d75a1eae1a28e52e4613832edb3"><td class="memItemLeft" align="right" valign="top">typedef map&lt; <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>, <a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_metadata_cache_entry.html">MetadataCacheEntry</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a75e42d75a1eae1a28e52e4613832edb3">MetadataCacheMap</a></td></tr>
<tr class="separator:a75e42d75a1eae1a28e52e4613832edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad657330e7020f561860d24366460271c" id="r_ad657330e7020f561860d24366460271c"><td class="memItemLeft" align="right" valign="top">typedef map&lt; <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>, <a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_resource_entry.html">ResourceEntry</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad657330e7020f561860d24366460271c">ResourceEntryMap</a></td></tr>
<tr class="separator:ad657330e7020f561860d24366460271c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_ogre_1_1_texture_gpu_listener"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_ogre_1_1_texture_gpu_listener')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_ogre_1_1_texture_gpu_listener.html">Ogre::TextureGpuListener</a></td></tr>
<tr class="memitem:afe11bd546cf7315f4526488e7078cc7d inherit pub_types_class_ogre_1_1_texture_gpu_listener" id="r_afe11bd546cf7315f4526488e7078cc7d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">Reason</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da2b732a317de0915527e291485ca42e82">Unknown</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da58fd07194714679ed3ba9857d7656f27">FromStorageToSysRam</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da058c0eecb9f3f188fccc4d0018bf337b">FromSysRamToStorage</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da55066351a26967068b944c2170e51af1">GainedResidency</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da61729c4ae25807d6132d5bc46580ff3d">LostResidency</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dafbdd85981846de4423d48d1a0ff665e0">PoolTextureSlotChanged</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da218a4243be85ec9c989b777119d5ff47">ResidentToSysRamSync</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da4f559ca1853a24a28b40caae1acda604">MetadataCacheOutOfDate</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da704ea118c7e9f0b1598b528bdcbe1b26">ExceptionThrown</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dae3eb70053cbf5401f22893cdb47f81a7">FsaaSettingAlteredByApi</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257">ReadyForRendering</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e">Deleted</a>
<br />
 }</td></tr>
<tr class="separator:afe11bd546cf7315f4526488e7078cc7d inherit pub_types_class_ogre_1_1_texture_gpu_listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7cc799aa12f7b03c686cec13d09d9c0b" id="r_a7cc799aa12f7b03c686cec13d09d9c0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a7cc799aa12f7b03c686cec13d09d9c0b">TextureGpuManager</a> (<a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, <a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *renderSystem)</td></tr>
<tr class="separator:a7cc799aa12f7b03c686cec13d09d9c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea7a2892140d8d84ee8db3f6ea7aae4" id="r_a8ea7a2892140d8d84ee8db3f6ea7aae4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a8ea7a2892140d8d84ee8db3f6ea7aae4">~TextureGpuManager</a> () override</td></tr>
<tr class="separator:a8ea7a2892140d8d84ee8db3f6ea7aae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dec5d2c3187c3d7be56d9c5cc55fc4" id="r_a68dec5d2c3187c3d7be56d9c5cc55fc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a68dec5d2c3187c3d7be56d9c5cc55fc4">_queueDownloadToRam</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, bool resyncOnly)</td></tr>
<tr class="separator:a68dec5d2c3187c3d7be56d9c5cc55fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a4bb400a24d0e3ea9a9299192fa51d" id="r_a89a4bb400a24d0e3ea9a9299192fa51d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a89a4bb400a24d0e3ea9a9299192fa51d">_releaseSlotFromTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a89a4bb400a24d0e3ea9a9299192fa51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called from main thread.  <br /></td></tr>
<tr class="separator:a89a4bb400a24d0e3ea9a9299192fa51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a3edb2437dae48c14a0d20c50877fa" id="r_a38a3edb2437dae48c14a0d20c50877fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a38a3edb2437dae48c14a0d20c50877fa">_removeMetadataCacheEntry</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="separator:a38a3edb2437dae48c14a0d20c50877fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93773f33d6018c991b4fa8c475a8a36d" id="r_a93773f33d6018c991b4fa8c475a8a36d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a93773f33d6018c991b4fa8c475a8a36d">_reserveSlotForTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a93773f33d6018c991b4fa8c475a8a36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called from main thread.  <br /></td></tr>
<tr class="separator:a93773f33d6018c991b4fa8c475a8a36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57719d6bae200d39449eb5f98098b1c5" id="r_a57719d6bae200d39449eb5f98098b1c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a57719d6bae200d39449eb5f98098b1c5">_scheduleTransitionTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> targetResidency, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image, bool autoDeleteImage, bool reuploadOnly, bool bSkipMultiload)</td></tr>
<tr class="separator:a57719d6bae200d39449eb5f98098b1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f6c11e4af75070ada1e868e7b24412" id="r_a46f6c11e4af75070ada1e868e7b24412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a46f6c11e4af75070ada1e868e7b24412">_scheduleUpdate</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> filters, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image, bool autoDeleteImage, bool skipMetadataCache=false, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> sliceOrDepth=std::numeric_limits&lt; <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> &gt;::max())</td></tr>
<tr class="separator:a46f6c11e4af75070ada1e868e7b24412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae905930e6b79e3a3c3152efc20d5249c" id="r_ae905930e6b79e3a3c3152efc20d5249c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ae905930e6b79e3a3c3152efc20d5249c">_setIgnoreScheduledTasks</a> (bool ignoreSchedTasks)</td></tr>
<tr class="memdesc:ae905930e6b79e3a3c3152efc20d5249c"><td class="mdescLeft">&#160;</td><td class="mdescRight">When true we will ignore all tasks in mScheduledTasks and execute transitions immediately Caller is responsible for ensuring this is safe to do.  <br /></td></tr>
<tr class="separator:ae905930e6b79e3a3c3152efc20d5249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa961b3aafc08805f7611d4edd283f804" id="r_aa961b3aafc08805f7611d4edd283f804"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804">_update</a> (bool syncWithWorkerThread)</td></tr>
<tr class="memdesc:aa961b3aafc08805f7611d4edd283f804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is no more streaming work to be done yet (if false, calls to _update could be needed once again) See waitForStreamingCompletion.  <br /></td></tr>
<tr class="separator:aa961b3aafc08805f7611d4edd283f804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6d7560d59263dc303563777b5c61e8" id="r_a4f6d7560d59263dc303563777b5c61e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a4f6d7560d59263dc303563777b5c61e8">_updateMetadataCache</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="separator:a4f6d7560d59263dc303563777b5c61e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b2dac622f85cd2dec83834ee10fecd" id="r_a71b2dac622f85cd2dec83834ee10fecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a71b2dac622f85cd2dec83834ee10fecd">_updateStreaming</a> ()</td></tr>
<tr class="separator:a71b2dac622f85cd2dec83834ee10fecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6ee50fe51ac71c60f66e044859bf9d" id="r_a4f6ee50fe51ac71c60f66e044859bf9d"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a4f6ee50fe51ac71c60f66e044859bf9d">_updateStreamingWorkerThread</a> (<a class="el" href="class_ogre_1_1_thread_handle.html">ThreadHandle</a> *threadHandle)</td></tr>
<tr class="separator:a4f6ee50fe51ac71c60f66e044859bf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada01fc57b26dd0f912572c288eb08dac" id="r_ada01fc57b26dd0f912572c288eb08dac"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ada01fc57b26dd0f912572c288eb08dac">_updateTextureMultiLoadWorkerThread</a> (<a class="el" href="class_ogre_1_1_thread_handle.html">ThreadHandle</a> *threadHandle)</td></tr>
<tr class="memdesc:ada01fc57b26dd0f912572c288eb08dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements multiload.  <br /></td></tr>
<tr class="separator:ada01fc57b26dd0f912572c288eb08dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c872d542fd78e2db884ff8904d4c39d" id="r_a2c872d542fd78e2db884ff8904d4c39d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a2c872d542fd78e2db884ff8904d4c39d">_waitFor</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, bool metadataOnly)</td></tr>
<tr class="memdesc:a2c872d542fd78e2db884ff8904d4c39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use directly. See <a class="el" href="class_ogre_1_1_texture_gpu.html#a13af2e0d5c099c3be71e33c2159b16e9" title="Blocks main thread until metadata is ready.">TextureGpu::waitForMetadata</a> &amp; TextureGpu::waitForDataReady.  <br /></td></tr>
<tr class="separator:a2c872d542fd78e2db884ff8904d4c39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55e0672860ad3ed3695374d9e12c7ba" id="r_ac55e0672860ad3ed3695374d9e12c7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ac55e0672860ad3ed3695374d9e12c7ba">_waitForPendingGpuToCpuSyncs</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:ac55e0672860ad3ed3695374d9e12c7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use directly. See TextureGpu::waitForPendingSyncs.  <br /></td></tr>
<tr class="separator:ac55e0672860ad3ed3695374d9e12c7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cace3a36dcc63cb0ba5662f2c29b8a" id="r_ae4cace3a36dcc63cb0ba5662f2c29b8a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ae4cace3a36dcc63cb0ba5662f2c29b8a">checkSupport</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> format, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> textureFlags) const</td></tr>
<tr class="memdesc:ae4cace3a36dcc63cb0ba5662f2c29b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given format with the texture flags combination is supported.  <br /></td></tr>
<tr class="separator:ae4cace3a36dcc63cb0ba5662f2c29b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e7ae62f823f48c7c4844a2d34589de" id="r_a71e7ae62f823f48c7c4844a2d34589de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_async_texture_ticket.html">AsyncTextureTicket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a71e7ae62f823f48c7c4844a2d34589de">createAsyncTextureTicket</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> depthOrSlices, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormatFamily)</td></tr>
<tr class="memdesc:a71e7ae62f823f48c7c4844a2d34589de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="class_ogre_1_1_async_texture_ticket.html" title="In Ogre 2.2 reading data from GPU back to CPU is asynchronous.">AsyncTextureTicket</a> that can be used to download data GPU -&gt; CPU from a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>.  <br /></td></tr>
<tr class="separator:a71e7ae62f823f48c7c4844a2d34589de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad118a876e3102b5ae6ba5cefba5bdf1d" id="r_ad118a876e3102b5ae6ba5cefba5bdf1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad118a876e3102b5ae6ba5cefba5bdf1d">createOrRetrieveTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;aliasName, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre_1_1_common_texture_types.html#a3a978c834ce00930123468c9a64047b4">CommonTextureTypes::CommonTextureTypes</a> type, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId=0)</td></tr>
<tr class="memdesc:ad118a876e3102b5ae6ba5cefba5bdf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to call createOrRetrieveTexture with common parameters used for 2D diffuse textures loaded from file.  <br /></td></tr>
<tr class="separator:ad118a876e3102b5ae6ba5cefba5bdf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f8cd49c0990fb532306a1569b58f33" id="r_a24f8cd49c0990fb532306a1569b58f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a24f8cd49c0990fb532306a1569b58f33">createOrRetrieveTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;aliasName, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> filters=0, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId=0)</td></tr>
<tr class="separator:a24f8cd49c0990fb532306a1569b58f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5643e2d490f3f305828e3de64e1b5934" id="r_a5643e2d490f3f305828e3de64e1b5934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a5643e2d490f3f305828e3de64e1b5934">createOrRetrieveTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre_1_1_common_texture_types.html#a3a978c834ce00930123468c9a64047b4">CommonTextureTypes::CommonTextureTypes</a> type, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId=0)</td></tr>
<tr class="separator:a5643e2d490f3f305828e3de64e1b5934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf67202da75b8c6f9134d7e81baa89d8" id="r_abf67202da75b8c6f9134d7e81baa89d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abf67202da75b8c6f9134d7e81baa89d8">createOrRetrieveTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> filters=0, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId=0)</td></tr>
<tr class="separator:abf67202da75b8c6f9134d7e81baa89d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017eec4324d75ffb0de6b0fc1fdd2654" id="r_a017eec4324d75ffb0de6b0fc1fdd2654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a017eec4324d75ffb0de6b0fc1fdd2654">createTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;aliasName, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> filters=0, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId=0)</td></tr>
<tr class="separator:a017eec4324d75ffb0de6b0fc1fdd2654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1cdf54c1a262bc911d37235682ec1c" id="r_a8d1cdf54c1a262bc911d37235682ec1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a8d1cdf54c1a262bc911d37235682ec1c">createTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> filters=0, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId=0)</td></tr>
<tr class="separator:a8d1cdf54c1a262bc911d37235682ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148bb602fcf5d9b37d38bb15eaff5944" id="r_a148bb602fcf5d9b37d38bb15eaff5944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a148bb602fcf5d9b37d38bb15eaff5944">destroyAllAsyncTextureTicket</a> ()</td></tr>
<tr class="separator:a148bb602fcf5d9b37d38bb15eaff5944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af906e6a5e055170b281a1986374b4754" id="r_af906e6a5e055170b281a1986374b4754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#af906e6a5e055170b281a1986374b4754">destroyAsyncTextureTicket</a> (<a class="el" href="class_ogre_1_1_async_texture_ticket.html">AsyncTextureTicket</a> *ticket)</td></tr>
<tr class="separator:af906e6a5e055170b281a1986374b4754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc898578da3113affb78ed60f209b71" id="r_a7dc898578da3113affb78ed60f209b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a7dc898578da3113affb78ed60f209b71">destroyTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a7dc898578da3113affb78ed60f209b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a texture.  <br /></td></tr>
<tr class="separator:a7dc898578da3113affb78ed60f209b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841f10a656bbd24ed92b87f616e33f74" id="r_a841f10a656bbd24ed92b87f616e33f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a841f10a656bbd24ed92b87f616e33f74">dumpMemoryUsage</a> (<a class="el" href="class_ogre_1_1_log.html">Log</a> *log, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">Ogre::uint32</a> mask=<a class="el" href="namespace_ogre_1_1_residency_mask.html#a41a75eb215f69beb19a0039eb7e2b141a98b6ac43f7a59e7ed0b61a1b529f06ca">ResidencyMask::All</a>) const</td></tr>
<tr class="separator:a841f10a656bbd24ed92b87f616e33f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f7904a44ab902755cd06ab73fe4c77" id="r_ab9f7904a44ab902755cd06ab73fe4c77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ab9f7904a44ab902755cd06ab73fe4c77">dumpStats</a> () const</td></tr>
<tr class="separator:ab9f7904a44ab902755cd06ab73fe4c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ea160f5cd58eb1569743dee3bff9cc" id="r_a25ea160f5cd58eb1569743dee3bff9cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a25ea160f5cd58eb1569743dee3bff9cc">exportTextureMetadataCache</a> (<a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;outJson)</td></tr>
<tr class="separator:a25ea160f5cd58eb1569743dee3bff9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7dedc19c2251a15643a3e240225abd" id="r_abf7dedc19c2251a15643a3e240225abd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abf7dedc19c2251a15643a3e240225abd">findAliasNameStr</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> idName) const</td></tr>
<tr class="memdesc:abf7dedc19c2251a15643a3e240225abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function CAN be called from any thread.  <br /></td></tr>
<tr class="separator:abf7dedc19c2251a15643a3e240225abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a7a36c00587fb8298f4100606c627" id="r_abf7a7a36c00587fb8298f4100606c627"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abf7a7a36c00587fb8298f4100606c627">findResourceGroupStr</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> idName) const</td></tr>
<tr class="memdesc:abf7a7a36c00587fb8298f4100606c627"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function CAN be called from any thread.  <br /></td></tr>
<tr class="separator:abf7a7a36c00587fb8298f4100606c627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45819a2f57371a1d5ae1d026a21510ab" id="r_a45819a2f57371a1d5ae1d026a21510ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a45819a2f57371a1d5ae1d026a21510ab">findResourceNameStr</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> idName) const</td></tr>
<tr class="memdesc:a45819a2f57371a1d5ae1d026a21510ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function CAN be called from any thread.  <br /></td></tr>
<tr class="separator:a45819a2f57371a1d5ae1d026a21510ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aa5c6af459eb788ed985104c21f5f7" id="r_ad7aa5c6af459eb788ed985104c21f5f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad7aa5c6af459eb788ed985104c21f5f7">findTextureNoThrow</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name) const</td></tr>
<tr class="separator:ad7aa5c6af459eb788ed985104c21f5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68c04c2f29c8abc579dd3cb1788f0a" id="r_a7d68c04c2f29c8abc579dd3cb1788f0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a7d68c04c2f29c8abc579dd3cb1788f0a">getBudget</a> () const</td></tr>
<tr class="separator:a7d68c04c2f29c8abc579dd3cb1788f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254afe8b84c3aceb91286e03f3d15bd6" id="r_a254afe8b84c3aceb91286e03f3d15bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a254afe8b84c3aceb91286e03f3d15bd6">getDefaultMipmapGeneration</a> () const</td></tr>
<tr class="separator:a254afe8b84c3aceb91286e03f3d15bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc903cc9c56854c0d0586dca2546cff" id="r_a8fc903cc9c56854c0d0586dca2546cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a8fc903cc9c56854c0d0586dca2546cff">getDefaultMipmapGenerationCubemaps</a> () const</td></tr>
<tr class="separator:a8fc903cc9c56854c0d0586dca2546cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0249d493bc5e78dc91e57a44a93c290e" id="r_a0249d493bc5e78dc91e57a44a93c290e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad657330e7020f561860d24366460271c">ResourceEntryMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a0249d493bc5e78dc91e57a44a93c290e">getEntries</a> () const</td></tr>
<tr class="separator:a0249d493bc5e78dc91e57a44a93c290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9374e0a6a80f16ef5b3e95f38c2e44" id="r_a0e9374e0a6a80f16ef5b3e95f38c2e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#af7c8391e4119084465186113a849f065">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a0e9374e0a6a80f16ef5b3e95f38c2e44">getLoadRequestsCounter</a> () const</td></tr>
<tr class="memdesc:a0e9374e0a6a80f16ef5b3e95f38c2e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling waitForStreamingCompletion before <a class="el" href="class_ogre_1_1_root.html#ae3836b7e78a71d20713e07f748c4d760" title="Render one frame.">Root::renderOneFrame</a> should guarantee the render is perfect.  <br /></td></tr>
<tr class="separator:a0e9374e0a6a80f16ef5b3e95f38c2e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3886c70b1674b192547c407edeb4c67e" id="r_a3886c70b1674b192547c407edeb4c67e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a3886c70b1674b192547c407edeb4c67e">getMemoryStats</a> (size_t &amp;outTextureBytesCpu, size_t &amp;outTextureBytesGpu, size_t &amp;outUsedStagingTextureBytes, size_t &amp;outAvailableStagingTextureBytes)</td></tr>
<tr class="separator:a3886c70b1674b192547c407edeb4c67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d792552906d877cc26b4f0b725a126" id="r_a52d792552906d877cc26b4f0b725a126"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a52d792552906d877cc26b4f0b725a126">getProfileLoadingTime</a> () const</td></tr>
<tr class="separator:a52d792552906d877cc26b4f0b725a126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6d3b3e837106749a77009cc204a63c" id="r_aba6d3b3e837106749a77009cc204a63c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aba6d3b3e837106749a77009cc204a63c">getRenderSystem</a> () const</td></tr>
<tr class="separator:aba6d3b3e837106749a77009cc204a63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2ab9f38f0dbf29a75a82030231a9f" id="r_a18f2ab9f38f0dbf29a75a82030231a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a18f2ab9f38f0dbf29a75a82030231a9f">getStagingTexture</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> depth, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> slices, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat, size_t minConsumptionRatioThreshold=25u)</td></tr>
<tr class="memdesc:a18f2ab9f38f0dbf29a75a82030231a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> which is required to upload data CPU -&gt; GPU into a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>.  <br /></td></tr>
<tr class="separator:a18f2ab9f38f0dbf29a75a82030231a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad520c068fa3e00e87b0267336ec749b9" id="r_ad520c068fa3e00e87b0267336ec749b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad520c068fa3e00e87b0267336ec749b9">getVaoManager</a> () const</td></tr>
<tr class="separator:ad520c068fa3e00e87b0267336ec749b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064b32e7db16917d223a729f3ce03a96" id="r_a064b32e7db16917d223a729f3ce03a96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a064b32e7db16917d223a729f3ce03a96">hasPoolId</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numMipmaps, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat) const</td></tr>
<tr class="separator:a064b32e7db16917d223a729f3ce03a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7152f97e84cd44d73afc86d77951120" id="r_ae7152f97e84cd44d73afc86d77951120"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ae7152f97e84cd44d73afc86d77951120">hasTextureResource</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;aliasName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup) const</td></tr>
<tr class="memdesc:ae7152f97e84cd44d73afc86d77951120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a texture with the given aliasName exists, or if a <a class="el" href="class_ogre_1_1_resource_group_listener.html" title="This abstract class defines an interface which is called back during resource group loading to indica...">ResourceGroupListener</a> provides such texture, or if such texture exists (i.e.  <br /></td></tr>
<tr class="separator:ae7152f97e84cd44d73afc86d77951120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423e53613f85ab74171ac4bb291c2555" id="r_a423e53613f85ab74171ac4bb291c2555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a423e53613f85ab74171ac4bb291c2555">importTextureMetadataCache</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, const char *jsonString, bool bCreateReservedPools)</td></tr>
<tr class="separator:a423e53613f85ab74171ac4bb291c2555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c61552db1bcabec430a34c6255fb05" id="r_aa7c61552db1bcabec430a34c6255fb05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa7c61552db1bcabec430a34c6255fb05">isDoneStreaming</a> () const</td></tr>
<tr class="memdesc:aa7c61552db1bcabec430a34c6255fb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if we're done loading all textures based on the return value of the last call to <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a> and whether new tasks have been scheduled since then.  <br /></td></tr>
<tr class="separator:aa7c61552db1bcabec430a34c6255fb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251ca6ba922c656400b1c7ac7cac0fcd" id="r_a251ca6ba922c656400b1c7ac7cac0fcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a251ca6ba922c656400b1c7ac7cac0fcd">notifyTextureChanged</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">TextureGpuListener::Reason</a> reason, void *extraData) override</td></tr>
<tr class="separator:a251ca6ba922c656400b1c7ac7cac0fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614a8c355b86c01d9f7b847b670c1cd3" id="r_a614a8c355b86c01d9f7b847b670c1cd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a614a8c355b86c01d9f7b847b670c1cd3">removeStagingTexture</a> (<a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> *stagingTexture)</td></tr>
<tr class="separator:a614a8c355b86c01d9f7b847b670c1cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e96132817c27bfae1c0374e98d20dfc" id="r_a6e96132817c27bfae1c0374e98d20dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a6e96132817c27bfae1c0374e98d20dfc">reservePoolId</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numSlices, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numMipmaps, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat)</td></tr>
<tr class="memdesc:a6e96132817c27bfae1c0374e98d20dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves and preallocates a pool with the given parameters Returns the master texture that owns the pool.  <br /></td></tr>
<tr class="separator:a6e96132817c27bfae1c0374e98d20dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3796bc1de6a5a6efc208620686982b54" id="r_a3796bc1de6a5a6efc208620686982b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a3796bc1de6a5a6efc208620686982b54">saveTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;folderPath, set&lt; <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &gt;::type &amp;savedTextures, bool saveOitd, bool saveOriginal, <a class="el" href="class_ogre_1_1_hlms_texture_export_listener.html">HlmsTextureExportListener</a> *listener)</td></tr>
<tr class="separator:a3796bc1de6a5a6efc208620686982b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe21fe76416e68bcfc8fe57f2655e868" id="r_abe21fe76416e68bcfc8fe57f2655e868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abe21fe76416e68bcfc8fe57f2655e868">setDefaultMipmapGeneration</a> (<a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a> defaultMipmapGen, <a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a> defaultMipmapGenCubemaps)</td></tr>
<tr class="memdesc:abe21fe76416e68bcfc8fe57f2655e868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to use HW or SW mipmap generation when specifying <a class="el" href="namespace_ogre_1_1_texture_filter.html#ad1f488159fb867da13bf2ae96f04b054a537f83d75be40b8f38b5f9dc03912afa">TextureFilter::TypeGenerateDefaultMipmaps</a> for loading files from textures.  <br /></td></tr>
<tr class="separator:abe21fe76416e68bcfc8fe57f2655e868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff9f8223324c7091eaa3698bd39efe2" id="r_a1ff9f8223324c7091eaa3698bd39efe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a1ff9f8223324c7091eaa3698bd39efe2">setMultiLoadPool</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numThreads)</td></tr>
<tr class="memdesc:a1ff9f8223324c7091eaa3698bd39efe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">OgreNext always performs background streaming to load textures in a worker thread.  <br /></td></tr>
<tr class="separator:a1ff9f8223324c7091eaa3698bd39efe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e35f39923cc1f38d41c4f5fae52dcf9" id="r_a4e35f39923cc1f38d41c4f5fae52dcf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a4e35f39923cc1f38d41c4f5fae52dcf9">setProfileLoadingTime</a> (bool bProfile)</td></tr>
<tr class="memdesc:a4e35f39923cc1f38d41c4f5fae52dcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">When enabled, we will profile the time it takes a texture to go from Resident to Ready and <a class="el" href="class_ogre_1_1_log.html">Log</a> it.  <br /></td></tr>
<tr class="separator:a4e35f39923cc1f38d41c4f5fae52dcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164a5285771064ccd10c8c2d9392d9da" id="r_a164a5285771064ccd10c8c2d9392d9da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a164a5285771064ccd10c8c2d9392d9da">setStagingTextureMaxBudgetBytes</a> (size_t stagingTextureMaxBudgetBytes)</td></tr>
<tr class="memdesc:a164a5285771064ccd10c8c2d9392d9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">At a high level, texture loading works like this:  <br /></td></tr>
<tr class="separator:a164a5285771064ccd10c8c2d9392d9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68751724984a25c311ca98459a739aa" id="r_af68751724984a25c311ca98459a739aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#af68751724984a25c311ca98459a739aa">setTextureGpuManagerListener</a> (<a class="el" href="class_ogre_1_1_texture_gpu_manager_listener.html">TextureGpuManagerListener</a> *listener)</td></tr>
<tr class="memdesc:af68751724984a25c311ca98459a739aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new listener.  <br /></td></tr>
<tr class="separator:af68751724984a25c311ca98459a739aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c9420839cf914f7a5c1901c53539b" id="r_a763c9420839cf914f7a5c1901c53539b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a763c9420839cf914f7a5c1901c53539b">setTrylockMutexFailureLimit</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> tryLockFailureLimit)</td></tr>
<tr class="memdesc:a763c9420839cf914f7a5c1901c53539b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main thread tries to acquire a lock from the background thread, do something very quick, and release it.  <br /></td></tr>
<tr class="separator:a763c9420839cf914f7a5c1901c53539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb00a770d365459f490c2ecd9b96f025" id="r_aeb00a770d365459f490c2ecd9b96f025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aeb00a770d365459f490c2ecd9b96f025">setWorkerThreadMaxPerStagingTextureRequestBytes</a> (size_t maxPerStagingTextureRequestBytes)</td></tr>
<tr class="memdesc:aeb00a770d365459f490c2ecd9b96f025"><td class="mdescLeft">&#160;</td><td class="mdescRight">The worker thread tracks how many data it is loading so the Main thread can request additional StagingTextures if necessary.  <br /></td></tr>
<tr class="separator:aeb00a770d365459f490c2ecd9b96f025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de9d156bb0ef5a625f0f8a6f08a9b19" id="r_a6de9d156bb0ef5a625f0f8a6f08a9b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a6de9d156bb0ef5a625f0f8a6f08a9b19">setWorkerThreadMaxPreloadBytes</a> (size_t maxPreloadBytes)</td></tr>
<tr class="memdesc:a6de9d156bb0ef5a625f0f8a6f08a9b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The worker thread first loads the texture from disk to RAM (aka "preload", and then copies from RAM to <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a>.  <br /></td></tr>
<tr class="separator:a6de9d156bb0ef5a625f0f8a6f08a9b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cd14ba1ba374c0bf5d0774a79b1290" id="r_a40cd14ba1ba374c0bf5d0774a79b1290"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a40cd14ba1ba374c0bf5d0774a79b1290">setWorkerThreadMinimumBudget</a> (const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a> &amp;budget, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> maxSplitResolution=0)</td></tr>
<tr class="memdesc:a40cd14ba1ba374c0bf5d0774a79b1290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Background streaming works by having a bunch of preallocated StagingTextures so we're ready to start uploading as soon as we see a request to load a texture from file.  <br /></td></tr>
<tr class="separator:a40cd14ba1ba374c0bf5d0774a79b1290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1188e251546ab3391ef646d60f2317d8" id="r_a1188e251546ab3391ef646d60f2317d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a1188e251546ab3391ef646d60f2317d8">shutdown</a> ()</td></tr>
<tr class="separator:a1188e251546ab3391ef646d60f2317d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ac834c93bbe00900232169bd8b3b53" id="r_a34ac834c93bbe00900232169bd8b3b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a34ac834c93bbe00900232169bd8b3b53">waitForStreamingCompletion</a> ()</td></tr>
<tr class="memdesc:a34ac834c93bbe00900232169bd8b3b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks main thread until all pending textures are fully loaded.  <br /></td></tr>
<tr class="separator:a34ac834c93bbe00900232169bd8b3b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_ogre_1_1_texture_gpu_listener"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_ogre_1_1_texture_gpu_listener')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_ogre_1_1_texture_gpu_listener.html">Ogre::TextureGpuListener</a></td></tr>
<tr class="memitem:a315edc6e949e74ca2565d004269a2ad7 inherit pub_methods_class_ogre_1_1_texture_gpu_listener" id="r_a315edc6e949e74ca2565d004269a2ad7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#a315edc6e949e74ca2565d004269a2ad7">~TextureGpuListener</a> ()</td></tr>
<tr class="separator:a315edc6e949e74ca2565d004269a2ad7 inherit pub_methods_class_ogre_1_1_texture_gpu_listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1427f0b635a4186cd6083a9bab879fa2 inherit pub_methods_class_ogre_1_1_texture_gpu_listener" id="r_a1427f0b635a4186cd6083a9bab879fa2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#a1427f0b635a4186cd6083a9bab879fa2">shouldStayLoaded</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a1427f0b635a4186cd6083a9bab879fa2 inherit pub_methods_class_ogre_1_1_texture_gpu_listener"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> should likely stay loaded or else graphical changes could occur.  <br /></td></tr>
<tr class="separator:a1427f0b635a4186cd6083a9bab879fa2 inherit pub_methods_class_ogre_1_1_texture_gpu_listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1146a2b41f0f3f5d3b0b1bab1e74248d" id="r_a1146a2b41f0f3f5d3b0b1bab1e74248d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a1146a2b41f0f3f5d3b0b1bab1e74248d">mIgnoreSRgbPreference</a></td></tr>
<tr class="memdesc:a1146a2b41f0f3f5d3b0b1bab1e74248d"><td class="mdescLeft">&#160;</td><td class="mdescRight">While true, calls to createTexture &amp; createOrRetrieveTexture will ignore and unset the <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434aac3ff5c1bb3a3ef222a7eef0d83836ba" title="Prefer loading FROM FILES as sRGB when possible.">TextureFlags::PrefersLoadingFromFileAsSRGB</a> flag.  <br /></td></tr>
<tr class="separator:a1146a2b41f0f3f5d3b0b1bab1e74248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class manages all textures (i.e. </p>
<p><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>) since <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2</p>
<p>Explanation of the streaming model:</p>
<p><a class="el" href="class_ogre_1_1_texture_gpu_manager.html" title="This class manages all textures (i.e.">TextureGpuManager</a> uses a worker thread to load textures in the background. There are several restrictions the implementation needs to account for:</p><ul>
<li>D3D11 does not support persistent mapping. This means we must call unmap on a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> before we can copy it to the final texture.</li>
<li>Calling map/unmap from multiple threads is nearly impossible in OpenGL. This means map/unmap calls must happen in the main thread.</li>
<li><a class="el" href="class_ogre_1_1_resource_group_manager.html" title="This singleton class manages the list of resource groups, and notifying the various resource managers...">ResourceGroupManager</a> is not thread-friendly (building with thread support fills <a class="el" href="class_ogre_1_1_resource_group_manager.html" title="This singleton class manages the list of resource groups, and notifying the various resource managers...">ResourceGroupManager</a> with huge fat mutexes)</li>
<li>Most APIs allow using a simple buffer to store all sorts of staging data (regardless of format and resolution), but D3D11 is very inflexible about this, requiring StagingTextures to have a 2D resolution (rather than being a 1D buffer with just bytes), and must match the same format.</li>
</ul>
<p>Because of these restrictions, TextureGpuManager::scheduleLoadRequest will grab the <a class="el" href="class_ogre_1_1_archive.html" title="Archive-handling class.">Archive</a> to load from file from <a class="el" href="class_ogre_1_1_resource_group_manager.html" title="This singleton class manages the list of resource groups, and notifying the various resource managers...">ResourceGroupManager</a> and then create a request for the worker thread.</p>
<p>The worker thread (_updateStreamingWorkerThread) runs an infinite loop waiting for new requests.</p>
<p>The worker thread will process incoming LoadRequest: it will open the file and retrieve the important information first aka the metadata (such as resolution, pixel format, number of mipmaps, etc). It is most likely the worker thread will load the whole image from disk, and not just the metadata (at least the first slice + first mip).</p>
<p>The image is at the moment in RAM, but two things need to happen:</p><ol type="1">
<li>The image must be copied to a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> so that it can be later be copied to the final texture.</li>
<li>The texture must become Resident so that our API commands can actually work (like copying from <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> to the final texture object)</li>
</ol>
<p>The worker thread will now push an entry to mStreamingData.queuedImages for all the slices &amp; mips that are pending to copy from RAM to a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a>. That includes slice 0 mip 0.</p>
<p>It will also emit a command the main thread will eventually see to make the texture Resident (via ObjCmdBuffer::TransitionToResident)</p>
<p>The worker thread will call TextureGpuManager::getStreaming to grab an available <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> that has been pre-mapped in the main thread that can hold the data we want to upload.</p>
<p>If no such Texture is available, we cannot upload the texture yet and this failure is recorded; and we do not remove the entry from mStreamingData.queuedImages Until mStreamingData.queuedImages[i].empty() returns true, the worker thread, with each new iteration, will try again to grab a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> to finish the jobs.</p>
<p>From the main thread, with each <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a>; fullfillBudget will check the recorded failures in getStreaming from the worker thread and create &amp; map more StagingTextures to satisfy the worker thread.</p>
<p>The main thread will also execute the transition to resident commands sent from the worker thread.</p>
<p>This means that in worst case scenario, uploading a texture may require multiple ping pongs between the worker &amp; main thread, which is why <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a34ac834c93bbe00900232169bd8b3b53" title="Blocks main thread until all pending textures are fully loaded.">TextureGpuManager::waitForStreamingCompletion</a> keeps calling _update in a loop until the texture is fully loaded.</p>
<p>To put things into perspective: if getStreaming always failed to grab a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> (i.e. due to a bug), then waitForStreamingCompletion would be stuck in an infinite loop.</p>
<p>Note that this behavior applies to both multithreaded and singlethreaded versions (i.e. when OGRE_FORCE_TEXTURE_STREAMING_ON_MAIN_THREAD is defined).</p>
<p>When everything's done, queuedImage.empty() returns true, a <a class="el" href="class_ogre_1_1_obj_cmd_buffer_1_1_notify_data_is_ready.html">ObjCmdBuffer::NotifyDataIsReady</a> command to the main thread is issued, and the entry is removed from mStreamingData.queuedImages</p>
<p>Of course, the main thread tries to predict how much <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> will be needed by tracking past usage and by trying to fullfill mBudget (see <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a40cd14ba1ba374c0bf5d0774a79b1290" title="Background streaming works by having a bunch of preallocated StagingTextures so we&#39;re ready to start ...">TextureGpuManager::setWorkerThreadMinimumBudget</a>), so under best case scenario the ping pong between worker &amp; main thread is kept to a minimum.</p>
<p>TextureGpuManager::mMaxPreloadBytes puts an upper limit to this prediction to prevent memory from sky-rocketing (or reaching out of memory conditions) during spikes. There's only so much GART/GTT memory available in a system.</p>
<p>The variable mEntriesToProcessPerIteration controls how many entries in LoadRequests are processed per iteration in the worker thread. High values cause the worker thread to appear "stuck" loading lots of images without flushing our internal command buffer, which means the main thread won't see what's happening and thus unable to fullfull budget failure requests, predict accurately, and unable to perform transition to resident requests. I.e. the main thread will sit idle, until it suddenly sees a lot of work coming from the worker thread. Very low values can cause more threading contention due to excessive flushing.</p>
<p>The metadata cache helps with performance by being able to know in the main thread before creating the LoadRequest what texture pool to reserve. But performance will be degraded if the metadata cache lied, as we must then perform multiple ping pongs between the threads to correct the error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Even if you use waitForStreamingCompletion to have all of your frames rendering "perfectly" (i.e. prefer stalling rendering instead of showing a replacement texture until the real one is loaded), multithreaded streaming can still reduce your loading times because <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will immediately start loading the texture from disk while the main thread can keep executing your code (like moving on to the next <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Item</a> or Datablock you're instantiating) </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a243112239378b673ba9f1df5e7abdbf3" name="a243112239378b673ba9f1df5e7abdbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243112239378b673ba9f1df5e7abdbf3">&#9670;&#160;</a></span>BudgetEntryVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_budget_entry.html">BudgetEntry</a>&gt;::type <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">Ogre::TextureGpuManager::BudgetEntryVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75e42d75a1eae1a28e52e4613832edb3" name="a75e42d75a1eae1a28e52e4613832edb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e42d75a1eae1a28e52e4613832edb3">&#9670;&#160;</a></span>MetadataCacheMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef map&lt;<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>,<a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_metadata_cache_entry.html">MetadataCacheEntry</a>&gt;::type <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a75e42d75a1eae1a28e52e4613832edb3">Ogre::TextureGpuManager::MetadataCacheMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad657330e7020f561860d24366460271c" name="ad657330e7020f561860d24366460271c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad657330e7020f561860d24366460271c">&#9670;&#160;</a></span>ResourceEntryMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef map&lt;<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>,<a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_resource_entry.html">ResourceEntry</a>&gt;::type <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad657330e7020f561860d24366460271c">Ogre::TextureGpuManager::ResourceEntryMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7cc799aa12f7b03c686cec13d09d9c0b" name="a7cc799aa12f7b03c686cec13d09d9c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc799aa12f7b03c686cec13d09d9c0b">&#9670;&#160;</a></span>TextureGpuManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::TextureGpuManager::TextureGpuManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>renderSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ea7a2892140d8d84ee8db3f6ea7aae4" name="a8ea7a2892140d8d84ee8db3f6ea7aae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea7a2892140d8d84ee8db3f6ea7aae4">&#9670;&#160;</a></span>~TextureGpuManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::TextureGpuManager::~TextureGpuManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a68dec5d2c3187c3d7be56d9c5cc55fc4" name="a68dec5d2c3187c3d7be56d9c5cc55fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dec5d2c3187c3d7be56d9c5cc55fc4">&#9670;&#160;</a></span>_queueDownloadToRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_queueDownloadToRam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resyncOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89a4bb400a24d0e3ea9a9299192fa51d" name="a89a4bb400a24d0e3ea9a9299192fa51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a4bb400a24d0e3ea9a9299192fa51d">&#9670;&#160;</a></span>_releaseSlotFromTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_releaseSlotFromTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Must be called from main thread. </p>

</div>
</div>
<a id="a38a3edb2437dae48c14a0d20c50877fa" name="a38a3edb2437dae48c14a0d20c50877fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a3edb2437dae48c14a0d20c50877fa">&#9670;&#160;</a></span>_removeMetadataCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_removeMetadataCacheEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93773f33d6018c991b4fa8c475a8a36d" name="a93773f33d6018c991b4fa8c475a8a36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93773f33d6018c991b4fa8c475a8a36d">&#9670;&#160;</a></span>_reserveSlotForTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_reserveSlotForTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Must be called from main thread. </p>

</div>
</div>
<a id="a57719d6bae200d39449eb5f98098b1c5" name="a57719d6bae200d39449eb5f98098b1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57719d6bae200d39449eb5f98098b1c5">&#9670;&#160;</a></span>_scheduleTransitionTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_scheduleTransitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>targetResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reuploadOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSkipMultiload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46f6c11e4af75070ada1e868e7b24412" name="a46f6c11e4af75070ada1e868e7b24412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f6c11e4af75070ada1e868e7b24412">&#9670;&#160;</a></span>_scheduleUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_scheduleUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipMetadataCache</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>sliceOrDepth</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae905930e6b79e3a3c3152efc20d5249c" name="ae905930e6b79e3a3c3152efc20d5249c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae905930e6b79e3a3c3152efc20d5249c">&#9670;&#160;</a></span>_setIgnoreScheduledTasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_setIgnoreScheduledTasks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreSchedTasks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When true we will ignore all tasks in mScheduledTasks and execute transitions immediately Caller is responsible for ensuring this is safe to do. </p>
<p>The main reason for this function is that when the metadata cache is proven to be out of date and comes back to the main thread, we need to perform a Resident -&gt; OnStorage -&gt; Resident transition that bypasses pending operations, and pretend the texture has been in Resident all along. </p>

</div>
</div>
<a id="aa961b3aafc08805f7611d4edd283f804" name="aa961b3aafc08805f7611d4edd283f804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa961b3aafc08805f7611d4edd283f804">&#9670;&#160;</a></span>_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::_update </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncWithWorkerThread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there is no more streaming work to be done yet (if false, calls to _update could be needed once again) See waitForStreamingCompletion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWithWorkerThread</td><td>When true, we will wait for the worker thread to release the main mutex instead of just continuing and trying again next time we get called. This is important for waitForStreamingCompletion &amp; _waitFor because otherwise main thread may not see worker thread has finished because it's also grabbing the main mutex; and waitForStreamingCompletion will go to sleep thinking worker thread has yet to finish, and worker thread won't wake up the main thread because it has already notified it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f6d7560d59263dc303563777b5c61e8" name="a4f6d7560d59263dc303563777b5c61e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6d7560d59263dc303563777b5c61e8">&#9670;&#160;</a></span>_updateMetadataCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_updateMetadataCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71b2dac622f85cd2dec83834ee10fecd" name="a71b2dac622f85cd2dec83834ee10fecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b2dac622f85cd2dec83834ee10fecd">&#9670;&#160;</a></span>_updateStreaming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_updateStreaming </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f6ee50fe51ac71c60f66e044859bf9d" name="a4f6ee50fe51ac71c60f66e044859bf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6ee50fe51ac71c60f66e044859bf9d">&#9670;&#160;</a></span>_updateStreamingWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Ogre::TextureGpuManager::_updateStreamingWorkerThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>threadHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada01fc57b26dd0f912572c288eb08dac" name="ada01fc57b26dd0f912572c288eb08dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada01fc57b26dd0f912572c288eb08dac">&#9670;&#160;</a></span>_updateTextureMultiLoadWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Ogre::TextureGpuManager::_updateTextureMultiLoadWorkerThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>threadHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements multiload. </p>
<p>It is a simple job pool that picks the next request and loads an <a class="el" href="class_ogre_1_1_image2.html" title="Class representing an image file.">Image2</a>.</p>
<p>Then passes it to the worker thread as if the main thread had requested to load a texture from an <a class="el" href="class_ogre_1_1_image2.html" title="Class representing an image file.">Image2</a> pointer, instead of loading it from file or listener.</p>
<p>i.e. it pretends the user loaded: tex-&gt;scheduleTransitionTo( <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a>, &amp;image, autoDeleteImage = true );</p>
<p>If there are any errors we abort and pass the raw LoadRequest to the streaming thread; and the streaming thread, trying to open this texture, should encounter the same error again and handle it properly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadHandle</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Thread's return value. </dd></dl>

</div>
</div>
<a id="a2c872d542fd78e2db884ff8904d4c39d" name="a2c872d542fd78e2db884ff8904d4c39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c872d542fd78e2db884ff8904d4c39d">&#9670;&#160;</a></span>_waitFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_waitFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>metadataOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not use directly. See <a class="el" href="class_ogre_1_1_texture_gpu.html#a13af2e0d5c099c3be71e33c2159b16e9" title="Blocks main thread until metadata is ready.">TextureGpu::waitForMetadata</a> &amp; TextureGpu::waitForDataReady. </p>

</div>
</div>
<a id="ac55e0672860ad3ed3695374d9e12c7ba" name="ac55e0672860ad3ed3695374d9e12c7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55e0672860ad3ed3695374d9e12c7ba">&#9670;&#160;</a></span>_waitForPendingGpuToCpuSyncs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_waitForPendingGpuToCpuSyncs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not use directly. See TextureGpu::waitForPendingSyncs. </p>

</div>
</div>
<a id="ae4cace3a36dcc63cb0ba5662f2c29b8a" name="ae4cace3a36dcc63cb0ba5662f2c29b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cace3a36dcc63cb0ba5662f2c29b8a">&#9670;&#160;</a></span>checkSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpuManager::checkSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given format with the texture flags combination is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">textureFlags</td><td>See <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434">TextureFlags::TextureFlags</a> Supported flags are: NotTexture RenderToTexture Uav AllowAutomipmaps</td></tr>
  </table>
  </dd>
</dl>
<p>When NotTexture is set, we don't check whether it's possible to sample from this texture. Note that some buggy Android drivers may report that it's not possible to sample from that texture when it actually is. </p><dl class="section return"><dt>Returns</dt><dd>True if supported. False otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_metal_texture_gpu_manager.html#aa91c35a4b4cbe4bf4cf6d4b120e3bac5">Ogre::MetalTextureGpuManager</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_manager.html#a50565b61f8effc61866934c7862a7cd8">Ogre::VulkanTextureGpuManager</a>.</p>

</div>
</div>
<a id="a71e7ae62f823f48c7c4844a2d34589de" name="a71e7ae62f823f48c7c4844a2d34589de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e7ae62f823f48c7c4844a2d34589de">&#9670;&#160;</a></span>createAsyncTextureTicket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_async_texture_ticket.html">AsyncTextureTicket</a> * Ogre::TextureGpuManager::createAsyncTextureTicket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormatFamily</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="class_ogre_1_1_async_texture_ticket.html" title="In Ogre 2.2 reading data from GPU back to CPU is asynchronous.">AsyncTextureTicket</a> that can be used to download data GPU -&gt; CPU from a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>. </p>
<p>To upload data CPU -&gt; GPU see getStagingTexture </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td></td></tr>
    <tr><td class="paramname">depthOrSlices</td><td></td></tr>
    <tr><td class="paramname">pixelFormatFamily</td><td>If the value is not a family value, it will automatically be converted to one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad118a876e3102b5ae6ba5cefba5bdf1d" name="ad118a876e3102b5ae6ba5cefba5bdf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad118a876e3102b5ae6ba5cefba5bdf1d">&#9670;&#160;</a></span>createOrRetrieveTexture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createOrRetrieveTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_common_texture_types.html#a3a978c834ce00930123468c9a64047b4">CommonTextureTypes::CommonTextureTypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to call createOrRetrieveTexture with common parameters used for 2D diffuse textures loaded from file. </p>

</div>
</div>
<a id="a24f8cd49c0990fb532306a1569b58f33" name="a24f8cd49c0990fb532306a1569b58f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f8cd49c0990fb532306a1569b58f33">&#9670;&#160;</a></span>createOrRetrieveTexture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createOrRetrieveTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5643e2d490f3f305828e3de64e1b5934" name="a5643e2d490f3f305828e3de64e1b5934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5643e2d490f3f305828e3de64e1b5934">&#9670;&#160;</a></span>createOrRetrieveTexture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createOrRetrieveTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_common_texture_types.html#a3a978c834ce00930123468c9a64047b4">CommonTextureTypes::CommonTextureTypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf67202da75b8c6f9134d7e81baa89d8" name="abf67202da75b8c6f9134d7e81baa89d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf67202da75b8c6f9134d7e81baa89d8">&#9670;&#160;</a></span>createOrRetrieveTexture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createOrRetrieveTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a017eec4324d75ffb0de6b0fc1fdd2654" name="a017eec4324d75ffb0de6b0fc1fdd2654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017eec4324d75ffb0de6b0fc1fdd2654">&#9670;&#160;</a></span>createTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the resource. For example TreeWood.png </td></tr>
    <tr><td class="paramname">aliasName</td><td>Usually aliasName = name. An alias name allows you to load the same texture (e.g. TreeWood.png) with different settings. For example: Alias 0 - "Tree Wood With Mipmaps" Alias 1 - "Tree Wood Without Mipmaps" Alias 2 - "Tree Wood Without TextureFlags::AutomaticBatching" This lets you have 3 copies of the same file in memory. </td></tr>
    <tr><td class="paramname">pageOutStrategy</td><td></td></tr>
    <tr><td class="paramname">textureFlags</td><td>See <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434">TextureFlags::TextureFlags</a> </td></tr>
    <tr><td class="paramname">initialType</td><td>Strictly not required (i.e. can be left <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82a13888ea41a337938a549d0c5657d799d">TextureTypes::Unknown</a>) however it can be needed if set to a material before it is fully loaded; and the shader expects a particular type (e.g. it expects a cubemap). While it's not yet loaded, a dummy texture will that matches the type will be used; and it's important that the right dummy texture is selected. So if you know in advance a particular type is needed, this parameter tells <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> what dummy to use. </td></tr>
    <tr><td class="paramname">resourceGroup</td><td>Optional, but required if you want to load files from disk (or anything provided by the <a class="el" href="class_ogre_1_1_resource_group_manager.html" title="This singleton class manages the list of resource groups, and notifying the various resource managers...">ResourceGroupManager</a>) </td></tr>
    <tr><td class="paramname">poolId</td><td>Optional. See <a class="el" href="class_ogre_1_1_texture_gpu.html#a78bd23c2116dc08afcaa8dc1b8d2384e" title="2D Texture with automatic batching will be merged with other textures into the same pool as one big 2...">TextureGpu::setTexturePoolId</a> This parameter informs which pool ID you wish the texture to be assigned for. Note however, if you're using createOrRetrieveTexture and the texture has already been created (i.e. it's being retrieved) then the pool ID parameter will be ignored, as the texture was already created with a pool ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8d1cdf54c1a262bc911d37235682ec1c" name="a8d1cdf54c1a262bc911d37235682ec1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1cdf54c1a262bc911d37235682ec1c">&#9670;&#160;</a></span>createTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a148bb602fcf5d9b37d38bb15eaff5944" name="a148bb602fcf5d9b37d38bb15eaff5944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148bb602fcf5d9b37d38bb15eaff5944">&#9670;&#160;</a></span>destroyAllAsyncTextureTicket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::destroyAllAsyncTextureTicket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af906e6a5e055170b281a1986374b4754" name="af906e6a5e055170b281a1986374b4754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af906e6a5e055170b281a1986374b4754">&#9670;&#160;</a></span>destroyAsyncTextureTicket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::destroyAsyncTextureTicket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_async_texture_ticket.html">AsyncTextureTicket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dc898578da3113affb78ed60f209b71" name="a7dc898578da3113affb78ed60f209b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc898578da3113affb78ed60f209b71">&#9670;&#160;</a></span>destroyTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::destroyTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a texture. </p>
<p>Classes who wish to hold a weak reference should listen for <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e">TextureGpuListener::Deleted</a> events and clear their pointers when the texture gets destroyed.</p>
<p>Classes who wish to hold a stronger reference (note: it says 'stronger', not 'strong') should return true in <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#a1427f0b635a4186cd6083a9bab879fa2" title="Return true if this TextureGpu should likely stay loaded or else graphical changes could occur.">TextureGpuListener::shouldStayLoaded</a>, but it is not guaranteed to be honoured.</p>
<p>Users should iterate through listeners and see if any listener's shouldStayLoaded returns true. If you still want to destroy the texture, the class should still be able to handle <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e">TextureGpuListener::Deleted</a> gracefully.</p>
<p>See MemoryGameState::unloadUnusedTextures in Tutorial_MemoryGameState.cpp</p>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> doesn't call destroyTexture unless it's on shutdown or a specific Ogre-controlled texture (e.g. something related to PBS, Irradiance Fields, etc)</p>
<p>Users are the ones in control of which textures get unloaded. It is suggested users group textures by criteria so that they can be loaded and unloaded in bulk (i.e. by relation to a level, or area in an open world game, by scene, etc) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a841f10a656bbd24ed92b87f616e33f74" name="a841f10a656bbd24ed92b87f616e33f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841f10a656bbd24ed92b87f616e33f74">&#9670;&#160;</a></span>dumpMemoryUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::dumpMemoryUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_log.html">Log</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">Ogre::uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="namespace_ogre_1_1_residency_mask.html#a41a75eb215f69beb19a0039eb7e2b141a98b6ac43f7a59e7ed0b61a1b529f06ca">ResidencyMask::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9f7904a44ab902755cd06ab73fe4c77" name="ab9f7904a44ab902755cd06ab73fe4c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f7904a44ab902755cd06ab73fe4c77">&#9670;&#160;</a></span>dumpStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::dumpStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25ea160f5cd58eb1569743dee3bff9cc" name="a25ea160f5cd58eb1569743dee3bff9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ea160f5cd58eb1569743dee3bff9cc">&#9670;&#160;</a></span>exportTextureMetadataCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::exportTextureMetadataCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>outJson</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf7dedc19c2251a15643a3e240225abd" name="abf7dedc19c2251a15643a3e240225abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7dedc19c2251a15643a3e240225abd">&#9670;&#160;</a></span>findAliasNameStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> * Ogre::TextureGpuManager::findAliasNameStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>idName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function CAN be called from any thread. </p>

</div>
</div>
<a id="abf7a7a36c00587fb8298f4100606c627" name="abf7a7a36c00587fb8298f4100606c627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7a7a36c00587fb8298f4100606c627">&#9670;&#160;</a></span>findResourceGroupStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> * Ogre::TextureGpuManager::findResourceGroupStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>idName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function CAN be called from any thread. </p>

</div>
</div>
<a id="a45819a2f57371a1d5ae1d026a21510ab" name="a45819a2f57371a1d5ae1d026a21510ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45819a2f57371a1d5ae1d026a21510ab">&#9670;&#160;</a></span>findResourceNameStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> * Ogre::TextureGpuManager::findResourceNameStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>idName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function CAN be called from any thread. </p>

</div>
</div>
<a id="ad7aa5c6af459eb788ed985104c21f5f7" name="ad7aa5c6af459eb788ed985104c21f5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aa5c6af459eb788ed985104c21f5f7">&#9670;&#160;</a></span>findTextureNoThrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::findTextureNoThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d68c04c2f29c8abc579dd3cb1788f0a" name="a7d68c04c2f29c8abc579dd3cb1788f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d68c04c2f29c8abc579dd3cb1788f0a">&#9670;&#160;</a></span>getBudget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a> &amp; Ogre::TextureGpuManager::getBudget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a254afe8b84c3aceb91286e03f3d15bd6" name="a254afe8b84c3aceb91286e03f3d15bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254afe8b84c3aceb91286e03f3d15bd6">&#9670;&#160;</a></span>getDefaultMipmapGeneration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a> Ogre::TextureGpuManager::getDefaultMipmapGeneration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fc903cc9c56854c0d0586dca2546cff" name="a8fc903cc9c56854c0d0586dca2546cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc903cc9c56854c0d0586dca2546cff">&#9670;&#160;</a></span>getDefaultMipmapGenerationCubemaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a> Ogre::TextureGpuManager::getDefaultMipmapGenerationCubemaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0249d493bc5e78dc91e57a44a93c290e" name="a0249d493bc5e78dc91e57a44a93c290e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0249d493bc5e78dc91e57a44a93c290e">&#9670;&#160;</a></span>getEntries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad657330e7020f561860d24366460271c">ResourceEntryMap</a> &amp; Ogre::TextureGpuManager::getEntries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e9374e0a6a80f16ef5b3e95f38c2e44" name="a0e9374e0a6a80f16ef5b3e95f38c2e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9374e0a6a80f16ef5b3e95f38c2e44">&#9670;&#160;</a></span>getLoadRequestsCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#af7c8391e4119084465186113a849f065">uint64</a> Ogre::TextureGpuManager::getLoadRequestsCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calling waitForStreamingCompletion before <a class="el" href="class_ogre_1_1_root.html#ae3836b7e78a71d20713e07f748c4d760" title="Render one frame.">Root::renderOneFrame</a> should guarantee the render is perfect. </p>
<p>Except... a new texture may be loaded while inside renderOneFrame. If that happens the render may not be perfect. You can solve that by rendering the frame again if you need all frames to be 'perfect':</p>
<div class="fragment"><div class="line">textureMgr-&gt;waitForStreamingCompletion();</div>
<div class="line"><span class="keyword">const</span> oldValue = textureMgr-&gt;getLoadRequestsCounter();</div>
<div class="line">root-&gt;renderOneFrame();</div>
<div class="line"><span class="keywordflow">if</span>( oldValue != textureMgr-&gt;getLoadRequestsCounter() )</div>
<div class="line">{</div>
<div class="line">    textureMgr-&gt;waitForStreamingCompletion();</div>
<div class="line">    root-&gt;renderOneFrame();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3886c70b1674b192547c407edeb4c67e" name="a3886c70b1674b192547c407edeb4c67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3886c70b1674b192547c407edeb4c67e">&#9670;&#160;</a></span>getMemoryStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::getMemoryStats </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outTextureBytesCpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outTextureBytesGpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outUsedStagingTextureBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outAvailableStagingTextureBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52d792552906d877cc26b4f0b725a126" name="a52d792552906d877cc26b4f0b725a126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d792552906d877cc26b4f0b725a126">&#9670;&#160;</a></span>getProfileLoadingTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::getProfileLoadingTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba6d3b3e837106749a77009cc204a63c" name="aba6d3b3e837106749a77009cc204a63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6d3b3e837106749a77009cc204a63c">&#9670;&#160;</a></span>getRenderSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> * Ogre::TextureGpuManager::getRenderSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18f2ab9f38f0dbf29a75a82030231a9f" name="a18f2ab9f38f0dbf29a75a82030231a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f2ab9f38f0dbf29a75a82030231a9f">&#9670;&#160;</a></span>getStagingTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> * Ogre::TextureGpuManager::getStagingTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minConsumptionRatioThreshold</em> = <code>25u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> which is required to upload data CPU -&gt; GPU into a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>. </p>
<p>To download data GPU -&gt; CPU see readRequest </p><dl class="section remark"><dt>Remarks</dt><dd>We try to find the smallest available texture (won't stall) that can fit the request. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minConsumptionRatioThreshold</td><td>Value in range [0; 100]. The smallest available texture we find may still be too big (e.g. you need to upload 64x64 texture RGBA8 and we return a 8192x8192x4 staging texture which is overkill). For these cases, here you can specify how much "is too big". For example by specifying a consumptionRatio of 50; it means that the data you asked for must occupy at least 50% of the space; otherwise we'll create a new <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>A value of 100 means the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> must fit exactly (fully used). A value of 0 means any <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> will do, no matter how large.</p>
<p>StagingTextures that haven't been using in a while will be destroyed. However if for some reason we end up returning a huge texture every frame for small workloads, we'll be keeping that waste potentially forever. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> that meets the criteria. When you're done, remove it by calling removeStagingTexture. </dd></dl>

</div>
</div>
<a id="ad520c068fa3e00e87b0267336ec749b9" name="ad520c068fa3e00e87b0267336ec749b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad520c068fa3e00e87b0267336ec749b9">&#9670;&#160;</a></span>getVaoManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> * Ogre::TextureGpuManager::getVaoManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a064b32e7db16917d223a729f3ce03a96" name="a064b32e7db16917d223a729f3ce03a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064b32e7db16917d223a729f3ce03a96">&#9670;&#160;</a></span>hasPoolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::hasPoolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7152f97e84cd44d73afc86d77951120" name="ae7152f97e84cd44d73afc86d77951120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7152f97e84cd44d73afc86d77951120">&#9670;&#160;</a></span>hasTextureResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::hasTextureResource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a texture with the given aliasName exists, or if a <a class="el" href="class_ogre_1_1_resource_group_listener.html" title="This abstract class defines an interface which is called back during resource group loading to indica...">ResourceGroupListener</a> provides such texture, or if such texture exists (i.e. </p>
<p>as a file) in the <a class="el" href="class_ogre_1_1_resource_group_manager.html" title="This singleton class manages the list of resource groups, and notifying the various resource managers...">ResourceGroupManager</a>.</p>
<p>This can return true regardless of whether the texture has been loaded or created.</p>
<p>Not to be confused with findTextureNoThrow which only looks for already created textures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aliasName</td><td></td></tr>
    <tr><td class="paramname">resourceGroup</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is such texture (loaded or not) False if there is no such texture </dd></dl>

</div>
</div>
<a id="a423e53613f85ab74171ac4bb291c2555" name="a423e53613f85ab74171ac4bb291c2555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423e53613f85ab74171ac4bb291c2555">&#9670;&#160;</a></span>importTextureMetadataCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::importTextureMetadataCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>jsonString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreateReservedPools</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7c61552db1bcabec430a34c6255fb05" name="aa7c61552db1bcabec430a34c6255fb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c61552db1bcabec430a34c6255fb05">&#9670;&#160;</a></span>isDoneStreaming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::isDoneStreaming </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if we're done loading all textures based on the return value of the last call to <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a> and whether new tasks have been scheduled since then. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Do NOT call this in a loop e.g.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Do not do this</span></div>
<div class="line"><span class="keywordflow">while</span>( textureGpuManager-&gt;isDoneStreaming() )</div>
<div class="line">    Sleep( 1 );</div>
</div><!-- fragment --><p>Because it will spin forever! The return value of this function changes whenever <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a> is called (directly or indirectly).</p>
<p>The main purpose for this function is to poll whether we're done streaming so that e.g. users can show/hide a loading screen or loading icon.</p>
<p>If you need to wait until all textures are done, use waitForStreamingCompletion </p>

</div>
</div>
<a id="a251ca6ba922c656400b1c7ac7cac0fcd" name="a251ca6ba922c656400b1c7ac7cac0fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251ca6ba922c656400b1c7ac7cac0fcd">&#9670;&#160;</a></span>notifyTextureChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::notifyTextureChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">TextureGpuListener::Reason</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extraData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#aad4e9062c9a92d1e2cc57d4bbe50eb95" title="Called when a TextureGpu changed in a way that affects how it is displayed:">TextureGpuListener::notifyTextureChanged</a> </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#aad4e9062c9a92d1e2cc57d4bbe50eb95">Ogre::TextureGpuListener</a>.</p>

</div>
</div>
<a id="a614a8c355b86c01d9f7b847b670c1cd3" name="a614a8c355b86c01d9f7b847b670c1cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614a8c355b86c01d9f7b847b670c1cd3">&#9670;&#160;</a></span>removeStagingTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::removeStagingTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> *&#160;</td>
          <td class="paramname"><em>stagingTexture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e96132817c27bfae1c0374e98d20dfc" name="a6e96132817c27bfae1c0374e98d20dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e96132817c27bfae1c0374e98d20dfc">&#9670;&#160;</a></span>reservePoolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::reservePoolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves and preallocates a pool with the given parameters Returns the master texture that owns the pool. </p>
<p>Destroy this pool with <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a7dc898578da3113affb78ed60f209b71" title="Destroys a texture.">TextureGpuManager::destroyTexture</a> </p>

</div>
</div>
<a id="a3796bc1de6a5a6efc208620686982b54" name="a3796bc1de6a5a6efc208620686982b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3796bc1de6a5a6efc208620686982b54">&#9670;&#160;</a></span>saveTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::saveTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>folderPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>savedTextures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveOitd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_texture_export_listener.html">HlmsTextureExportListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe21fe76416e68bcfc8fe57f2655e868" name="abe21fe76416e68bcfc8fe57f2655e868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe21fe76416e68bcfc8fe57f2655e868">&#9670;&#160;</a></span>setDefaultMipmapGeneration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setDefaultMipmapGeneration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a>&#160;</td>
          <td class="paramname"><em>defaultMipmapGen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a>&#160;</td>
          <td class="paramname"><em>defaultMipmapGenCubemaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to use HW or SW mipmap generation when specifying <a class="el" href="namespace_ogre_1_1_texture_filter.html#ad1f488159fb867da13bf2ae96f04b054a537f83d75be40b8f38b5f9dc03912afa">TextureFilter::TypeGenerateDefaultMipmaps</a> for loading files from textures. </p>
<p>This setting has no effect for filters explicitly asking for HW mipmap generation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultMipmapGen</td><td>Whether to enable HW mipmap generation for textures. Default is true. </td></tr>
    <tr><td class="paramname">defaultMipmapGenCubemaps</td><td>Whether to enable HW mipmap generation for cubemap textures. Default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ff9f8223324c7091eaa3698bd39efe2" name="a1ff9f8223324c7091eaa3698bd39efe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff9f8223324c7091eaa3698bd39efe2">&#9670;&#160;</a></span>setMultiLoadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setMultiLoadPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OgreNext always performs background streaming to load textures in a worker thread. </p>
<p>However there is only ONE background thread performing all work serially while the main thread can do other stuff (like rendering, even if textures aren't ready).</p>
<p>There are times where you need to load many textures at once and having a threadpool of textures increases throughput.</p>
<p>The threadpool will load N textures at once into RAM, and then send them to the background thread to upload them to the GPU.</p>
<p>Once the background thread is ready, the main thread is signalled about the situation.</p>
<p>Enabling the MultiLoad pool can give performance benefits in the following scenarios:</p>
<ul>
<li>You are IO limited: the threadpool gets stalled but in the meantime the background thread still loads what's ready in System RAM into GPU RAM</li>
<li>You are ALU/CPU limited: Loading PNG/JPG files needs decoding. Loading multiple at once is better use of CPU resources.</li>
</ul>
<p>Enabling Multiload pool may increase memory consumption because you may end up with many images (more than numThreads) loaded in RAM.</p>
<p>You can change this value at any time, but it is an expensive call as we need to synchronize with the threadpool and flush all work.</p>
<p>Testing shows on an AMD Ryzen 5900X (12C/24T) loading of many PNG &amp; JPG files of varying sizes (up to 2048x2048 RGBA8_UNORM) was cut from 1 second to 0.7 seconds in a Debug build.</p>
<p>However a Lenovo TB-X6C6X (4C/4T) Android tablet, the same workload cut from 5 seconds to 1 second, in a Release build. </p><dl class="section remark"><dt>Remarks</dt><dd>Because of the multithreaded nature, enabling this feature means textures may be loaded out of order.</dd></dl>
<p>Without this feature, normally textures would be loaded in order, unless there was an issue (e.g. file couldn't be found, raising an exception; the metadata cache was out of date, etc).</p>
<p>This can have an impact if you rely on the order (e.g. if you are using <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a6e96132817c27bfae1c0374e98d20dfc" title="Reserves and preallocates a pool with the given parameters Returns the master texture that owns the p...">reservePoolId()</a>). If you need to preserve ordering, you can use TextureGpu::scheduleTransition and set bSkipMultiload = true.</p>
<p>Testing indicates the ideal value is somewhere between 4-8 threads. More threads and you get diminishing returns. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numThreads</td><td>How many number of threads to use for loading multiple textures. 0 to disable this feature (Default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e35f39923cc1f38d41c4f5fae52dcf9" name="a4e35f39923cc1f38d41c4f5fae52dcf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e35f39923cc1f38d41c4f5fae52dcf9">&#9670;&#160;</a></span>setProfileLoadingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setProfileLoadingTime </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bProfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When enabled, we will profile the time it takes a texture to go from Resident to Ready and <a class="el" href="class_ogre_1_1_log.html">Log</a> it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bProfile</td><td>True to enable. False to disable profiling. Default value depends on Debug mode (default to true on Debug, false on Release) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a164a5285771064ccd10c8c2d9392d9da" name="a164a5285771064ccd10c8c2d9392d9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164a5285771064ccd10c8c2d9392d9da">&#9670;&#160;</a></span>setStagingTextureMaxBudgetBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setStagingTextureMaxBudgetBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stagingTextureMaxBudgetBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>At a high level, texture loading works like this: </p>
<ol type="1">
<li>Grab a free <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> from "available" pool in main thread</li>
<li>Load image from file in secondary thread and fill the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a></li>
<li>Copy from <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> to final <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> in main thread</li>
<li>Release the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> so it goes back to "available" pool.</li>
<li>Repeat from step 1 for next batch of images to load. <dl class="section user"><dt></dt><dd>All is well except for one little detail in steps 1 and 4: The <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> released at step 4 can't become immediately available as the GPU could still be performing the copy from step 3, so we must wait a few frames until it's safe to map it again. </dd></dl>
<dl class="section user"><dt></dt><dd>That means at step 1, there may be StagingTextures in the "available" pool, yet however none of them are actually ready to grab; so we create a new one instead. </dd></dl>
<dl class="section user"><dt></dt><dd>In other words, if the CPU produces textures faster than the GPU can consume them, we may keep creating more and more StagingTextures until we run out of memory. </dd></dl>
<dl class="section user"><dt></dt><dd>That's where this function comes in. This function limits how much we let the "available" pool grow. If the threshold is exceeded, instead of creating a new <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> at step 1; we'll begin to stall and wait for the GPU to catch up; so we can reuse these StagingTextures again. If no <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> is capable of performing the upload (e.g. they're of incompatible format) we'll start deleting StagingTextures to make room for the one we need. The details are explained in checkStagingTextureLimits. </dd></dl>
<dl class="section user"><dt></dt><dd>This limit is tightly respected by <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> but not a hard one. For example if you set the limit on 256MB and we require a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> of 326MB to load a very, very big texture, then <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> has no other choice but to delete all textures in mAvailableStagingTextures and create one of 326MB that can perform the operation; but <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> won't error out because 326 &gt; 256MB. (though in such scenario the process may run out of memory and crash) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This limit only counts for textures that are in zero-referenced in mAvailableStagingTextures. For example if you've set the limit in 256MB and you've created 1GB worth of StagingTextures (i.e. via getStagingTexture) and never released them via removeStagingTexture; those textures don't count. We only check the limit against the released textures in mAvailableStagingTextures. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stagingTextureMaxBudgetBytes</td><td>Limit in bytes, on how much memory we let in mAvailableStagingTextures before we start stalling the GPU and/or aggressively destroying them. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="af68751724984a25c311ca98459a739aa" name="af68751724984a25c311ca98459a739aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68751724984a25c311ca98459a739aa">&#9670;&#160;</a></span>setTextureGpuManagerListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setTextureGpuManagerListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_manager_listener.html">TextureGpuManagerListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a new listener. </p>
<p>The old one will be destroyed with OGRE_DELETE See <a class="el" href="class_ogre_1_1_texture_gpu_manager_listener.html">TextureGpuManagerListener</a>. Pointer cannot be null. </p>

</div>
</div>
<a id="a763c9420839cf914f7a5c1901c53539b" name="a763c9420839cf914f7a5c1901c53539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c9420839cf914f7a5c1901c53539b">&#9670;&#160;</a></span>setTrylockMutexFailureLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setTrylockMutexFailureLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>tryLockFailureLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main thread tries to acquire a lock from the background thread, do something very quick, and release it. </p>
<p>If the lock failed to acquire, we try again next time _update is called. However if this happens too often in a row, we should stall and wait indefinitely for the background thread.</p>
<p>This function allows you to specify how many failures we have to let pass before we stall. </p><dl class="section remark"><dt>Remarks</dt><dd>This is a failsafe mechanism for edge case behaviors that should never happen. It is rare for the tryLock() to fail more than twice in a row.</dd></dl>
<p>However if loading a several big files (e.g. large cubemaps) or loading from a slow medium (e.g. from the internet directly) many tryLock() failures could be common.</p>
<p>If failure to acquire the lock is common and expected, small limit values could cause a lot of stutter, because e.g. a value of 3 could cause fps lag spikes every 3 frames.</p>
<p>A sensible value such as 1200 means that a stall would only happen after 20 seconds of repeated failure if running at constant 60 fps. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tryLockFailureLimit</td><td>How many failures we have to wait for a stall, expressed in calls <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a>. Usually there's one call to _update per frame, but there can be more. Use 0 to always stall Use std::numeric_limits&lt;uint32&gt;::max() for no failure limits (i.e. never stall) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb00a770d365459f490c2ecd9b96f025" name="aeb00a770d365459f490c2ecd9b96f025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb00a770d365459f490c2ecd9b96f025">&#9670;&#160;</a></span>setWorkerThreadMaxPerStagingTextureRequestBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setWorkerThreadMaxPerStagingTextureRequestBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPerStagingTextureRequestBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The worker thread tracks how many data it is loading so the Main thread can request additional StagingTextures if necessary. </p>
<p>One big <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> reduces the amount of time we map memory so we can upload.</p>
<p>However one big <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> also means that if we've used 1 byte out of 200MB available, we have to wait until that byte has finished transferring (that usually means the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> becomes available 3 frames later); which can result in three big StagingTextures (one for each frame) which can be overkill.</p>
<p>This function allows you to specify when we decide to break these requests in smaller pieces, which by default is set at 64MB </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxPerStagingTextureRequestBytes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6de9d156bb0ef5a625f0f8a6f08a9b19" name="a6de9d156bb0ef5a625f0f8a6f08a9b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de9d156bb0ef5a625f0f8a6f08a9b19">&#9670;&#160;</a></span>setWorkerThreadMaxPreloadBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setWorkerThreadMaxPreloadBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPreloadBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The worker thread first loads the texture from disk to RAM (aka "preload", and then copies from RAM to <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a>. </p>
<p>Later the main thread will copy from <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> to actual texture. </p><dl class="section user"><dt></dt><dd>This value controls how many bytes are preloaded (i.e. from disk to RAM) by the worker thread until the next _update call from the main thread is issued. </dd></dl>
<dl class="section user"><dt></dt><dd>Higher values allows worker thread to keep loading textures while your main thread loads the rest of the scene. Lower values prevent Out of Memory conditions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Due to how the code works, this value will also affect how much <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> we ask to the main thread (because preloading becomes a bottleneck). </dd></dl>
<dl class="section user"><dt></dt><dd>Testing shows that very high values (i.e. &gt;256MB) have the potential of uncovering driver bugs (even in 64-bit builds) and thus are not recommended. </dd></dl>
<dl class="section user"><dt></dt><dd>The value is an approximation and not a hard limit. e.g. if loading a 128MB cubemap and the limit is 1 byte; then we'll preload 128MBs. But we won't be loading anything else. Also due to how the code works, there is some broad granularity issues that can cause us to consume a bit more. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxPreloadBytes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40cd14ba1ba374c0bf5d0774a79b1290" name="a40cd14ba1ba374c0bf5d0774a79b1290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cd14ba1ba374c0bf5d0774a79b1290">&#9670;&#160;</a></span>setWorkerThreadMinimumBudget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setWorkerThreadMinimumBudget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a> &amp;&#160;</td>
          <td class="paramname"><em>budget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>maxSplitResolution</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Background streaming works by having a bunch of preallocated StagingTextures so we're ready to start uploading as soon as we see a request to load a texture from file. </p>
<dl class="section user"><dt></dt><dd>If there is no minimum budget or it is too small for the texture you're trying to load, background threads can't start as soon as possible and has to wait until the next call to _update (or to waitForStreamingCompletion). This controls how much memory we reserve. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Be careful on reserving too much memory, or else Out of Memory situations could arise. The amount of memory you can reserved is limited by the GTT (Graphics Translation Table) and the limit may be much lower than the total System RAM. For example my 16GB RAM system with a 2GB GPU, the GTT limit on Linux is of 3GB (use radeontop to find this information). See <a href="https://en.wikipedia.org/wiki/Graphics_address_remapping_table">https://en.wikipedia.org/wiki/Graphics_address_remapping_table</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">budget</td><td>Array of parameters for the staging textures we'll reserve. The budget can be empty. </td></tr>
    <tr><td class="paramname">maxSplitResolution</td><td>Textures bigger than this resolution in any axis will be taken as "exceptions" or "spikes" that won't last long. e.g. if maxSplitResolution = 2048 then a 2048x16, 67x2048, 2048x2048, and a 4096x4096 texture will all be considered abnormal.</td></tr>
  </table>
  </dd>
</dl>
<p>This can significantly affect how much memory we consume while streaming. A value of 0 means to keep current value.</p>
<p>If an entry in the budget contains minNumSlices &gt; 1 and minResolution &gt;= maxSplitResolution then a lot of memory waste could end up being caused; thus we will warn to the Ogre.log if you set such setting.</p>
<p>The default value in 32-bit systems and mobile is 2048 The default value in 64-bit Desktop systems is 4096</p>
<p>This setting is closely related to setWorkerThreadMaxPerStagingTextureRequestBytes, because a texture whose resolution is &gt;= maxSplitResolution will force us to use multiple StagingTextures, thus relieving the pressure on memory and memory fragmentation. </p>

</div>
</div>
<a id="a1188e251546ab3391ef646d60f2317d8" name="a1188e251546ab3391ef646d60f2317d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1188e251546ab3391ef646d60f2317d8">&#9670;&#160;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34ac834c93bbe00900232169bd8b3b53" name="a34ac834c93bbe00900232169bd8b3b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ac834c93bbe00900232169bd8b3b53">&#9670;&#160;</a></span>waitForStreamingCompletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::waitForStreamingCompletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks main thread until all pending textures are fully loaded. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1146a2b41f0f3f5d3b0b1bab1e74248d" name="a1146a2b41f0f3f5d3b0b1bab1e74248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1146a2b41f0f3f5d3b0b1bab1e74248d">&#9670;&#160;</a></span>mIgnoreSRgbPreference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::mIgnoreSRgbPreference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>While true, calls to createTexture &amp; createOrRetrieveTexture will ignore and unset the <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434aac3ff5c1bb3a3ef222a7eef0d83836ba" title="Prefer loading FROM FILES as sRGB when possible.">TextureFlags::PrefersLoadingFromFileAsSRGB</a> flag. </p>
<p>This is useful if user is not doing PBR, or working in its own colour space manually handled.</p>
<p>Default value is false</p>
<dl class="section remark"><dt>Remarks</dt><dd>PUBLIC VARIABLE. This variable can be altered directly. Changes are reflected immediately.</dd></dl>
<p>Changes will be reflected on new textures. Existing textures no longer possess the information to know whether they were created w/ PrefersLoadingFromFileAsSRGB</p>
<p>This value is not read nor write from the worker thread, thus it is thread-safe.</p>
<p>Textures may still be loaded as SRGB if they explicitly request SRGB e.g. <code>texture-&gt;setPixelFormat( PFG_RGBA8_UNORM_SRGB )</code> was called or the texture is loaded from an OITD or DDS format specifically asking for PFG_RGBA8_UNORM_SRGB.</p>
<p>What this flag controls is that if we're loading a regular texture asking for PFG_RGBA8_UNORM like PNG (and other linear formats) then should we honour PrefersLoadingFromFileAsSRGB flag or not. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_texture_gpu_manager_8h.html">OgreTextureGpuManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
