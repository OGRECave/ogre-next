<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::VaoManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE-Next
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_vao_manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_vao_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::VaoManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreVaoManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::VaoManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_vao_manager__inherit__graph.svg" width="580" height="291"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_vao_manager_1_1_memory_stats_entry.html">MemoryStatsEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8a984ae987b00e95b35198131a4e9a6b"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="struct_ogre_1_1_vao_manager_1_1_memory_stats_entry.html">MemoryStatsEntry</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a8a984ae987b00e95b35198131a4e9a6b">MemoryStatsEntryVec</a></td></tr>
<tr class="separator:a8a984ae987b00e95b35198131a4e9a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aefc5b9e08e0a507c264f5e3c93f6c706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#aefc5b9e08e0a507c264f5e3c93f6c706">VaoManager</a> (const <a class="el" href="group___general.html#gad887d0555b483f6499fcd3a4dab0e0c6">NameValuePairList</a> *params)</td></tr>
<tr class="separator:aefc5b9e08e0a507c264f5e3c93f6c706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947e41649220c4e3bdc012476b71c89d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a947e41649220c4e3bdc012476b71c89d">~VaoManager</a> ()</td></tr>
<tr class="separator:a947e41649220c4e3bdc012476b71c89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6116b67f3bbdbd05f087d7e3bbb5131"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ad6116b67f3bbdbd05f087d7e3bbb5131">_beginFrame</a> ()</td></tr>
<tr class="separator:ad6116b67f3bbdbd05f087d7e3bbb5131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4c485c93cb4547e0c93a8cc5f05224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a0a4c485c93cb4547e0c93a8cc5f05224">_getDynamicBufferCurrentFrameNoWait</a> () const</td></tr>
<tr class="separator:a0a4c485c93cb4547e0c93a8cc5f05224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374058250675bac30bfb5b03c26b5eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a374058250675bac30bfb5b03c26b5eb7">_notifyStagingBufferEnteredZeroRef</a> (<a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *stagingBuffer)</td></tr>
<tr class="separator:a374058250675bac30bfb5b03c26b5eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2545e4ce03ff536e3d505e4669cc91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ace2545e4ce03ff536e3d505e4669cc91">_notifyStagingBufferLeftZeroRef</a> (<a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *stagingBuffer)</td></tr>
<tr class="separator:ace2545e4ce03ff536e3d505e4669cc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa96e4f0157b0109ab892a52e57a9d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a6fa96e4f0157b0109ab892a52e57a9d8">_update</a> ()</td></tr>
<tr class="separator:a6fa96e4f0157b0109ab892a52e57a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4042640f22065fba7929049f3770008"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ac4042640f22065fba7929049f3770008">_waitUntilCommitedCommandBufferCompleted</a> ()</td></tr>
<tr class="memdesc:ac4042640f22065fba7929049f3770008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the last committed command buffer completion instead of the last frame completion with command buffer switching, so we can continue to work with current command buffer.  <a href="class_ogre_1_1_vao_manager.html#ac4042640f22065fba7929049f3770008">More...</a><br /></td></tr>
<tr class="separator:ac4042640f22065fba7929049f3770008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320cb3ed58ddfdc5870d097e90064f3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a320cb3ed58ddfdc5870d097e90064f3f">cleanupEmptyPools</a> ()=0</td></tr>
<tr class="memdesc:a320cb3ed58ddfdc5870d097e90064f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees GPU memory if there are empty, unused pools.  <a href="class_ogre_1_1_vao_manager.html#a320cb3ed58ddfdc5870d097e90064f3f">More...</a><br /></td></tr>
<tr class="separator:a320cb3ed58ddfdc5870d097e90064f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7cb641e18e9489cfa9bf868fd30985"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aef9bfd2a5567613e99bc8d7eae1c1bf9">AsyncTicketPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a0b7cb641e18e9489cfa9bf868fd30985">createAsyncTicket</a> (<a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *creator, <a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *stagingBuffer, size_t elementStart, size_t elementCount)=0</td></tr>
<tr class="separator:a0b7cb641e18e9489cfa9bf868fd30985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952ab60d93451fc2ea18e14bbc31c309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a952ab60d93451fc2ea18e14bbc31c309">createConstBuffer</a> (size_t sizeBytes, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a952ab60d93451fc2ea18e14bbc31c309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an constant buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a952ab60d93451fc2ea18e14bbc31c309">More...</a><br /></td></tr>
<tr class="separator:a952ab60d93451fc2ea18e14bbc31c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f791867304e682175612237b3bfd470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a0f791867304e682175612237b3bfd470">createIndexBuffer</a> (<a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexBufferPacked::IndexType</a> indexType, size_t numIndices, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a0f791867304e682175612237b3bfd470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an index buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a0f791867304e682175612237b3bfd470">More...</a><br /></td></tr>
<tr class="separator:a0f791867304e682175612237b3bfd470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ec74188530974bc3c28f3d1ab2982f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_indirect_buffer_packed.html">IndirectBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ad5ec74188530974bc3c28f3d1ab2982f">createIndirectBuffer</a> (size_t sizeBytes, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:ad5ec74188530974bc3c28f3d1ab2982f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an indirect buffer.  <a href="class_ogre_1_1_vao_manager.html#ad5ec74188530974bc3c28f3d1ab2982f">More...</a><br /></td></tr>
<tr class="separator:ad5ec74188530974bc3c28f3d1ab2982f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f95d947d7dae2068089fe00a03eb37d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html">ReadOnlyBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a9f95d947d7dae2068089fe00a03eb37d">createReadOnlyBuffer</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat, size_t sizeBytes, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a9f95d947d7dae2068089fe00a03eb37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a read-only buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a9f95d947d7dae2068089fe00a03eb37d">More...</a><br /></td></tr>
<tr class="separator:a9f95d947d7dae2068089fe00a03eb37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f1ac357be2baf213594f302d8c90d8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ae9f1ac357be2baf213594f302d8c90d8">createStagingBuffer</a> (size_t sizeBytes, bool forUpload)=0</td></tr>
<tr class="memdesc:ae9f1ac357be2baf213594f302d8c90d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new staging buffer and adds it to the pool.  <a href="class_ogre_1_1_vao_manager.html#ae9f1ac357be2baf213594f302d8c90d8">More...</a><br /></td></tr>
<tr class="separator:ae9f1ac357be2baf213594f302d8c90d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15deceadb9ee88de12fd801464e4b09b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a15deceadb9ee88de12fd801464e4b09b">createTexBuffer</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat, size_t sizeBytes, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a15deceadb9ee88de12fd801464e4b09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an constant buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a15deceadb9ee88de12fd801464e4b09b">More...</a><br /></td></tr>
<tr class="separator:a15deceadb9ee88de12fd801464e4b09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6001313fdecc1491daa683595fdb5018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a6001313fdecc1491daa683595fdb5018">createUavBuffer</a> (size_t numElements, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> bytesPerElement, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> bindFlags, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a6001313fdecc1491daa683595fdb5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an UAV buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a6001313fdecc1491daa683595fdb5018">More...</a><br /></td></tr>
<tr class="separator:a6001313fdecc1491daa683595fdb5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76927e1aaf3cdd9dfddcf4f7bbb0a48a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_vertex_array_object.html">VertexArrayObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a76927e1aaf3cdd9dfddcf4f7bbb0a48a">createVertexArrayObject</a> (const <a class="el" href="namespace_ogre.html#a0a4ccde77034efa918c66e561958949a">VertexBufferPackedVec</a> &amp;vertexBuffers, <a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *indexBuffer, <a class="el" href="group___general.html#ga0ef99399e9e670e7bb69dc373968a666">OperationType</a> opType)</td></tr>
<tr class="memdesc:a76927e1aaf3cdd9dfddcf4f7bbb0a48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="struct_ogre_1_1_vertex_array_object.html" title="Vertex array objects (Vaos) are immutable objects that describe a combination of vertex buffers and i...">VertexArrayObject</a> that binds all the vertex buffers with their respective declarations, and the index buffers.  <a href="class_ogre_1_1_vao_manager.html#a76927e1aaf3cdd9dfddcf4f7bbb0a48a">More...</a><br /></td></tr>
<tr class="separator:a76927e1aaf3cdd9dfddcf4f7bbb0a48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163fd24c8a7f2c33595bb7fe94e97cf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_buffer_packed.html">VertexBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3">createVertexBuffer</a> (const <a class="el" href="namespace_ogre.html#a03b06afe794fcbba8e2d2172892a80f6">VertexElement2Vec</a> &amp;vertexElements, size_t numVertices, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a163fd24c8a7f2c33595bb7fe94e97cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vertex buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3">More...</a><br /></td></tr>
<tr class="separator:a163fd24c8a7f2c33595bb7fe94e97cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204c8055903cea82fe38e6a9fbc62f6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a204c8055903cea82fe38e6a9fbc62f6d">deleteStagingBuffers</a> ()</td></tr>
<tr class="separator:a204c8055903cea82fe38e6a9fbc62f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f5147151805c3d294ae200683d76bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a51f5147151805c3d294ae200683d76bb">destroyConstBuffer</a> (<a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *constBuffer)</td></tr>
<tr class="memdesc:a51f5147151805c3d294ae200683d76bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given constant buffer created with createConstBuffer.  <a href="class_ogre_1_1_vao_manager.html#a51f5147151805c3d294ae200683d76bb">More...</a><br /></td></tr>
<tr class="separator:a51f5147151805c3d294ae200683d76bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c53b84b4c6ba27fdcbf57a08d4b044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a04c53b84b4c6ba27fdcbf57a08d4b044">destroyIndexBuffer</a> (<a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *indexBuffer)</td></tr>
<tr class="memdesc:a04c53b84b4c6ba27fdcbf57a08d4b044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given index buffer created with createIndexBuffer.  <a href="class_ogre_1_1_vao_manager.html#a04c53b84b4c6ba27fdcbf57a08d4b044">More...</a><br /></td></tr>
<tr class="separator:a04c53b84b4c6ba27fdcbf57a08d4b044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7e88128e2496523ab0ca8e35634879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a4e7e88128e2496523ab0ca8e35634879">destroyIndirectBuffer</a> (<a class="el" href="class_ogre_1_1_indirect_buffer_packed.html">IndirectBufferPacked</a> *indirectBuffer)</td></tr>
<tr class="memdesc:a4e7e88128e2496523ab0ca8e35634879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given indirect buffer created with createIndirectBuffer.  <a href="class_ogre_1_1_vao_manager.html#a4e7e88128e2496523ab0ca8e35634879">More...</a><br /></td></tr>
<tr class="separator:a4e7e88128e2496523ab0ca8e35634879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703bff2ff022184c4f40da6ecb9a19ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a703bff2ff022184c4f40da6ecb9a19ee">destroyReadOnlyBuffer</a> (<a class="el" href="class_ogre_1_1_read_only_buffer_packed.html">ReadOnlyBufferPacked</a> *readOnlyBuffer)</td></tr>
<tr class="memdesc:a703bff2ff022184c4f40da6ecb9a19ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given texture buffer created with createReadOnlyBuffer.  <a href="class_ogre_1_1_vao_manager.html#a703bff2ff022184c4f40da6ecb9a19ee">More...</a><br /></td></tr>
<tr class="separator:a703bff2ff022184c4f40da6ecb9a19ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6241229a8f3c895dcd49e7d0e8dfe545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a6241229a8f3c895dcd49e7d0e8dfe545">destroyTexBuffer</a> (<a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *texBuffer)</td></tr>
<tr class="memdesc:a6241229a8f3c895dcd49e7d0e8dfe545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given texture buffer created with createTexBuffer.  <a href="class_ogre_1_1_vao_manager.html#a6241229a8f3c895dcd49e7d0e8dfe545">More...</a><br /></td></tr>
<tr class="separator:a6241229a8f3c895dcd49e7d0e8dfe545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f235ad527a20a7c20b9daae8dc18ff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a0f235ad527a20a7c20b9daae8dc18ff7">destroyUavBuffer</a> (<a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *uavBuffer)</td></tr>
<tr class="memdesc:a0f235ad527a20a7c20b9daae8dc18ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given UAV buffer created with createUavBuffer.  <a href="class_ogre_1_1_vao_manager.html#a0f235ad527a20a7c20b9daae8dc18ff7">More...</a><br /></td></tr>
<tr class="separator:a0f235ad527a20a7c20b9daae8dc18ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d56b87f51c489bdc2df07d1ce040512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a4d56b87f51c489bdc2df07d1ce040512">destroyVertexArrayObject</a> (<a class="el" href="struct_ogre_1_1_vertex_array_object.html">VertexArrayObject</a> *vao)</td></tr>
<tr class="memdesc:a4d56b87f51c489bdc2df07d1ce040512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the input pointer.  <a href="class_ogre_1_1_vao_manager.html#a4d56b87f51c489bdc2df07d1ce040512">More...</a><br /></td></tr>
<tr class="separator:a4d56b87f51c489bdc2df07d1ce040512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dce3c8cb8c7d08ff77e6c4776fed1f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a1dce3c8cb8c7d08ff77e6c4776fed1f4">destroyVertexBuffer</a> (<a class="el" href="class_ogre_1_1_vertex_buffer_packed.html">VertexBufferPacked</a> *vertexBuffer)</td></tr>
<tr class="memdesc:a1dce3c8cb8c7d08ff77e6c4776fed1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given vertex buffer created with createVertexBuffer.  <a href="class_ogre_1_1_vao_manager.html#a1dce3c8cb8c7d08ff77e6c4776fed1f4">More...</a><br /></td></tr>
<tr class="separator:a1dce3c8cb8c7d08ff77e6c4776fed1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aed3a4936a8be631d3f135bb4cc759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ac0aed3a4936a8be631d3f135bb4cc759">getConstBufferAlignment</a> () const</td></tr>
<tr class="separator:ac0aed3a4936a8be631d3f135bb4cc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5901852733aca5d593b2f884204ffb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a3f5901852733aca5d593b2f884204ffb">getConstBufferMaxSize</a> () const</td></tr>
<tr class="separator:a3f5901852733aca5d593b2f884204ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188a85cb2888f7353fed61c07d666dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a188a85cb2888f7353fed61c07d666dda">getDefaultStagingBufferLifetime</a> () const</td></tr>
<tr class="separator:a188a85cb2888f7353fed61c07d666dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820bddab761ba53ea76cf199565e7220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a820bddab761ba53ea76cf199565e7220">getDefaultStagingBufferUnfencedTime</a> () const</td></tr>
<tr class="separator:a820bddab761ba53ea76cf199565e7220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232bf21126a76c3a3fde72b05568e51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a232bf21126a76c3a3fde72b05568e51d">getDynamicBufferMultiplier</a> () const</td></tr>
<tr class="separator:a232bf21126a76c3a3fde72b05568e51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7480a3acdc16d5092f8108ddff49783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#af7480a3acdc16d5092f8108ddff49783">getFrameCount</a> ()</td></tr>
<tr class="separator:af7480a3acdc16d5092f8108ddff49783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb673d6cf486d740c9aa5dc33c1f4c0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#afb673d6cf486d740c9aa5dc33c1f4c0d">getMemoryStats</a> (<a class="el" href="class_ogre_1_1_vao_manager.html#a8a984ae987b00e95b35198131a4e9a6b">MemoryStatsEntryVec</a> &amp;outStats, size_t &amp;outCapacityBytes, size_t &amp;outFreeBytes, <a class="el" href="class_ogre_1_1_log.html">Log</a> *log, bool &amp;outIncludesTextures) const =0</td></tr>
<tr class="memdesc:afb673d6cf486d740c9aa5dc33c1f4c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves memory stats about our GPU pools being managed.  <a href="class_ogre_1_1_vao_manager.html#afb673d6cf486d740c9aa5dc33c1f4c0d">More...</a><br /></td></tr>
<tr class="separator:afb673d6cf486d740c9aa5dc33c1f4c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0607898a5553aadd2bccb8a82cc6c952"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a0607898a5553aadd2bccb8a82cc6c952">getReadOnlyBufferMaxSize</a> () const</td></tr>
<tr class="separator:a0607898a5553aadd2bccb8a82cc6c952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755b7f61f17c568f32a6708c4d4cb986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a755b7f61f17c568f32a6708c4d4cb986">getStagingBuffer</a> (size_t minSizeBytes, bool forUpload)</td></tr>
<tr class="memdesc:a755b7f61f17c568f32a6708c4d4cb986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a staging buffer for use.  <a href="class_ogre_1_1_vao_manager.html#a755b7f61f17c568f32a6708c4d4cb986">More...</a><br /></td></tr>
<tr class="separator:a755b7f61f17c568f32a6708c4d4cb986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61efe17fa95abcd4fb4da830b78cc67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ab61efe17fa95abcd4fb4da830b78cc67">getTexBufferAlignment</a> () const</td></tr>
<tr class="separator:ab61efe17fa95abcd4fb4da830b78cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41937e26220533e4fb60c5e4d51f1802"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a41937e26220533e4fb60c5e4d51f1802">getTexBufferMaxSize</a> () const</td></tr>
<tr class="separator:a41937e26220533e4fb60c5e4d51f1802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2c12eae58c6e049221a75c0aafe91e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_timer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a1d2c12eae58c6e049221a75c0aafe91e">getTimer</a> ()</td></tr>
<tr class="separator:a1d2c12eae58c6e049221a75c0aafe91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa4278b6061752264f2887aa3dff7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a0aa4278b6061752264f2887aa3dff7ed">getUavBufferAlignment</a> () const</td></tr>
<tr class="separator:a0aa4278b6061752264f2887aa3dff7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b3d648f62caca1093fbad2b3b740f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a25b3d648f62caca1093fbad2b3b740f0">getUavBufferMaxSize</a> () const</td></tr>
<tr class="separator:a25b3d648f62caca1093fbad2b3b740f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48589a1d12b10aa89082ebca7a9c524d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a48589a1d12b10aa89082ebca7a9c524d">isFrameFinished</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> frameCount)=0</td></tr>
<tr class="memdesc:a48589a1d12b10aa89082ebca7a9c524d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this returns true, then waitForSpecificFrameToFinish is guaranteed to return immediately.  <a href="class_ogre_1_1_vao_manager.html#a48589a1d12b10aa89082ebca7a9c524d">More...</a><br /></td></tr>
<tr class="separator:a48589a1d12b10aa89082ebca7a9c524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d419c20a81ff0fd9d970263947e9a88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a9d419c20a81ff0fd9d970263947e9a88">readOnlyIsTexBuffer</a> () const</td></tr>
<tr class="memdesc:a9d419c20a81ff0fd9d970263947e9a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">When true, <a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> behaves like <a class="el" href="class_ogre_1_1_tex_buffer_packed.html" title="Represents Texture buffers (also known as tbuffers in D3D11)">TexBufferPacked</a>, i.e.  <a href="class_ogre_1_1_vao_manager.html#a9d419c20a81ff0fd9d970263947e9a88">More...</a><br /></td></tr>
<tr class="separator:a9d419c20a81ff0fd9d970263947e9a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445b8e5486e061745af43d1831f60eb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a445b8e5486e061745af43d1831f60eb6">setDefaultStagingBufferlifetime</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> lifetime, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> unfencedTime)</td></tr>
<tr class="memdesc:a445b8e5486e061745af43d1831f60eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default time for staging buffers.  <a href="class_ogre_1_1_vao_manager.html#a445b8e5486e061745af43d1831f60eb6">More...</a><br /></td></tr>
<tr class="separator:a445b8e5486e061745af43d1831f60eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39462274237779198775b927fabd4c2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a39462274237779198775b927fabd4c2c">supportsBaseInstance</a> () const</td></tr>
<tr class="separator:a39462274237779198775b927fabd4c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d060170f4a1b7ff1e750f869a9e6298"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a1d060170f4a1b7ff1e750f869a9e6298">supportsIndirectBuffers</a> () const</td></tr>
<tr class="memdesc:a1d060170f4a1b7ff1e750f869a9e6298"><td class="mdescLeft">&#160;</td><td class="mdescRight">When false, <a class="el" href="class_ogre_1_1_indirect_buffer_packed.html" title="Represents Indirect buffers for storing draw call commands.">IndirectBufferPacked</a> will emulate the mapping behavior, and we need to use the emulated calls in <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>.  <a href="class_ogre_1_1_vao_manager.html#a1d060170f4a1b7ff1e750f869a9e6298">More...</a><br /></td></tr>
<tr class="separator:a1d060170f4a1b7ff1e750f869a9e6298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedd48d2dd6f21e37fa069f92865eb45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#aaedd48d2dd6f21e37fa069f92865eb45">supportsPersistentMapping</a> () const</td></tr>
<tr class="separator:aaedd48d2dd6f21e37fa069f92865eb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af029f21d9a83ae3024e36695a3f554f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#af029f21d9a83ae3024e36695a3f554f7">waitForSpecificFrameToFinish</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> frameCount)=0</td></tr>
<tr class="memdesc:af029f21d9a83ae3024e36695a3f554f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a specific frame to be ready.  <a href="class_ogre_1_1_vao_manager.html#af029f21d9a83ae3024e36695a3f554f7">More...</a><br /></td></tr>
<tr class="separator:af029f21d9a83ae3024e36695a3f554f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a95cb3f3eeb2135707a2aec26b371c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a7a95cb3f3eeb2135707a2aec26b371c0">waitForTailFrameToFinish</a> ()=0</td></tr>
<tr class="memdesc:a7a95cb3f3eeb2135707a2aec26b371c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current frame # (which wraps to 0 every mDynamicBufferMultiplier times).  <a href="class_ogre_1_1_vao_manager.html#a7a95cb3f3eeb2135707a2aec26b371c0">More...</a><br /></td></tr>
<tr class="separator:a7a95cb3f3eeb2135707a2aec26b371c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a222d4e40df5eb53ab0b050e37aca7b89"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a222d4e40df5eb53ab0b050e37aca7b89">calculateVertexSize</a> (const <a class="el" href="namespace_ogre.html#a03b06afe794fcbba8e2d2172892a80f6">VertexElement2Vec</a> &amp;vertexElements)</td></tr>
<tr class="memdesc:a222d4e40df5eb53ab0b050e37aca7b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a single vertex buffer source with the given declaration, in bytes.  <a href="class_ogre_1_1_vao_manager.html#a222d4e40df5eb53ab0b050e37aca7b89">More...</a><br /></td></tr>
<tr class="separator:a222d4e40df5eb53ab0b050e37aca7b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8a984ae987b00e95b35198131a4e9a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a984ae987b00e95b35198131a4e9a6b">&#9670;&nbsp;</a></span>MemoryStatsEntryVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="struct_ogre_1_1_vao_manager_1_1_memory_stats_entry.html">MemoryStatsEntry</a>&gt;::type <a class="el" href="class_ogre_1_1_vao_manager.html#a8a984ae987b00e95b35198131a4e9a6b">Ogre::VaoManager::MemoryStatsEntryVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aefc5b9e08e0a507c264f5e3c93f6c706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc5b9e08e0a507c264f5e3c93f6c706">&#9670;&nbsp;</a></span>VaoManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::VaoManager::VaoManager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___general.html#gad887d0555b483f6499fcd3a4dab0e0c6">NameValuePairList</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a947e41649220c4e3bdc012476b71c89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947e41649220c4e3bdc012476b71c89d">&#9670;&nbsp;</a></span>~VaoManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::VaoManager::~VaoManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad6116b67f3bbdbd05f087d7e3bbb5131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6116b67f3bbdbd05f087d7e3bbb5131">&#9670;&nbsp;</a></span>_beginFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VaoManager::_beginFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#aceb474b23d5f38453c6ba575b7442219">Ogre::D3D11VaoManager</a>.</p>

</div>
</div>
<a id="a0a4c485c93cb4547e0c93a8cc5f05224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4c485c93cb4547e0c93a8cc5f05224">&#9670;&nbsp;</a></span>_getDynamicBufferCurrentFrameNoWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::VaoManager::_getDynamicBufferCurrentFrameNoWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a374058250675bac30bfb5b03c26b5eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374058250675bac30bfb5b03c26b5eb7">&#9670;&nbsp;</a></span>_notifyStagingBufferEnteredZeroRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::_notifyStagingBufferEnteredZeroRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td>
          <td class="paramname"><em>stagingBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2545e4ce03ff536e3d505e4669cc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2545e4ce03ff536e3d505e4669cc91">&#9670;&nbsp;</a></span>_notifyStagingBufferLeftZeroRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::_notifyStagingBufferLeftZeroRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td>
          <td class="paramname"><em>stagingBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fa96e4f0157b0109ab892a52e57a9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa96e4f0157b0109ab892a52e57a9d8">&#9670;&nbsp;</a></span>_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VaoManager::_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_vao_manager.html#ac73735e43fe3530434e7f0762824a12f">Ogre::VulkanVaoManager</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_vao_manager.html#a3d56cf0561c76828b4d073a2fc7ccb67">Ogre::NULLVaoManager</a>, <a class="el" href="class_ogre_1_1_metal_vao_manager.html#aef197b0fbe37b6c3e04236da8d4949ce">Ogre::MetalVaoManager</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a2298828954f04d6ac6dc29183c7ed733">Ogre::GL3PlusVaoManager</a>, <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#a0883005bd43a1f7817c7b25cb340e791">Ogre::D3D11VaoManager</a>, and <a class="el" href="class_ogre_1_1_g_l_e_s2_vao_manager.html#ac89183899ce6e9570437aef231ffbb0b">Ogre::GLES2VaoManager</a>.</p>

</div>
</div>
<a id="ac4042640f22065fba7929049f3770008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4042640f22065fba7929049f3770008">&#9670;&nbsp;</a></span>_waitUntilCommitedCommandBufferCompleted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VaoManager::_waitUntilCommitedCommandBufferCompleted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the last committed command buffer completion instead of the last frame completion with command buffer switching, so we can continue to work with current command buffer. </p>
<p>It's required for BT_DEFAULT_SHARED buffers upload </p><dl class="section remark"><dt>Remarks</dt><dd>BT_DEFAULT_SHARED were designed for rare uploads. Nevertheless if we need to upload new data we have to be sure that last committed command buffer's completed to avoid artefacts due to data changing on the go. Indeed on some heavy scenes gpu may still execute last committed command buffer that uses BT_DEFAULT_SHARED vertex/index buffers when we come to upload some new data. Of cause we can wait for previous frame completion using <a class="el" href="class_ogre_1_1_vao_manager.html#af029f21d9a83ae3024e36695a3f554f7" title="Waits for a specific frame to be ready.">waitForSpecificFrameToFinish()</a>, but waitForSpecificFrameToFinish(vaoManager-&gt;<a class="el" href="class_ogre_1_1_vao_manager.html#af7480a3acdc16d5092f8108ddff49783">getFrameCount()</a>) leads to stall() call which is more slow: switches current command buffer and notify everyone with _notifyDeviceStalled() call. So <a class="el" href="class_ogre_1_1_vao_manager.html#ac4042640f22065fba7929049f3770008" title="Waits for the last committed command buffer completion instead of the last frame completion with comm...">_waitUntilCommitedCommandBufferCompleted()</a> is more lightweight aspecially for Metal render system </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_metal_vao_manager.html#ab598d3faae2953fab0440abbdcea51d1">Ogre::MetalVaoManager</a>.</p>

</div>
</div>
<a id="a222d4e40df5eb53ab0b050e37aca7b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222d4e40df5eb53ab0b050e37aca7b89">&#9670;&nbsp;</a></span>calculateVertexSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::calculateVertexSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a03b06afe794fcbba8e2d2172892a80f6">VertexElement2Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of a single vertex buffer source with the given declaration, in bytes. </p>

</div>
</div>
<a id="a320cb3ed58ddfdc5870d097e90064f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320cb3ed58ddfdc5870d097e90064f3f">&#9670;&nbsp;</a></span>cleanupEmptyPools()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VaoManager::cleanupEmptyPools </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees GPU memory if there are empty, unused pools. </p>

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_vao_manager.html#a44f12302a9b143e0bd98f89d4c3693b9">Ogre::VulkanVaoManager</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_vao_manager.html#a81e19d8012b2de503a8dc931c6bbc35d">Ogre::NULLVaoManager</a>, <a class="el" href="class_ogre_1_1_metal_vao_manager.html#a8a3575e92200eac70e002a5d678e87a9">Ogre::MetalVaoManager</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a36b558b6c4cc150ce7d2a68ffca4a1f3">Ogre::GL3PlusVaoManager</a>, and <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#a995b22bd0bab22cf895b272372c491df">Ogre::D3D11VaoManager</a>.</p>

</div>
</div>
<a id="a0b7cb641e18e9489cfa9bf868fd30985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7cb641e18e9489cfa9bf868fd30985">&#9670;&nbsp;</a></span>createAsyncTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aef9bfd2a5567613e99bc8d7eae1c1bf9">AsyncTicketPtr</a> Ogre::VaoManager::createAsyncTicket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td>
          <td class="paramname"><em>stagingBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_vao_manager.html#a7862d71e9e7b7dfdbde153df705c247a">Ogre::VulkanVaoManager</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_vao_manager.html#ae225d09a92c2d2d4a6d28d3df094c337">Ogre::NULLVaoManager</a>, <a class="el" href="class_ogre_1_1_metal_vao_manager.html#abae9ed549b1ff2e055934abeb7726a58">Ogre::MetalVaoManager</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a679cdeccd914be8eebded4614e3c581b">Ogre::GL3PlusVaoManager</a>, <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#aea1d358af760a77fdef6497ec22fb35a">Ogre::D3D11VaoManager</a>, and <a class="el" href="class_ogre_1_1_g_l_e_s2_vao_manager.html#a94d2ceb28fc032b4af6d66ef86c50911">Ogre::GLES2VaoManager</a>.</p>

</div>
</div>
<a id="a952ab60d93451fc2ea18e14bbc31c309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952ab60d93451fc2ea18e14bbc31c309">&#9670;&nbsp;</a></span>createConstBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a>* Ogre::VaoManager::createConstBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an constant buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. (depends on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>, on D3D11 we're forced to give its own buffer) </p><dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3" title="Creates a vertex buffer based on the given parameters.">createVertexBuffer()</a> for the remaining parameters not documented here. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the given constant buffer. API restrictions may apply. To stay safe keep it multiple of 16, don't request more than 64kb per buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired const buffer pointer </dd></dl>

</div>
</div>
<a id="a0f791867304e682175612237b3bfd470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f791867304e682175612237b3bfd470">&#9670;&nbsp;</a></span>createIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a>* Ogre::VaoManager::createIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexBufferPacked::IndexType</a>&#160;</td>
          <td class="paramname"><em>indexType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an index buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. </p><dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3" title="Creates a vertex buffer based on the given parameters.">createVertexBuffer()</a> for the remaining parameters not documented here. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexType</td><td>Whether this Index Buffer should be 16-bit (recommended) or 32-bit </td></tr>
    <tr><td class="paramname">numIndices</td><td>The number of indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired index buffer pointer </dd></dl>

</div>
</div>
<a id="ad5ec74188530974bc3c28f3d1ab2982f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ec74188530974bc3c28f3d1ab2982f">&#9670;&nbsp;</a></span>createIndirectBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_indirect_buffer_packed.html">IndirectBufferPacked</a>* Ogre::VaoManager::createIndirectBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an indirect buffer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3" title="Creates a vertex buffer based on the given parameters.">createVertexBuffer()</a> for the remaining parameters not documented here. </dd></dl>

</div>
</div>
<a id="a9f95d947d7dae2068089fe00a03eb37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f95d947d7dae2068089fe00a03eb37d">&#9670;&nbsp;</a></span>createReadOnlyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html">ReadOnlyBufferPacked</a>* Ogre::VaoManager::createReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a read-only buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. (depends on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>, on D3D11 we're forced to give its own buffer) </p><dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3" title="Creates a vertex buffer based on the given parameters.">VaoManager::createVertexBuffer</a> for the remaining parameters not documented here. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pixel format for the texture buffer. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the given constant buffer. API restrictions may apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired read-only buffer pointer </dd></dl>

</div>
</div>
<a id="ae9f1ac357be2baf213594f302d8c90d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f1ac357be2baf213594f302d8c90d8">&#9670;&nbsp;</a></span>createStagingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a>* Ogre::VaoManager::createStagingBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forUpload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new staging buffer and adds it to the pool. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_vao_manager.html#a755b7f61f17c568f32a6708c4d4cb986" title="Retrieves a staging buffer for use.">getStagingBuffer</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The returned buffer starts with a reference count of 1. You should decrease it when you're done using it. </dd></dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_vao_manager.html#a45ff102de58acd7d8d5cd77ea0bf8851">Ogre::VulkanVaoManager</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_vao_manager.html#aaff1979a659427454341793163a50ca2">Ogre::NULLVaoManager</a>, <a class="el" href="class_ogre_1_1_metal_vao_manager.html#a0bf5d22ff4cb5757461c3c716c389922">Ogre::MetalVaoManager</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#ae953acdb91bb542f51967a52c375341a">Ogre::GL3PlusVaoManager</a>, <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#af42126d8367ea0feb2a9593936c35106">Ogre::D3D11VaoManager</a>, and <a class="el" href="class_ogre_1_1_g_l_e_s2_vao_manager.html#af93ed720de935513aba7bbd8ab476827">Ogre::GLES2VaoManager</a>.</p>

</div>
</div>
<a id="a15deceadb9ee88de12fd801464e4b09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15deceadb9ee88de12fd801464e4b09b">&#9670;&nbsp;</a></span>createTexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a>* Ogre::VaoManager::createTexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an constant buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. (depends on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>, on D3D11 we're forced to give its own buffer) </p><dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3" title="Creates a vertex buffer based on the given parameters.">createVertexBuffer()</a> for the remaining parameters not documented here. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pixel format for the texture buffer. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the given constant buffer. API restrictions may apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired texture buffer pointer </dd></dl>

</div>
</div>
<a id="a6001313fdecc1491daa683595fdb5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6001313fdecc1491daa683595fdb5018">&#9670;&nbsp;</a></span>createUavBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a>* Ogre::VaoManager::createUavBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>bytesPerElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>bindFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an UAV buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. (depends on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>, on D3D11 we're forced to give its own buffer) </p><dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3" title="Creates a vertex buffer based on the given parameters.">createVertexBuffer()</a> for the remaining parameters not documented here. There is no BufferType option as the only available one is BT_DEFAULT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the given constant buffer. API restrictions may apply. </td></tr>
    <tr><td class="paramname">bindFlags</td><td>A combination of BufferBindFlags. BB_FLAG_UAV is implicit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired UAV buffer pointer </dd></dl>

</div>
</div>
<a id="a76927e1aaf3cdd9dfddcf4f7bbb0a48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76927e1aaf3cdd9dfddcf4f7bbb0a48a">&#9670;&nbsp;</a></span>createVertexArrayObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_vertex_array_object.html">VertexArrayObject</a>* Ogre::VaoManager::createVertexArrayObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a0a4ccde77034efa918c66e561958949a">VertexBufferPackedVec</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga0ef99399e9e670e7bb69dc373968a666">OperationType</a>&#160;</td>
          <td class="paramname"><em>opType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="struct_ogre_1_1_vertex_array_object.html" title="Vertex array objects (Vaos) are immutable objects that describe a combination of vertex buffers and i...">VertexArrayObject</a> that binds all the vertex buffers with their respective declarations, and the index buffers. </p>
<p>The returned value is immutable and thus cannot be modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffers</td><td>An array of vertex buffers to be bound to the vertex array object. </td></tr>
    <tr><td class="paramname">indexBuffer</td><td>The index buffer to be bound. </td></tr>
    <tr><td class="paramname">opType</td><td>Type of operation. Cannot be changed later. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ogre_1_1_vertex_array_object.html" title="Vertex array objects (Vaos) are immutable objects that describe a combination of vertex buffers and i...">VertexArrayObject</a> that can be rendered. </dd></dl>

</div>
</div>
<a id="a163fd24c8a7f2c33595bb7fe94e97cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163fd24c8a7f2c33595bb7fe94e97cf3">&#9670;&nbsp;</a></span>createVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_buffer_packed.html">VertexBufferPacked</a>* Ogre::VaoManager::createVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a03b06afe794fcbba8e2d2172892a80f6">VertexElement2Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vertex buffer based on the given parameters. </p>
<p>Behind the scenes, the vertex buffer is part of much larger vertex buffer, in order to reduce bindings at runtime. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexElements</td><td>A list of element bindings for this vertex buffer. Once created, changing VertexElements is not possible, you'll have to create another Vertex Buffer. </td></tr>
    <tr><td class="paramname">numVertices</td><td>The number of vertices for this vertex </td></tr>
    <tr><td class="paramname">bufferType</td><td>The type of buffer for this vertex buffer. See <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9a3c263c60e96eb7ef68ad8886e70c8969" title="Read access from GPU.">BT_DYNAMIC_DEFAULT</a> special case. </td></tr>
    <tr><td class="paramname">initialData</td><td>Initial data the buffer will hold upon creation. Can be null (i.e. you plan to upload later). Cannot be null when bufferType is <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9adb62fa4394e5ed5eb8d45742e6b28719" title="Read access from GPU.">BT_IMMUTABLE</a>. Must have enough room to prevent an overflow. See <a class="el" href="class_ogre_1_1_buffer_packed.html#a50d8ee96245a8ac3dd7066eebf1f202d" title="Generic constructor.">BufferPacked::BufferPacked</a> </td></tr>
    <tr><td class="paramname">keepAsShadow</td><td>Whether to keep the pointer "initialData" as a shadow copy of the contents. See <a class="el" href="class_ogre_1_1_buffer_packed.html#a50d8ee96245a8ac3dd7066eebf1f202d" title="Generic constructor.">BufferPacked::BufferPacked</a> regarding on who is responsible for freeing this pointer and what happens if an exception was raised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired vertex buffer pointer </dd></dl>

</div>
</div>
<a id="a204c8055903cea82fe38e6a9fbc62f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204c8055903cea82fe38e6a9fbc62f6d">&#9670;&nbsp;</a></span>deleteStagingBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::deleteStagingBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51f5147151805c3d294ae200683d76bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f5147151805c3d294ae200683d76bb">&#9670;&nbsp;</a></span>destroyConstBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyConstBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>constBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given constant buffer created with createConstBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constBuffer</td><td>Constant Buffer created with createConstBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04c53b84b4c6ba27fdcbf57a08d4b044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c53b84b4c6ba27fdcbf57a08d4b044">&#9670;&nbsp;</a></span>destroyIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>indexBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given index buffer created with createIndexBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexBuffer</td><td>Index Buffer created with createIndexBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e7e88128e2496523ab0ca8e35634879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7e88128e2496523ab0ca8e35634879">&#9670;&nbsp;</a></span>destroyIndirectBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyIndirectBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_indirect_buffer_packed.html">IndirectBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>indirectBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given indirect buffer created with createIndirectBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indirectBuffer</td><td>Indirect Buffer created with createIndirectBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a703bff2ff022184c4f40da6ecb9a19ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703bff2ff022184c4f40da6ecb9a19ee">&#9670;&nbsp;</a></span>destroyReadOnlyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html">ReadOnlyBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>readOnlyBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given texture buffer created with createReadOnlyBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readOnlyBuffer</td><td><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> created with createReadOnlyBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6241229a8f3c895dcd49e7d0e8dfe545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6241229a8f3c895dcd49e7d0e8dfe545">&#9670;&nbsp;</a></span>destroyTexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyTexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>texBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given texture buffer created with createTexBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texBuffer</td><td>Texture Buffer created with createTexBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f235ad527a20a7c20b9daae8dc18ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f235ad527a20a7c20b9daae8dc18ff7">&#9670;&nbsp;</a></span>destroyUavBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyUavBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>uavBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given UAV buffer created with createUavBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uavBuffer</td><td>Uav Buffer created with createUavBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d56b87f51c489bdc2df07d1ce040512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d56b87f51c489bdc2df07d1ce040512">&#9670;&nbsp;</a></span>destroyVertexArrayObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyVertexArrayObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_vertex_array_object.html">VertexArrayObject</a> *&#160;</td>
          <td class="paramname"><em>vao</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the input pointer. </p>
<p>After this call, it's no longer valid </p><dl class="section remark"><dt>Remarks</dt><dd>API memory may or may not be released since VertexArrayObjects may internally share the same API constructs. </dd></dl>
<dl class="section user"><dt></dt><dd>The vertex &amp; index buffers associated with this vao are not destroyed by this function. </dd></dl>

</div>
</div>
<a id="a1dce3c8cb8c7d08ff77e6c4776fed1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dce3c8cb8c7d08ff77e6c4776fed1f4">&#9670;&nbsp;</a></span>destroyVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vertex_buffer_packed.html">VertexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given vertex buffer created with createVertexBuffer. </p>
<p>NOTE: Vertex Buffers created by a MultiSourceVertexBufferPool must be freed by the pool that created it, don't use this function for those. </p><dl class="section remark"><dt>Remarks</dt><dd>Performs an O(N) lookup. Where N is the number of created vertex buffers </dd></dl>

</div>
</div>
<a id="ac0aed3a4936a8be631d3f135bb4cc759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0aed3a4936a8be631d3f135bb4cc759">&#9670;&nbsp;</a></span>getConstBufferAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getConstBufferAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f5901852733aca5d593b2f884204ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5901852733aca5d593b2f884204ffb">&#9670;&nbsp;</a></span>getConstBufferMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VaoManager::getConstBufferMaxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a188a85cb2888f7353fed61c07d666dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188a85cb2888f7353fed61c07d666dda">&#9670;&nbsp;</a></span>getDefaultStagingBufferLifetime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getDefaultStagingBufferLifetime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a820bddab761ba53ea76cf199565e7220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820bddab761ba53ea76cf199565e7220">&#9670;&nbsp;</a></span>getDefaultStagingBufferUnfencedTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getDefaultStagingBufferUnfencedTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a232bf21126a76c3a3fde72b05568e51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232bf21126a76c3a3fde72b05568e51d">&#9670;&nbsp;</a></span>getDynamicBufferMultiplier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::VaoManager::getDynamicBufferMultiplier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7480a3acdc16d5092f8108ddff49783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7480a3acdc16d5092f8108ddff49783">&#9670;&nbsp;</a></span>getFrameCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getFrameCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb673d6cf486d740c9aa5dc33c1f4c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb673d6cf486d740c9aa5dc33c1f4c0d">&#9670;&nbsp;</a></span>getMemoryStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VaoManager::getMemoryStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html#a8a984ae987b00e95b35198131a4e9a6b">MemoryStatsEntryVec</a> &amp;&#160;</td>
          <td class="paramname"><em>outStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outCapacityBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outFreeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_log.html">Log</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>outIncludesTextures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves memory stats about our GPU pools being managed. </p>
<p>The output in the <a class="el" href="class_ogre_1_1_log.html">Log</a> will be csv data that resembles the following: <a class="el" href="class_ogre_1_1_pool.html" title="Template class describing a simple pool of items.">Pool</a> Type Offset Bytes <a class="el" href="class_ogre_1_1_pool.html" title="Template class describing a simple pool of items.">Pool</a> Capacity CPU_INACCESSIBLE 0 148128 67108864 CPU_INACCESSIBLE 200000 1024 67108864 CPU_ACCESSIBLE_PERSISTENT 0 1152 16777216</p>
<p>These are the chunks of memory currently in use. If there are multiple entries belonging to the same pool, that means the memory has been fragmented.</p>
<p>The actual output may vary depending on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. </p><dl class="section remark"><dt>Remarks</dt><dd>Worst case scenario this function has O(N^2) complexity where N is the number of free blocks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStats</td><td>Detailed information about each entry. </td></tr>
    <tr><td class="paramname">outCapacityBytes</td><td>Total capacity i.e. total used VRAM in GPU. </td></tr>
    <tr><td class="paramname">outFreeBytes</td><td>Total free memory available for consumption. </td></tr>
    <tr><td class="paramname">log</td><td>Optional to dump all information to a CSV file. Nullptr to avoid dumping. </td></tr>
    <tr><td class="paramname">outIncludesTextures</td><td>[out] When true, memory reports in outCapacityBytes &amp; outFreeBytes include textures. See Tutorial_Memory on how to deal with this output.</td></tr>
  </table>
  </dd>
</dl>
<p>Note outIncludesTextures may be false but some entries in outStats[n].bPoolHasTextures may be true. If this happens, then outCapacityBytes &amp; outFreeBytes don't include texture consumption; but the pools with bPoolHasTextures in MemoryStatsEntryVec may. </p>

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_vao_manager.html#a73a67c1093aa4ac1f7197dae0a320279">Ogre::VulkanVaoManager</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_vao_manager.html#a8f35fe25cb3d5a27f23b36a8fae24ff6">Ogre::NULLVaoManager</a>, <a class="el" href="class_ogre_1_1_metal_vao_manager.html#af7109a3e4d3d267b73af36c4d1d06b80">Ogre::MetalVaoManager</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a8e058f9ed8ee7fa3db373387c347c01a">Ogre::GL3PlusVaoManager</a>, and <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#a2998f7fba8ce1fdcd67e79eeead26384">Ogre::D3D11VaoManager</a>.</p>

</div>
</div>
<a id="a0607898a5553aadd2bccb8a82cc6c952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0607898a5553aadd2bccb8a82cc6c952">&#9670;&nbsp;</a></span>getReadOnlyBufferMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VaoManager::getReadOnlyBufferMaxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a755b7f61f17c568f32a6708c4d4cb986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755b7f61f17c568f32a6708c4d4cb986">&#9670;&nbsp;</a></span>getStagingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a>* Ogre::VaoManager::getStagingBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forUpload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a staging buffer for use. </p>
<p>We'll search for existing ones that can hold minSizeBytes. We first prioritize those that won't cause a stall at all. Then those that will cause a partial stall, and otherwise return one that will cause full stall. If we can't find any existing buffer that can hold the requested number bytes, we'll create a new one. </p><dl class="section remark"><dt>Remarks</dt><dd>Calling this function causes the reference count of the returned pointer to be increased. You should decrease the reference count after you're done with the returned pointer. See <a class="el" href="class_ogre_1_1_staging_buffer.html#a9d425e7d85804eaa45c01f6476ec204a" title="Decreases the reference count by one.">StagingBuffer::removeReferenceCount</a> regarding ref. counting. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minSizeBytes</td><td>Minimum size, in bytes, of the staging buffer. The returned buffer may be bigger. </td></tr>
    <tr><td class="paramname">forUpload</td><td>True if it should be used to upload data to GPU, false to download. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The staging buffer. </dd></dl>

</div>
</div>
<a id="ab61efe17fa95abcd4fb4da830b78cc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61efe17fa95abcd4fb4da830b78cc67">&#9670;&nbsp;</a></span>getTexBufferAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getTexBufferAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41937e26220533e4fb60c5e4d51f1802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41937e26220533e4fb60c5e4d51f1802">&#9670;&nbsp;</a></span>getTexBufferMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VaoManager::getTexBufferMaxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d2c12eae58c6e049221a75c0aafe91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2c12eae58c6e049221a75c0aafe91e">&#9670;&nbsp;</a></span>getTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_timer.html">Timer</a>* Ogre::VaoManager::getTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0aa4278b6061752264f2887aa3dff7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa4278b6061752264f2887aa3dff7ed">&#9670;&nbsp;</a></span>getUavBufferAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getUavBufferAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a25b3d648f62caca1093fbad2b3b740f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b3d648f62caca1093fbad2b3b740f0">&#9670;&nbsp;</a></span>getUavBufferMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VaoManager::getUavBufferMaxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48589a1d12b10aa89082ebca7a9c524d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48589a1d12b10aa89082ebca7a9c524d">&#9670;&nbsp;</a></span>isFrameFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::VaoManager::isFrameFinished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>frameCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this returns true, then waitForSpecificFrameToFinish is guaranteed to return immediately. </p>

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_vao_manager.html#af84adcd5063ffc4c16f9735b26e07d3b">Ogre::VulkanVaoManager</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_vao_manager.html#a6b3f5c09195ea5b32e79bd13e221dcac">Ogre::NULLVaoManager</a>, <a class="el" href="class_ogre_1_1_metal_vao_manager.html#a5a4961a1cff599463983096e5ad9d53d">Ogre::MetalVaoManager</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#adcdf176fa9589c782b86c2d877df7db4">Ogre::GL3PlusVaoManager</a>, <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#ab746af32469303c8b90999803f168b2e">Ogre::D3D11VaoManager</a>, and <a class="el" href="class_ogre_1_1_g_l_e_s2_vao_manager.html#adad0bea0e9aeff600982ab1a38dcbed6">Ogre::GLES2VaoManager</a>.</p>

</div>
</div>
<a id="a9d419c20a81ff0fd9d970263947e9a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d419c20a81ff0fd9d970263947e9a88">&#9670;&nbsp;</a></span>readOnlyIsTexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VaoManager::readOnlyIsTexBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When true, <a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> behaves like <a class="el" href="class_ogre_1_1_tex_buffer_packed.html" title="Represents Texture buffers (also known as tbuffers in D3D11)">TexBufferPacked</a>, i.e. </p>
<p>assigned to texture buffer slots.</p>
<p>When false, <a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> behaves like <a class="el" href="class_ogre_1_1_uav_buffer_packed.html" title="Represents UAV buffers (also known as SSBOs in OpenGL) Uav buffers are supported in DX10/DX10....">UavBufferPacked</a> i.e. assigned to UAV buffer slots. Except D3D11, which still uses texture buffer slots when false but chooses StructuredBuffer over Buffer </p>

</div>
</div>
<a id="a445b8e5486e061745af43d1831f60eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445b8e5486e061745af43d1831f60eb6">&#9670;&nbsp;</a></span>setDefaultStagingBufferlifetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::setDefaultStagingBufferlifetime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>lifetime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>unfencedTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default time for staging buffers. </p>
<p>Staging buffers are recycled/reused. When their reference count reaches 0, this <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> will begin to track how long since the last time they've reached ref count 0. When the time threshold is met, the staging buffer gets removed. </p><dl class="section remark"><dt>Remarks</dt><dd>See getStagingBuffer </dd></dl>
<dl class="section user"><dt></dt><dd>Small explanation on <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> lifetime management (so you can make sense on what we're doing here):</dd></dl>
<p>StagingBuffers may produce "pops" when created (due to API/driver stalls) so we reuse them. We keep track of how long StagingBuffers have been remained unused, and delete old ones. The intention is to be able to recycle old buffers, while getting rid of the excess if a sudden spike happened. That's what the lifetime threshold controls.</p>
<p>We also have the "unfenced threshold". This controls something very different. StagingBuffers usages need fences to check whether we're done using the buffer. But we don't issue a fence every time you do something with them, because that could result in a lot of fences (i.e. imagine you do a 1000 uploads of 16 bytes each, in succession, we shouldn't do 1000 fences); so we fence when certain upload/download thresholds are met (i.e. you've uploaded 1MB of data). So if you've uploaded 750kb so far, no fence will be issued. But if you upload 300kb more, we will fence. But what happens if you've only uploaded 750kb and then nothing more for the last 10 minutes? Since we haven't fenced, and now you need to upload a lot more, we don't know if those 750kb are done uploading because we never fenced it. It probably ended 10 minutes ago, but we won't know. We would have to fence now and perform a full stall waiting for that fence. To solve this edge case, we fence whenever X time has elapsed without fencing (and only if there's data that remains unfenced of course). That's what the unfenced threshold is for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lifetime</td><td>Time in milliseconds. The default is 5 minutes. A staging buffer that remained at zero ref. count for lifetime milliseconds will be destroyed. </td></tr>
    <tr><td class="paramname">unfencedTime</td><td>For efficiency reasons (API overhead), some staging buffers implementations will not track all hazards on fences. A staging buffer that remained at zero ref. count for unfencedTime milliseconds will be told to clean their hazards, creating the missing appropiate fences. unfencedTime can't be higher than lifetime. unfencedTime should not be too far away from lifetime, and not too soon either, to maximize the chances of no stalls when we finally destroy it and avoid excessive API overhead in keeping fences alive. The default is 4 minutes 59 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39462274237779198775b927fabd4c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39462274237779198775b927fabd4c2c">&#9670;&nbsp;</a></span>supportsBaseInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VaoManager::supportsBaseInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d060170f4a1b7ff1e750f869a9e6298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d060170f4a1b7ff1e750f869a9e6298">&#9670;&nbsp;</a></span>supportsIndirectBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VaoManager::supportsIndirectBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When false, <a class="el" href="class_ogre_1_1_indirect_buffer_packed.html" title="Represents Indirect buffers for storing draw call commands.">IndirectBufferPacked</a> will emulate the mapping behavior, and we need to use the emulated calls in <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. </p>

</div>
</div>
<a id="aaedd48d2dd6f21e37fa069f92865eb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedd48d2dd6f21e37fa069f92865eb45">&#9670;&nbsp;</a></span>supportsPersistentMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VaoManager::supportsPersistentMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af029f21d9a83ae3024e36695a3f554f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af029f21d9a83ae3024e36695a3f554f7">&#9670;&nbsp;</a></span>waitForSpecificFrameToFinish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VaoManager::waitForSpecificFrameToFinish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>frameCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for a specific frame to be ready. </p>
<p>Calling waitForSpecificFrameToFinish( mFrameCount - mDynamicBufferMultiplier ) equals to calling waitForTailFrameToFinish. </p><dl class="section remark"><dt>Remarks</dt><dd>WARNING: calling waitForSpecificFrameToFinish( mFrameCount ); will perform a full stall! </dd></dl>
<dl class="section user"><dt></dt><dd>Avoid calling this function. Some implementations may decide to always full stall unless (mFrameCount - frameCount) &gt;= mDynamicBufferMultiplier </dd></dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_vao_manager.html#abf65946524c59fd0a4e09e3230e6e23a">Ogre::VulkanVaoManager</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_vao_manager.html#a100903c73b12e1821b946ab17c5cedda">Ogre::NULLVaoManager</a>, <a class="el" href="class_ogre_1_1_metal_vao_manager.html#a0bfec349598fe9246f626f5ddaa7a228">Ogre::MetalVaoManager</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#ae2a29b07920e091d7d08452cc35fe635">Ogre::GL3PlusVaoManager</a>, <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#acecbebc28df5a9d1863191030b8d55ac">Ogre::D3D11VaoManager</a>, and <a class="el" href="class_ogre_1_1_g_l_e_s2_vao_manager.html#a12ac311cf4480a5b817dac49099758c6">Ogre::GLES2VaoManager</a>.</p>

</div>
</div>
<a id="a7a95cb3f3eeb2135707a2aec26b371c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a95cb3f3eeb2135707a2aec26b371c0">&#9670;&nbsp;</a></span>waitForTailFrameToFinish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::VaoManager::waitForTailFrameToFinish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current frame # (which wraps to 0 every mDynamicBufferMultiplier times). </p>
<p>But first stalls until that mDynamicBufferMultiplier-1 frame behind is finished. </p>

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_vao_manager.html#a08ecd0459408a5f93c4193bad5e225b6">Ogre::VulkanVaoManager</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_vao_manager.html#a0ff9ec675aa9160110d5fa381daa1ed0">Ogre::NULLVaoManager</a>, <a class="el" href="class_ogre_1_1_metal_vao_manager.html#adcf387a327a1fe5dafb309f9bfc6dec4">Ogre::MetalVaoManager</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a248b84a6f40f01f36e2a56474912ac3b">Ogre::GL3PlusVaoManager</a>, <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#a6398691f6a128e2b37f4cd27a27aab01">Ogre::D3D11VaoManager</a>, and <a class="el" href="class_ogre_1_1_g_l_e_s2_vao_manager.html#a932de9db6547e936d04aaee5cedd3e77">Ogre::GLES2VaoManager</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_vao_manager_8h.html">OgreVaoManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
