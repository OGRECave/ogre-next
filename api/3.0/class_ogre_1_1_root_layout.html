<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::RootLayout Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_root_layout.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_ogre_1_1_root_layout-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::RootLayout Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_ogre_1_1_root_layout.html" title="The RootLayout class.">RootLayout</a> class.  
 <a href="class_ogre_1_1_root_layout.html#details">More...</a></p>

<p><code>#include &lt;OgreRootLayout.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::RootLayout:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_root_layout__inherit__graph.svg" width="190" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_root_layout_1_1_array_desc.html">ArrayDesc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3941a0c37152b3559a25a4af3689ad03" id="r_a3941a0c37152b3559a25a4af3689ad03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a3941a0c37152b3559a25a4af3689ad03">RootLayout</a> ()</td></tr>
<tr class="separator:a3941a0c37152b3559a25a4af3689ad03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1650e2afb8299250021f4e7e6279da1f" id="r_a1650e2afb8299250021f4e7e6279da1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a1650e2afb8299250021f4e7e6279da1f">addArrayBinding</a> (<a class="el" href="namespace_ogre_1_1_desc_binding_types.html#af97aae360aa16970ee0873372c96c6be">DescBindingTypes::DescBindingTypes</a> bindingType, <a class="el" href="struct_ogre_1_1_root_layout_1_1_array_desc.html">ArrayDesc</a> arrayDesc)</td></tr>
<tr class="memdesc:a1650e2afb8299250021f4e7e6279da1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the <a class="el" href="class_ogre_1_1_root_layout.html" title="The RootLayout class.">RootLayout</a> that the element at setIdx and bindingIdx is an array of size arraySize.  <br /></td></tr>
<tr class="separator:a1650e2afb8299250021f4e7e6279da1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681f252194d5a7035f1f7fc9e9899342" id="r_a681f252194d5a7035f1f7fc9e9899342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a681f252194d5a7035f1f7fc9e9899342">copyFrom</a> (const <a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a> &amp;other, bool bIncludeArrayBindings=true)</td></tr>
<tr class="memdesc:a681f252194d5a7035f1f7fc9e9899342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all our parameters from 'other' Does NOT call <a class="el" href="class_ogre_1_1_root_layout.html#a3de2623ecb78001c7df226de5975002d">validate()</a>  <br /></td></tr>
<tr class="separator:a681f252194d5a7035f1f7fc9e9899342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa948ba479d75b0920922eb309a1e7a27" id="r_aa948ba479d75b0920922eb309a1e7a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#aa948ba479d75b0920922eb309a1e7a27">dump</a> (<a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;outJson) const</td></tr>
<tr class="memdesc:aa948ba479d75b0920922eb309a1e7a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the current <a class="el" href="class_ogre_1_1_root_layout.html" title="The RootLayout class.">RootLayout</a> to a JSON string.  <br /></td></tr>
<tr class="separator:aa948ba479d75b0920922eb309a1e7a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d927a71ab1acfa3931b1188a6e1480a" id="r_a0d927a71ab1acfa3931b1188a6e1480a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a0d927a71ab1acfa3931b1188a6e1480a">findParamsBuffer</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shaderStage, size_t &amp;outSetIdx, size_t &amp;outBindingIdx) const</td></tr>
<tr class="memdesc:a0d927a71ab1acfa3931b1188a6e1480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the set and binding idx of the params buffer.  <br /></td></tr>
<tr class="separator:a0d927a71ab1acfa3931b1188a6e1480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25608d1929f65056de8e0e5996e209a5" id="r_a25608d1929f65056de8e0e5996e209a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_desc_binding_range.html">DescBindingRange</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a25608d1929f65056de8e0e5996e209a5">getDescBindingRanges</a> (size_t setIdx) const</td></tr>
<tr class="separator:a25608d1929f65056de8e0e5996e209a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4951d6514a0a8e570ce20d489fcce7fb" id="r_a4951d6514a0a8e570ce20d489fcce7fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a4951d6514a0a8e570ce20d489fcce7fb">parseRootLayout</a> (const char *rootLayout, const bool bCompute, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename)</td></tr>
<tr class="memdesc:a4951d6514a0a8e570ce20d489fcce7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a root layout definition from a JSON string The JSON string:  <br /></td></tr>
<tr class="separator:a4951d6514a0a8e570ce20d489fcce7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de2623ecb78001c7df226de5975002d" id="r_a3de2623ecb78001c7df226de5975002d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a3de2623ecb78001c7df226de5975002d">validate</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename) const</td></tr>
<tr class="separator:a3de2623ecb78001c7df226de5975002d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ace64a521d831703a6f6881f0d1e318" id="r_a8ace64a521d831703a6f6881f0d1e318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a8ace64a521d831703a6f6881f0d1e318">validateArrayBindings</a> (const <a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a> &amp;groundTruth, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename) const</td></tr>
<tr class="memdesc:a8ace64a521d831703a6f6881f0d1e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates that the array bindings in groundTruth.mArrayRanges are included in this-&gt;mArrayRanges.  <br /></td></tr>
<tr class="separator:a8ace64a521d831703a6f6881f0d1e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a394d744f62c9cd35003cbadf91c79ca2" id="r_a394d744f62c9cd35003cbadf91c79ca2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a394d744f62c9cd35003cbadf91c79ca2">mBaked</a> [<a class="el" href="_ogre_root_layout_8h.html#a27adb7082b35d3f58fcf9b174e4e2ef2">OGRE_MAX_NUM_BOUND_DESCRIPTOR_SETS</a>]</td></tr>
<tr class="separator:a394d744f62c9cd35003cbadf91c79ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64a14dcf0778e201691f84fc3d57351" id="r_af64a14dcf0778e201691f84fc3d57351"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#af64a14dcf0778e201691f84fc3d57351">mCompute</a></td></tr>
<tr class="separator:af64a14dcf0778e201691f84fc3d57351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203ae6402ca5eeee926f9b3a4e4c344f" id="r_a203ae6402ca5eeee926f9b3a4e4c344f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_desc_binding_range.html">DescBindingRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#a203ae6402ca5eeee926f9b3a4e4c344f">mDescBindingRanges</a> [<a class="el" href="_ogre_root_layout_8h.html#a27adb7082b35d3f58fcf9b174e4e2ef2">OGRE_MAX_NUM_BOUND_DESCRIPTOR_SETS</a>][<a class="el" href="namespace_ogre_1_1_desc_binding_types.html#af97aae360aa16970ee0873372c96c6bea0d280ffc6b3e89d6300f58171dd0c6c0">DescBindingTypes::NumDescBindingTypes</a>]</td></tr>
<tr class="separator:a203ae6402ca5eeee926f9b3a4e4c344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c63c10694ecc14870c535065d3e997" id="r_ab7c63c10694ecc14870c535065d3e997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_root_layout.html#ab7c63c10694ecc14870c535065d3e997">mParamsBuffStages</a></td></tr>
<tr class="separator:ab7c63c10694ecc14870c535065d3e997"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_ogre_1_1_root_layout.html" title="The RootLayout class.">RootLayout</a> class. </p>
<pre class="fragment">D3D11, OpenGL and Metal use a 'table' model for binding resources.
While there are a couple differences between the APIs, if we look at HLSL's binding model:

    - There is a special const buffer for uniform parameters
    - All const buffers are in slots [b0; b8)
    - Textures and TexBuffers share the same slots, range [t0; t128)
    - Samplers have their own slots [s0; s16)
    - UAV textures and buffers share the same slots, range [u0; u8)

Vulkan &amp; D3D12 however don't follow this table model. Instead they distribute
bindings into sets and bindings. Vulkan guarantees at least 4 sets will be available.

A binding can contain ANYTHING: sampler, const buffer, textures, etc

@code
    layout( set = 0, location = 0 ) texture2D myTex;
    layout( set = 0, location = 1 ) sampler mySampler;
    layout( set = 0, location = 2 ) buffer myBuffer { uint myUavArray[4096]; };
    layout( set = 0, location = ... ) ;

    layout( set = 1, location = 0 ) samplerBuffer myTexBuffer;
    layout( set = 1, location = 1 ) sampler anotherSampler;
    layout( set = 1, location = ... ) ;
@endcode

Since Ogre has historically followed the 'table' model and we want to reuse existing
shaders as much as possible; this RootLayout tells Ogre which resources your shader
is planning to use, so we can create the optimal DescriptorSets.

For example an HLSL shader that ONLY declares and uses the following resources:

@code
    cbuffer myConstBuffer0      : register(b4) {};
    cbuffer myConstBuffer1      : register(b5) {};
    cbuffer myConstBuffer2      : register(b6) {};
    Buffer&lt;float4&gt; myTexBuffer  : register(t1);
    Texture2D myTex0            : register(t3);
    Texture2D myTex1            : register(t4);
    SamplerState mySampler      : register(s1);
    RWTexture3D&lt;float&gt; myUavTex : register(u0);
    RWBuffer&lt;float&gt; myUavBuffer : register(u1);
@endcode

Would work using the following RootLayout:

@code
    {
        "0" :
        {
            "const_buffers"     : [4,7],
            "tex_buffers"       : [1,2],
            "textures"          : [3,4],
            "samplers"          : [1,2],
            "uav_buffers"       : [1,2],
            "uav_textures"      : [0,1]
        }
    }
@endcode

That is, explicitly declare that you're using const buffer range [4; 7),
tex buffer range [1; 2) etc.

In Vulkan we will automatically generate macros for use in bindings
(buffers are uppercase letter, textures lowercase):

@code
    // Const buffers
    #define ogre_B4 set = 0, binding = 0
    #define ogre_B5 set = 0, binding = 1
    #define ogre_B6 set = 0, binding = 2

    // Texture buffers
    #define ogre_T1 set = 0, binding = 3

    // Textures
    #define ogre_t3 set = 0, binding = 4

    // Samplers
    #define ogre_s1 set = 0, binding = 5

    // UAV buffers
    #define ogre_U1 set = 0, binding = 6

    // UAV textures
    #define ogre_u0 set = 0, binding = 7
@endcode

Thus a GLSL shader can use it like this:
@code
    layout( ogre_B4 ) uniform bufferName
    {
        uniform float myParam;
        uniform float2 myParam2;
    };

    layout( ogre_t3 ) uniform texture2D myTexture;
    // etc...
@endcode

Could you have used e.g. "const_buffers" : [0,7] instead of [4,7]?
i.e. declare slots in range [0;4) even though they won't be used?

Yes. But you would be consuming more memory.

Note that if your vertex shader uses slots [0; 3) and pixel shader uses range
[4; 7) then BOTH shaders must use a RootLayout that at least declares range [0; 7)
so they can be paired together

RootLayouts have a memory vs performance trade off:

    - Declaring unused slots helps reusing RootLayout. Reuse leads to fewer descriptor swapping
    - Unused slots waste RAM and VRAM

That's why low level materials provide prefab RootLayouts, in order to maximize
RootLayout reuse while also keeping reasonable memory consumption.
See GpuProgram::setPrefabRootLayout

Note that if two shaders were compiled with different RootLayouts, they may still
be able to be used together if their layouts are compatible; and the 'bigger' RootLayout
which can be used for both shaders will be selected.

For example if vertex shader declared:

@code
    {
        "0" :
        {
            "const_buffers"     : [0,3]
        }
    }
@endcode

and the pixel shader declared:

@code
    {
        "0" :
        {
            "const_buffers"     : [0,3],
            "textures"          : [2,4]
        }
    }
@endcode

Then they're compatible; and pixel shader's will be selected to be used for both shaders.

That is because both layouts declared 3 const buffers (perfect match); and textures
ALWAYS go after const buffers (THE ORDER is important and determined by
DescBindingTypes::DescBindingTypes).

Thus the pixel shader's RootLayout can be used for the vertex shader.

However if the vertex shader had declared instead:

@code
    {
        "0" :
        {
            "const_buffers"     : [0,3],
            "tex_buffers"       : [0,1]
        }
    }
@endcode

then both RootLayouts are incompatible.
This is because vertex shader uses 3 const_buf slots, then 1 tex buffer slot:

    1. const
    2. const
    3. const
    4. tex buffer

But where pixel shader uses 3 const_buf slots, then 2 texture slots:

    1. const
    2. const
    3. const
    4. texture --&gt; ERROR. CONFLICT
    5. texture

The 4th slot is in conflict because the vertex shader uses it for a tex buffer,
and the pixel shader uses it for a texture. A slot can only be used for one type of resource.

In order to fix this incompatibility, the pixel shader needs to declare a tex_buffer,
even if it won't ever use the tex_buffer slot (the vertex shader will):

@code
    {
        "0" :
        {
            "const_buffers"     : [0,3],
            "tex_buffers"       : [0,1],
            "textures"          : [2,4]
        }
    }
@endcode

&lt;b&gt;Baked sets:&lt;/b&gt;

If you intend to use UAVs or you're writing a shader with the Hlms which uses
DescriptorSetSampler, DescriptorSetTexture or DescriptorSetUav, then you need to use
a baked set.

For example if a low level material uses UAVs:

@code
    cbuffer myConstBuffer0      : register(b4) {};
    cbuffer myConstBuffer1      : register(b5) {};
    cbuffer myConstBuffer2      : register(b6) {};
    Buffer&lt;float4&gt; myTexBuffer  : register(t1);
    Texture2D myTex0            : register(t3);
    Texture2D myTex1            : register(t4);
    SamplerState mySampler      : register(s1);
    RWTexture3D&lt;float&gt; myUavTex : register(u0);
    RWBuffer&lt;float&gt; myUavBuffer : register(u1);
@endcode

You'll need a set for baking the UAVs:
@code
    {
        "0" :
        {
            "const_buffers"     : [4,7],
            "tex_buffers"       : [1,2],
            "textures"          : [3,4],
            "samplers"          : [1,2]
        },

        "1" :
        {
            "baked" : true,
            "uav_buffers"       : [1,2],
            "uav_textures"      : [0,1]
        }
    }
@endcode

If this is a Compute Shader or another Hlms shader, then the textures and samplers also need
to be in the baked set:

@code
    {
        "0" :
        {
            "const_buffers"     : [4,7],
        },

        "1" :
        {
            "baked" : true,
            "tex_buffers"       : [1,2],
            "textures"          : [3,4],
            "samplers"          : [1,2],
            "uav_buffers"       : [1,2],
            "uav_textures"      : [0,1]
        }
    }
@endcode

Note that you can use more than one set if e.g. you intend to swap a
DescriptorSetTexture much more often than the rest:

@code
    {
        "0" :
        {
            "const_buffers"     : [4,7],
        },

        "1" :
        {
            "baked" : true,
            "samplers"          : [1,2],
            "uav_buffers"       : [1,2],
            "uav_textures"      : [0,1]
        },

        "2" :
        {
            "baked" : true,
            "tex_buffers"       : [1,2],
            "textures"          : [3,4]
        }
    }
@endcode

For best performance, &lt;b&gt;the last set index should be the one that changes more frequently&lt;b/&gt;
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3941a0c37152b3559a25a4af3689ad03" name="a3941a0c37152b3559a25a4af3689ad03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3941a0c37152b3559a25a4af3689ad03">&#9670;&#160;</a></span>RootLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::RootLayout::RootLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1650e2afb8299250021f4e7e6279da1f" name="a1650e2afb8299250021f4e7e6279da1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1650e2afb8299250021f4e7e6279da1f">&#9670;&#160;</a></span>addArrayBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RootLayout::addArrayBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_desc_binding_types.html#af97aae360aa16970ee0873372c96c6be">DescBindingTypes::DescBindingTypes</a>&#160;</td>
          <td class="paramname"><em>bindingType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_root_layout_1_1_array_desc.html">ArrayDesc</a>&#160;</td>
          <td class="paramname"><em>arrayDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the <a class="el" href="class_ogre_1_1_root_layout.html" title="The RootLayout class.">RootLayout</a> that the element at setIdx and bindingIdx is an array of size arraySize. </p>
<p>The purpose of this function is that we can specify mDescBindingRanges[0][Texture] = [4, 6] and have: </p><pre class="fragment">vulkan_layout( ogre_t4 ) uniform texture2D myTexA;
vulkan_layout( ogre_t5 ) uniform texture2D myTexB;
</pre><p> However if we wish to have: </p><pre class="fragment">vulkan_layout( ogre_t4 ) uniform texture2D myTexA[2];
</pre><p> ogre_t5 is occupied </p><pre class="fragment">        Then we MUST call addArrayBinding( Texture, ArrayDesc( 4, 2 ) );
        since arrays are treated differently

        Arrays of length = 1 don't need to call this function.
    @remarks
        Calls must be done in order (i.e. increasing setIdx and bindingIdx)
        Bindings cannot overlap (i.e. last.bindingIdx + last.arraySize &lt;= new.bindingIdx)
        Will throw if this condition is not satisfied
</pre> 
</div>
</div>
<a id="a681f252194d5a7035f1f7fc9e9899342" name="a681f252194d5a7035f1f7fc9e9899342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681f252194d5a7035f1f7fc9e9899342">&#9670;&#160;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RootLayout::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeArrayBindings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all our parameters from 'other' Does NOT call <a class="el" href="class_ogre_1_1_root_layout.html#a3de2623ecb78001c7df226de5975002d">validate()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
    <tr><td class="paramname">bIncludeArrayBindings</td><td>When false, mArrayRanges are not included </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa948ba479d75b0920922eb309a1e7a27" name="aa948ba479d75b0920922eb309a1e7a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa948ba479d75b0920922eb309a1e7a27">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RootLayout::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>outJson</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps the current <a class="el" href="class_ogre_1_1_root_layout.html" title="The RootLayout class.">RootLayout</a> to a JSON string. </p>

</div>
</div>
<a id="a0d927a71ab1acfa3931b1188a6e1480a" name="a0d927a71ab1acfa3931b1188a6e1480a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d927a71ab1acfa3931b1188a6e1480a">&#9670;&#160;</a></span>findParamsBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RootLayout::findParamsBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shaderStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outSetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outBindingIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the set and binding idx of the params buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderStage</td><td>See GpuProgramType </td></tr>
    <tr><td class="paramname">outSetIdx</td><td>[out] Set in which it is located Value will not be modified if we return false </td></tr>
    <tr><td class="paramname">outBindingIdx</td><td>[out] Binding index in which it is located Value will not be modified if we return false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is a params buffer False otherwise and output params won't be modified </dd></dl>

</div>
</div>
<a id="a25608d1929f65056de8e0e5996e209a5" name="a25608d1929f65056de8e0e5996e209a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25608d1929f65056de8e0e5996e209a5">&#9670;&#160;</a></span>getDescBindingRanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_desc_binding_range.html">DescBindingRange</a> * Ogre::RootLayout::getDescBindingRanges </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>setIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4951d6514a0a8e570ce20d489fcce7fb" name="a4951d6514a0a8e570ce20d489fcce7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4951d6514a0a8e570ce20d489fcce7fb">&#9670;&#160;</a></span>parseRootLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RootLayout::parseRootLayout </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rootLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bCompute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a root layout definition from a JSON string The JSON string: </p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;0&quot;</span> :</div>
<div class="line">    {</div>
<div class="line">        <span class="stringliteral">&quot;has_params&quot;</span> : [<span class="stringliteral">&quot;all&quot;</span>, <span class="stringliteral">&quot;vs&quot;</span>, <span class="stringliteral">&quot;gs&quot;</span>, <span class="stringliteral">&quot;hs&quot;</span>, <span class="stringliteral">&quot;ds&quot;</span>, <span class="stringliteral">&quot;ps&quot;</span>, <span class="stringliteral">&quot;cs&quot;</span>],</div>
<div class="line">        <span class="stringliteral">&quot;const_buffers&quot;</span> : [0, 16],</div>
<div class="line">        <span class="stringliteral">&quot;tex_buffers&quot;</span> : [1, 16],</div>
<div class="line">        <span class="stringliteral">&quot;textures&quot;</span> : [0, 1],</div>
<div class="line">        <span class="stringliteral">&quot;samplers&quot;</span> : [0, 1],</div>
<div class="line">        <span class="stringliteral">&quot;uav_buffers&quot;</span> : [0, 16]</div>
<div class="line">        <span class="stringliteral">&quot;uav_textures&quot;</span> : [16, 32],</div>
<div class="line">        <span class="stringliteral">&quot;baked&quot;</span> : <span class="keyword">false</span></div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    <span class="stringliteral">&quot;arrays&quot;</span> :</div>
<div class="line">    {</div>
<div class="line">        <span class="stringliteral">&quot;tex_buffers&quot;</span> : [[4, 5], [10, 2]],</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>has_params can establish which shader stages allow parameters.</p><ul>
<li>"all" means all shader stages (vs through ps for graphics, cs for compute)</li>
</ul>
<p>Note that for compatibility with other APIs, textures and tex_buffers cannot overlap Same with uav_buffers and uav_textures </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootLayout</td><td>JSON string containing root layout </td></tr>
    <tr><td class="paramname">bCompute</td><td>True if this is meant for compute. False for graphics </td></tr>
    <tr><td class="paramname">filename</td><td>Filename for logging purposes if errors are found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de2623ecb78001c7df226de5975002d" name="a3de2623ecb78001c7df226de5975002d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de2623ecb78001c7df226de5975002d">&#9670;&#160;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RootLayout::validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ace64a521d831703a6f6881f0d1e318" name="a8ace64a521d831703a6f6881f0d1e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ace64a521d831703a6f6881f0d1e318">&#9670;&#160;</a></span>validateArrayBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RootLayout::validateArrayBindings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>groundTruth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates that the array bindings in groundTruth.mArrayRanges are included in this-&gt;mArrayRanges. </p>
<p>Will throw otherwise </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groundTruth</td><td><a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system.">Root</a> Layout to compare against. Its data should've been obtrained through reflection </td></tr>
    <tr><td class="paramname">filename</td><td>Filename for logging purposes if errors are found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a394d744f62c9cd35003cbadf91c79ca2" name="a394d744f62c9cd35003cbadf91c79ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394d744f62c9cd35003cbadf91c79ca2">&#9670;&#160;</a></span>mBaked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RootLayout::mBaked[<a class="el" href="_ogre_root_layout_8h.html#a27adb7082b35d3f58fcf9b174e4e2ef2">OGRE_MAX_NUM_BOUND_DESCRIPTOR_SETS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af64a14dcf0778e201691f84fc3d57351" name="af64a14dcf0778e201691f84fc3d57351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64a14dcf0778e201691f84fc3d57351">&#9670;&#160;</a></span>mCompute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RootLayout::mCompute</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a203ae6402ca5eeee926f9b3a4e4c344f" name="a203ae6402ca5eeee926f9b3a4e4c344f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203ae6402ca5eeee926f9b3a4e4c344f">&#9670;&#160;</a></span>mDescBindingRanges</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_desc_binding_range.html">DescBindingRange</a> Ogre::RootLayout::mDescBindingRanges[<a class="el" href="_ogre_root_layout_8h.html#a27adb7082b35d3f58fcf9b174e4e2ef2">OGRE_MAX_NUM_BOUND_DESCRIPTOR_SETS</a>][<a class="el" href="namespace_ogre_1_1_desc_binding_types.html#af97aae360aa16970ee0873372c96c6bea0d280ffc6b3e89d6300f58171dd0c6c0">DescBindingTypes::NumDescBindingTypes</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7c63c10694ecc14870c535065d3e997" name="ab7c63c10694ecc14870c535065d3e997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c63c10694ecc14870c535065d3e997">&#9670;&#160;</a></span>mParamsBuffStages</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::RootLayout::mParamsBuffStages</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_root_layout_8h.html">OgreRootLayout.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
