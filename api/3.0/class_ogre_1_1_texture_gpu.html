<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::TextureGpu Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_texture_gpu.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1_texture_gpu-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::TextureGpu Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreTextureGpu.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::TextureGpu:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_texture_gpu__inherit__graph.svg" width="1423" height="327"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1662fd08f6b623d76336c0bb0d18880d" id="r_a1662fd08f6b623d76336c0bb0d18880d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1662fd08f6b623d76336c0bb0d18880d">TextureGpu</a> (<a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, <a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *textureManager)</td></tr>
<tr class="separator:a1662fd08f6b623d76336c0bb0d18880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6264dca19450e6c574c825e732106c" id="r_aff6264dca19450e6c574c825e732106c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aff6264dca19450e6c574c825e732106c">~TextureGpu</a> () override</td></tr>
<tr class="separator:aff6264dca19450e6c574c825e732106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9591cec393bcb06deda9b5f94a040fc5" id="r_a9591cec393bcb06deda9b5f94a040fc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9591cec393bcb06deda9b5f94a040fc5">_autogenerateMipmaps</a> (<a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a> transitionMode=<a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a>)=0</td></tr>
<tr class="memdesc:a9591cec393bcb06deda9b5f94a040fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the API to let the HW autogenerate mipmaps.  <br /></td></tr>
<tr class="separator:a9591cec393bcb06deda9b5f94a040fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb11dd2fac1160eaa5ae7ea0d8165581" id="r_aeb11dd2fac1160eaa5ae7ea0d8165581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aeb11dd2fac1160eaa5ae7ea0d8165581">_getSysRamCopy</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="separator:aeb11dd2fac1160eaa5ae7ea0d8165581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e1fcc0e8d7a092a55c79ace4564a4a" id="r_a47e1fcc0e8d7a092a55c79ace4564a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a47e1fcc0e8d7a092a55c79ace4564a4a">_getSysRamCopyAsBox</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="separator:a47e1fcc0e8d7a092a55c79ace4564a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7046d90f92e6a950d6d803892ee4b09" id="r_af7046d90f92e6a950d6d803892ee4b09"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af7046d90f92e6a950d6d803892ee4b09">_getSysRamCopyBytesPerImage</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="memdesc:af7046d90f92e6a950d6d803892ee4b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: Returns non-zero even if there is no system ram copy.  <br /></td></tr>
<tr class="separator:af7046d90f92e6a950d6d803892ee4b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e61075bcb144b7ae9567892d8d27bb9" id="r_a0e61075bcb144b7ae9567892d8d27bb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a0e61075bcb144b7ae9567892d8d27bb9">_getSysRamCopyBytesPerRow</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="memdesc:a0e61075bcb144b7ae9567892d8d27bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: Returns non-zero even if there is no system ram copy.  <br /></td></tr>
<tr class="separator:a0e61075bcb144b7ae9567892d8d27bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf00037ce85addebc2e305fedbc7005" id="r_acaf00037ce85addebc2e305fedbc7005"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#acaf00037ce85addebc2e305fedbc7005">_isDataReadyImpl</a> () const =0</td></tr>
<tr class="memdesc:acaf00037ce85addebc2e305fedbc7005"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <br /></td></tr>
<tr class="separator:acaf00037ce85addebc2e305fedbc7005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7ae9f0cba99bcb7bdb728a56e3298e" id="r_a6c7ae9f0cba99bcb7bdb728a56e3298e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a6c7ae9f0cba99bcb7bdb728a56e3298e">_isManualTextureFlagPresent</a> () const</td></tr>
<tr class="separator:a6c7ae9f0cba99bcb7bdb728a56e3298e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df37fcb72b47849df985a18828f2e97" id="r_a0df37fcb72b47849df985a18828f2e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a0df37fcb72b47849df985a18828f2e97">_notifySysRamDownloadIsReady</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *sysRamPtr, bool resyncOnly)</td></tr>
<tr class="memdesc:a0df37fcb72b47849df985a18828f2e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not call directly.  <br /></td></tr>
<tr class="separator:a0df37fcb72b47849df985a18828f2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cae191a32588efad29844e71bdf40be" id="r_a3cae191a32588efad29844e71bdf40be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3cae191a32588efad29844e71bdf40be">_notifyTextureSlotChanged</a> (const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *newPool, <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slice)</td></tr>
<tr class="separator:a3cae191a32588efad29844e71bdf40be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6c6c27cc45d2cf9bcf1f02bad2d28e" id="r_a5b6c6c27cc45d2cf9bcf1f02bad2d28e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a5b6c6c27cc45d2cf9bcf1f02bad2d28e">_resetTextureManager</a> ()</td></tr>
<tr class="separator:a5b6c6c27cc45d2cf9bcf1f02bad2d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebb419ba824d0128f437bbe20cc81f9" id="r_aeebb419ba824d0128f437bbe20cc81f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aeebb419ba824d0128f437bbe20cc81f9">_resolveTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *resolveTexture)</td></tr>
<tr class="memdesc:aeebb419ba824d0128f437bbe20cc81f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately resolves this texture to the resolveTexture argument.  <br /></td></tr>
<tr class="separator:aeebb419ba824d0128f437bbe20cc81f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c626ccabbd6c853ee1490358b9ca490" id="r_a4c626ccabbd6c853ee1490358b9ca490"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4c626ccabbd6c853ee1490358b9ca490">_setDepthBufferDefaults</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> depthBufferPoolId, bool preferDepthTexture, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> desiredDepthBufferFormat)</td></tr>
<tr class="memdesc:a4c626ccabbd6c853ee1490358b9ca490"><td class="mdescLeft">&#160;</td><td class="mdescRight">These 3 values are used as defaults for the compositor to use, but they may be explicitly overriden by a <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a>.  <br /></td></tr>
<tr class="separator:a4c626ccabbd6c853ee1490358b9ca490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7345e4a1d69f94657945067273376684" id="r_a7345e4a1d69f94657945067273376684"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a7345e4a1d69f94657945067273376684">_setNextLayout</a> (<a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> layout)</td></tr>
<tr class="memdesc:a7345e4a1d69f94657945067273376684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the layout the texture should be transitioned to after the next copy operation (once the copy encoder gets closed)  <br /></td></tr>
<tr class="separator:a7345e4a1d69f94657945067273376684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4044404f7783aea108e986336caaedf6" id="r_a4044404f7783aea108e986336caaedf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4044404f7783aea108e986336caaedf6">_setSampleDescription</a> (<a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> desc, <a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> validatedSampleDesc)</td></tr>
<tr class="memdesc:a4044404f7783aea108e986336caaedf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <br /></td></tr>
<tr class="separator:a4044404f7783aea108e986336caaedf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae641939cec4a57193dab3fc88921b7ae" id="r_ae641939cec4a57193dab3fc88921b7ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae641939cec4a57193dab3fc88921b7ae">_setSourceType</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> type)</td></tr>
<tr class="separator:ae641939cec4a57193dab3fc88921b7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e3c937c79ca63bd2994af5532c547d" id="r_ab5e3c937c79ca63bd2994af5532c547d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ab5e3c937c79ca63bd2994af5532c547d">_setToDisplayDummyTexture</a> ()=0</td></tr>
<tr class="separator:ab5e3c937c79ca63bd2994af5532c547d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40511da73ca4dc4bd8a3e8fc42c44147" id="r_a40511da73ca4dc4bd8a3e8fc42c44147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a40511da73ca4dc4bd8a3e8fc42c44147">_syncGpuResidentToSystemRam</a> ()</td></tr>
<tr class="memdesc:a40511da73ca4dc4bd8a3e8fc42c44147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces downloading data from GPU to CPU, usually because the data on GPU changed and we're in strategy AlwaysKeepSystemRamCopy.  <br /></td></tr>
<tr class="separator:a40511da73ca4dc4bd8a3e8fc42c44147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f9670da9031ec138caf8b3e910b37e" id="r_a85f9670da9031ec138caf8b3e910b37e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a85f9670da9031ec138caf8b3e910b37e">_transitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> newResidency, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *sysRamCopy, bool autoDeleteSysRamCopy=true)</td></tr>
<tr class="memdesc:a85f9670da9031ec138caf8b3e910b37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function may be called manually (if user is manually managing a texture) or automatically (e.g.  <br /></td></tr>
<tr class="separator:a85f9670da9031ec138caf8b3e910b37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6dd0d57c28fe017e8a83877bea0c5f" id="r_a1b6dd0d57c28fe017e8a83877bea0c5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1b6dd0d57c28fe017e8a83877bea0c5f">addListener</a> (<a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *listener)</td></tr>
<tr class="separator:a1b6dd0d57c28fe017e8a83877bea0c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297cc2e34e6803ffe25614d36ae4da36" id="r_a297cc2e34e6803ffe25614d36ae4da36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a297cc2e34e6803ffe25614d36ae4da36">allowsAutoMipmaps</a> () const</td></tr>
<tr class="separator:a297cc2e34e6803ffe25614d36ae4da36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b8aace07a416886cc0f871b32f078c" id="r_a50b8aace07a416886cc0f871b32f078c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a50b8aace07a416886cc0f871b32f078c">copyContentsToMemory</a> (<a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> src, <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> dst, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> dstFormat, bool automaticResolve=true)</td></tr>
<tr class="memdesc:a50b8aace07a416886cc0f871b32f078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current contents of the render target to the memory.  <br /></td></tr>
<tr class="separator:a50b8aace07a416886cc0f871b32f078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1403e76b6775c08d2cb7b0c7d1398d" id="r_a1a1403e76b6775c08d2cb7b0c7d1398d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1a1403e76b6775c08d2cb7b0c7d1398d">copyParametersFrom</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *src)</td></tr>
<tr class="separator:a1a1403e76b6775c08d2cb7b0c7d1398d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f60db95a5d6b1681b34aae96d98c4c" id="r_a18f60db95a5d6b1681b34aae96d98c4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a18f60db95a5d6b1681b34aae96d98c4c">copyTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *dst, const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;dstBox, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> dstMipLevel, const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;srcBox, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> srcMipLevel, bool keepResolvedTexSynced=true, <a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a> srcTransitionMode=<a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a>, <a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a> dstTransitionMode=<a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a>)</td></tr>
<tr class="separator:a18f60db95a5d6b1681b34aae96d98c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb161795caec263b077532c05070dbe4" id="r_adb161795caec263b077532c05070dbe4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#adb161795caec263b077532c05070dbe4">getCurrentLayout</a> () const</td></tr>
<tr class="separator:adb161795caec263b077532c05070dbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecbe86d69c49a223a92070acbd309fc" id="r_aaecbe86d69c49a223a92070acbd309fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aaecbe86d69c49a223a92070acbd309fc">getCustomAttribute</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, void *pData)</td></tr>
<tr class="separator:aaecbe86d69c49a223a92070acbd309fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472f6a92131325af1a8f5ba2b78b86eb" id="r_a472f6a92131325af1a8f5ba2b78b86eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a472f6a92131325af1a8f5ba2b78b86eb">getDefaultLayout</a> (bool bIgnoreDiscardableFlag=false) const</td></tr>
<tr class="separator:a472f6a92131325af1a8f5ba2b78b86eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20508c2ba704e46e84453bc62aea85a0" id="r_a20508c2ba704e46e84453bc62aea85a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a20508c2ba704e46e84453bc62aea85a0">getDepth</a> () const</td></tr>
<tr class="memdesc:a20508c2ba704e46e84453bc62aea85a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For TypeCube &amp; TypeCubeArray, this value returns 1.  <br /></td></tr>
<tr class="separator:a20508c2ba704e46e84453bc62aea85a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ecd2c52d97dd2b62a2e4b52a5cb548" id="r_a62ecd2c52d97dd2b62a2e4b52a5cb548"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a62ecd2c52d97dd2b62a2e4b52a5cb548">getDepthBufferPoolId</a> () const</td></tr>
<tr class="separator:a62ecd2c52d97dd2b62a2e4b52a5cb548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479448e4772db382f106470a94fafa13" id="r_a479448e4772db382f106470a94fafa13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a479448e4772db382f106470a94fafa13">getDepthOrSlices</a> () const</td></tr>
<tr class="separator:a479448e4772db382f106470a94fafa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9b67097af3ad1a470065fc9dce032d" id="r_a5e9b67097af3ad1a470065fc9dce032d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a5e9b67097af3ad1a470065fc9dce032d">getDesiredDepthBufferFormat</a> () const</td></tr>
<tr class="separator:a5e9b67097af3ad1a470065fc9dce032d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714b2b71f5443736c7c0ac2a97753c02" id="r_a714b2b71f5443736c7c0ac2a97753c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a714b2b71f5443736c7c0ac2a97753c02">getEmptyBox</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="separator:a714b2b71f5443736c7c0ac2a97753c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8a88cae92d0f92e0b1b909e89ee418" id="r_a0a8a88cae92d0f92e0b1b909e89ee418"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a0a8a88cae92d0f92e0b1b909e89ee418">getHeight</a> () const</td></tr>
<tr class="separator:a0a8a88cae92d0f92e0b1b909e89ee418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721a122155347df2d22d18041dd5ace8" id="r_a721a122155347df2d22d18041dd5ace8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a721a122155347df2d22d18041dd5ace8">getInternalHeight</a> () const</td></tr>
<tr class="memdesc:a721a122155347df2d22d18041dd5ace8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real API height accounting for <a class="el" href="class_ogre_1_1_texture_gpu.html#a8993f62ca86dc5f0e92b1943b247889b">TextureGpu::getOrientationMode</a>. See getInternalWidth.  <br /></td></tr>
<tr class="separator:a721a122155347df2d22d18041dd5ace8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce184c672016ba3c13781c772a6e406" id="r_acce184c672016ba3c13781c772a6e406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#acce184c672016ba3c13781c772a6e406">getInternalSliceStart</a> () const</td></tr>
<tr class="separator:acce184c672016ba3c13781c772a6e406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae831c8c3a0760106f62a502b7fb21a" id="r_adae831c8c3a0760106f62a502b7fb21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#adae831c8c3a0760106f62a502b7fb21a">getInternalTextureType</a> () const</td></tr>
<tr class="separator:adae831c8c3a0760106f62a502b7fb21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe66c8fd9f7402c90fcf7729f2a67c44" id="r_abe66c8fd9f7402c90fcf7729f2a67c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#abe66c8fd9f7402c90fcf7729f2a67c44">getInternalWidth</a> () const</td></tr>
<tr class="memdesc:abe66c8fd9f7402c90fcf7729f2a67c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real API width accounting for <a class="el" href="class_ogre_1_1_texture_gpu.html#a8993f62ca86dc5f0e92b1943b247889b">TextureGpu::getOrientationMode</a> If orientation mode is 90° or 270° then getInternalWidth returns the height and getInternalHeight returns the width.  <br /></td></tr>
<tr class="separator:abe66c8fd9f7402c90fcf7729f2a67c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05adaec1366a16ccb1fa2816d3fe5747" id="r_a05adaec1366a16ccb1fa2816d3fe5747"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> * &gt;::type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a05adaec1366a16ccb1fa2816d3fe5747">getListeners</a> () const</td></tr>
<tr class="separator:a05adaec1366a16ccb1fa2816d3fe5747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2b359561c96f9f60c3e2db8c7008fb" id="r_afb2b359561c96f9f60c3e2db8c7008fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#afb2b359561c96f9f60c3e2db8c7008fb">getNameStr</a> () const override</td></tr>
<tr class="memdesc:afb2b359561c96f9f60c3e2db8c7008fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: This returns the alias name of the texture.  <br /></td></tr>
<tr class="separator:afb2b359561c96f9f60c3e2db8c7008fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f193236caf39fcaa5f90ae613f355a0" id="r_a2f193236caf39fcaa5f90ae613f355a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a2f193236caf39fcaa5f90ae613f355a0">getNumMipmaps</a> () const</td></tr>
<tr class="separator:a2f193236caf39fcaa5f90ae613f355a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494d1ec99e6e6589c4059125a1d10966" id="r_a494d1ec99e6e6589c4059125a1d10966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a494d1ec99e6e6589c4059125a1d10966">getNumSlices</a> () const</td></tr>
<tr class="memdesc:a494d1ec99e6e6589c4059125a1d10966"><td class="mdescLeft">&#160;</td><td class="mdescRight">For TypeCube this value returns 6.  <br /></td></tr>
<tr class="separator:a494d1ec99e6e6589c4059125a1d10966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8993f62ca86dc5f0e92b1943b247889b" id="r_a8993f62ca86dc5f0e92b1943b247889b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a8993f62ca86dc5f0e92b1943b247889b">getOrientationMode</a> () const</td></tr>
<tr class="separator:a8993f62ca86dc5f0e92b1943b247889b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72ce773bbfd3c330fa3fbd5df40a649" id="r_ad72ce773bbfd3c330fa3fbd5df40a649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad72ce773bbfd3c330fa3fbd5df40a649">getPixelFormat</a> () const</td></tr>
<tr class="separator:ad72ce773bbfd3c330fa3fbd5df40a649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3f5bbd523cb6e1c1a678a22d034baf" id="r_abc3f5bbd523cb6e1c1a678a22d034baf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#abc3f5bbd523cb6e1c1a678a22d034baf">getPreferDepthTexture</a> () const</td></tr>
<tr class="separator:abc3f5bbd523cb6e1c1a678a22d034baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88776112af1b31c69566c2d1b6217d64" id="r_a88776112af1b31c69566c2d1b6217d64"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a88776112af1b31c69566c2d1b6217d64">getRealResourceNameStr</a> () const</td></tr>
<tr class="memdesc:a88776112af1b31c69566c2d1b6217d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real name (e.g. disk in file) of the resource.  <br /></td></tr>
<tr class="separator:a88776112af1b31c69566c2d1b6217d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975e937d93d9c0d961ba658dd901fdac" id="r_a975e937d93d9c0d961ba658dd901fdac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a975e937d93d9c0d961ba658dd901fdac">getRequestedSampleDescription</a> () const</td></tr>
<tr class="memdesc:a975e937d93d9c0d961ba658dd901fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns original requested sample description, i.e. the raw input to setSampleDescription.  <br /></td></tr>
<tr class="separator:a975e937d93d9c0d961ba658dd901fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65fb98f0b6a575bf54c72bce4491b20" id="r_ad65fb98f0b6a575bf54c72bce4491b20"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad65fb98f0b6a575bf54c72bce4491b20">getResourceGroupStr</a> () const</td></tr>
<tr class="separator:ad65fb98f0b6a575bf54c72bce4491b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddc319ba3c8969c033d6549d933795b" id="r_a8ddc319ba3c8969c033d6549d933795b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a8ddc319ba3c8969c033d6549d933795b">getSampleDescription</a> () const</td></tr>
<tr class="memdesc:a8ddc319ba3c8969c033d6549d933795b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns effective sample description supported by the API.  <br /></td></tr>
<tr class="separator:a8ddc319ba3c8969c033d6549d933795b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f26820d396ef6b0384126f432d38dba" id="r_a1f26820d396ef6b0384126f432d38dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1f26820d396ef6b0384126f432d38dba">getSettingsDesc</a> () const</td></tr>
<tr class="separator:a1f26820d396ef6b0384126f432d38dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6ca873871e56f34e4abbb4faf33315" id="r_a9b6ca873871e56f34e4abbb4faf33315"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9b6ca873871e56f34e4abbb4faf33315">getSizeBytes</a> () const</td></tr>
<tr class="memdesc:a9b6ca873871e56f34e4abbb4faf33315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total size in bytes used in GPU by this texture (not by its pool) including mipmaps.  <br /></td></tr>
<tr class="separator:a9b6ca873871e56f34e4abbb4faf33315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414988b01605099f449d5f452c50ca08" id="r_a414988b01605099f449d5f452c50ca08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a414988b01605099f449d5f452c50ca08">getSourceType</a> () const</td></tr>
<tr class="memdesc:a414988b01605099f449d5f452c50ca08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This setting is for where the texture is created, e.g.  <br /></td></tr>
<tr class="separator:a414988b01605099f449d5f452c50ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a458af605a3aa67117fe267ac453c17" id="r_a1a458af605a3aa67117fe267ac453c17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1a458af605a3aa67117fe267ac453c17">getSubsampleLocations</a> (vector&lt; <a class="el" href="class_ogre_1_1_vector2.html">Vector2</a> &gt;::type locations)=0</td></tr>
<tr class="memdesc:a1a458af605a3aa67117fe267ac453c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MSAA subsample locations.  <br /></td></tr>
<tr class="separator:a1a458af605a3aa67117fe267ac453c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a00d4b20fcb8ec0c03f5f905577839" id="r_af2a00d4b20fcb8ec0c03f5f905577839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af2a00d4b20fcb8ec0c03f5f905577839">getTextureManager</a> () const</td></tr>
<tr class="separator:af2a00d4b20fcb8ec0c03f5f905577839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf93ab56a0c0006c4ba0de53acf01876" id="r_abf93ab56a0c0006c4ba0de53acf01876"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#abf93ab56a0c0006c4ba0de53acf01876">getTexturePool</a> () const</td></tr>
<tr class="separator:abf93ab56a0c0006c4ba0de53acf01876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad10f8ad89aa3d058e879b8a7280b8c5" id="r_aad10f8ad89aa3d058e879b8a7280b8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aad10f8ad89aa3d058e879b8a7280b8c5">getTexturePoolId</a> () const</td></tr>
<tr class="separator:aad10f8ad89aa3d058e879b8a7280b8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b75fd64ef4af817e1ce1e881132b78d" id="r_a4b75fd64ef4af817e1ce1e881132b78d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4b75fd64ef4af817e1ce1e881132b78d">getTextureType</a> () const</td></tr>
<tr class="separator:a4b75fd64ef4af817e1ce1e881132b78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1ea0e81537e4b98ad11f6cc06f14cd" id="r_add1ea0e81537e4b98ad11f6cc06f14cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#add1ea0e81537e4b98ad11f6cc06f14cd">getWidth</a> () const</td></tr>
<tr class="separator:add1ea0e81537e4b98ad11f6cc06f14cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd906e6f2bc6ec0a23c2b8c5d1b343" id="r_a3cdd906e6f2bc6ec0a23c2b8c5d1b343"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3cdd906e6f2bc6ec0a23c2b8c5d1b343">hasAutomaticBatching</a> () const</td></tr>
<tr class="separator:a3cdd906e6f2bc6ec0a23c2b8c5d1b343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e9e1aa38bfc4c638d4dc50c0f60518" id="r_a15e9e1aa38bfc4c638d4dc50c0f60518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a15e9e1aa38bfc4c638d4dc50c0f60518">hasAutoMipmapAuto</a> () const</td></tr>
<tr class="separator:a15e9e1aa38bfc4c638d4dc50c0f60518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af943f8d1fd87f457fb4633058d696470" id="r_af943f8d1fd87f457fb4633058d696470"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af943f8d1fd87f457fb4633058d696470">hasEquivalentParameters</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *other) const</td></tr>
<tr class="separator:af943f8d1fd87f457fb4633058d696470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61d6984f85ded6bbdd1678b08e92b52" id="r_af61d6984f85ded6bbdd1678b08e92b52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af61d6984f85ded6bbdd1678b08e92b52">hasMsaaExplicitResolves</a> () const</td></tr>
<tr class="separator:af61d6984f85ded6bbdd1678b08e92b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3771accff5d16846747c8ea99756bd8a" id="r_a3771accff5d16846747c8ea99756bd8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3771accff5d16846747c8ea99756bd8a">isDataReady</a> () const</td></tr>
<tr class="memdesc:a3771accff5d16846747c8ea99756bd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this texture is fully ready to be used for displaying.  <br /></td></tr>
<tr class="separator:a3771accff5d16846747c8ea99756bd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9203b7f0a8ae0f862fcd5d17f11d7ed" id="r_ad9203b7f0a8ae0f862fcd5d17f11d7ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad9203b7f0a8ae0f862fcd5d17f11d7ed">isDiscardableContent</a> () const</td></tr>
<tr class="separator:ad9203b7f0a8ae0f862fcd5d17f11d7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8915b3073eaf7d90db8d44def65c8749" id="r_a8915b3073eaf7d90db8d44def65c8749"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a8915b3073eaf7d90db8d44def65c8749">isManualTexture</a> () const</td></tr>
<tr class="separator:a8915b3073eaf7d90db8d44def65c8749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9212250fb5225d8f37b6554e11a7ed39" id="r_a9212250fb5225d8f37b6554e11a7ed39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9212250fb5225d8f37b6554e11a7ed39">isMetadataReady</a> () const</td></tr>
<tr class="memdesc:a9212250fb5225d8f37b6554e11a7ed39"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is threadsafe to call this function from main thread.  <br /></td></tr>
<tr class="separator:a9212250fb5225d8f37b6554e11a7ed39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebc3bec47d599f4d0f7a9cde67bd4d3" id="r_a4ebc3bec47d599f4d0f7a9cde67bd4d3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4ebc3bec47d599f4d0f7a9cde67bd4d3">isMsaaPatternSupported</a> (<a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0f">MsaaPatterns::MsaaPatterns</a> pattern)</td></tr>
<tr class="separator:a4ebc3bec47d599f4d0f7a9cde67bd4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5484c1525a406ce02774a0d26f7ac41" id="r_ad5484c1525a406ce02774a0d26f7ac41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad5484c1525a406ce02774a0d26f7ac41">isMultisample</a> () const</td></tr>
<tr class="separator:ad5484c1525a406ce02774a0d26f7ac41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2efdb62aa1600025965301318308a55" id="r_aa2efdb62aa1600025965301318308a55"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa2efdb62aa1600025965301318308a55">isOpenGLRenderWindow</a> () const</td></tr>
<tr class="memdesc:aa2efdb62aa1600025965301318308a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL RenderWindows are a bit specific:  <br /></td></tr>
<tr class="separator:aa2efdb62aa1600025965301318308a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeee1147f96cbc850aafbe11b4842258" id="r_aaeee1147f96cbc850aafbe11b4842258"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aaeee1147f96cbc850aafbe11b4842258">isPoolOwner</a> () const</td></tr>
<tr class="separator:aaeee1147f96cbc850aafbe11b4842258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad046ba9fe6192934b95b513239949044" id="r_ad046ba9fe6192934b95b513239949044"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad046ba9fe6192934b95b513239949044">isReinterpretable</a> () const</td></tr>
<tr class="separator:ad046ba9fe6192934b95b513239949044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1996625da438d07e34c2abca24a9f0" id="r_a1a1996625da438d07e34c2abca24a9f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1a1996625da438d07e34c2abca24a9f0">isRenderToTexture</a> () const</td></tr>
<tr class="separator:a1a1996625da438d07e34c2abca24a9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadda46635a310a0b5a24b7bf93cfee19" id="r_aadda46635a310a0b5a24b7bf93cfee19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aadda46635a310a0b5a24b7bf93cfee19">isRenderWindowSpecific</a> () const</td></tr>
<tr class="separator:aadda46635a310a0b5a24b7bf93cfee19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7d52501e9da7655079f9c4d6f1c037" id="r_a4b7d52501e9da7655079f9c4d6f1c037"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4b7d52501e9da7655079f9c4d6f1c037">isTexture</a> () const</td></tr>
<tr class="separator:a4b7d52501e9da7655079f9c4d6f1c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcab7d39a3d28af67cccee42f37c73f" id="r_abdcab7d39a3d28af67cccee42f37c73f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#abdcab7d39a3d28af67cccee42f37c73f">isTextureGpu</a> () const override</td></tr>
<tr class="separator:abdcab7d39a3d28af67cccee42f37c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1abe749069021e4e83cdaa7668b3bc" id="r_afb1abe749069021e4e83cdaa7668b3bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#afb1abe749069021e4e83cdaa7668b3bc">isUav</a> () const</td></tr>
<tr class="separator:afb1abe749069021e4e83cdaa7668b3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52acdc930dff7ae7f455256822d9520d" id="r_a52acdc930dff7ae7f455256822d9520d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a52acdc930dff7ae7f455256822d9520d">notifyAllListenersTextureChanged</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> reason, void *extraData=0)</td></tr>
<tr class="separator:a52acdc930dff7ae7f455256822d9520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d480691663c93439835ff7d11f7739" id="r_a73d480691663c93439835ff7d11f7739"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a73d480691663c93439835ff7d11f7739">notifyDataIsReady</a> ()=0</td></tr>
<tr class="memdesc:a73d480691663c93439835ff7d11f7739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies it is safe to use the real data. Everything has been uploaded.  <br /></td></tr>
<tr class="separator:a73d480691663c93439835ff7d11f7739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4d050aca586041f3e6586fdfc6bd5e" id="r_adc4d050aca586041f3e6586fdfc6bd5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#adc4d050aca586041f3e6586fdfc6bd5e">prefersLoadingFromFileAsSRGB</a> () const</td></tr>
<tr class="separator:adc4d050aca586041f3e6586fdfc6bd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e0ad601752b91f2851c88f9ed49869" id="r_ae3e0ad601752b91f2851c88f9ed49869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae3e0ad601752b91f2851c88f9ed49869">removeListener</a> (<a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *listener)</td></tr>
<tr class="separator:ae3e0ad601752b91f2851c88f9ed49869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac090ad8bd36b3bc9c4370444f04e943d" id="r_ac090ad8bd36b3bc9c4370444f04e943d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ac090ad8bd36b3bc9c4370444f04e943d">requiresTextureFlipping</a> () const</td></tr>
<tr class="separator:ac090ad8bd36b3bc9c4370444f04e943d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfbfac96361e544a0298a223250b028" id="r_a3cfbfac96361e544a0298a223250b028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3cfbfac96361e544a0298a223250b028">scheduleReupload</a> (<a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image=0, bool autoDeleteImage=true, bool bSkipMultiload=false)</td></tr>
<tr class="memdesc:a3cfbfac96361e544a0298a223250b028"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are times where you want to reload a texture again (e.g.  <br /></td></tr>
<tr class="separator:a3cfbfac96361e544a0298a223250b028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e5eb68dc3ba4521042fa82656a8a53" id="r_a32e5eb68dc3ba4521042fa82656a8a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a32e5eb68dc3ba4521042fa82656a8a53">scheduleTransitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image=0, bool autoDeleteImage=true, bool bSkipMultiload=false)</td></tr>
<tr class="memdesc:a32e5eb68dc3ba4521042fa82656a8a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as unsafeScheduleTransitionTo, but first checks if we're already in the residency state we want to go to, or if it has already been scheduled; thus it can be called multiple times.  <br /></td></tr>
<tr class="separator:a32e5eb68dc3ba4521042fa82656a8a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae40391d39c8feae00acaf25839c6f9" id="r_a6ae40391d39c8feae00acaf25839c6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a6ae40391d39c8feae00acaf25839c6f9">setNumMipmaps</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numMipmaps)</td></tr>
<tr class="separator:a6ae40391d39c8feae00acaf25839c6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3866a77dfd74f1b70fdd31f42382c544" id="r_a3866a77dfd74f1b70fdd31f42382c544"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3866a77dfd74f1b70fdd31f42382c544">setOrientationMode</a> (<a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a> orientationMode)</td></tr>
<tr class="memdesc:a3866a77dfd74f1b70fdd31f42382c544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given orientation.  <br /></td></tr>
<tr class="separator:a3866a77dfd74f1b70fdd31f42382c544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dfe2523d8e5647e79caaf28c296d4e" id="r_a54dfe2523d8e5647e79caaf28c296d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a54dfe2523d8e5647e79caaf28c296d4e">setPixelFormat</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat)</td></tr>
<tr class="memdesc:a54dfe2523d8e5647e79caaf28c296d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel format.  <br /></td></tr>
<tr class="separator:a54dfe2523d8e5647e79caaf28c296d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e22c90559d13385d75dc19970806d" id="r_af79e22c90559d13385d75dc19970806d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af79e22c90559d13385d75dc19970806d">setResolution</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> depthOrSlices=1u)</td></tr>
<tr class="separator:af79e22c90559d13385d75dc19970806d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ee4d088c32b3e9efeb4d2fec5cad3e" id="r_aa2ee4d088c32b3e9efeb4d2fec5cad3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa2ee4d088c32b3e9efeb4d2fec5cad3e">setSampleDescription</a> (<a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> desc)</td></tr>
<tr class="separator:aa2ee4d088c32b3e9efeb4d2fec5cad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bd23c2116dc08afcaa8dc1b8d2384e" id="r_a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a78bd23c2116dc08afcaa8dc1b8d2384e">setTexturePoolId</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId)</td></tr>
<tr class="memdesc:a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D Texture with automatic batching will be merged with other textures into the same pool as one big 2D Array texture behind the scenes.  <br /></td></tr>
<tr class="separator:a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadb4961ae1af0313cbd253bd32285dd" id="r_aeadb4961ae1af0313cbd253bd32285dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aeadb4961ae1af0313cbd253bd32285dd">setTextureType</a> (<a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType)</td></tr>
<tr class="separator:aeadb4961ae1af0313cbd253bd32285dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd2fb8a2ce598268c8813f5f230ddd8" id="r_a3bd2fb8a2ce598268c8813f5f230ddd8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3bd2fb8a2ce598268c8813f5f230ddd8">supportsAsDepthBufferFor</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *colourTarget) const</td></tr>
<tr class="separator:a3bd2fb8a2ce598268c8813f5f230ddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57666f9b894eb0c488461e558d22e033" id="r_a57666f9b894eb0c488461e558d22e033"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a57666f9b894eb0c488461e558d22e033">swapBuffers</a> ()</td></tr>
<tr class="memdesc:a57666f9b894eb0c488461e558d22e033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only valid for <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> classes.  <br /></td></tr>
<tr class="separator:a57666f9b894eb0c488461e558d22e033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aee068205a09b2d3aa61d021c8a62a8" id="r_a3aee068205a09b2d3aa61d021c8a62a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3aee068205a09b2d3aa61d021c8a62a8">unsafeScheduleTransitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image=0, bool autoDeleteImage=true, bool bSkipMultiload=false)</td></tr>
<tr class="memdesc:a3aee068205a09b2d3aa61d021c8a62a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules an async transition in residency.  <br /></td></tr>
<tr class="separator:a3aee068205a09b2d3aa61d021c8a62a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236d643259ed803cab8b550af78fc755" id="r_a236d643259ed803cab8b550af78fc755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a236d643259ed803cab8b550af78fc755">waitForData</a> ()</td></tr>
<tr class="memdesc:a236d643259ed803cab8b550af78fc755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks main thread until data is ready.  <br /></td></tr>
<tr class="separator:a236d643259ed803cab8b550af78fc755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13af2e0d5c099c3be71e33c2159b16e9" id="r_a13af2e0d5c099c3be71e33c2159b16e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a13af2e0d5c099c3be71e33c2159b16e9">waitForMetadata</a> ()</td></tr>
<tr class="memdesc:a13af2e0d5c099c3be71e33c2159b16e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks main thread until metadata is ready.  <br /></td></tr>
<tr class="separator:a13af2e0d5c099c3be71e33c2159b16e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af042e9ab52c07776f154ee077330f592" id="r_af042e9ab52c07776f154ee077330f592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af042e9ab52c07776f154ee077330f592">writeContentsToFile</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> minMip, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> maxMip, bool automaticResolve=true)</td></tr>
<tr class="memdesc:af042e9ab52c07776f154ee077330f592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current contents of the render target to the named file.  <br /></td></tr>
<tr class="separator:af042e9ab52c07776f154ee077330f592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ogre_1_1_gpu_tracked_resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_ogre_1_1_gpu_tracked_resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ogre_1_1_gpu_tracked_resource.html">Ogre::GpuTrackedResource</a></td></tr>
<tr class="memitem:a69277d380374e3036b00e8c051c09689 inherit pub_methods_struct_ogre_1_1_gpu_tracked_resource" id="r_a69277d380374e3036b00e8c051c09689"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_gpu_tracked_resource.html#a69277d380374e3036b00e8c051c09689">~GpuTrackedResource</a> ()</td></tr>
<tr class="separator:a69277d380374e3036b00e8c051c09689 inherit pub_methods_struct_ogre_1_1_gpu_tracked_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_ogre_1_1_gpu_resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_ogre_1_1_gpu_resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_ogre_1_1_gpu_resource.html">Ogre::GpuResource</a></td></tr>
<tr class="memitem:a396a21931e716ebd97553a0a99978838 inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_a396a21931e716ebd97553a0a99978838"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a396a21931e716ebd97553a0a99978838">GpuResource</a> (<a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name)</td></tr>
<tr class="separator:a396a21931e716ebd97553a0a99978838 inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecbf330f3a8ee478c77b250abb85ea9 inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_a3ecbf330f3a8ee478c77b250abb85ea9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a3ecbf330f3a8ee478c77b250abb85ea9">~GpuResource</a> ()</td></tr>
<tr class="separator:a3ecbf330f3a8ee478c77b250abb85ea9 inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad623ee0c97e95e276074d3cfd64c374c inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_ad623ee0c97e95e276074d3cfd64c374c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#ad623ee0c97e95e276074d3cfd64c374c">_addPendingResidencyChanges</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> value)</td></tr>
<tr class="separator:ad623ee0c97e95e276074d3cfd64c374c inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ccef279ef9251c5a4b40bfaf7b9e05 inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_a56ccef279ef9251c5a4b40bfaf7b9e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a56ccef279ef9251c5a4b40bfaf7b9e05">_setNextResidencyStatus</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency)</td></tr>
<tr class="separator:a56ccef279ef9251c5a4b40bfaf7b9e05 inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9311078ea7d4d85ed5cbaae4e641f765 inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_a9311078ea7d4d85ed5cbaae4e641f765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a9311078ea7d4d85ed5cbaae4e641f765">getGpuPageOutStrategy</a> () const</td></tr>
<tr class="separator:a9311078ea7d4d85ed5cbaae4e641f765 inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa747c8f9b2503e09c167d885e9dcbdee inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_aa747c8f9b2503e09c167d885e9dcbdee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#aa747c8f9b2503e09c167d885e9dcbdee">getName</a> () const</td></tr>
<tr class="separator:aa747c8f9b2503e09c167d885e9dcbdee inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbc14f1a5f1750b92a5197215f5e6dc inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_acfbc14f1a5f1750b92a5197215f5e6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#acfbc14f1a5f1750b92a5197215f5e6dc">getNextResidencyStatus</a> () const</td></tr>
<tr class="memdesc:acfbc14f1a5f1750b92a5197215f5e6dc inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <a class="el" href="class_ogre_1_1_gpu_resource.html#a070b7c583f5541ecbd8ad3b1aa919140">getResidencyStatus()</a> != <a class="el" href="class_ogre_1_1_gpu_resource.html#acfbc14f1a5f1750b92a5197215f5e6dc" title="When getResidencyStatus() != getNextResidencyStatus(), residency changes happen in the main thread,...">getNextResidencyStatus()</a>, residency changes happen in the main thread, while some preparation may be happening in the background.  <br /></td></tr>
<tr class="separator:acfbc14f1a5f1750b92a5197215f5e6dc inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a51a82de7ad88e7c09410d23d16d28 inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_a97a51a82de7ad88e7c09410d23d16d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a97a51a82de7ad88e7c09410d23d16d28">getPendingResidencyChanges</a> () const</td></tr>
<tr class="memdesc:a97a51a82de7ad88e7c09410d23d16d28 inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of pending residency changes.  <br /></td></tr>
<tr class="separator:a97a51a82de7ad88e7c09410d23d16d28 inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070b7c583f5541ecbd8ad3b1aa919140 inherit pub_methods_class_ogre_1_1_gpu_resource" id="r_a070b7c583f5541ecbd8ad3b1aa919140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a070b7c583f5541ecbd8ad3b1aa919140">getResidencyStatus</a> () const</td></tr>
<tr class="separator:a070b7c583f5541ecbd8ad3b1aa919140 inherit pub_methods_class_ogre_1_1_gpu_resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8ec57ce0ef0c682416c3a6b6d13a095a" id="r_a8ec57ce0ef0c682416c3a6b6d13a095a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a8ec57ce0ef0c682416c3a6b6d13a095a">msDefaultOrientationMode</a></td></tr>
<tr class="memdesc:a8ec57ce0ef0c682416c3a6b6d13a095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PUBLIC VARIABLE.  <br /></td></tr>
<tr class="separator:a8ec57ce0ef0c682416c3a6b6d13a095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed2bdf11740fd262b9311a33e33f935" id="r_a3ed2bdf11740fd262b9311a33e33f935"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3ed2bdf11740fd262b9311a33e33f935">msFinalTextureBuffer</a></td></tr>
<tr class="separator:a3ed2bdf11740fd262b9311a33e33f935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43888e98f84f5c9eb9ded14dd0deb34d" id="r_a43888e98f84f5c9eb9ded14dd0deb34d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a43888e98f84f5c9eb9ded14dd0deb34d">msMsaaTextureBuffer</a></td></tr>
<tr class="separator:a43888e98f84f5c9eb9ded14dd0deb34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section remark"><dt>Remarks</dt><dd>Internal layout of data in memory: <pre class="fragment">        Mip0 -&gt; Slice 0, Slice 1, ..., Slice N
        Mip1 -&gt; Slice 0, Slice 1, ..., Slice N
        ...
        MipN -&gt; Slice 0, Slice 1, ..., Slice N</pre></dd></dl>
<p>The layout for 3D volume and array textures is the same. The only thing that changes is that for 3D volumes, the number of slices also decreases with each mip, while for array textures it is kept constant.</p>
<p>For 1D array textures, the number of slices is stored in mDepthOrSlices, not in Height.</p>
<p>For code reference, look at _getSysRamCopyAsBox implementation, and <a class="el" href="struct_ogre_1_1_texture_box.html#a9f7197469f66e005ae66680212f9b5fd" title="x, y &amp; z are in pixels.">TextureBox::at</a> Each row of pixels is aligned to 4 bytes (except for compressed formats that require more strict alignments, such as alignment to the block).</p>
<p>A <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> loaded from file has the following life cycle, usually:</p><ol type="1">
<li>At creation it's mResidencyStatus = <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98ad60acc99d4bcd4898f280cbf6d8ef1dc" title="Texture is on storage (i.e.">GpuResidency::OnStorage</a></li>
<li>Loading is scheduled via scheduleTransitionTo. mNextResidencyStatus = <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a></li>
<li>Texture transitions to resident. mResidencyStatus = <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> isMetadataReady returns true. How fast this happens depends on whether there was a metadata cache or not.</li>
<li>If there is a metadata cache, and the cache turned out to be wrong (e.g. it lied or was out of date), the texture will transition back to OnStorage and the whole process repeats from step 1.</li>
<li>Texture finishes loading. notifyDataIsReady gets called and now isDataReady returns true. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1662fd08f6b623d76336c0bb0d18880d" name="a1662fd08f6b623d76336c0bb0d18880d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1662fd08f6b623d76336c0bb0d18880d">&#9670;&#160;</a></span>TextureGpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::TextureGpu::TextureGpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *&#160;</td>
          <td class="paramname"><em>textureManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff6264dca19450e6c574c825e732106c" name="aff6264dca19450e6c574c825e732106c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6264dca19450e6c574c825e732106c">&#9670;&#160;</a></span>~TextureGpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::TextureGpu::~TextureGpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9591cec393bcb06deda9b5f94a040fc5" name="a9591cec393bcb06deda9b5f94a040fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9591cec393bcb06deda9b5f94a040fc5">&#9670;&#160;</a></span>_autogenerateMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::_autogenerateMipmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a>&#160;</td>
          <td class="paramname"><em>transitionMode</em> = <code><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the API to let the HW autogenerate mipmaps. </p>
<p>Assumes <a class="el" href="class_ogre_1_1_texture_gpu.html#a297cc2e34e6803ffe25614d36ae4da36">allowsAutoMipmaps()</a> == true and <a class="el" href="class_ogre_1_1_texture_gpu.html#a1a1996625da438d07e34c2abca24a9f0">isRenderToTexture()</a> == true </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitionMode</td><td>See <a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a" title="Copy Encoder Transition modes to be used by TextureGpu::copyTo and TextureGpu::_autogenerateMipmaps.">CopyEncTransitionMode::CopyEncTransitionMode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#a938565d670bd9e47835e6521f97baa82">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a04dc356263ed47caaf131d71294d05ce">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#aac3c3e9ae59e2e7fb941b20eb6f129c3">Ogre::MetalTextureGpu</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu.html#acbcbd56f3364c8ae4647fb8380c5cdfe">Ogre::NULLTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#aac31af333bec62f18b68ba5e9f926a76">Ogre::VulkanTextureGpu</a>.</p>

</div>
</div>
<a id="aeb11dd2fac1160eaa5ae7ea0d8165581" name="aeb11dd2fac1160eaa5ae7ea0d8165581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb11dd2fac1160eaa5ae7ea0d8165581">&#9670;&#160;</a></span>_getSysRamCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> * Ogre::TextureGpu::_getSysRamCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47e1fcc0e8d7a092a55c79ace4564a4a" name="a47e1fcc0e8d7a092a55c79ace4564a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e1fcc0e8d7a092a55c79ace4564a4a">&#9670;&#160;</a></span>_getSysRamCopyAsBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> Ogre::TextureGpu::_getSysRamCopyAsBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7046d90f92e6a950d6d803892ee4b09" name="af7046d90f92e6a950d6d803892ee4b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7046d90f92e6a950d6d803892ee4b09">&#9670;&#160;</a></span>_getSysRamCopyBytesPerImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::TextureGpu::_getSysRamCopyBytesPerImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note: Returns non-zero even if there is no system ram copy. </p>

</div>
</div>
<a id="a0e61075bcb144b7ae9567892d8d27bb9" name="a0e61075bcb144b7ae9567892d8d27bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e61075bcb144b7ae9567892d8d27bb9">&#9670;&#160;</a></span>_getSysRamCopyBytesPerRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::_getSysRamCopyBytesPerRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note: Returns non-zero even if there is no system ram copy. </p>

</div>
</div>
<a id="acaf00037ce85addebc2e305fedbc7005" name="acaf00037ce85addebc2e305fedbc7005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf00037ce85addebc2e305fedbc7005">&#9670;&#160;</a></span>_isDataReadyImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::_isDataReadyImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use. </p>
<p>Do not call directly.</p>
<p>This function is the same isDataReady except it ignores pending residency changes, which is important when <a class="el" href="class_ogre_1_1_texture_gpu_manager.html" title="This class manages all textures (i.e.">TextureGpuManager</a> needs to know this information but the <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> is transitioning (thus mPendingResidencyChanges is in an inconsistent state) </p>

<p>Implemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#a1d8606c66c03bb052fda7f742cc78cdc">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#ad057c332e4f98b0c9fdf81edb01a5509">Ogre::D3D11TextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#ab5287f7fb95c8048d78d379a2417ca0e">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#abd65e2ad95f3fd99ef79fba43b5516e5">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#acba91467a260804381e579a61752d8c0">Ogre::MetalTextureGpu</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#ac84d362daea8a84046365387f31b7f27">Ogre::MetalTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu.html#a8ebcd1f3ee06d74d1ace338015846ed2">Ogre::NULLTextureGpu</a>, <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#ab259f654d8ff7dabfa59236fc8684e43">Ogre::VulkanTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a1986cc6f015b1f711c67668ea71fe5c0">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a6c7ae9f0cba99bcb7bdb728a56e3298e" name="a6c7ae9f0cba99bcb7bdb728a56e3298e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7ae9f0cba99bcb7bdb728a56e3298e">&#9670;&#160;</a></span>_isManualTextureFlagPresent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::_isManualTextureFlagPresent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0df37fcb72b47849df985a18828f2e97" name="a0df37fcb72b47849df985a18828f2e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df37fcb72b47849df985a18828f2e97">&#9670;&#160;</a></span>_notifySysRamDownloadIsReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_notifySysRamDownloadIsReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *&#160;</td>
          <td class="paramname"><em>sysRamPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resyncOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not call directly. </p>
<p>Will change mResidencyStatus from <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> to <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a96b255b9535992cc830591ed916d15f3" title="Texture is on System RAM.">GpuResidency::OnSystemRam</a> </p>

</div>
</div>
<a id="a3cae191a32588efad29844e71bdf40be" name="a3cae191a32588efad29844e71bdf40be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cae191a32588efad29844e71bdf40be">&#9670;&#160;</a></span>_notifyTextureSlotChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::_notifyTextureSlotChanged </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *&#160;</td>
          <td class="paramname"><em>newPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#ae96e5b80b9361bbda705b212613b6b73">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#a8d3203695e1f72d058a5acda64fe93b0">Ogre::D3D11TextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#ad4e2c0b62b4fa141134f45cd427b4616">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#af642cc9ad8bbbc9b2069f423f84e4464">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#ae80103e0b1b7c95fabb57696ad997378">Ogre::GL3PlusTextureGpuHeadlessWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#a605425155972cddb10d2268ff8709b76">Ogre::MetalTextureGpu</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#a09a8eda4f4c6719a016ee132baac891d">Ogre::MetalTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a8ee5f1b49f32641e8dae03d6e2611334">Ogre::VulkanTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a75aa39f54c45fbe964d037005328b5b4">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a5b6c6c27cc45d2cf9bcf1f02bad2d28e" name="a5b6c6c27cc45d2cf9bcf1f02bad2d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6c6c27cc45d2cf9bcf1f02bad2d28e">&#9670;&#160;</a></span>_resetTextureManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_resetTextureManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeebb419ba824d0128f437bbe20cc81f9" name="aeebb419ba824d0128f437bbe20cc81f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebb419ba824d0128f437bbe20cc81f9">&#9670;&#160;</a></span>_resolveTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_resolveTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>resolveTexture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately resolves this texture to the resolveTexture argument. </p>
<p>Source must be MSAA texture, destination must be non-MSAA. </p><dl class="section remark"><dt>Remarks</dt><dd>This function may be slow on some APIs and should only be used when required, for example, to capture the screen from an explicit MSAA target and save it to disk only on user demand. If you need to call this often (like once per frame or more), then consider setting a Compositor with CompositorNode::mLocalRtvs::resolveTextureName set so that the compositor automatically resolves the texture every frame as efficiently as possible. </dd></dl>

</div>
</div>
<a id="a4c626ccabbd6c853ee1490358b9ca490" name="a4c626ccabbd6c853ee1490358b9ca490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c626ccabbd6c853ee1490358b9ca490">&#9670;&#160;</a></span>_setDepthBufferDefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::_setDepthBufferDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>depthBufferPoolId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preferDepthTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>desiredDepthBufferFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These 3 values are used as defaults for the compositor to use, but they may be explicitly overriden by a <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a>. </p>
<p>Particularly required when passing the textures between nodes as input and output (since only the <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> pointer is passed, and thus this information is lost) </p><dl class="section remark"><dt>Remarks</dt><dd>Changing these settings won't take immediate effect because they're only used when creating the compositor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthBufferPoolId</td><td>Sets the pool ID this RenderTarget should query from. Default value is POOL_DEFAULT. Set to POOL_NO_DEPTH to avoid using a <a class="el" href="struct_ogre_1_1_depth_buffer.html" title="An abstract class that contains a depth/stencil buffer.">DepthBuffer</a> (or manually controlling it) </td></tr>
    <tr><td class="paramname">preferDepthTexture</td><td>Whether this RT should be attached to a depth texture, or a regular depth buffer. On older GPUs, preferring depth textures may result in certain depth precisions to not be available (or use integer precision instead of floating point, etc). True to use depth textures. False otherwise (default). </td></tr>
    <tr><td class="paramname">desiredDepthBufferFormat</td><td><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will try to honour this request, but if it's not supported, you may get lower precision. All formats will try to fallback to PF_D24_UNORM_S8_UINT if not supported. Must be one of the following: PFG_D24_UNORM_S8_UINT PFG_D16_UNORM PFG_D32_FLOAT PFG_D32_FLOAT_X24_S8_UINT </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#a04565d61eb6c2dbeaf1857aaf0c4ccbc">Ogre::D3D11TextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a0b727294bf20b09915c0881245b969a6">Ogre::GL3PlusTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#a5dbae05b9e172a4f17eaa458e1225358">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_render_target.html#a4f1c07a6dcd73c66cfa47060fdbb807f">Ogre::NULLTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#a4eefcddbdfa7632e343f25cd4925e9e1">Ogre::VulkanTextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a7345e4a1d69f94657945067273376684" name="a7345e4a1d69f94657945067273376684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7345e4a1d69f94657945067273376684">&#9670;&#160;</a></span>_setNextLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::_setNextLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the layout the texture should be transitioned to after the next copy operation (once the copy encoder gets closed) </p>
<p>This is specific to Vulkan &amp; D3D12 </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#aaa7d94c1cfce7146ea8e4e14b0288ce1">Ogre::VulkanTextureGpu</a>.</p>

</div>
</div>
<a id="a4044404f7783aea108e986336caaedf6" name="a4044404f7783aea108e986336caaedf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4044404f7783aea108e986336caaedf6">&#9670;&#160;</a></span>_setSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_setSampleDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>validatedSampleDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For internal use. </p>

</div>
</div>
<a id="ae641939cec4a57193dab3fc88921b7ae" name="ae641939cec4a57193dab3fc88921b7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae641939cec4a57193dab3fc88921b7ae">&#9670;&#160;</a></span>_setSourceType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_setSourceType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5e3c937c79ca63bd2994af5532c547d" name="ab5e3c937c79ca63bd2994af5532c547d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e3c937c79ca63bd2994af5532c547d">&#9670;&#160;</a></span>_setToDisplayDummyTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::_setToDisplayDummyTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#acb9f9661df0453a7cdd7c0a7f76ea3dc">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#a3b489d9e7d548a012832d780e53ab948">Ogre::D3D11TextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#afab65e298cae80ed4cbce381705ca9a3">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#a79931fb2c5669a051a0cb3c4102c6cd5">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#a4ae97d53c107d147f88ac934ecf9122d">Ogre::MetalTextureGpu</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#ab68f95a504c959af20160eeece1116a2">Ogre::MetalTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu.html#a5c7132cea192a603e84d69190e3c0ec4">Ogre::NULLTextureGpu</a>, <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a48d98bc808dd629f7a84ca69060e69f3">Ogre::VulkanTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a71322586f2d15b4f0be508b921fd5263">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a40511da73ca4dc4bd8a3e8fc42c44147" name="a40511da73ca4dc4bd8a3e8fc42c44147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40511da73ca4dc4bd8a3e8fc42c44147">&#9670;&#160;</a></span>_syncGpuResidentToSystemRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_syncGpuResidentToSystemRam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces downloading data from GPU to CPU, usually because the data on GPU changed and we're in strategy AlwaysKeepSystemRamCopy. </p>
<p>May stall. </p>

</div>
</div>
<a id="a85f9670da9031ec138caf8b3e910b37e" name="a85f9670da9031ec138caf8b3e910b37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f9670da9031ec138caf8b3e910b37e">&#9670;&#160;</a></span>_transitionTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_transitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>newResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *&#160;</td>
          <td class="paramname"><em>sysRamCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteSysRamCopy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function may be called manually (if user is manually managing a texture) or automatically (e.g. </p>
<p>loading from file, or automatic batching is enabled) Once you call this function, you're no longer in OnStorage mode; and will transition to either OnSystemRam or Resident depending on whether auto batching is enabled. </p><dl class="section remark"><dt>Remarks</dt><dd>Do NOT call this function yourself if you've created this function with AutomaticBatching as <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will call this, from a worker thread!</dd></dl>
<p>Make sure you're done using mSysRamCopy before calling this function, as we may free that pointer (unless autoDeleteSysRamCopyOnResident = false).</p>
<p>If you're calling _transitionTo yourself (i.e. you're not using scheduleTransitionTo) then you'll need to call _setNextResidencyStatus too, so that both getResidencyStatus and getNextResidencyStatus agree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysRamCopy</td><td>System RAM copy that backs this GPU data. May be null. Must've been allocated with <a class="el" href="_ogre_memory_allocator_config_8h.html#afd7ddaef10ac9ea1ffbd18902167b9a2" title="Allocate a block of raw memory aligned to SIMD boundaries, and indicate the category of usage.">OGRE_MALLOC_SIMD( size, MEMCATEGORY_RESOURCE )</a>; We will deallocate it. MUST respect _getSysRamCopyBytesPerRow &amp; _getSysRamCopyBytesPerImage. If in doubt, use <a class="el" href="class_ogre_1_1_pixel_format_gpu_utils.html#aee2ade90d769c187b8192e0a234c5f17">PixelFormatGpuUtils::getSizeBytes</a> with rowAlignment = 4u;</td></tr>
  </table>
  </dd>
</dl>
<p>This param must be nullptr or equal to get_getSysRamCopy when going from Resident to OnSystemRam and strategy is not AlwaysKeepSystemRamCopy; as we will async download the content from the GPU. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoDeleteSysRamCopy</td><td>When true, we free mSysRamCopy as we should. When false, caller is responsible for deleting this pointer else it will leak! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6dd0d57c28fe017e8a83877bea0c5f" name="a1b6dd0d57c28fe017e8a83877bea0c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6dd0d57c28fe017e8a83877bea0c5f">&#9670;&#160;</a></span>addListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::addListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a297cc2e34e6803ffe25614d36ae4da36" name="a297cc2e34e6803ffe25614d36ae4da36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297cc2e34e6803ffe25614d36ae4da36">&#9670;&#160;</a></span>allowsAutoMipmaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::allowsAutoMipmaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50b8aace07a416886cc0f871b32f078c" name="a50b8aace07a416886cc0f871b32f078c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b8aace07a416886cc0f871b32f078c">&#9670;&#160;</a></span>copyContentsToMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::copyContentsToMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>dstFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automaticResolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the current contents of the render target to the memory. </p>

</div>
</div>
<a id="a1a1403e76b6775c08d2cb7b0c7d1398d" name="a1a1403e76b6775c08d2cb7b0c7d1398d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1403e76b6775c08d2cb7b0c7d1398d">&#9670;&#160;</a></span>copyParametersFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::copyParametersFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18f60db95a5d6b1681b34aae96d98c4c" name="a18f60db95a5d6b1681b34aae96d98c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f60db95a5d6b1681b34aae96d98c4c">&#9670;&#160;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>dstMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>srcMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepResolvedTexSynced</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a>&#160;</td>
          <td class="paramname"><em>srcTransitionMode</em> = <code><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a>&#160;</td>
          <td class="paramname"><em>dstTransitionMode</em> = <code><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td></td></tr>
    <tr><td class="paramname">dstBox</td><td></td></tr>
    <tr><td class="paramname">dstMipLevel</td><td></td></tr>
    <tr><td class="paramname">srcBox</td><td></td></tr>
    <tr><td class="paramname">srcMipLevel</td><td></td></tr>
    <tr><td class="paramname">keepResolvedTexSynced</td><td>When true, if dst is an MSAA texture and is implicitly resolved (i.e. dst-&gt;<a class="el" href="class_ogre_1_1_texture_gpu.html#af61d6984f85ded6bbdd1678b08e92b52">hasMsaaExplicitResolves()</a> == false); the resolved texture is also kept up to date.</td></tr>
  </table>
  </dd>
</dl>
<p>Typically the reason to set this to false is if you plane on rendering more stuff to dst texture and then resolve. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcTransitionMode</td><td>Transition mode for 'this' </td></tr>
    <tr><td class="paramname">dstTransitionMode</td><td>Transition mode for 'dst' </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#aeffebac258a366b31c8d6d3d7cdc1133">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a47fcfbc078f98bca3f67a18e25915aa7">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#a40858750cad8b9aa96c5df490e75894a">Ogre::MetalTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#ad407300f4d9fa77e84e3d7e794b1cb65">Ogre::VulkanTextureGpu</a>.</p>

</div>
</div>
<a id="adb161795caec263b077532c05070dbe4" name="adb161795caec263b077532c05070dbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb161795caec263b077532c05070dbe4">&#9670;&#160;</a></span>getCurrentLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> Ogre::TextureGpu::getCurrentLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a7c53c1676cb0e183dddc2eb960a31972">Ogre::VulkanTextureGpu</a>.</p>

</div>
</div>
<a id="aaecbe86d69c49a223a92070acbd309fc" name="aaecbe86d69c49a223a92070acbd309fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecbe86d69c49a223a92070acbd309fc">&#9670;&#160;</a></span>getCustomAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::getCustomAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#ad6da7cf42f502a578bee7b956e540a03">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#ad7620496c3160b2081cca1f2f0796a5e">Ogre::D3D11TextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a485c7eb86b2e2c548fb36e1e11da9f3c">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#a6520715e7efad777c11a301d3b4c655c">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#a7d63d6c22d05291fad5491241a441049">Ogre::GL3PlusTextureGpuHeadlessWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#afdb9b936912f1f2e46dea8735619ea14">Ogre::MetalTextureGpu</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#ab0f830cbb6f297de8787358ae63a5b0f">Ogre::MetalTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#add4e14537b7528da5ec84335b5894d58">Ogre::VulkanTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a511c5f000d792c54f0a8b96b910f0f43">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a472f6a92131325af1a8f5ba2b78b86eb" name="a472f6a92131325af1a8f5ba2b78b86eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472f6a92131325af1a8f5ba2b78b86eb">&#9670;&#160;</a></span>getDefaultLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> Ogre::TextureGpu::getDefaultLayout </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoreDiscardableFlag</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20508c2ba704e46e84453bc62aea85a0" name="a20508c2ba704e46e84453bc62aea85a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20508c2ba704e46e84453bc62aea85a0">&#9670;&#160;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For TypeCube &amp; TypeCubeArray, this value returns 1. </p>

</div>
</div>
<a id="a62ecd2c52d97dd2b62a2e4b52a5cb548" name="a62ecd2c52d97dd2b62a2e4b52a5cb548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ecd2c52d97dd2b62a2e4b52a5cb548">&#9670;&#160;</a></span>getDepthBufferPoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::TextureGpu::getDepthBufferPoolId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#aa75ec1b2198c5765990bf501c8dbc88d">Ogre::D3D11TextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#aee044a098323f24fd2665821c8f2444a">Ogre::GL3PlusTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#a0fac7e584352a5c5390a6d18de9a74f6">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_render_target.html#a45d1fd9ffea81211a233dc22657fb236">Ogre::NULLTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#a2be43a8a72517dde2ec020801d453c9d">Ogre::VulkanTextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a479448e4772db382f106470a94fafa13" name="a479448e4772db382f106470a94fafa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479448e4772db382f106470a94fafa13">&#9670;&#160;</a></span>getDepthOrSlices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getDepthOrSlices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e9b67097af3ad1a470065fc9dce032d" name="a5e9b67097af3ad1a470065fc9dce032d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9b67097af3ad1a470065fc9dce032d">&#9670;&#160;</a></span>getDesiredDepthBufferFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::TextureGpu::getDesiredDepthBufferFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#a44c280317e2706a3ed8d46cc659aebf6">Ogre::D3D11TextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a95f0dbea763d7f7bad996dfb6c4df684">Ogre::GL3PlusTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#ae34c7570197b55b83e7c8aa3926b7fef">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_render_target.html#ada36da188b487be1a026edd938173341">Ogre::NULLTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#ab5e7074642b3a0d39fb73e3cb39ad716">Ogre::VulkanTextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a714b2b71f5443736c7c0ac2a97753c02" name="a714b2b71f5443736c7c0ac2a97753c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714b2b71f5443736c7c0ac2a97753c02">&#9670;&#160;</a></span>getEmptyBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> Ogre::TextureGpu::getEmptyBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a8a88cae92d0f92e0b1b909e89ee418" name="a0a8a88cae92d0f92e0b1b909e89ee418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8a88cae92d0f92e0b1b909e89ee418">&#9670;&#160;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a721a122155347df2d22d18041dd5ace8" name="a721a122155347df2d22d18041dd5ace8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721a122155347df2d22d18041dd5ace8">&#9670;&#160;</a></span>getInternalHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getInternalHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real API height accounting for <a class="el" href="class_ogre_1_1_texture_gpu.html#a8993f62ca86dc5f0e92b1943b247889b">TextureGpu::getOrientationMode</a>. See getInternalWidth. </p>

</div>
</div>
<a id="acce184c672016ba3c13781c772a6e406" name="acce184c672016ba3c13781c772a6e406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce184c672016ba3c13781c772a6e406">&#9670;&#160;</a></span>getInternalSliceStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::TextureGpu::getInternalSliceStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adae831c8c3a0760106f62a502b7fb21a" name="adae831c8c3a0760106f62a502b7fb21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae831c8c3a0760106f62a502b7fb21a">&#9670;&#160;</a></span>getInternalTextureType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> Ogre::TextureGpu::getInternalTextureType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe66c8fd9f7402c90fcf7729f2a67c44" name="abe66c8fd9f7402c90fcf7729f2a67c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe66c8fd9f7402c90fcf7729f2a67c44">&#9670;&#160;</a></span>getInternalWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getInternalWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real API width accounting for <a class="el" href="class_ogre_1_1_texture_gpu.html#a8993f62ca86dc5f0e92b1943b247889b">TextureGpu::getOrientationMode</a> If orientation mode is 90° or 270° then getInternalWidth returns the height and getInternalHeight returns the width. </p>

</div>
</div>
<a id="a05adaec1366a16ccb1fa2816d3fe5747" name="a05adaec1366a16ccb1fa2816d3fe5747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05adaec1366a16ccb1fa2816d3fe5747">&#9670;&#160;</a></span>getListeners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> * &gt;::type &amp; Ogre::TextureGpu::getListeners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb2b359561c96f9f60c3e2db8c7008fb" name="afb2b359561c96f9f60c3e2db8c7008fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2b359561c96f9f60c3e2db8c7008fb">&#9670;&#160;</a></span>getNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getNameStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note: This returns the alias name of the texture. </p>
<p>See <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a24f8cd49c0990fb532306a1569b58f33">TextureGpuManager::createOrRetrieveTexture</a> </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_gpu_resource.html#a006af8969409dd6a58306b4d44ecf677">Ogre::GpuResource</a>.</p>

</div>
</div>
<a id="a2f193236caf39fcaa5f90ae613f355a0" name="a2f193236caf39fcaa5f90ae613f355a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f193236caf39fcaa5f90ae613f355a0">&#9670;&#160;</a></span>getNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::TextureGpu::getNumMipmaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a494d1ec99e6e6589c4059125a1d10966" name="a494d1ec99e6e6589c4059125a1d10966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494d1ec99e6e6589c4059125a1d10966">&#9670;&#160;</a></span>getNumSlices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getNumSlices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For TypeCube this value returns 6. </p>
<p>For TypeCubeArray, value returns numSlices * 6u. </p>

</div>
</div>
<a id="a8993f62ca86dc5f0e92b1943b247889b" name="a8993f62ca86dc5f0e92b1943b247889b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8993f62ca86dc5f0e92b1943b247889b">&#9670;&#160;</a></span>getOrientationMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a> Ogre::TextureGpu::getOrientationMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#a8a47773203bb61e8ec5ef93aeb71ccf0">Ogre::D3D11TextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#ac30869ee407dac9f592cb12918b21094">Ogre::GL3PlusTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#aaaa5da805dc3a142f17652e62b0b8a00">Ogre::MetalTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#a8d527e6b34956a5833f94f78370333f9">Ogre::VulkanTextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="ad72ce773bbfd3c330fa3fbd5df40a649" name="ad72ce773bbfd3c330fa3fbd5df40a649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72ce773bbfd3c330fa3fbd5df40a649">&#9670;&#160;</a></span>getPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::TextureGpu::getPixelFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc3f5bbd523cb6e1c1a678a22d034baf" name="abc3f5bbd523cb6e1c1a678a22d034baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3f5bbd523cb6e1c1a678a22d034baf">&#9670;&#160;</a></span>getPreferDepthTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::getPreferDepthTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#a610bf0b137f4bdc2fdb6a400ee7cb03b">Ogre::D3D11TextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a52538718c94a881bf30a264d5fc6957f">Ogre::GL3PlusTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#a69a4b007459b9aad517f359c4e492b54">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_render_target.html#ad05f97271a6b1069b9c441141d238a49">Ogre::NULLTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#a7156e2ad73606ee6184bd7edab695070">Ogre::VulkanTextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a88776112af1b31c69566c2d1b6217d64" name="a88776112af1b31c69566c2d1b6217d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88776112af1b31c69566c2d1b6217d64">&#9670;&#160;</a></span>getRealResourceNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getRealResourceNameStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the real name (e.g. disk in file) of the resource. </p>

</div>
</div>
<a id="a975e937d93d9c0d961ba658dd901fdac" name="a975e937d93d9c0d961ba658dd901fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975e937d93d9c0d961ba658dd901fdac">&#9670;&#160;</a></span>getRequestedSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> Ogre::TextureGpu::getRequestedSampleDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns original requested sample description, i.e. the raw input to setSampleDescription. </p>

</div>
</div>
<a id="ad65fb98f0b6a575bf54c72bce4491b20" name="ad65fb98f0b6a575bf54c72bce4491b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65fb98f0b6a575bf54c72bce4491b20">&#9670;&#160;</a></span>getResourceGroupStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getResourceGroupStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ddc319ba3c8969c033d6549d933795b" name="a8ddc319ba3c8969c033d6549d933795b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddc319ba3c8969c033d6549d933795b">&#9670;&#160;</a></span>getSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> Ogre::TextureGpu::getSampleDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns effective sample description supported by the API. </p>
<p>Note it's only useful after having transitioned to resident. </p>

</div>
</div>
<a id="a1f26820d396ef6b0384126f432d38dba" name="a1f26820d396ef6b0384126f432d38dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f26820d396ef6b0384126f432d38dba">&#9670;&#160;</a></span>getSettingsDesc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getSettingsDesc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b6ca873871e56f34e4abbb4faf33315" name="a9b6ca873871e56f34e4abbb4faf33315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6ca873871e56f34e4abbb4faf33315">&#9670;&#160;</a></span>getSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::TextureGpu::getSizeBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns total size in bytes used in GPU by this texture (not by its pool) including mipmaps. </p>

</div>
</div>
<a id="a414988b01605099f449d5f452c50ca08" name="a414988b01605099f449d5f452c50ca08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414988b01605099f449d5f452c50ca08">&#9670;&#160;</a></span>getSourceType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::TextureGpu::getSourceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This setting is for where the texture is created, e.g. </p>
<p>its a compositor texture, a shadow texture or standard texture loaded for a mesh etc...</p>
<p>This value is merely for statistical tracking purposes </p>

</div>
</div>
<a id="a1a458af605a3aa67117fe267ac453c17" name="a1a458af605a3aa67117fe267ac453c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a458af605a3aa67117fe267ac453c17">&#9670;&#160;</a></span>getSubsampleLocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::getSubsampleLocations </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_ogre_1_1_vector2.html">Vector2</a> &gt;::type&#160;</td>
          <td class="paramname"><em>locations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the MSAA subsample locations. </p>
<p>mSampleDescription.pattern must not be <a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0fae9213e03f8cab27c1f90e1981b2ab623" title="Let the GPU decide.">MsaaPatterns::Undefined</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locations</td><td>Outputs an array with the locations for each subsample. Values are in range [-1; 1] </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#abd1ba9f9d2fdce26c44cab7cbbf1cee3">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#a095d9cdefe8cdc08dd8f6f2c4a18efeb">Ogre::D3D11TextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a89df38a73a5e6a1779e36cc60dfcddd4">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#ad0c279c77eb8b58119066f236ece32cc">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#a02856a836684f939ed41d8a2d44e6961">Ogre::MetalTextureGpu</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu.html#a3928f46b7b57d0eba4973442c26a9d09">Ogre::NULLTextureGpu</a>, <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a53843c62451d20ca4491d5b496471d09">Ogre::VulkanTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#ad60eccc877bf7cfaa651e4f48a7f43d0">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="af2a00d4b20fcb8ec0c03f5f905577839" name="af2a00d4b20fcb8ec0c03f5f905577839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a00d4b20fcb8ec0c03f5f905577839">&#9670;&#160;</a></span>getTextureManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> * Ogre::TextureGpu::getTextureManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf93ab56a0c0006c4ba0de53acf01876" name="abf93ab56a0c0006c4ba0de53acf01876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf93ab56a0c0006c4ba0de53acf01876">&#9670;&#160;</a></span>getTexturePool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> * Ogre::TextureGpu::getTexturePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad10f8ad89aa3d058e879b8a7280b8c5" name="aad10f8ad89aa3d058e879b8a7280b8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad10f8ad89aa3d058e879b8a7280b8c5">&#9670;&#160;</a></span>getTexturePoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getTexturePoolId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b75fd64ef4af817e1ce1e881132b78d" name="a4b75fd64ef4af817e1ce1e881132b78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b75fd64ef4af817e1ce1e881132b78d">&#9670;&#160;</a></span>getTextureType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> Ogre::TextureGpu::getTextureType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add1ea0e81537e4b98ad11f6cc06f14cd" name="add1ea0e81537e4b98ad11f6cc06f14cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1ea0e81537e4b98ad11f6cc06f14cd">&#9670;&#160;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cdd906e6f2bc6ec0a23c2b8c5d1b343" name="a3cdd906e6f2bc6ec0a23c2b8c5d1b343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd906e6f2bc6ec0a23c2b8c5d1b343">&#9670;&#160;</a></span>hasAutomaticBatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasAutomaticBatching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15e9e1aa38bfc4c638d4dc50c0f60518" name="a15e9e1aa38bfc4c638d4dc50c0f60518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e9e1aa38bfc4c638d4dc50c0f60518">&#9670;&#160;</a></span>hasAutoMipmapAuto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasAutoMipmapAuto </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af943f8d1fd87f457fb4633058d696470" name="af943f8d1fd87f457fb4633058d696470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af943f8d1fd87f457fb4633058d696470">&#9670;&#160;</a></span>hasEquivalentParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasEquivalentParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af61d6984f85ded6bbdd1678b08e92b52" name="af61d6984f85ded6bbdd1678b08e92b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61d6984f85ded6bbdd1678b08e92b52">&#9670;&#160;</a></span>hasMsaaExplicitResolves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasMsaaExplicitResolves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3771accff5d16846747c8ea99756bd8a" name="a3771accff5d16846747c8ea99756bd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3771accff5d16846747c8ea99756bd8a">&#9670;&#160;</a></span>isDataReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isDataReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if this texture is fully ready to be used for displaying. </p>
<p>IMPORTANT: Always returns true if getResidencyStatus != <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> and there are no pending residency transitions.</p>
<p>Returns false while there are pending residency status</p>
<p>If this is true, then isMetadataReady is also true. See isMetadataReady. </p>

</div>
</div>
<a id="ad9203b7f0a8ae0f862fcd5d17f11d7ed" name="ad9203b7f0a8ae0f862fcd5d17f11d7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9203b7f0a8ae0f862fcd5d17f11d7ed">&#9670;&#160;</a></span>isDiscardableContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isDiscardableContent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8915b3073eaf7d90db8d44def65c8749" name="a8915b3073eaf7d90db8d44def65c8749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8915b3073eaf7d90db8d44def65c8749">&#9670;&#160;</a></span>isManualTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isManualTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9212250fb5225d8f37b6554e11a7ed39" name="a9212250fb5225d8f37b6554e11a7ed39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9212250fb5225d8f37b6554e11a7ed39">&#9670;&#160;</a></span>isMetadataReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isMetadataReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is threadsafe to call this function from main thread. </p>
<p>If this returns false, then the following functions are not threadsafe: Setters must not be called, and getters may change from a worker thread:</p><ul>
<li>setResolution</li>
<li>getWidth, getHeight, getDepth, getDepthOrSlices, getNumSlices</li>
<li>set/getPixelFormat</li>
<li>set/getNumMipmaps</li>
<li>set/getTextureType</li>
<li>getTexturePool Note that this function may return true but the worker thread may still be uploading to this texture. Use isDataReady to see if the worker thread is fully done with this texture.</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>Function for querying/waiting for data and metadata to be ready are for blocking the main thread when a worker thread is loading the texture from file or a listener (i.e. isManualTexture returns false) otherwise you don't need to call these functions. </dd></dl>

</div>
</div>
<a id="a4ebc3bec47d599f4d0f7a9cde67bd4d3" name="a4ebc3bec47d599f4d0f7a9cde67bd4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebc3bec47d599f4d0f7a9cde67bd4d3">&#9670;&#160;</a></span>isMsaaPatternSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::isMsaaPatternSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0f">MsaaPatterns::MsaaPatterns</a>&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#af5bbe50ad92ad2a29b0c23d454d9ec81">Ogre::D3D11TextureGpu</a>.</p>

</div>
</div>
<a id="ad5484c1525a406ce02774a0d26f7ac41" name="ad5484c1525a406ce02774a0d26f7ac41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5484c1525a406ce02774a0d26f7ac41">&#9670;&#160;</a></span>isMultisample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isMultisample </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2efdb62aa1600025965301318308a55" name="aa2efdb62aa1600025965301318308a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2efdb62aa1600025965301318308a55">&#9670;&#160;</a></span>isOpenGLRenderWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::isOpenGLRenderWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OpenGL RenderWindows are a bit specific: </p>
<ul>
<li>Their origins are upside down. Which means we need to flip Y.</li>
<li>They can access resolved contents of MSAA even if hasMsaaExplicitResolves = true</li>
<li>Headless windows return false since internally they're FBOs. However isRenderWindowSpecific will return true </li>
</ul>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#a915309dc7083ecf9441276c86c2467ea">Ogre::GL3PlusTextureGpuWindow</a>, and <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#ae0c1e1ae91679dbbfea2563316cb8bdf">Ogre::GL3PlusTextureGpuHeadlessWindow</a>.</p>

</div>
</div>
<a id="aaeee1147f96cbc850aafbe11b4842258" name="aaeee1147f96cbc850aafbe11b4842258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeee1147f96cbc850aafbe11b4842258">&#9670;&#160;</a></span>isPoolOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isPoolOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad046ba9fe6192934b95b513239949044" name="ad046ba9fe6192934b95b513239949044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad046ba9fe6192934b95b513239949044">&#9670;&#160;</a></span>isReinterpretable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isReinterpretable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a1996625da438d07e34c2abca24a9f0" name="a1a1996625da438d07e34c2abca24a9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1996625da438d07e34c2abca24a9f0">&#9670;&#160;</a></span>isRenderToTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isRenderToTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadda46635a310a0b5a24b7bf93cfee19" name="aadda46635a310a0b5a24b7bf93cfee19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadda46635a310a0b5a24b7bf93cfee19">&#9670;&#160;</a></span>isRenderWindowSpecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isRenderWindowSpecific </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b7d52501e9da7655079f9c4d6f1c037" name="a4b7d52501e9da7655079f9c4d6f1c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7d52501e9da7655079f9c4d6f1c037">&#9670;&#160;</a></span>isTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdcab7d39a3d28af67cccee42f37c73f" name="abdcab7d39a3d28af67cccee42f37c73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcab7d39a3d28af67cccee42f37c73f">&#9670;&#160;</a></span>isTextureGpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isTextureGpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="struct_ogre_1_1_gpu_tracked_resource.html#ab24625894d83ec3f90972a350f27e60a">Ogre::GpuTrackedResource</a>.</p>

</div>
</div>
<a id="afb1abe749069021e4e83cdaa7668b3bc" name="afb1abe749069021e4e83cdaa7668b3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1abe749069021e4e83cdaa7668b3bc">&#9670;&#160;</a></span>isUav()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isUav </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52acdc930dff7ae7f455256822d9520d" name="a52acdc930dff7ae7f455256822d9520d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52acdc930dff7ae7f455256822d9520d">&#9670;&#160;</a></span>notifyAllListenersTextureChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::notifyAllListenersTextureChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extraData</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73d480691663c93439835ff7d11f7739" name="a73d480691663c93439835ff7d11f7739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d480691663c93439835ff7d11f7739">&#9670;&#160;</a></span>notifyDataIsReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::notifyDataIsReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies it is safe to use the real data. Everything has been uploaded. </p>

<p>Implemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#a85013161baaddb5bb6ccc8b02cbe7dbc">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#adc8b19ac20ceb1e984c06469aedda836">Ogre::D3D11TextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#ae8534775772b7508ceab69b49882c124">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#a70269ac9361d8f98a505cbc29c295e4b">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#ad02c3ee1e96b722c946075daea769437">Ogre::MetalTextureGpu</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#a38ded244641479dddf01370f1de4c9a7">Ogre::MetalTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu.html#ab8c5712b8a5b7f6b089eb2237bc4fac7">Ogre::NULLTextureGpu</a>, <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a9c6d57f7fadd84c0a5e29d952f1c1478">Ogre::VulkanTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a73d1e2dd9cc9bffa9338d038abc7248c">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="adc4d050aca586041f3e6586fdfc6bd5e" name="adc4d050aca586041f3e6586fdfc6bd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4d050aca586041f3e6586fdfc6bd5e">&#9670;&#160;</a></span>prefersLoadingFromFileAsSRGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::prefersLoadingFromFileAsSRGB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3e0ad601752b91f2851c88f9ed49869" name="ae3e0ad601752b91f2851c88f9ed49869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e0ad601752b91f2851c88f9ed49869">&#9670;&#160;</a></span>removeListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::removeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac090ad8bd36b3bc9c4370444f04e943d" name="ac090ad8bd36b3bc9c4370444f04e943d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac090ad8bd36b3bc9c4370444f04e943d">&#9670;&#160;</a></span>requiresTextureFlipping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::requiresTextureFlipping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cfbfac96361e544a0298a223250b028" name="a3cfbfac96361e544a0298a223250b028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfbfac96361e544a0298a223250b028">&#9670;&#160;</a></span>scheduleReupload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::scheduleReupload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSkipMultiload</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>There are times where you want to reload a texture again (e.g. </p>
<p>file on disk changed, uploading a new <a class="el" href="class_ogre_1_1_image2.html" title="Class representing an image file.">Image2</a>, etc) without visual disruption.</p>
<p>e.g. if you were to call: </p><div class="fragment"><div class="line">tex-&gt;scheduleTransitionTo( <a class="code hl_enumvalue" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98ad60acc99d4bcd4898f280cbf6d8ef1dc">GpuResidency::OnStorage</a> );</div>
<div class="line">tex-&gt;scheduleTransitionTo( <a class="code hl_enumvalue" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">GpuResidency::Resident</a>, ... );</div>
<div class="ttc" id="anamespace_ogre_1_1_gpu_residency_html_a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2"><div class="ttname"><a href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">Ogre::GpuResidency::Resident</a></div><div class="ttdeci">@ Resident</div><div class="ttdoc">VRAM and other GPU resources have been allocated for this resource.</div><div class="ttdef"><b>Definition</b> OgreGpuResource.h:66</div></div>
<div class="ttc" id="anamespace_ogre_1_1_gpu_residency_html_a2dee9b512fd45f8d010e8e18e25ebd98ad60acc99d4bcd4898f280cbf6d8ef1dc"><div class="ttname"><a href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98ad60acc99d4bcd4898f280cbf6d8ef1dc">Ogre::GpuResidency::OnStorage</a></div><div class="ttdeci">@ OnStorage</div><div class="ttdoc">Texture is on storage (i.e.</div><div class="ttdef"><b>Definition</b> OgreGpuResource.h:49</div></div>
</div><!-- fragment --><p>you'll achieve the same result, however the texture becomes immediately unavailable causing a few frames were all the user sees is a blank texture until it is fully reloaded.</p>
<p>This routine allows for an in-place hot-reload, where the old texture is swapped for the new one once it's done loading.</p>
<p>This is also faster because DescriptorTextureSets don't change</p>
<dl class="section remark"><dt>Remarks</dt><dd><ol type="1">
<li>Assumes the last queued transition to perform is into Resident or OnSystemRam</li>
<li><a class="el" href="class_visual.html">Visual</a> hitches are unavoidable if metadata changes (e.g. new texture is of different pixel format, different number of mipmaps, resolution, etc) If that's the case, it is faster to transition to OnStorage, remove the metadata entry from cache, then to Resident again</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>See <a class="el" href="class_ogre_1_1_texture_gpu.html#a3aee068205a09b2d3aa61d021c8a62a8" title="Schedules an async transition in residency.">TextureGpu::unsafeScheduleTransitionTo</a> </td></tr>
    <tr><td class="paramname">autoDeleteImage</td><td>Same <a class="el" href="class_ogre_1_1_texture_gpu.html#a3aee068205a09b2d3aa61d021c8a62a8" title="Schedules an async transition in residency.">TextureGpu::unsafeScheduleTransitionTo</a> </td></tr>
    <tr><td class="paramname">bSkipMultiload</td><td>Same <a class="el" href="class_ogre_1_1_texture_gpu.html#a3aee068205a09b2d3aa61d021c8a62a8" title="Schedules an async transition in residency.">TextureGpu::unsafeScheduleTransitionTo</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32e5eb68dc3ba4521042fa82656a8a53" name="a32e5eb68dc3ba4521042fa82656a8a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e5eb68dc3ba4521042fa82656a8a53">&#9670;&#160;</a></span>scheduleTransitionTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::scheduleTransitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>nextResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSkipMultiload</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as unsafeScheduleTransitionTo, but first checks if we're already in the residency state we want to go to, or if it has already been scheduled; thus it can be called multiple times. </p>

</div>
</div>
<a id="a6ae40391d39c8feae00acaf25839c6f9" name="a6ae40391d39c8feae00acaf25839c6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae40391d39c8feae00acaf25839c6f9">&#9670;&#160;</a></span>setNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setNumMipmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3866a77dfd74f1b70fdd31f42382c544" name="a3866a77dfd74f1b70fdd31f42382c544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3866a77dfd74f1b70fdd31f42382c544">&#9670;&#160;</a></span>setOrientationMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::setOrientationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a>&#160;</td>
          <td class="paramname"><em>orientationMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given orientation. </p>
<p>'this' must be a RenderTexture If <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> wasn't build with OGRE_CONFIG_ENABLE_VIEWPORT_ORIENTATIONMODE, calls to this function will not stick (i.e. getOrientationMode always returns the same value)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_gpu.html#a8ec57ce0ef0c682416c3a6b6d13a095a" title="PUBLIC VARIABLE.">TextureGpu::msDefaultOrientationMode</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_texture_gpu.html#abe66c8fd9f7402c90fcf7729f2a67c44" title="Real API width accounting for TextureGpu::getOrientationMode If orientation mode is 90° or 270° then ...">TextureGpu::getInternalWidth</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_texture_gpu.html#a721a122155347df2d22d18041dd5ace8" title="Real API height accounting for TextureGpu::getOrientationMode. See getInternalWidth.">TextureGpu::getInternalHeight</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Must be OnStorage.</dd></dl>
<p>If OrientationMode == OR_DEGREE_90 or OR_DEGREE_270, the internal resolution if flipped. i.e. swap( width, height ). This is important if you need to perform copyTo operations or AsyncTextureTickets</p>
<p>This setting has only been tested with Vulkan and is likely to malfunction with the other APIs if set to anything other than OR_DEGREE_0 </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#ab2edff152ce3501f2082dc6e142a7ac9">Ogre::D3D11TextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a3cf435fa781ad0d51750b0a275fd6322">Ogre::GL3PlusTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#a47545f0bf1a5526d4bd16ad32227e8b3">Ogre::MetalTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#a264b5a1d3408e7f3721b515c79af50d1">Ogre::VulkanTextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a54dfe2523d8e5647e79caaf28c296d4e" name="a54dfe2523d8e5647e79caaf28c296d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dfe2523d8e5647e79caaf28c296d4e">&#9670;&#160;</a></span>setPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setPixelFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pixel format. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="class_ogre_1_1_texture_gpu.html#adc4d050aca586041f3e6586fdfc6bd5e">prefersLoadingFromFileAsSRGB()</a> returns true, the format may not be fully honoured (as we'll use the equivalent _SRGB variation). </dd></dl>

</div>
</div>
<a id="af79e22c90559d13385d75dc19970806d" name="af79e22c90559d13385d75dc19970806d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79e22c90559d13385d75dc19970806d">&#9670;&#160;</a></span>setResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2ee4d088c32b3e9efeb4d2fec5cad3e" name="aa2ee4d088c32b3e9efeb4d2fec5cad3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ee4d088c32b3e9efeb4d2fec5cad3e">&#9670;&#160;</a></span>setSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setSampleDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78bd23c2116dc08afcaa8dc1b8d2384e" name="a78bd23c2116dc08afcaa8dc1b8d2384e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bd23c2116dc08afcaa8dc1b8d2384e">&#9670;&#160;</a></span>setTexturePoolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setTexturePoolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2D Texture with automatic batching will be merged with other textures into the same pool as one big 2D Array texture behind the scenes. </p>
<p>For two textures to be placed in the same pool (assuming it's not full) the following must match: Width, Height, PixelFormat, number of mipmaps, poolID</p>
<p><a class="el" href="class_ogre_1_1_pool.html" title="Template class describing a simple pool of items.">Pool</a> ID is an arbitrary value with no actual meaning. This is ID allows you to prevent certain textures from being group together. For example, you may want all textures from Level 0 to be grouped together while Level 1 gets grouped together in a different pool</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434a2f298fbaec7db976ba6616430b1f52a3" title="When not present: The Texture is exactly the type requested (e.g.">TextureFlags::AutomaticBatching</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a6e96132817c27bfae1c0374e98d20dfc" title="Reserves and preallocates a pool with the given parameters Returns the master texture that owns the p...">TextureGpuManager::reservePoolId</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value cannot be changed while the texture is resident (i.e. because it has already been assigned to a pool) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolId</td><td>Arbitrary value. Default value is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeadb4961ae1af0313cbd253bd32285dd" name="aeadb4961ae1af0313cbd253bd32285dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadb4961ae1af0313cbd253bd32285dd">&#9670;&#160;</a></span>setTextureType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::setTextureType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#a24b373ba6dfecf8c9349713a8d932af8">Ogre::D3D11TextureGpu</a>, <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#a6fcddce7295a390f84680fc0af7038e0">Ogre::D3D11TextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a67bb0bccd2a8c7f1fa2ae40e8a8e1ee9">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#af195a4ad4c610d4dc3df017de82a10c6">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#ab65260834ce0f59c520a83f0e189a5a7">Ogre::GL3PlusTextureGpuHeadlessWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu.html#a1020dd22550cc267d19f61d8c715ead4">Ogre::MetalTextureGpu</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#ad6f2da183f80a1dc8fe6fdf7b3934e41">Ogre::MetalTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a470fc007c8351e6b3d60dc48ee01e956">Ogre::VulkanTextureGpu</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a1720741c27580848636ec530f1275e4c">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a3bd2fb8a2ce598268c8813f5f230ddd8" name="a3bd2fb8a2ce598268c8813f5f230ddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd2fb8a2ce598268c8813f5f230ddd8">&#9670;&#160;</a></span>supportsAsDepthBufferFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::supportsAsDepthBufferFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>colourTarget</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57666f9b894eb0c488461e558d22e033" name="a57666f9b894eb0c488461e558d22e033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57666f9b894eb0c488461e558d22e033">&#9670;&#160;</a></span>swapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::swapBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only valid for <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> classes. </p>
<p>TODO: This may be moved to a different class. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#a5af39237440cdd105f1808ba1526bdeb">Ogre::D3D11TextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#ae9a6545cec6bc906a3d8243d757b32bd">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#a3a22880c94f6bfaff88182dd54a14208">Ogre::GL3PlusTextureGpuHeadlessWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#ab461b093390041b570a61133aa19f659">Ogre::MetalTextureGpuWindow</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a79d3eba20b0312c133b0682d3dfbb36d">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a3aee068205a09b2d3aa61d021c8a62a8" name="a3aee068205a09b2d3aa61d021c8a62a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aee068205a09b2d3aa61d021c8a62a8">&#9670;&#160;</a></span>unsafeScheduleTransitionTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::unsafeScheduleTransitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>nextResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSkipMultiload</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedules an async transition in residency. </p>
<p>If transitioning from OnStorage to Resident, it will read from file (ResourceGroup was set in createTexture) If transitioning from OnSystemRam to Resident, it will read from the pointer it has. Multiple transitions can be stack together. </p><dl class="section remark"><dt>Remarks</dt><dd>If you're not loading from file (i.e. you're creating it programatically), call _transitionTo &amp; _setNextResidencyStatus directly. Once you've called scheduleTransitionTo at least once, calling _transitionTo is very dangerous, as there are race conditions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_gpu.html#a32e5eb68dc3ba4521042fa82656a8a53" title="Same as unsafeScheduleTransitionTo, but first checks if we&#39;re already in the residency state we want ...">TextureGpu::scheduleTransitionTo</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nextResidency</td><td>The residency to change to. </td></tr>
    <tr><td class="paramname">image</td><td>Pointer to image if you want to load the texture from memory instead of loading it from file or a listener. Pointer must be null if this is a manual texture. Pointer must NOT be a stack variable nor be deleted immediately. The actual loading is postponed until the request reaches the worker thread. That means the image pointer is safe to delete once you receive the <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257" title="This Reason is called when TextureGpu::notifyDataIsReady is called.">TextureGpuListener::Reason::ReadyForRendering</a> message. </td></tr>
    <tr><td class="paramname">autoDeleteImage</td><td>Whether we should call "delete image" once we're done using the image. Otherwise you must listen for <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257" title="This Reason is called when TextureGpu::notifyDataIsReady is called.">TextureGpuListener::ReadyForRendering</a> message to know when we're done using the image. </td></tr>
    <tr><td class="paramname">bSkipMultiload</td><td>Do not send this texture to be loaded by multiload (see <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a1ff9f8223324c7091eaa3698bd39efe2" title="OgreNext always performs background streaming to load textures in a worker thread.">TextureGpuManager::setMultiLoadPool</a>) Useful if the order in which textures are being created into a pool must be preserved This value is implicitly true if image is not nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a236d643259ed803cab8b550af78fc755" name="a236d643259ed803cab8b550af78fc755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236d643259ed803cab8b550af78fc755">&#9670;&#160;</a></span>waitForData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::waitForData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks main thread until data is ready. </p>
<p>Afterwards isDataReady should return true. If it doesn't, then there was a problem loading the texture. See isMetadataReady remarks.</p>
<p>Q: What's the penalty for calling this function?</p>
<p>A: We need to wait for the worker thread to finish all previous textures until it processes this one. The manager only has broad resolution so it may be also possible that we even have to wait the worker thread to process a few textures that came <em>after</em> this one too.</p>
<p>Thus the cost can be anywhere from "very little" to "a lot" depending on the order in which other textures have been loaded.</p>
<p>The real cost is that you lose valuable ability to hide loading times. If you must call this function, you can mitigate the problem: </p><pre class="fragment">1. All textures you need to wait for, load them *first* together, then
   call TextureGpuManager::waitForStreamingCompletion (preferred) or
   this function. Then proceed to load the rest of the textures.
2. If you can't do the above, call this function as late as possible 
</pre> 
</div>
</div>
<a id="a13af2e0d5c099c3be71e33c2159b16e9" name="a13af2e0d5c099c3be71e33c2159b16e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13af2e0d5c099c3be71e33c2159b16e9">&#9670;&#160;</a></span>waitForMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::waitForMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks main thread until metadata is ready. </p>
<p>Afterwards isMetadataReady should return true. If it doesn't, then there was a problem loading the texture. See isMetadataReady remarks. </p>

</div>
</div>
<a id="af042e9ab52c07776f154ee077330f592" name="af042e9ab52c07776f154ee077330f592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af042e9ab52c07776f154ee077330f592">&#9670;&#160;</a></span>writeContentsToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::writeContentsToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>minMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>maxMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automaticResolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the current contents of the render target to the named file. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8ec57ce0ef0c682416c3a6b6d13a095a" name="a8ec57ce0ef0c682416c3a6b6d13a095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec57ce0ef0c682416c3a6b6d13a095a">&#9670;&#160;</a></span>msDefaultOrientationMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a> Ogre::TextureGpu::msDefaultOrientationMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PUBLIC VARIABLE. </p>
<p>This variable can be altered directly.</p>
<p>Changes are reflected immediately for new TextureGpus. Existing TextureGpus won't be affected </p>

</div>
</div>
<a id="a3ed2bdf11740fd262b9311a33e33f935" name="a3ed2bdf11740fd262b9311a33e33f935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed2bdf11740fd262b9311a33e33f935">&#9670;&#160;</a></span>msFinalTextureBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::TextureGpu::msFinalTextureBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43888e98f84f5c9eb9ded14dd0deb34d" name="a43888e98f84f5c9eb9ded14dd0deb34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43888e98f84f5c9eb9ded14dd0deb34d">&#9670;&#160;</a></span>msMsaaTextureBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::TextureGpu::msMsaaTextureBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_texture_gpu_8h.html">OgreTextureGpu.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
