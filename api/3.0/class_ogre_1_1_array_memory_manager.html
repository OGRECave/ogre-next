<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::ArrayMemoryManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_array_memory_manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1_array_memory_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::ArrayMemoryManager Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___memory.html">Memory</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Abstract memory manager for managing large chunks of contiguous memory, optimized for SoA (Structure of Arrays) implementations.  
 <a href="class_ogre_1_1_array_memory_manager.html#details">More...</a></p>

<p><code>#include &lt;OgreArrayMemoryManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::ArrayMemoryManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_array_memory_manager__inherit__graph.svg" width="507" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager_1_1_rebase_listener.html">RebaseListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When mUsedMemory &gt;= mMaxMemory (that is, we've exhausted all our preallocated memory) <a class="el" href="class_ogre_1_1_array_memory_manager.html" title="Abstract memory manager for managing large chunks of contiguous memory, optimized for SoA (Structure ...">ArrayMemoryManager</a> will proceed to reallocate all memory.  <a href="class_ogre_1_1_array_memory_manager_1_1_rebase_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aac88868dab1629f0becfe78f25f27426" id="r_aac88868dab1629f0becfe78f25f27426"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; ptrdiff_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#aac88868dab1629f0becfe78f25f27426">PtrdiffVec</a></td></tr>
<tr class="separator:aac88868dab1629f0becfe78f25f27426"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d4cefc1bbe7c9016496e60f7ceb6bcd" id="r_a9d4cefc1bbe7c9016496e60f7ceb6bcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#a9d4cefc1bbe7c9016496e60f7ceb6bcd">ArrayMemoryManager</a> (size_t const *elementsMemSize, <a class="el" href="group___memory.html#ga4670b4da69fc17f183690626fd3bf47f">CleanupRoutines</a> const *initRoutines, <a class="el" href="group___memory.html#ga4670b4da69fc17f183690626fd3bf47f">CleanupRoutines</a> const *cleanupRoutines, size_t numElementsSize, <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> depthLevel, size_t hintMaxNodes, size_t cleanupThreshold=100, size_t maxHardLimit=<a class="el" href="class_ogre_1_1_array_memory_manager.html#a738870646404c47464027863b9dea16c">MAX_MEMORY_SLOTS</a>, <a class="el" href="class_ogre_1_1_array_memory_manager_1_1_rebase_listener.html">RebaseListener</a> *rebaseListener=0)</td></tr>
<tr class="memdesc:a9d4cefc1bbe7c9016496e60f7ceb6bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a9d4cefc1bbe7c9016496e60f7ceb6bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39c1d7b610c181e4c9b5baeef0097cc" id="r_ac39c1d7b610c181e4c9b5baeef0097cc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#ac39c1d7b610c181e4c9b5baeef0097cc">~ArrayMemoryManager</a> ()</td></tr>
<tr class="separator:ac39c1d7b610c181e4c9b5baeef0097cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff6ca754a46c4d2fe35ec737681bc26" id="r_a1ff6ca754a46c4d2fe35ec737681bc26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#a1ff6ca754a46c4d2fe35ec737681bc26">defragment</a> ()</td></tr>
<tr class="memdesc:a1ff6ca754a46c4d2fe35ec737681bc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers on demand a defragmentation of the pools, so that all slots become contiguous in memory.  <br /></td></tr>
<tr class="separator:a1ff6ca754a46c4d2fe35ec737681bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59979265f37644b7b411c1c186412a0" id="r_aa59979265f37644b7b411c1c186412a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#aa59979265f37644b7b411c1c186412a0">destroy</a> ()</td></tr>
<tr class="memdesc:aa59979265f37644b7b411c1c186412a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the memory ptrs.  <br /></td></tr>
<tr class="separator:aa59979265f37644b7b411c1c186412a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c128b8ba585ecb04205e81d2aa2c341" id="r_a8c128b8ba585ecb04205e81d2aa2c341"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#a8c128b8ba585ecb04205e81d2aa2c341">getAllMemory</a> () const</td></tr>
<tr class="memdesc:a8c128b8ba585ecb04205e81d2aa2c341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all memory reserved for this manager.  <br /></td></tr>
<tr class="separator:a8c128b8ba585ecb04205e81d2aa2c341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac639db8f3c078fa02ceb2691d4b86065" id="r_ac639db8f3c078fa02ceb2691d4b86065"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#ac639db8f3c078fa02ceb2691d4b86065">getFreeMemory</a> () const</td></tr>
<tr class="memdesc:ac639db8f3c078fa02ceb2691d4b86065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets available memory in bytes.  <br /></td></tr>
<tr class="separator:ac639db8f3c078fa02ceb2691d4b86065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd91cd460057cd3a143e84c887655c26" id="r_afd91cd460057cd3a143e84c887655c26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#afd91cd460057cd3a143e84c887655c26">getNumUsedSlotsIncludingFragmented</a> () const</td></tr>
<tr class="memdesc:afd91cd460057cd3a143e84c887655c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mUsedMemory.  <br /></td></tr>
<tr class="separator:afd91cd460057cd3a143e84c887655c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1483bb4f495abd37502c209eecc08881" id="r_a1483bb4f495abd37502c209eecc08881"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#a1483bb4f495abd37502c209eecc08881">getUsedMemory</a> () const</td></tr>
<tr class="memdesc:a1483bb4f495abd37502c209eecc08881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets used memory in bytes (not including waste)  <br /></td></tr>
<tr class="separator:a1483bb4f495abd37502c209eecc08881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fe5a861ebd6b4610189ce2be86b032" id="r_a42fe5a861ebd6b4610189ce2be86b032"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#a42fe5a861ebd6b4610189ce2be86b032">getWastedMemory</a> () const</td></tr>
<tr class="memdesc:a42fe5a861ebd6b4610189ce2be86b032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets wasted memory (perform a cleanup to fix)  <br /></td></tr>
<tr class="separator:a42fe5a861ebd6b4610189ce2be86b032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad680fce37ec7058f94a5a69be2e2f4c5" id="r_ad680fce37ec7058f94a5a69be2e2f4c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#ad680fce37ec7058f94a5a69be2e2f4c5">initialize</a> ()</td></tr>
<tr class="memdesc:ad680fce37ec7058f94a5a69be2e2f4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes mMemoryPools.  <br /></td></tr>
<tr class="separator:ad680fce37ec7058f94a5a69be2e2f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443f00a249cbbc4b6edf56632c5e2756" id="r_a443f00a249cbbc4b6edf56632c5e2756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#a443f00a249cbbc4b6edf56632c5e2756">neverDefragment</a> ()</td></tr>
<tr class="memdesc:a443f00a249cbbc4b6edf56632c5e2756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent defragmentation from ever happening.  <br /></td></tr>
<tr class="separator:a443f00a249cbbc4b6edf56632c5e2756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1885069fab42349469ea51ea34590bad" id="r_a1885069fab42349469ea51ea34590bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#a1885069fab42349469ea51ea34590bad">shrinkToFit</a> ()</td></tr>
<tr class="memdesc:a1885069fab42349469ea51ea34590bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defragments memory, then reallocates a smaller pool that tightly fits the current number of objects.  <br /></td></tr>
<tr class="separator:a1885069fab42349469ea51ea34590bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a738870646404c47464027863b9dea16c" id="r_a738870646404c47464027863b9dea16c"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_memory_manager.html#a738870646404c47464027863b9dea16c">MAX_MEMORY_SLOTS</a></td></tr>
<tr class="separator:a738870646404c47464027863b9dea16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract memory manager for managing large chunks of contiguous memory, optimized for SoA (Structure of Arrays) implementations. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This class works by requesting slots from preallocated chunks, and then releasing those slots. This implementation is most efficient when using LIFO patterns. Since Entities &amp; SceneNodes use this manager, this means that you should create the most static ones first, and the most dynamic ones last (i.e. the ones that are going to be frequently inserted &amp; removed from scene) </dd></dl>
<dl class="section user"><dt></dt><dd>WARNING: This class requires its owner to manually call <a class="el" href="class_ogre_1_1_array_memory_manager.html#ad680fce37ec7058f94a5a69be2e2f4c5" title="Initializes mMemoryPools.">initialize()</a> and <a class="el" href="class_ogre_1_1_array_memory_manager.html#aa59979265f37644b7b411c1c186412a0" title="Destroys the memory ptrs.">destroy()</a> after all instances have been destroyed. Otherwise memory leaks will happen! </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matias N. Goldberg </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aac88868dab1629f0becfe78f25f27426" name="aac88868dab1629f0becfe78f25f27426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac88868dab1629f0becfe78f25f27426">&#9670;&#160;</a></span>PtrdiffVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;ptrdiff_t&gt; <a class="el" href="class_ogre_1_1_array_memory_manager.html#aac88868dab1629f0becfe78f25f27426">Ogre::ArrayMemoryManager::PtrdiffVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d4cefc1bbe7c9016496e60f7ceb6bcd" name="a9d4cefc1bbe7c9016496e60f7ceb6bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4cefc1bbe7c9016496e60f7ceb6bcd">&#9670;&#160;</a></span>ArrayMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ArrayMemoryManager::ArrayMemoryManager </td>
          <td>(</td>
          <td class="paramtype">size_t const *&#160;</td>
          <td class="paramname"><em>elementsMemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___memory.html#ga4670b4da69fc17f183690626fd3bf47f">CleanupRoutines</a> const *&#160;</td>
          <td class="paramname"><em>initRoutines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___memory.html#ga4670b4da69fc17f183690626fd3bf47f">CleanupRoutines</a> const *&#160;</td>
          <td class="paramname"><em>cleanupRoutines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElementsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>depthLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hintMaxNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cleanupThreshold</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxHardLimit</em> = <code><a class="el" href="class_ogre_1_1_array_memory_manager.html#a738870646404c47464027863b9dea16c">MAX_MEMORY_SLOTS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_array_memory_manager_1_1_rebase_listener.html">RebaseListener</a> *&#160;</td>
          <td class="paramname"><em>rebaseListener</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>See intialize(). See <a class="el" href="class_ogre_1_1_array_memory_manager.html#aa59979265f37644b7b411c1c186412a0" title="Destroys the memory ptrs.">destroy()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementsMemSize</td><td>Array containing the size in bytes of each element type (i.e. NodeElementsMemSize) </td></tr>
    <tr><td class="paramname">initRoutines</td><td>Array containing the cleanup function that will be called when default initializing memory. Unlike cleanupRoutines, just leave the function pointer null if all you want is just to initialize to 0. </td></tr>
    <tr><td class="paramname">cleanupRoutines</td><td>Array containing the cleanup function that will be called when performing cleanups. Many pointers can use the flatCleaner and is the fastest. However Array variables (i.e. <a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a>) have a layout where flatCleaner won't work correctly because the data is interleaved (rather than flat). </td></tr>
    <tr><td class="paramname">numElementsSize</td><td>Number of entries in elementsMemSize </td></tr>
    <tr><td class="paramname">depthLevel</td><td>Value only used to pass to the listener. Identifies to which hierarchy depth level this memory manager belongs to. </td></tr>
    <tr><td class="paramname">hintMaxNodes</td><td>Hint on how many SceneNodes we'll be creating. </td></tr>
    <tr><td class="paramname">cleanupThreshold</td><td>The threshold at which a cleanup is triggered after too many nodes have been destroyed in a non-LIFO order or without being created again. -1 to disable cleanups. </td></tr>
    <tr><td class="paramname">maxHardLimit</td><td>Maximum amount of SceneNodes. The manager is not allowed to grow and consume more memory past that limit. MAX_MEMORY_SLOTS for no limit. This is useful when target architecture has much less memory than the dev machine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd>Note that if hintMaxNodes &lt; maxHardLimit, the manager may be forced to do temporary allocations (to do the reallocs) thus during a brief perdiod of time it may consume more memory than the established hard limit (up to 2x). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rebaseListener</td><td>The listener to be called when cleaning up or growing the memory pool. If null, cleanupThreshold is set to -1 &amp; maxHardLimit will be set to hintMaxNodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac39c1d7b610c181e4c9b5baeef0097cc" name="ac39c1d7b610c181e4c9b5baeef0097cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39c1d7b610c181e4c9b5baeef0097cc">&#9670;&#160;</a></span>~ArrayMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::ArrayMemoryManager::~ArrayMemoryManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1ff6ca754a46c4d2fe35ec737681bc26" name="a1ff6ca754a46c4d2fe35ec737681bc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff6ca754a46c4d2fe35ec737681bc26">&#9670;&#160;</a></span>defragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayMemoryManager::defragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers on demand a defragmentation of the pools, so that all slots become contiguous in memory. </p>
<p>ArrayMemoryManager::destroySlot already does this when the number of fragmented slots reaches mCleanupThreshold </p>

</div>
</div>
<a id="aa59979265f37644b7b411c1c186412a0" name="aa59979265f37644b7b411c1c186412a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59979265f37644b7b411c1c186412a0">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayMemoryManager::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the memory ptrs. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_array_memory_manager.html#ad680fce37ec7058f94a5a69be2e2f4c5" title="Initializes mMemoryPools.">initialize</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If there were slots in use, make sure they're no longer used, as their ptrs will become dangling ptrs. We don't assert because this may be valid behavior (i.e. on shutdown) </dd></dl>

</div>
</div>
<a id="a8c128b8ba585ecb04205e81d2aa2c341" name="a8c128b8ba585ecb04205e81d2aa2c341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c128b8ba585ecb04205e81d2aa2c341">&#9670;&#160;</a></span>getAllMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ArrayMemoryManager::getAllMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all memory reserved for this manager. </p>

</div>
</div>
<a id="ac639db8f3c078fa02ceb2691d4b86065" name="ac639db8f3c078fa02ceb2691d4b86065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac639db8f3c078fa02ceb2691d4b86065">&#9670;&#160;</a></span>getFreeMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ArrayMemoryManager::getFreeMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets available memory in bytes. </p>

</div>
</div>
<a id="afd91cd460057cd3a143e84c887655c26" name="afd91cd460057cd3a143e84c887655c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd91cd460057cd3a143e84c887655c26">&#9670;&#160;</a></span>getNumUsedSlotsIncludingFragmented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ArrayMemoryManager::getNumUsedSlotsIncludingFragmented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mUsedMemory. </p>
<p>When ARRAY_PACKED_REALS = 4, and 4 objects have been created but the 2nd one has been deleted, getNumUsedSlotsIncludingFragmented will still return 4 until the 4th object is removed or a cleanup is performed </p>

</div>
</div>
<a id="a1483bb4f495abd37502c209eecc08881" name="a1483bb4f495abd37502c209eecc08881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1483bb4f495abd37502c209eecc08881">&#9670;&#160;</a></span>getUsedMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ArrayMemoryManager::getUsedMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets used memory in bytes (not including waste) </p>

</div>
</div>
<a id="a42fe5a861ebd6b4610189ce2be86b032" name="a42fe5a861ebd6b4610189ce2be86b032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fe5a861ebd6b4610189ce2be86b032">&#9670;&#160;</a></span>getWastedMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ArrayMemoryManager::getWastedMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets wasted memory (perform a cleanup to fix) </p>

</div>
</div>
<a id="ad680fce37ec7058f94a5a69be2e2f4c5" name="ad680fce37ec7058f94a5a69be2e2f4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad680fce37ec7058f94a5a69be2e2f4c5">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayMemoryManager::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes mMemoryPools. </p>
<p>Once it has been called, <a class="el" href="class_ogre_1_1_array_memory_manager.html#aa59979265f37644b7b411c1c186412a0" title="Destroys the memory ptrs.">destroy()</a> <b>must</b> be called. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_array_memory_manager.html#aa59979265f37644b7b411c1c186412a0" title="Destroys the memory ptrs.">destroy</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The destructor won't free the data, if you don't call destroy, memory will leak. Calling initialize twice is possible and won't leak, but will free the previous memory ptrs without calling the registered <a class="el" href="class_ogre_1_1_array_memory_manager_1_1_rebase_listener.html" title="When mUsedMemory &gt;= mMaxMemory (that is, we&#39;ve exhausted all our preallocated memory) ArrayMemoryMana...">RebaseListener</a>. So if there were slots in use, their pointers will become dangling. An assert will trigger if this happens. </dd></dl>

</div>
</div>
<a id="a443f00a249cbbc4b6edf56632c5e2756" name="a443f00a249cbbc4b6edf56632c5e2756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443f00a249cbbc4b6edf56632c5e2756">&#9670;&#160;</a></span>neverDefragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayMemoryManager::neverDefragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent defragmentation from ever happening. </p>

</div>
</div>
<a id="a1885069fab42349469ea51ea34590bad" name="a1885069fab42349469ea51ea34590bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1885069fab42349469ea51ea34590bad">&#9670;&#160;</a></span>shrinkToFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayMemoryManager::shrinkToFit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defragments memory, then reallocates a smaller pool that tightly fits the current number of objects. </p>
<p>Useful when you know you won't be creating more slots and you need to reclaim memory. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a738870646404c47464027863b9dea16c" name="a738870646404c47464027863b9dea16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738870646404c47464027863b9dea16c">&#9670;&#160;</a></span>MAX_MEMORY_SLOTS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t Ogre::ArrayMemoryManager::MAX_MEMORY_SLOTS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_array_memory_manager_8h.html">OgreArrayMemoryManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_array_memory_manager.html">ArrayMemoryManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
