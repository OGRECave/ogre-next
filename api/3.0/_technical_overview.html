<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Technical Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_technical_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Technical Overview</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#TechnicalOverviewOverview">Overview</a><ul><li class="level2"><a href="#SIMDCoherence">SIMD Coherence</a></li>
</ul>
</li>
<li class="level1"><a href="#MemoryManagerUsagePatterns">Memory Managers usage patterns</a><ul><li class="level2"><a href="#MemoryManagerCleanups">Cleanups</a></li>
</ul>
</li>
<li class="level1"><a href="#MemoryPreallocation">Memory preallocation</a></li>
<li class="level1"><a href="#ConfiguringMemoryManagers">Configuring memory managers</a></li>
<li class="level1"><a href="#RenderTargetUpdate">Where is RenderTarget::update? Why do I get errors in Viewport?</a></li>
<li class="level1"><a href="#PortingV1ToV2">Porting from 1.x to 2.0</a></li>
<li class="level1"><a href="#PortingV20ToV21">Porting from 2.0 to 2.1</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="TechnicalOverviewOverview"></a>
Overview</h1>
<p><code>ArrayMemoryManager</code> is the base abstract system for handling SoA memory. Derived classes (like <code>NodeArrayMemoryManager</code> or <code>ObjecDataArrayMemoryManager</code>) provide a list of with the bytes needed for each SoA pointer that will be used. I wrote <a href="http://yosoygames.com.ar/wp/2013/07/ogre-2-0-memory-manager-slides-uploaded-gsoc/">a few slides</a> to [^4]help with understanding these concepts.</p>
<p>There is one <code>NodeArrayMemoryManager</code> per <code>Node</code> parent level. Root node is parent level 0; the children of Root is parent level 1. And Root's children's children are parent level 2.</p>
<p>There is also one <code>ObjectDataArrayMemoryManager</code> per Render Queue.</p>
<p><code>NodeMemoryManager</code> is the main public interface, which handles all the <code>NodeArrayMemoryManagers</code>.</p>
<p>Likewise, <code>ObjectDataMemoryManager</code> is the main public interface, which handles all the <code>ObjectDataArrayMemoryManager</code>.</p>
<p><code>NodeMemoryManager</code></p>
<ul>
<li>Multiple NodeArrayMemoryManager. One per parent level.<ul>
<li>Each one return a <code>Transform</code> (contain 4x4 Matrices, position, rotations, scale, the derived pos, rot, scales; etc) which is all SoA pointers.</li>
</ul>
</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="node_mm.svg" style="pointer-events: none;"></object>
</div>
    <p><code>ObjectDataMemoryManager</code></p>
<ul>
<li>Multiple <code>ObjectDataArrayMemoryManager</code>. One per render queue.<ul>
<li>Each one return an <code>ObjectData</code> (contain Aabbs in local space, in world space, radius, visibility masks; etc) which is all SoA pointers.</li>
</ul>
</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="object_mm.svg" style="pointer-events: none;"></object>
</div>
    <h2><a class="anchor" id="SIMDCoherence"></a>
SIMD Coherence</h2>
<p>Using SSE2 single precision, OGRE usually processes 4 nodes/entities at a time. However, if there is only 3 Nodes; we need to allocate memory for 4 of them (<code>ArrayMemoryManager</code> already handles this) and initialize the values to sane defaults even if they aren't used (eg. Set quaternion &amp; matrices to identity) to prevent NaNs during computations. Certain architectures slowdown if one of the elements in an xmm register contains a NaN.</p>
<p>Furthermore, <a class="el" href="_ogre20_changes.html#DummyPointers">null pointers are not valid, but dummy pointers are used instead</a>.</p>
<p>SIMD Coherence is very important for both stability and performance, and is 99% of the time responsability of the Memory Managers</p>
<h1><a class="anchor" id="MemoryManagerUsagePatterns"></a>
Memory Managers usage patterns</h1>
<p><code>ArrayMemoryManagers</code> work with the concept of slots. When a Node asks for a <code>Transform</code>, it is asking for a slot. When a <code>MovableObject</code> asks for an <code>ObjectData</code>, it is asking for a slot.</p>
<p>In an SSE2 build, 4 slots make a block. How many slots are needed to make a block depends on the value of the macro <code>ARRAY_PACKED_REALS</code>.</p>
<p>Slots are most efficient when requested and released in <a href="http://en.wikipedia.org/wiki/LIFO_(computing)">LIFO</a> order.</p>
<p>When LIFO order is not respected, a release (i.e. destroying a Node) puts the released slot into a list. When a new slot is requested, the one from the list is used and removed from it. When this list grows too large, a cleanup will be performed. The cleanup threshold can be tweaked.</p>
<h2><a class="anchor" id="MemoryManagerCleanups"></a>
Cleanups</h2>
<p>Cleanups happen when the number of slots released in non-LIFO order grows too large. A cleanup will move memory so that it is contiguous again.</p>
<p>Why are cleanups needed? Simply put, <b>performance</b>. Imagine the following example (assuming <code>ARRAY_PACKED_REALS</code> = 4): The user created 20 nodes, named A through T:</p>
<blockquote class="doxtable">
<p>&zwj;<code>ABCD EFGH IJKL MNOP QRST</code> </p>
</blockquote>
<p>Then the user decides to delete nodes B, C, D, E, F, G, H, I, J, L, N, O, P, Q, R, S, T; the resulting memory layout will be the following:</p>
<blockquote class="doxtable">
<p>&zwj;<code>A*** **** **K* M*** ****</code> </p>
</blockquote>
<p>where the asterisk <code>*</code> means an empty slot. When parsing the SoA arrays (i.e. while updating the scene nodes, updating the MovableObject's world Aabbs, frustum culling) everything is accessed sequentially.</p>
<p>The code will loop <b>4 times</b>, to process A, then nothing, then K, them M. If <code>ARRAY_PACKED_REALS</code> would be 1; the code would loop 13 times.</p>
<p>This is obviously inefficient if it stays for a long time. During real world application this issue won't impact performance if only done for 4 nodes, but if this kind of "fragmentation" is happening to thousands of nodes, performance drop would be noticeable.</p>
<p>The cleanup will move all nodes to make them contiguous again:</p>
<p><code>AKM* **** **** **** ****</code></p>
<p>Hence the code will only loop once for SSE builds (or 3 times if <code>ARRAY_PACKED_REALS</code> = 1)</p>
<h1><a class="anchor" id="MemoryPreallocation"></a>
Memory preallocation</h1>
<p>ArrayMemoryManagers preallocate a fixed amount of slots (always rounded up to multiples of <code>ARRAY_PACKED_REALS</code>) specified at initialization time.</p>
<p>When this limit is reached, the following may happen:</p>
<ul>
<li>The buffer is resized. Any pointer to the slots will be invalidated (i.e. holding an external reference to Transform::mPosition). The Nodes &amp; MovableObjects internal pointers are automatically updated.</li>
<li>The hard limit is reached (hard limit is also set at initialization time, the default is no limit). When this happens the memory manager will throw.</li>
</ul>
<h1><a class="anchor" id="ConfiguringMemoryManagers"></a>
Configuring memory managers</h1>
<blockquote class="doxtable">
<p>&zwj;<b>Note:</b> at the time of writing, memory managers have not a direct way of setting up the amount of preallocations or how often they perform cleanups. </p>
</blockquote>
<h1><a class="anchor" id="RenderTargetUpdate"></a>
Where is RenderTarget::update? Why do I get errors in Viewport?</h1>
<p>Advanced users are probably used to low level manipulation of RenderTargets. As such they're used to setting up their custom Viewports and calling <code>RenderTarget::update</code>.</p>
<p>That is too low level. <b>Instead, users are now encouraged to setup Compositor nodes and multiple workspaces to perform rendering to multiple RTs, even if it's for your own custom stuff</b>. The new Compositor is much more flexible than the old one (which has been removed). See section aboutCompositors for more information.</p>
<p>Viewports are no longer associated with cameras as they're now stateless (they used to cache the camera currently in use) and a lot of settings they used to hold (like background colour, clear settings, etc) have been moved to nodes. See <code>CompositorPassClearDef</code> and <code>CompositorPassClear</code>.</p>
<p><code>RenderTarget::update</code> has disappeared because the render scene update has been <a href="http://yosoygames.com.ar/wp/2013/09/shadow-mapping-nightmare/">split in two stages, cull and render</a>.</p>
<p>If you still insist in going low level, see the code on <code>CompositorPassScene::execute</code> to understand how to prepare a <code>RenderTarget</code> and render it manually. But again, we insist you should try the Compositor.</p>
<h1><a class="anchor" id="PortingV1ToV2"></a>
Porting from 1.x to 2.0</h1>
<p>You can port directly from 1.x to 2.1; however doing it in steps can be a great as the changes are incremental and you can adapt to them while also testing the new features step by step without being overwhelmed with all the features at once and then figgure out what went wrong.</p>
<p>The main changes are:</p>
<ul>
<li>The Compositor. Definitely the most noticeable change. The Compositor isn't just for postprocessing fancy effects anymore. It's a key component of <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>. You need to tell <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> how you want it to render your scene. You do that via the Compositor. See Compositor chapter for more information.</li>
<li>Listeners. <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> was listener-heavy. Every event had a listener for. This was crippling performance. Many listeners were removed, a few may not work. The most important listener now is <code>CompositorWorkspaceListener</code>. Also for custom rendering and injecting new Renderables, consider creating a custom pass via a <code>CompositorPassProvider</code>, which is the cleanest, most extensible way.</li>
<li>Behavior of SceneNodes, Lights and Cameras: Lights must be attached to a scene node. SceneNodes &amp; Cameras shouldn't be modified once <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> started rendering (e.g. inside a listener). If you still do it, in some cases calling <code>Node::_getTransformUpdated</code> can force the Node to update itself, but you still have to be careful. For example if you move the Camera's node, it's likely that frustum culling on objects and lights has already happened. So don't be surprised if objects disappear or don't get lit correctly. Be sure to test in Debug builds so that our aggressive asserts help you catch these issues.</li>
</ul>
<h1><a class="anchor" id="PortingV20ToV21"></a>
Porting from 2.0 to 2.1</h1>
<p>If you've already gone from 1.9 to 2.0 that's great. You're halfway there. You can test that your Compositor setups works and you get used to it, that no asserts get triggered, that everything shows up.</p>
<p>The two groundbreaking changes introduced between 2.0 and 2.1 are: the v2 objects and the Hlms materials (aka <code>HlmsDatablock</code>)</p>
<p>The v2 objects, Item is the clear example of it. It's the new "Entity". Item is faster (considerably faster depending on your scene).</p>
<p>If your preexisting engine is too complex to migrate Entity to Items; leaving Entity is a reasonable choice. However if you're starting a new project, Items is the best choice (with certain exceptions). v1 objects do work and they still get quite good performance because auto instancing works on them.</p>
<p>The difference between Items &amp; Entity is that if you've got 100 instances of the same mesh with 5 materials that use the same texture array; they will probably end up as just one draw call. Even if they're Entity.</p>
<p>However, if you've got 100 different <b>meshes</b> (not instances of the same mesh as in the previous example); Entity requires 100 draw calls, while Items can still do it in 1 draw call.</p>
<p>Items also have a lower memory footprint CPU-side than Entities.</p>
<p>If you decide to keep Entity (which is probably what makes most sense for existing codebases; if this is a new codebase or a simple one, then Items all the way) probably the most annoying part will be writing the "`v1::`" prefix for the namespace. Instead of Entity, it's now <code>v1::Entity</code>, and so on with many multiple classes.</p>
<p>Then there's the materials. Here's where it's quite different but often pleasant. In 1.x and 2.0; there was a <code>Renderable::setMaterial</code> function (and <code>setMaterialName</code>). In 2.1; Materials are <b>severely discouraged</b> and you should use Hlms datablocks instead (except for postprocessing).</p>
<p>There is a function <code>Renderable::setDatablockOrMaterialName</code> which, like the name implies, "First tries to see if an HLMS datablock exist with
the given name, if not, tries to search among low level materials." which is quite convenient when porting.</p>
<p>You'll have to port your Materials to PBS &amp; Unlit Datablock equivalents. In a Material, you would often define a vertex shader program, a pixel shader program. Then link these programs to the material. Setup the auto parameters. Then setup the texture units. Then setup the casters. It was a lot of work. (and also write the shader in HLSL, GLSL, and whatever else you needed to support).</p>
<p>It got worse if you wanted to selectively toggle features (e.g. toggle normal mapping on / off; Hardware Skeletal animation, etc). You even had to define multiple shader programs.</p>
<p>With Hlms datablocks you won't deal with any of that. Just setup the textures, the colour parameters, and you're done. The Hlms will analyze the Entity/Item when setting up the Datablock and create the appropriate shaders based from a template.</p>
<p>Probably the most shocking part is if you had a lot of C++ code that manipulated Materials directly (and its class members: <code>Technique</code>, <code>Pass</code>, <code>TextureUnitState</code>), because HlmsDatablocks are completely different. However if you dealt them via scripts, you won't have any issues. Chances are though, that if you had code that manipulated Materials directly, it was probably to do what the Hlms now does for you, and you won't be needing it anymore.</p>
<p>And then you're set :)</p>
<p>If you want to customize the Hlms, there's a very long and informative section in this manual about its inner workings. How it analyzes the geometry information and combines it with the pass' information (is this a shadow caster pass? a receiver pass?) and only then generate the shader</p>
<p>Most users won't have to ever touch this, but if you're looking for a very particular look or want to port your shaders from a previous framework, it will depend on the amount of work you need to do: you may want to just extend or modify the shader templates; or create your own templates. Or modify the C++ side of the Hlms implementation. As a recommendation, first see how the generated shaders look like (they get dumped where Hlms::setDebugOutputPath says) and walk your way backwards to the template to understand existing implementations.</p>
<p>[^4]:<a href="http://www.yosoygames.com.ar/other/GSoC-NodeMemoryManager-slides.7z">Mirror 1</a>; <a href="http://www.mediafire.com/?jgscslxbbp673nl">Mirror 2</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
