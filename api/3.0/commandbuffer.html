<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: The Command Buffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('commandbuffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The Command Buffer</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#CommandBufferAddCommand">Adding a command</a></li>
<li class="level1"><a href="#CommandBufferCommandStructure">Structure of a command</a></li>
<li class="level1"><a href="#CommandBufferExecutionTable">Execution table</a><ul><li class="level2"><a href="#CommandBufferExecutionTableHacks">Hacks and Tricks</a></li>
</ul>
</li>
<li class="level1"><a href="#CommandBufferPostProcessing">Post-processing the command buffer</a></li>
</ul>
</div>
<div class="textblock"><p>The Command Buffer was the response to a very practical problem: <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> couldn't assume persistent mapping is supported as this would break compatibility with DX10-level hardware and DX11 API.</p>
<p>This means that we need to map a buffer to update its contents. But we can't issue a draw call while a buffer is mapped. Unmapping and mapping before and after each draw call would be extremely costly; and therefore a command buffer was needed that would record all the API calls that have to be made; in order for buffers (i.e. constant and texture buffers to send data to the shaders) to be mapped only once.</p>
<p>Once we're done updating all buffers, the command buffer is executed, playing back all the API calls in the right order.</p>
<p>Note that the command buffer is written for high performance, low footprint; thus its inner workings and interface are very C-like.</p>
<h1><a class="anchor" id="CommandBufferAddCommand"></a>
Adding a command</h1>
<p>A C++ template is used to simplify the process; though you are not forced to use it.</p>
<p>The function "addCommand" creates an uninitialized command, and it's your job to initialize it to valid values.</p>
<p>The following snippet will record the command to set a new Vao, which will eventually calling <code>RenderSystem::_setVertexArrayObject</code> when it gets executed:</p>
<div class="fragment"><div class="line">VertexArrayObject*vao=<span class="comment">/*...*/</span>;</div>
<div class="line">*mCommandBuffer-&gt;addCommand&lt;CbVao&gt;()=CbVao(vao);</div>
</div><!-- fragment --><p>The following snippet will issue a v1-style indexed draw call: </p><div class="fragment"><div class="line">v1::CbDrawCallIndexed*drawCall=</div>
<div class="line">        mCommandBuffer-&gt;addCommand&lt;v1::CbDrawCallIndexed&gt;();</div>
<div class="line">*drawCall=v1::CbDrawCallIndexed();</div>
<div class="line">drawCall-&gt;operationType    =renderOp.operationType;</div>
<div class="line">drawCall-&gt;useGlobalInstancingVertexBufferIsAvailable=</div>
<div class="line">        renderOp.useGlobalInstancingVertexBufferIsAvailable;</div>
<div class="line">drawCall-&gt;primCount        =renderOp.indexData-&gt;indexCount;</div>
<div class="line">drawCall-&gt;instanceCount    =renderOp.numberOfInstances;</div>
<div class="line">drawCall-&gt;firstVertexIndex =renderOp.indexData-&gt;indexStart;</div>
<div class="line">drawCall-&gt;baseInstance     =baseInstance;</div>
</div><!-- fragment --><p>All the CommandBuffer-related code is under the CommandBuffer folder. By convention, all commands start with the <code>Cb</code> prefix.</p>
<p>The returned pointer should not be kept for long as further calls to <code>addCommand</code> may invalidate the pointer.</p>
<h1><a class="anchor" id="CommandBufferCommandStructure"></a>
Structure of a command</h1>
<p>Each command is, at the time of writting, of a fixed size of 32 bytes. This value is controlled by <code>CommandBuffer::COMMAND_FIXED_SIZE</code>. The first 2 bytes are reserved for the command type; which leaves you with 30 bytes of actual space.</p>
<p>Beware of storing pointers in the command: In a 32-bit environment each pointer is 4 bytes. But in a 64-bit environment, each pointer is 8 bytes. Make sure they still fit within the size of the command.</p>
<p>If 32 bytes is not enough, you can try researching into implementing multi-commands (an action that spans multiple commands and would read back and forth through the command buffer to obtain all the necessary data, beware of respecting the header in each command!); or raise the <code>COMMAND_FIXED_SIZE</code> constant.</p>
<p>Keeping the constant size low is vital to achieve good bandwidth and cache utilization, and hence keep the overhead to a minimum.</p>
<h1><a class="anchor" id="CommandBufferExecutionTable"></a>
Execution table</h1>
<p>The command buffer is implemented via a manual virtual table. The variable CommandBuffer::CommandBufferExecuteFunc* CbExecutionTable[MAX_COMMAND_BUFFER+1]<code>is populated with all the entries to this vtable. See enum</code>CbType` for all the possible entries.</p>
<p>Each function accepts a pointer to <code>this</code> state and the command itself.</p>
<p>Commands are stored in structs and its constructors are used to ensure each command populates the command type value properly.</p>
<p>Example:</p>
<p>To implement a command that will call <code>renderSystem-&gt;_setHlmsMacroblock( myMacroblock )</code>; a structure is defined:</p>
<div class="fragment"><div class="line">struct_OgreExportCbMacroblock:publicCbBase</div>
<div class="line">{</div>
<div class="line">    HlmsMacroblockconst   *block;</div>
<div class="line">    CbMacroblock(constHlmsMacroblock*_block);</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>Block</code> is the <code>myMacroblock</code> we want to set. We derive from <code>CbBase</code> which conveniently has already the 16-bit value defined. Since <code>CbBase</code> is only 2 bytes, take in mind compilers may add padding between the end of CbBase and the beginning of CbMacroblock unless compiler packing extensions[^16] are used; which leaves us with an usable space of 28 bytes in 32-bit environments, or 24 bytes in 64-bit. Note that you're not required to derive from <code>CbBase</code> (in case you're pressed with the command's size). This is just for convenience and consistency.</p>
<p>The constructor will populate all the proper values:</p>
<div class="fragment"><div class="line">CbMacroblock::CbMacroblock(constHlmsMacroblock*_block):</div>
<div class="line">    CbBase(CB_SET_MACROBLOCK),</div>
<div class="line">    block(_block)</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --><p>The constructor sets the command type to <code>CB_SET_MACROBLOCK</code> which is already part of <code>CbType</code>.</p>
<p>Therefore running <code>*commandBuffer-&gt;addCommand&lt;CbMacroblock&gt;() = CbMacroblock( myMacroblock )</code>; will just work.</p>
<p>But there's one more thing: We need to implement the actual command!</p>
<p>For that, we declare and define the following function:</p>
<div class="fragment"><div class="line"><span class="comment">//Declaration</span></div>
<div class="line">class_OgreExportCommandBuffer</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    staticCommandBufferExecuteFuncexecute_setMacroblock;</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">};</div>
<div class="line"><span class="comment">//Definition</span></div>
<div class="line">voidCommandBuffer::execute_setMacroblock(CommandBuffer*_this,constCbBase*RESTRICT_ALIAS_cmd)</div>
<div class="line">{</div>
<div class="line">    constCbMacroblock*cmd=<span class="keyword">static_cast&lt;</span>constCbMacroblock*<span class="keyword">&gt;</span>(_cmd);</div>
<div class="line">    _this-&gt;mRenderSystem-&gt;_setHlmsMacroblock(cmd-&gt;block);</div>
<div class="line">}    </div>
</div><!-- fragment --><p>Last but not least, we have to add the function to the table:</p>
<div class="fragment"><div class="line">CommandBuffer::CommandBufferExecuteFunc*CbExecutionTable[MAX_COMMAND_BUFFER+1]=</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    <span class="comment">//MAKESURETHEINDEXPOSITIONMATCHESTHEVALUEOFCB_SET_MACROBLOCK</span></div>
<div class="line">    &amp;CommandBuffer::execute_setMacroblock,</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">};   </div>
</div><!-- fragment --><p>The comment's remark is very important: You can't add <code>execute_setMacroblock</code> anywhere, you must store it at the same index as the value of <code>CB_SET_MACROBLOCK</code>, so that <code>CbExecutionTable[CB_SET_MACROBLOCK]</code> points to to <code>execute_setMacroblock</code>.</p>
<h2><a class="anchor" id="CommandBufferExecutionTableHacks"></a>
Hacks and Tricks</h2>
<p>Maintaining a manual vtable may seem like a lot of trouble, but the amount of commands is manageable (don't feel tempted to add one command for every little thing!) and it has very powerful benefits: You can manipulate the command type with simple integer arithmetic, thus saving expensive branch evaluations per object.</p>
<p>For example, <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> supports indirect buffers when available. But when indirect buffers aren't supported, not only we have to store the draw command data in CPU memory rather than GPU memory, but we also have to use very different draw calls. This is shown in <code>RenderSystem::_render</code> vs <code>RenderSystem::_renderEmulated</code>.</p>
<p>The former uses indirect buffer draw calls, the latter doesn't. Both do the exact same thing.</p>
<p>Usually, during command generation, the RenderQueue could look like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(size_ti=0;i&lt;numRenderables;++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(supportsIndirectBuffers)</div>
<div class="line">        *mCommandBuffer-&gt;addCommand&lt;CbDrawCallIndexed&gt;()=CbDrawCallIndexed();</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        *mCommandBuffer-&gt;addCommand&lt;CbDrawCallIndexedEmulated&gt;()=CbDrawCallIndexedEmulated();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This involves a branch per renderable. Since there can be literally hundred of thousands of them, this is costly.</p>
<p>Instead, you can just store the indirectBuffer version and the emulated together in the vtable, and use integer arithmetic to modify the index to the table:</p>
<div class="fragment"><div class="line">CbDrawCallIndexed::CbDrawCallIndexed(boolsupportsIndirectBuffers):</div>
<div class="line">    CbDrawCall(CB_DRAW_CALL_INDEXED_EMULATED+supportsIndirectBuffers)</div>
<div class="line">{</div>
<div class="line">}    </div>
</div><!-- fragment --><p>Then during the command generation in the RenderQueue just write:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> supportsIndirectBuffers = <span class="comment">/*...*/</span>;</div>
<div class="line"><span class="keywordflow">for</span>(size_ti=0;i&lt;numRenderables;++i)</div>
<div class="line">{</div>
<div class="line">    *mCommandBuffer-&gt;addCommand&lt;CbDrawCallIndexed&gt;()=</div>
<div class="line">                            CbDrawCallIndexed( supportsIndirectBuffers );</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's not just cleaner, it's also more efficient. A cmp, a jmp and a mov instruction (plus a potential miss-prediction) was just transformed into a single add.</p>
<h1><a class="anchor" id="CommandBufferPostProcessing"></a>
Post-processing the command buffer</h1>
<p>Another advantage of a command buffer, is that you may have more information about the rendering sequence only after you have processed all objects. You could also try to detect redundant state changes (<a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> doesn't do this though).</p>
<p>For example, both texture buffers require binding them to a shader by specifying an offset and a size.</p>
<p>The offset is known at the time the texture buffer is needed, but the size is not. The same texture buffer may be used to store data of many subsequent Renderables, and thus required size may not be known until we're done processing all of them.</p>
<p>For example, the Hlms implementations shipped with <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> populate this size at the end. For that, it saves the command location with <code>CommandBuffer::getCommandOffset</code> called after adding the command:</p>
<div class="fragment"><div class="line">CbShaderBuffer*shaderBufferCmd=commandBuffer-&gt;addCommand&lt;CbShaderBuffer&gt;();</div>
<div class="line">*shaderBufferCmd=CbShaderBuffer(shaderResourceSlot,</div>
<div class="line">                                   texBuffer,offsetStart,0);</div>
<div class="line">size_ttexBufferOffset=commandBuffer-&gt;getCommandOffset(shaderBufferCmd);  </div>
</div><!-- fragment --><p>The size at this point is set to 0, which is wrong. This will be corrected once we're done:</p>
<div class="fragment"><div class="line"><span class="comment">//Setthebindingsizeoftheoldbindingcommand(ifexists)</span></div>
<div class="line">CbShaderBuffer*shaderBufferCmd=<span class="keyword">reinterpret_cast&lt;</span>CbShaderBuffer*<span class="keyword">&gt;</span>(</div>
<div class="line">            commandBuffer-&gt;getCommandFromOffset(texBufferOffset));</div>
<div class="line">shaderBufferCmd-&gt;bindSizeBytes=writtenBytes;</div>
</div><!-- fragment --><p>The function <code>getCommandFromOffset</code> will only return a null pointer if the value from <code>texBufferOffset</code> is invalid.</p>
<p>We need to use these functions, as saving the command's pointer is not safe as it is not guaranteed to be valid after the next <code>addCommand</code> call.</p>
<p>[^14]: For example DX11 doesn't allow this level of flexibility. However we can still batch all meshes into the same vertex buffer, and in the same index buffer; texture buffers are also very flexible.</p>
<p>[^15]: On DX11, we can emulate fences using dummy occlusion queries.</p>
<p>[^16]: Like #pragma pack </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
