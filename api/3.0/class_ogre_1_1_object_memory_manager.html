<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::ObjectMemoryManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_object_memory_manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_object_memory_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::ObjectMemoryManager Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___memory.html">Memory</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Wrap-around class that contains multiple <a class="el" href="class_ogre_1_1_array_memory_manager.html" title="Abstract memory manager for managing large chunks of contiguous memory, optimized for SoA (Structure ...">ArrayMemoryManager</a>, one per render queue.  
 <a href="class_ogre_1_1_object_memory_manager.html#details">More...</a></p>

<p><code>#include &lt;OgreObjectMemoryManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::ObjectMemoryManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_object_memory_manager__inherit__graph.svg" width="226" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad476ec990597bd0f5e505f7a14527aa9" id="r_ad476ec990597bd0f5e505f7a14527aa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#ad476ec990597bd0f5e505f7a14527aa9">ObjectMemoryManager</a> ()</td></tr>
<tr class="separator:ad476ec990597bd0f5e505f7a14527aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a9dab2dfc3424659309b98794b2633" id="r_a23a9dab2dfc3424659309b98794b2633"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a23a9dab2dfc3424659309b98794b2633">~ObjectMemoryManager</a> ()</td></tr>
<tr class="separator:a23a9dab2dfc3424659309b98794b2633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c8bb313d67c58eb8405040b77ad567" id="r_ae1c8bb313d67c58eb8405040b77ad567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#ae1c8bb313d67c58eb8405040b77ad567">_getDummyNode</a> () const</td></tr>
<tr class="memdesc:ae1c8bb313d67c58eb8405040b77ad567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the dummy node (useful when detaching)  <br /></td></tr>
<tr class="separator:ae1c8bb313d67c58eb8405040b77ad567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c0d3a0c920dd3890e2606b4bc8627b" id="r_ad6c0d3a0c920dd3890e2606b4bc8627b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#ad6c0d3a0c920dd3890e2606b4bc8627b">_getTotalRenderQueues</a> () const</td></tr>
<tr class="separator:ad6c0d3a0c920dd3890e2606b4bc8627b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9ae13f4b0cc10d7dee8e8d15a02313" id="r_ada9ae13f4b0cc10d7dee8e8d15a02313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#ada9ae13f4b0cc10d7dee8e8d15a02313">_setTwin</a> (<a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> memoryManagerType, <a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *twinMemoryManager)</td></tr>
<tr class="separator:ada9ae13f4b0cc10d7dee8e8d15a02313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08ed3ab4ea707b14f9ddeff2296e54b" id="r_ae08ed3ab4ea707b14f9ddeff2296e54b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#ae08ed3ab4ea707b14f9ddeff2296e54b">applyRebase</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> level, const <a class="el" href="namespace_ogre.html#a43278e35ec4d27a6f37928aa78eded36">MemoryPoolVec</a> &amp;newBasePtrs, const <a class="el" href="class_ogre_1_1_array_memory_manager.html#aac88868dab1629f0becfe78f25f27426">ArrayMemoryManager::PtrdiffVec</a> &amp;diffsList) override</td></tr>
<tr class="memdesc:ae08ed3ab4ea707b14f9ddeff2296e54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the manager already grew it's memory pool to honour more node requests.  <br /></td></tr>
<tr class="separator:ae08ed3ab4ea707b14f9ddeff2296e54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5eb570db358e45e9e9a7969e14788" id="r_a5ef5eb570db358e45e9e9a7969e14788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a5ef5eb570db358e45e9e9a7969e14788">buildDiffList</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> level, const <a class="el" href="namespace_ogre.html#a43278e35ec4d27a6f37928aa78eded36">MemoryPoolVec</a> &amp;basePtrs, <a class="el" href="class_ogre_1_1_array_memory_manager.html#aac88868dab1629f0becfe78f25f27426">ArrayMemoryManager::PtrdiffVec</a> &amp;outDiffsList) override</td></tr>
<tr class="memdesc:a5ef5eb570db358e45e9e9a7969e14788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the manager needs to grow it's memory pool to honour more node requests.  <br /></td></tr>
<tr class="separator:a5ef5eb570db358e45e9e9a7969e14788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346cede27716fbf7136b1ca934532e65" id="r_a346cede27716fbf7136b1ca934532e65"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a346cede27716fbf7136b1ca934532e65">calculateTotalNumObjectDataIncludingFragmentedSlots</a> () const</td></tr>
<tr class="memdesc:a346cede27716fbf7136b1ca934532e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the opposite of getTotalNumObjects.  <br /></td></tr>
<tr class="separator:a346cede27716fbf7136b1ca934532e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5bcff087383d2a8e57a953b9d6d66a" id="r_a4d5bcff087383d2a8e57a953b9d6d66a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a4d5bcff087383d2a8e57a953b9d6d66a">defragment</a> ()</td></tr>
<tr class="memdesc:a4d5bcff087383d2a8e57a953b9d6d66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers on demand a defragmentation of the pools, so that all slots become contiguous in memory.    <br /></td></tr>
<tr class="separator:a4d5bcff087383d2a8e57a953b9d6d66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3205860c2fded5b34bb8f0802526af" id="r_a5a3205860c2fded5b34bb8f0802526af"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a5a3205860c2fded5b34bb8f0802526af">getFirstObjectData</a> (<a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;outObjectData, size_t renderQueue)</td></tr>
<tr class="memdesc:a5a3205860c2fded5b34bb8f0802526af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a <a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a> pointing to the first <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> in the given render queue.  <br /></td></tr>
<tr class="separator:a5a3205860c2fded5b34bb8f0802526af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c23b281a75f46db6eeda9f6827b3d" id="r_a032c23b281a75f46db6eeda9f6827b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a032c23b281a75f46db6eeda9f6827b3d">getMemoryManagerType</a> () const</td></tr>
<tr class="separator:a032c23b281a75f46db6eeda9f6827b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc3f26a856c2e4f9b463d3fed7825f4" id="r_aacc3f26a856c2e4f9b463d3fed7825f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#aacc3f26a856c2e4f9b463d3fed7825f4">getNumRenderQueues</a> () const</td></tr>
<tr class="memdesc:aacc3f26a856c2e4f9b463d3fed7825f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of render queues that have been created.  <br /></td></tr>
<tr class="separator:aacc3f26a856c2e4f9b463d3fed7825f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade91dd0361c03668a712ddae1757c01c" id="r_ade91dd0361c03668a712ddae1757c01c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#ade91dd0361c03668a712ddae1757c01c">getTotalNumObjects</a> () const</td></tr>
<tr class="memdesc:ade91dd0361c03668a712ddae1757c01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the sum of the number of objects in all render queues.  <br /></td></tr>
<tr class="separator:ade91dd0361c03668a712ddae1757c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c192d77d52b71feeb4a2fdb5cae692" id="r_a62c192d77d52b71feeb4a2fdb5cae692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a62c192d77d52b71feeb4a2fdb5cae692">getTwin</a> () const</td></tr>
<tr class="memdesc:a62c192d77d52b71feeb4a2fdb5cae692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note the return value can be null.  <br /></td></tr>
<tr class="separator:a62c192d77d52b71feeb4a2fdb5cae692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059f579b3fce6297b6541e6a06a36d40" id="r_a059f579b3fce6297b6541e6a06a36d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a059f579b3fce6297b6541e6a06a36d40">migrateTo</a> (<a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;inOutTransform, size_t renderQueue, <a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *dstObjectMemoryManager)</td></tr>
<tr class="memdesc:a059f579b3fce6297b6541e6a06a36d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory belonging to us, not before copying it into another manager.  <br /></td></tr>
<tr class="separator:a059f579b3fce6297b6541e6a06a36d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c9f2fecf984b7045f656517b931849" id="r_a30c9f2fecf984b7045f656517b931849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a30c9f2fecf984b7045f656517b931849">objectCreated</a> (<a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;outObjectData, size_t renderQueue)</td></tr>
<tr class="memdesc:a30c9f2fecf984b7045f656517b931849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests memory for the given <a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a>, initializing values.  <br /></td></tr>
<tr class="separator:a30c9f2fecf984b7045f656517b931849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2e6b8ba5fbcabd6765f23e4d228e36" id="r_aae2e6b8ba5fbcabd6765f23e4d228e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#aae2e6b8ba5fbcabd6765f23e4d228e36">objectDestroyed</a> (<a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;outObjectData, size_t renderQueue)</td></tr>
<tr class="memdesc:aae2e6b8ba5fbcabd6765f23e4d228e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases current memory.  <br /></td></tr>
<tr class="separator:aae2e6b8ba5fbcabd6765f23e4d228e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba0525c6ea5c99223df05d5593822ac" id="r_a3ba0525c6ea5c99223df05d5593822ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a3ba0525c6ea5c99223df05d5593822ac">objectMoved</a> (<a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;inOutObjectData, size_t oldRenderQueue, size_t newRenderQueue)</td></tr>
<tr class="memdesc:a3ba0525c6ea5c99223df05d5593822ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests memory for the given <a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a> to be moved to a different render queue, transferring existing values inside to the new memory slot.  <br /></td></tr>
<tr class="separator:a3ba0525c6ea5c99223df05d5593822ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9f7f049d953a3fb4fe4ae5bc2ce225" id="r_a6a9f7f049d953a3fb4fe4ae5bc2ce225"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a6a9f7f049d953a3fb4fe4ae5bc2ce225">performCleanup</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> level, const <a class="el" href="namespace_ogre.html#a43278e35ec4d27a6f37928aa78eded36">MemoryPoolVec</a> &amp;basePtrs, size_t const *elementsMemSizes, size_t startInstance, size_t diffInstances) override</td></tr>
<tr class="memdesc:a6a9f7f049d953a3fb4fe4ae5bc2ce225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when too many nodes were destroyed in a non-LIFO fashion.  <br /></td></tr>
<tr class="separator:a6a9f7f049d953a3fb4fe4ae5bc2ce225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653f6a2a1b0deba78eb242e9d09538ef" id="r_a653f6a2a1b0deba78eb242e9d09538ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_object_memory_manager.html#a653f6a2a1b0deba78eb242e9d09538ef">shrinkToFit</a> ()</td></tr>
<tr class="memdesc:a653f6a2a1b0deba78eb242e9d09538ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defragments memory, then reallocates a smaller pool that tightly fits the current number of objects.    <br /></td></tr>
<tr class="separator:a653f6a2a1b0deba78eb242e9d09538ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrap-around class that contains multiple <a class="el" href="class_ogre_1_1_array_memory_manager.html" title="Abstract memory manager for managing large chunks of contiguous memory, optimized for SoA (Structure ...">ArrayMemoryManager</a>, one per render queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the main memory manager that actually manages MovableObjects, and has to be called when a new <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> was created and when a <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> changes <a class="el" href="class_ogre_1_1_render_queue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that some <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementations (i.e. Octree like) may want to have more than one <a class="el" href="class_ogre_1_1_object_memory_manager.html" title="Wrap-around class that contains multiple ArrayMemoryManager, one per render queue.">ObjectMemoryManager</a>, for example one per octant. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad476ec990597bd0f5e505f7a14527aa9" name="ad476ec990597bd0f5e505f7a14527aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad476ec990597bd0f5e505f7a14527aa9">&#9670;&#160;</a></span>ObjectMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ObjectMemoryManager::ObjectMemoryManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23a9dab2dfc3424659309b98794b2633" name="a23a9dab2dfc3424659309b98794b2633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a9dab2dfc3424659309b98794b2633">&#9670;&#160;</a></span>~ObjectMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::ObjectMemoryManager::~ObjectMemoryManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1c8bb313d67c58eb8405040b77ad567" name="ae1c8bb313d67c58eb8405040b77ad567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c8bb313d67c58eb8405040b77ad567">&#9670;&#160;</a></span>_getDummyNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> * Ogre::ObjectMemoryManager::_getDummyNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the dummy node (useful when detaching) </p>

</div>
</div>
<a id="ad6c0d3a0c920dd3890e2606b4bc8627b" name="ad6c0d3a0c920dd3890e2606b4bc8627b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c0d3a0c920dd3890e2606b4bc8627b">&#9670;&#160;</a></span>_getTotalRenderQueues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ObjectMemoryManager::_getTotalRenderQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada9ae13f4b0cc10d7dee8e8d15a02313" name="ada9ae13f4b0cc10d7dee8e8d15a02313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9ae13f4b0cc10d7dee8e8d15a02313">&#9670;&#160;</a></span>_setTwin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::_setTwin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>memoryManagerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>twinMemoryManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>mMemoryManagerType </dd></dl>

</div>
</div>
<a id="ae08ed3ab4ea707b14f9ddeff2296e54b" name="ae08ed3ab4ea707b14f9ddeff2296e54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08ed3ab4ea707b14f9ddeff2296e54b">&#9670;&#160;</a></span>applyRebase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::applyRebase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a43278e35ec4d27a6f37928aa78eded36">MemoryPoolVec</a> &amp;&#160;</td>
          <td class="paramname"><em>newBasePtrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_memory_manager.html#aac88868dab1629f0becfe78f25f27426">ArrayMemoryManager::PtrdiffVec</a> &amp;&#160;</td>
          <td class="paramname"><em>diffsList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the manager already grew it's memory pool to honour more node requests. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Will use the new base ptr and the list we built in </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_object_memory_manager.html#a5ef5eb570db358e45e9e9a7969e14788" title="Called when the manager needs to grow it&#39;s memory pool to honour more node requests.">buildDiffList()</a> to know what mChunkPtr &amp; mIndex needs to be set for each ArrayVector3/etc we have. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The hierarchy depth level </td></tr>
    <tr><td class="paramname">newBasePtrs</td><td>The new base ptr. </td></tr>
    <tr><td class="paramname">diffsList</td><td>The list built in buildDiffList </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_array_memory_manager_1_1_rebase_listener.html#aefcfd7751701e774e0ba3ba51935438d">Ogre::ArrayMemoryManager::RebaseListener</a>.</p>

</div>
</div>
<a id="a5ef5eb570db358e45e9e9a7969e14788" name="a5ef5eb570db358e45e9e9a7969e14788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef5eb570db358e45e9e9a7969e14788">&#9670;&#160;</a></span>buildDiffList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::buildDiffList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a43278e35ec4d27a6f37928aa78eded36">MemoryPoolVec</a> &amp;&#160;</td>
          <td class="paramname"><em>basePtrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_array_memory_manager.html#aac88868dab1629f0becfe78f25f27426">ArrayMemoryManager::PtrdiffVec</a> &amp;&#160;</td>
          <td class="paramname"><em>outDiffsList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the manager needs to grow it's memory pool to honour more node requests. </p>
<p>See the class description on why we need to do this (to avoid C++ undefined behavior) </p><dl class="section remark"><dt>Remarks</dt><dd>Needs to builds a list that will contain the difference in bytes between each ArrayVector3/ArrayMatrix4/etc and the base pointers <em>in_the_order</em> in which the derived class holds those pointers (i.e. in the order the SceneNodes are arranged in memory) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The hierarchy depth level </td></tr>
    <tr><td class="paramname">basePtrs</td><td>The base pointers from each pool so we can calculate the differences </td></tr>
    <tr><td class="paramname">outDiffsList</td><td>The list we'll generate. "outDiffsList" already has enough reserved space </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_array_memory_manager_1_1_rebase_listener.html#a11b893d66c86445b9d73207118a579cc">Ogre::ArrayMemoryManager::RebaseListener</a>.</p>

</div>
</div>
<a id="a346cede27716fbf7136b1ca934532e65" name="a346cede27716fbf7136b1ca934532e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346cede27716fbf7136b1ca934532e65">&#9670;&#160;</a></span>calculateTotalNumObjectDataIncludingFragmentedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ObjectMemoryManager::calculateTotalNumObjectDataIncludingFragmentedSlots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the opposite of getTotalNumObjects. </p>
<p>This function returns the sum of the return values of getFirstObjectData </p>

</div>
</div>
<a id="a4d5bcff087383d2a8e57a953b9d6d66a" name="a4d5bcff087383d2a8e57a953b9d6d66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5bcff087383d2a8e57a953b9d6d66a">&#9670;&#160;</a></span>defragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::defragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers on demand a defragmentation of the pools, so that all slots become contiguous in memory.   </p>
<p>ArrayMemoryManager::destroySlot already does this when the number of fragmented slots reaches mCleanupThreshold   </p>

</div>
</div>
<a id="a5a3205860c2fded5b34bb8f0802526af" name="a5a3205860c2fded5b34bb8f0802526af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3205860c2fded5b34bb8f0802526af">&#9670;&#160;</a></span>getFirstObjectData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ObjectMemoryManager::getFirstObjectData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;&#160;</td>
          <td class="paramname"><em>outObjectData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>renderQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a <a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a> pointing to the first <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> in the given render queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outObjectData</td><td>[out] <a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a> with filled pointers to the first <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> in this depth </td></tr>
    <tr><td class="paramname">renderQueue</td><td>Current render queue it belongs to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> in this depth level </dd></dl>

</div>
</div>
<a id="a032c23b281a75f46db6eeda9f6827b3d" name="a032c23b281a75f46db6eeda9f6827b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c23b281a75f46db6eeda9f6827b3d">&#9670;&#160;</a></span>getMemoryManagerType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> Ogre::ObjectMemoryManager::getMemoryManagerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aacc3f26a856c2e4f9b463d3fed7825f4" name="aacc3f26a856c2e4f9b463d3fed7825f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc3f26a856c2e4f9b463d3fed7825f4">&#9670;&#160;</a></span>getNumRenderQueues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ObjectMemoryManager::getNumRenderQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of render queues that have been created. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The return value is equal or below mMemoryManagers.size(), you should cache the result instead of calling this function too often. </dd></dl>

</div>
</div>
<a id="ade91dd0361c03668a712ddae1757c01c" name="ade91dd0361c03668a712ddae1757c01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade91dd0361c03668a712ddae1757c01c">&#9670;&#160;</a></span>getTotalNumObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::ObjectMemoryManager::getTotalNumObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the sum of the number of objects in all render queues. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The value is cached to avoid iterating through all RQ levels, however be <b>VERY CAREFUL</b> with this value it may not be equal to the sum of all <a class="el" href="class_ogre_1_1_object_memory_manager.html#a5a3205860c2fded5b34bb8f0802526af" title="Retrieves a ObjectData pointing to the first MovableObject in the given render queue.">getFirstObjectData()</a> from all render queues. Specially careful when distributing work to different threads, since you may have to include skipping unassigned slots, and thus the last thread may end up writing out of bounds if you use getTotalNumObjects to allocate a buffer to hold results instead of calculateTotalNumObjectDataIncludingFragmentedSlots (depends on how your algorithm works). </dd></dl>
<dl class="section user"><dt></dt><dd>When ARRAY_PACKED_REALS = 4, and 4 objects have been created but the 2nd one has been deleted, getFirstObjectData will still return 4 until the 4th object is removed or a cleanup is performed; whereas getTotalNumObjects will return the actual number of objects. </dd></dl>

</div>
</div>
<a id="a62c192d77d52b71feeb4a2fdb5cae692" name="a62c192d77d52b71feeb4a2fdb5cae692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c192d77d52b71feeb4a2fdb5cae692">&#9670;&#160;</a></span>getTwin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> * Ogre::ObjectMemoryManager::getTwin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note the return value can be null. </p>

</div>
</div>
<a id="a059f579b3fce6297b6541e6a06a36d40" name="a059f579b3fce6297b6541e6a06a36d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059f579b3fce6297b6541e6a06a36d40">&#9670;&#160;</a></span>migrateTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::migrateTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;&#160;</td>
          <td class="paramname"><em>inOutTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>renderQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>dstObjectMemoryManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases memory belonging to us, not before copying it into another manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is useful when implementing multiple Memory Managers in Scene Managers or when switching nodes from Static to/from Dynamic. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inOutTransform</td><td>Valid <a class="el" href="struct_ogre_1_1_transform.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">Transform</a> that belongs to us. Output will belong to the other memory mgr. </td></tr>
    <tr><td class="paramname">depth</td><td>Current hierarchy level depth it belongs to. </td></tr>
    <tr><td class="paramname">dstObjectMemoryManager</td><td><a class="el" href="class_ogre_1_1_object_memory_manager.html" title="Wrap-around class that contains multiple ArrayMemoryManager, one per render queue.">ObjectMemoryManager</a> that will now own the transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30c9f2fecf984b7045f656517b931849" name="a30c9f2fecf984b7045f656517b931849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c9f2fecf984b7045f656517b931849">&#9670;&#160;</a></span>objectCreated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::objectCreated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;&#160;</td>
          <td class="paramname"><em>outObjectData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>renderQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests memory for the given <a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a>, initializing values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outObjectData</td><td><a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a> with filled pointers </td></tr>
    <tr><td class="paramname">renderQueue</td><td><a class="el" href="class_ogre_1_1_render_queue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a> ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae2e6b8ba5fbcabd6765f23e4d228e36" name="aae2e6b8ba5fbcabd6765f23e4d228e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2e6b8ba5fbcabd6765f23e4d228e36">&#9670;&#160;</a></span>objectDestroyed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::objectDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;&#160;</td>
          <td class="paramname"><em>outObjectData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>renderQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases current memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outObjectData</td><td><a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a> whose pointers will be nullified. </td></tr>
    <tr><td class="paramname">renderQueue</td><td>Current render queue it belongs to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ba0525c6ea5c99223df05d5593822ac" name="a3ba0525c6ea5c99223df05d5593822ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba0525c6ea5c99223df05d5593822ac">&#9670;&#160;</a></span>objectMoved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::objectMoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_object_data.html">ObjectData</a> &amp;&#160;</td>
          <td class="paramname"><em>inOutObjectData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>oldRenderQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newRenderQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests memory for the given <a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a> to be moved to a different render queue, transferring existing values inside to the new memory slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inOutObjectData</td><td><a class="el" href="struct_ogre_1_1_object_data.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">ObjectData</a> with filled pointers </td></tr>
    <tr><td class="paramname">oldRenderQueue</td><td><a class="el" href="class_ogre_1_1_render_queue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a> it's living now. </td></tr>
    <tr><td class="paramname">newRenderQueue</td><td><a class="el" href="class_ogre_1_1_render_queue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a> it wants to live in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a9f7f049d953a3fb4fe4ae5bc2ce225" name="a6a9f7f049d953a3fb4fe4ae5bc2ce225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9f7f049d953a3fb4fe4ae5bc2ce225">&#9670;&#160;</a></span>performCleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::performCleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a43278e35ec4d27a6f37928aa78eded36">MemoryPoolVec</a> &amp;&#160;</td>
          <td class="paramname"><em>basePtrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const *&#160;</td>
          <td class="paramname"><em>elementsMemSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>diffInstances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when too many nodes were destroyed in a non-LIFO fashion. </p>
<p>Without cleaning up, the scene manager will waste CPU &amp; bandwidth on processing vectors &amp; matrices that are not in use. The more fragmented/unordered those removals were, the worst it is. Try to create everything static first, then dynamic content. </p><dl class="section remark"><dt>Remarks</dt><dd>The manager behaves similarly to a Garbage Collector, as it is triggered after certain amount of nodes have been freed (unless they respected LIFO order)</dd></dl>
<p>In a way, it's very similar to vector::remove(), as removing an element from the middle means we need to shift everything past that point one place (or more). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The hierarchy depth level </td></tr>
    <tr><td class="paramname">basePtrs</td><td>The base ptrs. </td></tr>
    <tr><td class="paramname">startInstance</td><td>The instance to which past that we need to shift </td></tr>
    <tr><td class="paramname">diffInstances</td><td>How many places we need to shift backwards. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_array_memory_manager_1_1_rebase_listener.html#a4d3c6c480b79a8757e1348de53c80adb">Ogre::ArrayMemoryManager::RebaseListener</a>.</p>

</div>
</div>
<a id="a653f6a2a1b0deba78eb242e9d09538ef" name="a653f6a2a1b0deba78eb242e9d09538ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653f6a2a1b0deba78eb242e9d09538ef">&#9670;&#160;</a></span>shrinkToFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ObjectMemoryManager::shrinkToFit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defragments memory, then reallocates a smaller pool that tightly fits the current number of objects.   </p>
<p>Useful when you know you won't be creating more slots and you need to reclaim memory.   </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_object_memory_manager_8h.html">OgreObjectMemoryManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
