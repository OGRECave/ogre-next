<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::Image2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_image2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_image2-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::Image2 Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___image.html">Image</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Class representing an image file.  
 <a href="class_ogre_1_1_image2.html#details">More...</a></p>

<p><code>#include &lt;OgreImage2.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::Image2:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_image2__inherit__graph.svg" width="186" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3c76426b32883e39309d5bb9e62f966a" id="r_a3c76426b32883e39309d5bb9e62f966a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aa695f19b7a87b2da1a76c3607a56026e5">FILTER_NEAREST</a>
, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aafdffe1fd9781087a20f9c2560a5e9552">FILTER_LINEAR</a>
, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1">FILTER_BILINEAR</a>
, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aaa5d78856fa9e8f86c58abac46b97b950">FILTER_BOX</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aadebce2bd74f33f69ee560727beeaf7ae">FILTER_TRIANGLE</a>
, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aae494e47d74b2c2f5f6a7038eda6f6f2b">FILTER_BICUBIC</a>
, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aa112863fa24779bf6d5efc48dd1072d1f">FILTER_GAUSSIAN</a>
, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aaf4a89ed7ab203d0310833c97b68faf23">FILTER_GAUSSIAN_HIGH</a>
<br />
 }</td></tr>
<tr class="separator:a3c76426b32883e39309d5bb9e62f966a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad18b40edf26aa50c846ed4e5cb9c46ca" id="r_ad18b40edf26aa50c846ed4e5cb9c46ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#ad18b40edf26aa50c846ed4e5cb9c46ca">Image2</a> ()</td></tr>
<tr class="separator:ad18b40edf26aa50c846ed4e5cb9c46ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231cd9dc637d048b924737c4eec1a77e" id="r_a231cd9dc637d048b924737c4eec1a77e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a231cd9dc637d048b924737c4eec1a77e">Image2</a> (const <a class="el" href="class_ogre_1_1_image2.html">Image2</a> &amp;img)</td></tr>
<tr class="memdesc:a231cd9dc637d048b924737c4eec1a77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructor - copies all the data from the target image.  <br /></td></tr>
<tr class="separator:a231cd9dc637d048b924737c4eec1a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b4d5f75facd8bc1d7e855e366183ea" id="r_a56b4d5f75facd8bc1d7e855e366183ea"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a56b4d5f75facd8bc1d7e855e366183ea">~Image2</a> ()</td></tr>
<tr class="separator:a56b4d5f75facd8bc1d7e855e366183ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1c994ef2593120e930535c26c83ea3" id="r_a3e1c994ef2593120e930535c26c83ea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a3e1c994ef2593120e930535c26c83ea3">_setAutoDelete</a> (bool autoDelete)</td></tr>
<tr class="separator:a3e1c994ef2593120e930535c26c83ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf13aa1cedd6abda976a6f837d1bd29b" id="r_aaf13aa1cedd6abda976a6f837d1bd29b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#aaf13aa1cedd6abda976a6f837d1bd29b">convertFromTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> minMip, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> maxMip, bool automaticResolve=true)</td></tr>
<tr class="memdesc:aaf13aa1cedd6abda976a6f837d1bd29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously downloads the selected mips from a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> into this Image.  <br /></td></tr>
<tr class="separator:aaf13aa1cedd6abda976a6f837d1bd29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313d5c18ad48dd7e94cba236754121f8" id="r_a313d5c18ad48dd7e94cba236754121f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a313d5c18ad48dd7e94cba236754121f8">createEmptyImage</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> depthOrSlices, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> format, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numMipmaps=1u)</td></tr>
<tr class="memdesc:a313d5c18ad48dd7e94cba236754121f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function.  <br /></td></tr>
<tr class="separator:a313d5c18ad48dd7e94cba236754121f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eb13ec60c94720c3f4f298ea535fdc" id="r_a39eb13ec60c94720c3f4f298ea535fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a39eb13ec60c94720c3f4f298ea535fdc">createEmptyImageLike</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a39eb13ec60c94720c3f4f298ea535fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as createEmptyImage, but retrieves all metadata parameters from the input texture.  <br /></td></tr>
<tr class="separator:a39eb13ec60c94720c3f4f298ea535fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b32812ad755fe1c86c603d990efc89b" id="r_a9b32812ad755fe1c86c603d990efc89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a9b32812ad755fe1c86c603d990efc89b">encode</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;formatextension, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numMipmaps)</td></tr>
<tr class="memdesc:a9b32812ad755fe1c86c603d990efc89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the image and return a stream to the data.  <br /></td></tr>
<tr class="separator:a9b32812ad755fe1c86c603d990efc89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177f56007dff21f99fab04fe75c9cc71" id="r_a177f56007dff21f99fab04fe75c9cc71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a177f56007dff21f99fab04fe75c9cc71">flipAroundX</a> ()</td></tr>
<tr class="memdesc:a177f56007dff21f99fab04fe75c9cc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips (mirrors) the image around the X-axis.  <br /></td></tr>
<tr class="separator:a177f56007dff21f99fab04fe75c9cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dd6fb3e2569edd5b647109b4224c4a" id="r_af5dd6fb3e2569edd5b647109b4224c4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#af5dd6fb3e2569edd5b647109b4224c4a">flipAroundY</a> ()</td></tr>
<tr class="memdesc:af5dd6fb3e2569edd5b647109b4224c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips (mirrors) the image around the Y-axis.  <br /></td></tr>
<tr class="separator:af5dd6fb3e2569edd5b647109b4224c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c2cacf707eef6fa36ef3f8a0b210c6" id="r_aa6c2cacf707eef6fa36ef3f8a0b210c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#aa6c2cacf707eef6fa36ef3f8a0b210c6">freeMemory</a> ()</td></tr>
<tr class="memdesc:aa6c2cacf707eef6fa36ef3f8a0b210c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the memory held by this image, if owned by this image (not dynamic)  <br /></td></tr>
<tr class="separator:aa6c2cacf707eef6fa36ef3f8a0b210c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a609400317652829b640c341eac7fdd" id="r_a5a609400317652829b640c341eac7fdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a5a609400317652829b640c341eac7fdd">generateMipmaps</a> (bool gammaCorrected, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a> filter=<a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1">FILTER_BILINEAR</a>)</td></tr>
<tr class="memdesc:a5a609400317652829b640c341eac7fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the mipmaps for this image.  <br /></td></tr>
<tr class="separator:a5a609400317652829b640c341eac7fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bf677b34c30c57290e1db7ae0f11fc" id="r_a02bf677b34c30c57290e1db7ae0f11fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a02bf677b34c30c57290e1db7ae0f11fc">getAutoDelete</a> () const</td></tr>
<tr class="separator:a02bf677b34c30c57290e1db7ae0f11fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12515aebeac43c582f39dadae156d563" id="r_a12515aebeac43c582f39dadae156d563"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a12515aebeac43c582f39dadae156d563">getBytesPerImage</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel) const</td></tr>
<tr class="separator:a12515aebeac43c582f39dadae156d563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1edc1b909b98df354e3b52d703c9ce2" id="r_ad1edc1b909b98df354e3b52d703c9ce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#ad1edc1b909b98df354e3b52d703c9ce2">getBytesPerRow</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel) const</td></tr>
<tr class="separator:ad1edc1b909b98df354e3b52d703c9ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88b9fb94e9a0fac4435c10a05597cc6" id="r_af88b9fb94e9a0fac4435c10a05597cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#af88b9fb94e9a0fac4435c10a05597cc6">getColourAt</a> (size_t x, size_t y, size_t z, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel=0) const</td></tr>
<tr class="memdesc:af88b9fb94e9a0fac4435c10a05597cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get colour value from a certain location in the image.  <br /></td></tr>
<tr class="separator:af88b9fb94e9a0fac4435c10a05597cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b0b0963105c375ae421d0aa66c665" id="r_aed0b0b0963105c375ae421d0aa66c665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#aed0b0b0963105c375ae421d0aa66c665">getData</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel) const</td></tr>
<tr class="memdesc:aed0b0b0963105c375ae421d0aa66c665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal image buffer.  <br /></td></tr>
<tr class="separator:aed0b0b0963105c375ae421d0aa66c665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d60b388d2706501f8e81f005ad4da25" id="r_a6d60b388d2706501f8e81f005ad4da25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a6d60b388d2706501f8e81f005ad4da25">getDepth</a> () const</td></tr>
<tr class="memdesc:a6d60b388d2706501f8e81f005ad4da25"><td class="mdescLeft">&#160;</td><td class="mdescRight">For TypeCube &amp; TypeCubeArray, this value returns 1.  <br /></td></tr>
<tr class="separator:a6d60b388d2706501f8e81f005ad4da25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5526c65f133ac9c4770d060da41cd230" id="r_a5526c65f133ac9c4770d060da41cd230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a5526c65f133ac9c4770d060da41cd230">getDepthOrSlices</a> () const</td></tr>
<tr class="separator:a5526c65f133ac9c4770d060da41cd230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b34092e39b25018ece11e958f626cd" id="r_ab1b34092e39b25018ece11e958f626cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#ab1b34092e39b25018ece11e958f626cd">getHeight</a> () const</td></tr>
<tr class="separator:ab1b34092e39b25018ece11e958f626cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341d83a329db905ba1deaf81f16e1347" id="r_a341d83a329db905ba1deaf81f16e1347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a341d83a329db905ba1deaf81f16e1347">getNumMipmaps</a> () const</td></tr>
<tr class="separator:a341d83a329db905ba1deaf81f16e1347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf3c5f7163ae7a3e3da5e2a92474a30" id="r_a5bf3c5f7163ae7a3e3da5e2a92474a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a5bf3c5f7163ae7a3e3da5e2a92474a30">getNumSlices</a> () const</td></tr>
<tr class="memdesc:a5bf3c5f7163ae7a3e3da5e2a92474a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">For TypeCube this value returns 6.  <br /></td></tr>
<tr class="separator:a5bf3c5f7163ae7a3e3da5e2a92474a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb07bf197aa72719069268216847539" id="r_a8fb07bf197aa72719069268216847539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a8fb07bf197aa72719069268216847539">getPixelFormat</a> () const</td></tr>
<tr class="separator:a8fb07bf197aa72719069268216847539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865d9c52a751eaa0c9c0393e90962cf5" id="r_a865d9c52a751eaa0c9c0393e90962cf5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a865d9c52a751eaa0c9c0393e90962cf5">getRawBuffer</a> ()</td></tr>
<tr class="separator:a865d9c52a751eaa0c9c0393e90962cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee108eebc0a4fe062e0e7b52e0b51eab" id="r_aee108eebc0a4fe062e0e7b52e0b51eab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#aee108eebc0a4fe062e0e7b52e0b51eab">getSizeBytes</a> () const</td></tr>
<tr class="memdesc:aee108eebc0a4fe062e0e7b52e0b51eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total size in bytes used in GPU by this texture including mipmaps.  <br /></td></tr>
<tr class="separator:aee108eebc0a4fe062e0e7b52e0b51eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b2f34b4b23c1d53a80395adae45b5d" id="r_aa8b2f34b4b23c1d53a80395adae45b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#aa8b2f34b4b23c1d53a80395adae45b5d">getTextureType</a> () const</td></tr>
<tr class="separator:aa8b2f34b4b23c1d53a80395adae45b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381f06196319f0c93c24cb9d1b1bd74e" id="r_a381f06196319f0c93c24cb9d1b1bd74e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a381f06196319f0c93c24cb9d1b1bd74e">getWidth</a> () const</td></tr>
<tr class="separator:a381f06196319f0c93c24cb9d1b1bd74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab92d036f444fc21e273d9ef398fe97" id="r_a2ab92d036f444fc21e273d9ef398fe97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a2ab92d036f444fc21e273d9ef398fe97">load</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName)</td></tr>
<tr class="memdesc:a2ab92d036f444fc21e273d9ef398fe97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an image file.  <br /></td></tr>
<tr class="separator:a2ab92d036f444fc21e273d9ef398fe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2e246db6951ea3931ce782bf70608d" id="r_acc2e246db6951ea3931ce782bf70608d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#acc2e246db6951ea3931ce782bf70608d">load</a> (<a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;type=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:acc2e246db6951ea3931ce782bf70608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an image file from a stream.  <br /></td></tr>
<tr class="separator:acc2e246db6951ea3931ce782bf70608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d525709c60f0cecd95f50687f13e27a" id="r_a1d525709c60f0cecd95f50687f13e27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a1d525709c60f0cecd95f50687f13e27a">load2</a> (<a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename)</td></tr>
<tr class="memdesc:a1d525709c60f0cecd95f50687f13e27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_ogre_1_1_image2.html#a2ab92d036f444fc21e273d9ef398fe97" title="Loads an image file.">load()</a> as but we will try to find the codec by both magic numbers and extension The original <a class="el" href="class_ogre_1_1_image2.html#a2ab92d036f444fc21e273d9ef398fe97" title="Loads an image file.">load()</a> only allows to either use magic number OR name extension This version tries both.  <br /></td></tr>
<tr class="separator:a1d525709c60f0cecd95f50687f13e27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2de619e8267001f7c8690471db77c7" id="r_afe2de619e8267001f7c8690471db77c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#afe2de619e8267001f7c8690471db77c7">loadDynamicImage</a> (void *pData, bool autoDelete, const <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image)</td></tr>
<tr class="separator:afe2de619e8267001f7c8690471db77c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8dc803cebdeef4ae91231aebf483a9" id="r_a2b8dc803cebdeef4ae91231aebf483a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a2b8dc803cebdeef4ae91231aebf483a9">loadDynamicImage</a> (void *pData, bool autoDelete, const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a2b8dc803cebdeef4ae91231aebf483a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function.  <br /></td></tr>
<tr class="separator:a2b8dc803cebdeef4ae91231aebf483a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad896e65db839ac43766ebd1991fc50d" id="r_aad896e65db839ac43766ebd1991fc50d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#aad896e65db839ac43766ebd1991fc50d">loadDynamicImage</a> (void *pData, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> depthOrSlices, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> format, bool autoDelete, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numMipmaps=1u)</td></tr>
<tr class="memdesc:aad896e65db839ac43766ebd1991fc50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to raw data in memory.  <br /></td></tr>
<tr class="separator:aad896e65db839ac43766ebd1991fc50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15248576f7a74232579f06224557007" id="r_ae15248576f7a74232579f06224557007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#ae15248576f7a74232579f06224557007">operator=</a> (const <a class="el" href="class_ogre_1_1_image2.html">Image2</a> &amp;img)</td></tr>
<tr class="memdesc:ae15248576f7a74232579f06224557007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator - copies all the data from the target image.  <br /></td></tr>
<tr class="separator:ae15248576f7a74232579f06224557007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605930f31cc26da8829cbd356e612c6d" id="r_a605930f31cc26da8829cbd356e612c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a605930f31cc26da8829cbd356e612c6d">resize</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a> filter=<a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1">FILTER_BILINEAR</a>)</td></tr>
<tr class="memdesc:a605930f31cc26da8829cbd356e612c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a 2D image, applying the appropriate filter.  <br /></td></tr>
<tr class="separator:a605930f31cc26da8829cbd356e612c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0ab1cfb3f348be3087816ed0d3785b" id="r_a6a0ab1cfb3f348be3087816ed0d3785b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a6a0ab1cfb3f348be3087816ed0d3785b">save</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numMipmaps)</td></tr>
<tr class="memdesc:a6a0ab1cfb3f348be3087816ed0d3785b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the image as a file.  <br /></td></tr>
<tr class="separator:a6a0ab1cfb3f348be3087816ed0d3785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2329729f76e79feae856c6130090af70" id="r_a2329729f76e79feae856c6130090af70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a2329729f76e79feae856c6130090af70">setColourAt</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;cv, size_t x, size_t y, size_t z, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel=0)</td></tr>
<tr class="memdesc:a2329729f76e79feae856c6130090af70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set colour value at a certain location in the image.  <br /></td></tr>
<tr class="separator:a2329729f76e79feae856c6130090af70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb29bff27ed8e1f0ab35c965cb7cbf59" id="r_acb29bff27ed8e1f0ab35c965cb7cbf59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#acb29bff27ed8e1f0ab35c965cb7cbf59">uploadTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> minMip, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> maxMip, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> dstZorSliceStart=0u, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> srcDepthOrSlices=0u)</td></tr>
<tr class="memdesc:acb29bff27ed8e1f0ab35c965cb7cbf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously uploads the selected mips from this Image into a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>.  <br /></td></tr>
<tr class="separator:acb29bff27ed8e1f0ab35c965cb7cbf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1a837e1213f1d754d01d08075f0e5379" id="r_a1a837e1213f1d754d01d08075f0e5379"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a1a837e1213f1d754d01d08075f0e5379">copyContentsToMemory</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *srcTexture, <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> srcBox, <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> dstBox, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> dstFormat, bool automaticResolve=true)</td></tr>
<tr class="memdesc:a1a837e1213f1d754d01d08075f0e5379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously downloads the mip 0 from a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> into the <a class="el" href="struct_ogre_1_1_texture_box.html" title="For cubemaps, the face is in sliceStart, (see CubemapSide::CubemapSide) For cubemap arrays,...">TextureBox</a>.  <br /></td></tr>
<tr class="separator:a1a837e1213f1d754d01d08075f0e5379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f960e9434c80b164ec5eedab59de65" id="r_aa0f960e9434c80b164ec5eedab59de65"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#aa0f960e9434c80b164ec5eedab59de65">getDownsamplerFunctions</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> format, void **imageDownsampler2D, void **imageDownsampler3D, void **imageDownsamplerCube, void **imageBlur2D, bool gammaCorrected, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> depthOrSlices, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a> filter)</td></tr>
<tr class="memdesc:aa0f960e9434c80b164ec5eedab59de65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the proper downsampler functions to generate mipmaps.  <br /></td></tr>
<tr class="separator:aa0f960e9434c80b164ec5eedab59de65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f43ac443c5c1addef1ea6c54aad7d7" id="r_ac9f43ac443c5c1addef1ea6c54aad7d7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#ac9f43ac443c5c1addef1ea6c54aad7d7">getFileExtFromMagic</a> (<a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;stream)</td></tr>
<tr class="memdesc:ac9f43ac443c5c1addef1ea6c54aad7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function to get an image type string from a stream via magic numbers.  <br /></td></tr>
<tr class="separator:ac9f43ac443c5c1addef1ea6c54aad7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da16a65bdbe2a2350d31c6d52c4261e" id="r_a3da16a65bdbe2a2350d31c6d52c4261e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#a3da16a65bdbe2a2350d31c6d52c4261e">scale</a> (const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;src, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> srcFormat, <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;dst, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> dstFormat, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a> filter=<a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1">FILTER_BILINEAR</a>)</td></tr>
<tr class="memdesc:a3da16a65bdbe2a2350d31c6d52c4261e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a 1D, 2D or 3D image volume.  <br /></td></tr>
<tr class="separator:a3da16a65bdbe2a2350d31c6d52c4261e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ab51a51df74ad62c7dc69e93b4397b" id="r_ac1ab51a51df74ad62c7dc69e93b4397b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_image2.html#ac1ab51a51df74ad62c7dc69e93b4397b">supportsSwMipmaps</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> format, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> depthOrSlices, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType, <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a> filter)</td></tr>
<tr class="separator:ac1ab51a51df74ad62c7dc69e93b4397b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing an image file. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The Image class usually holds uncompressed image data and is the only object that can be loaded in a texture. Image objects handle image data decoding themselves by the means of locating the correct <a class="el" href="class_ogre_1_1_codec.html" title="Abstract class that defines a &#39;codec&#39;.">Codec</a> object for each data type. </dd></dl>
<dl class="section user"><dt></dt><dd>Typically, you would want to use an Image object to load a texture when extra processing needs to be done on an image before it is loaded or when you want to blit to an existing texture. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3c76426b32883e39309d5bb9e62f966a" name="a3c76426b32883e39309d5bb9e62f966a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c76426b32883e39309d5bb9e62f966a">&#9670;&#160;</a></span>Filter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Ogre::Image2::Filter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3c76426b32883e39309d5bb9e62f966aa695f19b7a87b2da1a76c3607a56026e5" name="a3c76426b32883e39309d5bb9e62f966aa695f19b7a87b2da1a76c3607a56026e5"></a>FILTER_NEAREST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c76426b32883e39309d5bb9e62f966aafdffe1fd9781087a20f9c2560a5e9552" name="a3c76426b32883e39309d5bb9e62f966aafdffe1fd9781087a20f9c2560a5e9552"></a>FILTER_LINEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1" name="a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1"></a>FILTER_BILINEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c76426b32883e39309d5bb9e62f966aaa5d78856fa9e8f86c58abac46b97b950" name="a3c76426b32883e39309d5bb9e62f966aaa5d78856fa9e8f86c58abac46b97b950"></a>FILTER_BOX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c76426b32883e39309d5bb9e62f966aadebce2bd74f33f69ee560727beeaf7ae" name="a3c76426b32883e39309d5bb9e62f966aadebce2bd74f33f69ee560727beeaf7ae"></a>FILTER_TRIANGLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c76426b32883e39309d5bb9e62f966aae494e47d74b2c2f5f6a7038eda6f6f2b" name="a3c76426b32883e39309d5bb9e62f966aae494e47d74b2c2f5f6a7038eda6f6f2b"></a>FILTER_BICUBIC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3c76426b32883e39309d5bb9e62f966aa112863fa24779bf6d5efc48dd1072d1f" name="a3c76426b32883e39309d5bb9e62f966aa112863fa24779bf6d5efc48dd1072d1f"></a>FILTER_GAUSSIAN&#160;</td><td class="fielddoc"><p>Applies gaussian filter over the image, then a point sampling reduction This is done at the same time (i.e. </p>
<p>we don't blur pixels we ignore). </p>
</td></tr>
<tr><td class="fieldname"><a id="a3c76426b32883e39309d5bb9e62f966aaf4a89ed7ab203d0310833c97b68faf23" name="a3c76426b32883e39309d5bb9e62f966aaf4a89ed7ab203d0310833c97b68faf23"></a>FILTER_GAUSSIAN_HIGH&#160;</td><td class="fielddoc"><p>Applies gaussian filter over the image, then bilinear downsamples. </p>
<p>This prevents certain artifacts for some images when using FILTER_GAUSSIAN, like biasing towards certain direction. Not supported by cubemaps. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad18b40edf26aa50c846ed4e5cb9c46ca" name="ad18b40edf26aa50c846ed4e5cb9c46ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18b40edf26aa50c846ed4e5cb9c46ca">&#9670;&#160;</a></span>Image2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Image2::Image2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a231cd9dc637d048b924737c4eec1a77e" name="a231cd9dc637d048b924737c4eec1a77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231cd9dc637d048b924737c4eec1a77e">&#9670;&#160;</a></span>Image2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Image2::Image2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_image2.html">Image2</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-constructor - copies all the data from the target image. </p>

</div>
</div>
<a id="a56b4d5f75facd8bc1d7e855e366183ea" name="a56b4d5f75facd8bc1d7e855e366183ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b4d5f75facd8bc1d7e855e366183ea">&#9670;&#160;</a></span>~Image2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::Image2::~Image2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e1c994ef2593120e930535c26c83ea3" name="a3e1c994ef2593120e930535c26c83ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1c994ef2593120e930535c26c83ea3">&#9670;&#160;</a></span>_setAutoDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::_setAutoDelete </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDelete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf13aa1cedd6abda976a6f837d1bd29b" name="aaf13aa1cedd6abda976a6f837d1bd29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf13aa1cedd6abda976a6f837d1bd29b">&#9670;&#160;</a></span>convertFromTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::convertFromTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>minMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>maxMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automaticResolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously downloads the selected mips from a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> into this Image. </p>
<p>This function is for convenience for when going async is not important. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minMip</td><td>First mipmap to download, inclusive. </td></tr>
    <tr><td class="paramname">maxMip</td><td>Last mipmap to download, inclusive. </td></tr>
    <tr><td class="paramname">automaticResolve</td><td>When true, we will take care of resolving explicit MSAA textures if necessary, so that the download from GPU works fine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a837e1213f1d754d01d08075f0e5379" name="a1a837e1213f1d754d01d08075f0e5379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a837e1213f1d754d01d08075f0e5379">&#9670;&#160;</a></span>copyContentsToMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Image2::copyContentsToMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>srcTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td>
          <td class="paramname"><em>srcBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td>
          <td class="paramname"><em>dstBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>dstFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automaticResolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously downloads the mip 0 from a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> into the <a class="el" href="struct_ogre_1_1_texture_box.html" title="For cubemaps, the face is in sliceStart, (see CubemapSide::CubemapSide) For cubemap arrays,...">TextureBox</a>. </p>
<p>This function is for convenience for when going async is not important. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBox</td><td>Source region of source texture to download. Only x, y, z, sliceStart, width, height, depth, numSlices fields are used. </td></tr>
    <tr><td class="paramname">dstBox</td><td>Together with dstFormat describes the destination memory region. It is explicitly allowed for this region to be non-contiguous. </td></tr>
    <tr><td class="paramname">dstFormat</td><td>Together with dstBox describes the destination memory region. This format is not required to be the same as the format of the source texture, it could be any supported by bulkPixelConversion, including 24bpp formats. </td></tr>
    <tr><td class="paramname">automaticResolve</td><td>When true, we will take care of resolving explicit MSAA textures if necessary, so that the download from GPU works fine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a313d5c18ad48dd7e94cba236754121f8" name="a313d5c18ad48dd7e94cba236754121f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313d5c18ad48dd7e94cba236754121f8">&#9670;&#160;</a></span>createEmptyImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::createEmptyImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function. </p>
<p>Same as <a class="el" href="class_ogre_1_1_image2.html#aad896e65db839ac43766ebd1991fc50d" title="Stores a pointer to raw data in memory.">Image2::loadDynamicImage</a>, but allocates an uninitialized pointer to store all data and call loadDynamicImage with it </p>

</div>
</div>
<a id="a39eb13ec60c94720c3f4f298ea535fdc" name="a39eb13ec60c94720c3f4f298ea535fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eb13ec60c94720c3f4f298ea535fdc">&#9670;&#160;</a></span>createEmptyImageLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::createEmptyImageLike </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as createEmptyImage, but retrieves all metadata parameters from the input texture. </p>

</div>
</div>
<a id="a9b32812ad755fe1c86c603d990efc89b" name="a9b32812ad755fe1c86c603d990efc89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b32812ad755fe1c86c603d990efc89b">&#9670;&#160;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> Ogre::Image2::encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>formatextension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the image and return a stream to the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatextension</td><td>An extension to identify the image format to encode into, e.g. "jpg" or "png" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a177f56007dff21f99fab04fe75c9cc71" name="a177f56007dff21f99fab04fe75c9cc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177f56007dff21f99fab04fe75c9cc71">&#9670;&#160;</a></span>flipAroundX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::flipAroundX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips (mirrors) the image around the X-axis. </p>
<dl class="section remark"><dt>Remarks</dt><dd>An example of an original and flipped image: <pre>
            flip axis
                |
    originalimg|gmilanigiro
    00000000000|00000000000
    00000000000|00000000000
    00000000000|00000000000
    00000000000|00000000000
    00000000000|00000000000
    </pre> </dd></dl>

</div>
</div>
<a id="af5dd6fb3e2569edd5b647109b4224c4a" name="af5dd6fb3e2569edd5b647109b4224c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dd6fb3e2569edd5b647109b4224c4a">&#9670;&#160;</a></span>flipAroundY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::flipAroundY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips (mirrors) the image around the Y-axis. </p>
<dl class="section remark"><dt>Remarks</dt><dd>An example of an original and flipped image: <pre>
    originalimg
    00000000000
    00000000000
    00000000000
    00000000000
    00000000000
    ------------&gt; flip axis
    00000000000
    00000000000
    00000000000
    00000000000
    00000000000
    originalimg
    </pre> </dd></dl>

</div>
</div>
<a id="aa6c2cacf707eef6fa36ef3f8a0b210c6" name="aa6c2cacf707eef6fa36ef3f8a0b210c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c2cacf707eef6fa36ef3f8a0b210c6">&#9670;&#160;</a></span>freeMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::freeMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all the memory held by this image, if owned by this image (not dynamic) </p>

</div>
</div>
<a id="a5a609400317652829b640c341eac7fdd" name="a5a609400317652829b640c341eac7fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a609400317652829b640c341eac7fdd">&#9670;&#160;</a></span>generateMipmaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Image2::generateMipmaps </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gammaCorrected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1">FILTER_BILINEAR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the mipmaps for this image. </p>
<p>For Cubemaps, the filtering is seamless; and a gaussian filter is recommended although it's slow. </p><dl class="section remark"><dt>Remarks</dt><dd>Cannot handle compressed formats. Gaussian filter is implemented with a generic 1-pass convolution matrix, which in turn means it is O( N^N ) instead of a 2-pass filter which is O( 2^N ); where N is the number of taps. The Gaussian filter is 5x5 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gammaCorrected</td><td>True if the filter should be applied in linear space. </td></tr>
    <tr><td class="paramname">filter</td><td>The type of filter to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if failed to generate and mipmaps properties won't be changed. True on success. </dd></dl>

</div>
</div>
<a id="a02bf677b34c30c57290e1db7ae0f11fc" name="a02bf677b34c30c57290e1db7ae0f11fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bf677b34c30c57290e1db7ae0f11fc">&#9670;&#160;</a></span>getAutoDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Image2::getAutoDelete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12515aebeac43c582f39dadae156d563" name="a12515aebeac43c582f39dadae156d563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12515aebeac43c582f39dadae156d563">&#9670;&#160;</a></span>getBytesPerImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Image2::getBytesPerImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1edc1b909b98df354e3b52d703c9ce2" name="ad1edc1b909b98df354e3b52d703c9ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1edc1b909b98df354e3b52d703c9ce2">&#9670;&#160;</a></span>getBytesPerRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Image2::getBytesPerRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af88b9fb94e9a0fac4435c10a05597cc6" name="af88b9fb94e9a0fac4435c10a05597cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88b9fb94e9a0fac4435c10a05597cc6">&#9670;&#160;</a></span>getColourAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> Ogre::Image2::getColourAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get colour value from a certain location in the image. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is slow as we need to calculate the mipmap offset every time. If you need to call it often, prefer using <a class="el" href="class_ogre_1_1_image2.html#aed0b0b0963105c375ae421d0aa66c665" title="Returns a pointer to the internal image buffer.">Image2::getData</a> and then call <a class="el" href="struct_ogre_1_1_texture_box.html#aa03bb44178bbe534762593ef6748b8d8" title="Get colour value from a certain location in the image.">TextureBox::getColourAt</a> instead. </dd></dl>

</div>
</div>
<a id="aed0b0b0963105c375ae421d0aa66c665" name="aed0b0b0963105c375ae421d0aa66c665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0b0b0963105c375ae421d0aa66c665">&#9670;&#160;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> Ogre::Image2::getData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the internal image buffer. </p>

</div>
</div>
<a id="a6d60b388d2706501f8e81f005ad4da25" name="a6d60b388d2706501f8e81f005ad4da25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d60b388d2706501f8e81f005ad4da25">&#9670;&#160;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Image2::getDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For TypeCube &amp; TypeCubeArray, this value returns 1. </p>

</div>
</div>
<a id="a5526c65f133ac9c4770d060da41cd230" name="a5526c65f133ac9c4770d060da41cd230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5526c65f133ac9c4770d060da41cd230">&#9670;&#160;</a></span>getDepthOrSlices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Image2::getDepthOrSlices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0f960e9434c80b164ec5eedab59de65" name="aa0f960e9434c80b164ec5eedab59de65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f960e9434c80b164ec5eedab59de65">&#9670;&#160;</a></span>getDownsamplerFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::Image2::getDownsamplerFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>imageDownsampler2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>imageDownsampler3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>imageDownsamplerCube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>imageBlur2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gammaCorrected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the proper downsampler functions to generate mipmaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">imageDownsampler2D</td><td>[out] </td></tr>
    <tr><td class="paramname">imageDownsampler3D</td><td>[out] </td></tr>
    <tr><td class="paramname">imageDownsamplerCube</td><td>[out] </td></tr>
    <tr><td class="paramname">imageBlur2D</td><td>[out] </td></tr>
    <tr><td class="paramname">gammaCorrected</td><td>When true, force gamma correction on. If this value is false but format is of the sRGB family, gamma correction will still be used. </td></tr>
    <tr><td class="paramname">depthOrSlices</td><td>Required to properly calculate the return value </td></tr>
    <tr><td class="paramname">textureType</td><td>Required to properly calculate the return value </td></tr>
    <tr><td class="paramname">filter</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if mipmaps can be generated. False if mipmaps cannot be generated. </dd></dl>

</div>
</div>
<a id="ac9f43ac443c5c1addef1ea6c54aad7d7" name="ac9f43ac443c5c1addef1ea6c54aad7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f43ac443c5c1addef1ea6c54aad7d7">&#9670;&#160;</a></span>getFileExtFromMagic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::Image2::getFileExtFromMagic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function to get an image type string from a stream via magic numbers. </p>

</div>
</div>
<a id="ab1b34092e39b25018ece11e958f626cd" name="ab1b34092e39b25018ece11e958f626cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b34092e39b25018ece11e958f626cd">&#9670;&#160;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Image2::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a341d83a329db905ba1deaf81f16e1347" name="a341d83a329db905ba1deaf81f16e1347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341d83a329db905ba1deaf81f16e1347">&#9670;&#160;</a></span>getNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::Image2::getNumMipmaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bf3c5f7163ae7a3e3da5e2a92474a30" name="a5bf3c5f7163ae7a3e3da5e2a92474a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf3c5f7163ae7a3e3da5e2a92474a30">&#9670;&#160;</a></span>getNumSlices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Image2::getNumSlices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For TypeCube this value returns 6. </p>
<p>For TypeCubeArray, value returns numSlices * 6u. </p>

</div>
</div>
<a id="a8fb07bf197aa72719069268216847539" name="a8fb07bf197aa72719069268216847539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb07bf197aa72719069268216847539">&#9670;&#160;</a></span>getPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::Image2::getPixelFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a865d9c52a751eaa0c9c0393e90962cf5" name="a865d9c52a751eaa0c9c0393e90962cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865d9c52a751eaa0c9c0393e90962cf5">&#9670;&#160;</a></span>getRawBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Ogre::Image2::getRawBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee108eebc0a4fe062e0e7b52e0b51eab" name="aee108eebc0a4fe062e0e7b52e0b51eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee108eebc0a4fe062e0e7b52e0b51eab">&#9670;&#160;</a></span>getSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Image2::getSizeBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns total size in bytes used in GPU by this texture including mipmaps. </p>

</div>
</div>
<a id="aa8b2f34b4b23c1d53a80395adae45b5d" name="aa8b2f34b4b23c1d53a80395adae45b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b2f34b4b23c1d53a80395adae45b5d">&#9670;&#160;</a></span>getTextureType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> Ogre::Image2::getTextureType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a381f06196319f0c93c24cb9d1b1bd74e" name="a381f06196319f0c93c24cb9d1b1bd74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381f06196319f0c93c24cb9d1b1bd74e">&#9670;&#160;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Image2::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ab92d036f444fc21e273d9ef398fe97" name="a2ab92d036f444fc21e273d9ef398fe97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab92d036f444fc21e273d9ef398fe97">&#9670;&#160;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an image file. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method loads an image into memory. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> format for which an associated ImageCodec is registered can be loaded. This can include complex formats like DDS with embedded custom mipmaps, cube faces and volume textures. The type can be determined by calling getFormat(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of an image file to load. </td></tr>
    <tr><td class="paramname">groupName</td><td>Name of the resource group to search for the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The memory associated with this buffer is destroyed with the Image object. </dd></dl>

</div>
</div>
<a id="acc2e246db6951ea3931ce782bf70608d" name="acc2e246db6951ea3931ce782bf70608d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2e246db6951ea3931ce782bf70608d">&#9670;&#160;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an image file from a stream. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method works in the same way as the filename-based load method except it loads the image from a <a class="el" href="class_ogre_1_1_data_stream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> object. This <a class="el" href="class_ogre_1_1_data_stream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> is expected to contain the encoded data as it would be held in a file. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> format for which an associated ImageCodec is registered can be loaded. This can include complex formats like DDS with embedded custom mipmaps, cube faces and volume textures. The type can be determined by calling getFormat(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The source data. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the image. Used to decide what decompression codec to use. Can be left blank if the stream data includes a header to identify the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Image::load( const String&amp; filename ) </dd></dl>

</div>
</div>
<a id="a1d525709c60f0cecd95f50687f13e27a" name="a1d525709c60f0cecd95f50687f13e27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d525709c60f0cecd95f50687f13e27a">&#9670;&#160;</a></span>load2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::load2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a8a2a961b4205aacff9c01e81e08d7781">DataStreamPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="class_ogre_1_1_image2.html#a2ab92d036f444fc21e273d9ef398fe97" title="Loads an image file.">load()</a> as but we will try to find the codec by both magic numbers and extension The original <a class="el" href="class_ogre_1_1_image2.html#a2ab92d036f444fc21e273d9ef398fe97" title="Loads an image file.">load()</a> only allows to either use magic number OR name extension This version tries both. </p>

</div>
</div>
<a id="afe2de619e8267001f7c8690471db77c7" name="afe2de619e8267001f7c8690471db77c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2de619e8267001f7c8690471db77c7">&#9670;&#160;</a></span>loadDynamicImage() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::loadDynamicImage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDelete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b8dc803cebdeef4ae91231aebf483a9" name="a2b8dc803cebdeef4ae91231aebf483a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8dc803cebdeef4ae91231aebf483a9">&#9670;&#160;</a></span>loadDynamicImage() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::loadDynamicImage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDelete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function. </p>
<p>Same as <a class="el" href="class_ogre_1_1_image2.html#aad896e65db839ac43766ebd1991fc50d" title="Stores a pointer to raw data in memory.">Image2::loadDynamicImage</a>, but retrieves all metadata parameters from the input texture </p>

</div>
</div>
<a id="aad896e65db839ac43766ebd1991fc50d" name="aad896e65db839ac43766ebd1991fc50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad896e65db839ac43766ebd1991fc50d">&#9670;&#160;</a></span>loadDynamicImage() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::loadDynamicImage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDelete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a pointer to raw data in memory. </p>
<p>The pixel format has to be specified. </p><dl class="section remark"><dt>Remarks</dt><dd>This method loads an image into memory held in the object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps, volume maps, and images including custom mip levels. The layout of the internal memory should be: <ul>
<li>
face 0, mip 0 (top), width x height (x depth) </li>
<li>
face 0, mip 1, width/2 x height/2 (x depth/2) </li>
<li>
.. remaining mips for face 0 ..  </li>
<li>
face 1, mip 0 (top), width x height (x depth) </li>
<li>
.. and so on.  </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>The data pointer. Must've been allocated with <a class="el" href="_ogre_memory_allocator_config_8h.html#afd7ddaef10ac9ea1ffbd18902167b9a2" title="Allocate a block of raw memory aligned to SIMD boundaries, and indicate the category of usage.">OGRE_MALLOC_SIMD( sizeBytes, MEMCATEGORY_RESOURCE )</a>; and sizeBytes assumes a pitch with row alignment = 4u; Use PixelFormatGpuUtils::getSizeBytes( width, 1u, 1u, 1u, pixelFormat, 4u ); to get the pitch. </td></tr>
    <tr><td class="paramname">width</td><td>Width of image </td></tr>
    <tr><td class="paramname">height</td><td>Height of image </td></tr>
    <tr><td class="paramname">depthOrSlices</td><td>Image Depth. For 3D images, it's the depth. For cubemaps it must be 6. For cubemap arrays it must be 6 x num_arrays. For the rest it must be 1. </td></tr>
    <tr><td class="paramname">textureType</td><td>The type of the texture. </td></tr>
    <tr><td class="paramname">format</td><td>Pixel Format </td></tr>
    <tr><td class="paramname">autoDelete</td><td>If memory associated with this buffer is to be destroyed with the Image object. Note: it's important that if you set this option to true, that you allocated the memory using OGRE_MALLOC_SIMD with a category of MEMCATEGORY_RESOURCE to ensure the freeing of memory matches up. </td></tr>
    <tr><td class="paramname">numMipmaps</td><td>The number of mipmaps the image data has inside. A value of 0 is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The memory associated with this buffer is NOT destroyed with the Image object, unless autoDelete is set to true. </dd></dl>

</div>
</div>
<a id="ae15248576f7a74232579f06224557007" name="ae15248576f7a74232579f06224557007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15248576f7a74232579f06224557007">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> &amp; Ogre::Image2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_image2.html">Image2</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator - copies all the data from the target image. </p>

</div>
</div>
<a id="a605930f31cc26da8829cbd356e612c6d" name="a605930f31cc26da8829cbd356e612c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605930f31cc26da8829cbd356e612c6d">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1">FILTER_BILINEAR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a 2D image, applying the appropriate filter. </p>

</div>
</div>
<a id="a6a0ab1cfb3f348be3087816ed0d3785b" name="a6a0ab1cfb3f348be3087816ed0d3785b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0ab1cfb3f348be3087816ed0d3785b">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the image as a file. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Saving and loading are implemented by back end (sometimes third party) codecs. Implemented saving functionality is more limited than loading in some cases. Particularly DDS file format support is currently limited to true colour or single channel float32, square, power of two textures with no mipmaps. Volumetric support is currently limited to DDS files. </dd></dl>

</div>
</div>
<a id="a3da16a65bdbe2a2350d31c6d52c4261e" name="a3da16a65bdbe2a2350d31c6d52c4261e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da16a65bdbe2a2350d31c6d52c4261e">&#9670;&#160;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Image2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>srcFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>dstFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966aab7314dfaf587f6a57a8ac404e5186ed1">FILTER_BILINEAR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale a 1D, 2D or 3D image volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>PixelBox containing the source pointer, dimensions and format </td></tr>
    <tr><td class="paramname">dst</td><td>PixelBox containing the destination pointer, dimensions and format </td></tr>
    <tr><td class="paramname">filter</td><td>Which filter to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can do pixel format conversion in the process. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>dst and src can point to the same PixelBox object without any problem </dd></dl>

</div>
</div>
<a id="a2329729f76e79feae856c6130090af70" name="a2329729f76e79feae856c6130090af70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2329729f76e79feae856c6130090af70">&#9670;&#160;</a></span>setColourAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::setColourAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set colour value at a certain location in the image. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is slow as we need to calculate the mipmap offset every time. If you need to call it often, prefer using <a class="el" href="class_ogre_1_1_image2.html#aed0b0b0963105c375ae421d0aa66c665" title="Returns a pointer to the internal image buffer.">Image2::getData</a> and then call <a class="el" href="struct_ogre_1_1_texture_box.html#adf17acee81fd9154a8490e6eb432188b" title="Set colour value at a certain location in the image.">TextureBox::setColourAt</a> instead. </dd></dl>

</div>
</div>
<a id="ac1ab51a51df74ad62c7dc69e93b4397b" name="ac1ab51a51df74ad62c7dc69e93b4397b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ab51a51df74ad62c7dc69e93b4397b">&#9670;&#160;</a></span>supportsSwMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::Image2::supportsSwMipmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html#a3c76426b32883e39309d5bb9e62f966a">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb29bff27ed8e1f0ab35c965cb7cbf59" name="acb29bff27ed8e1f0ab35c965cb7cbf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb29bff27ed8e1f0ab35c965cb7cbf59">&#9670;&#160;</a></span>uploadTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Image2::uploadTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>minMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>maxMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>dstZorSliceStart</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>srcDepthOrSlices</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously uploads the selected mips from this Image into a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>. </p>
<p>This function is for convenience for when going async is not important. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture to upload to. Must have the same resolution and same pixel format family as this Image. For simplicity, you can't upload mip 0 of this image into mip 1. </td></tr>
    <tr><td class="paramname">minMip</td><td>First mipmap to upload, inclusive. </td></tr>
    <tr><td class="paramname">maxMip</td><td>Last mipmap to upload, inclusive. </td></tr>
    <tr><td class="paramname">dstZorSliceStart</td><td>Destination offset in the texture (e.g. when dstZorSliceStart = 5, it uploads N slices between [5; 5+N) ) </td></tr>
    <tr><td class="paramname">srcDepthOrSlices</td><td>How many slices from this <a class="el" href="class_ogre_1_1_image2.html" title="Class representing an image file.">Image2</a> to upload. Zero to upload all of them. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_image2_8h.html">OgreImage2.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_image2.html">Image2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
