<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Threading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('threading.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Threading</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ThreadingInitializing">Initializing</a><ul><li class="level2"><a href="#ThreadingInitializingNumberOfThreads">Ideal number of threads</a></li>
</ul>
</li>
<li class="level1"><a href="#ThreadingInOgre">What tasks are threaded in Ogre</a></li>
<li class="level1"><a href="#ThreadingCustomTasks">Using Ogre&#39;s threading system for custom tasks</a></li>
<li class="level1"><a href="#ThreadSafetySceneNodes">Thread safety of SceneNodes</a></li>
</ul>
</div>
<div class="textblock"><p>OgreNext uses synchronous threading for some of its operations. This means the main thread wakes up the worker threads, and waits for all worker threads to finish. It also means users don't have to be worried that <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> is using CPU cores while the application is outside a <code>renderOneFrame</code> call.</p>
<h1><a class="anchor" id="ThreadingInitializing"></a>
Initializing</h1>
<p>The number of worker threads must be provided by the user when creating the SceneManager:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> numThreads = 4;</div>
<div class="line">InstancingTheadedCullingMethod</div>
<div class="line">        threadedCullingMethod = INSTANCING_CULLING_THREADED;</div>
<div class="line"> </div>
<div class="line">mSceneMgr = mRoot-&gt;createSceneManager( ST_GENERIC,numThreads,</div>
<div class="line">                                       threadedCullingMethod,</div>
<div class="line">                                       <span class="stringliteral">&quot;ExampleSMInstance&quot;</span> );</div>
</div><!-- fragment --><p>The other threading parameter besides the number of threads, is the threading strategy used for Instancing, which can be single threaded or multithreaded.</p>
<h2><a class="anchor" id="ThreadingInitializingNumberOfThreads"></a>
Ideal number of threads</h2>
<p>The threading model is synchronous, and meant to be used for tasks that take roughly the same amount of time in each thread (which is a very important assumption!). The ideal number of worker threads is the number of logical cores exposed by the CPU (excluding hyperthreading cores).</p>
<p>Spawning more threads than cores will oversubscribe the system and won't run faster. In fact it should only slow it down.</p>
<p>If you plan to use a whole core for your own computations that will run in parallel while renderOneFrame is working (i.e. one thread for physics) and take a significant cpu time from that core; then in this case the ideal number of threads becomes number_of_logical_cores â€“ 1</p>
<p>Whether increasing the number of threads to include hyperthreading cores improves performance or not remains to be tested.</p>
<h1><a class="anchor" id="ThreadingInOgre"></a>
What tasks are threaded in Ogre</h1>
<p>The following tasks are partitioned into multiple threads:</p>
<ul>
<li><b>Frustum culling:</b> The pool of all visible Entities, InstanceBatches, etc are frustum culled in multiple threads and added to a culled list, one per thread. When all threads are done, the main thread collects the results from all lists.</li>
<li><p class="startli"><b>Culling the receiver's box:</b> Very specific to shadow nodes. When a render_scene pass uses (for example) render queues 4 to 8, but the shadow node users render queues 0 to 8; the shadow node needs receiver's aabb data from RQs 0 to 3; which aren't available. It is very similar to frustum culling; except that the cull list isn't produced, only the aabb is calculated. Since aabb merges are associative:<img src="aabb_merge.svg" alt="" style="pointer-events: none;" class="inline"/>    </p>
<p class="startli">we can join the results from all threads after they're done. In fact, we even exploit this associative property to process them using SIMD.</p>
</li>
<li>Node transform updates: Updating all scene nodes' derived position and orientation by inheriting from their parent's derived position &amp; orientation. We have to wait for every parent level depth due to data dependencies.</li>
<li>Updating all bounds: Updating the World AABB by applying the node's transform to the local aabbs. The World AABB is needed for correct frustum culling, among other things.</li>
<li>Frustum culling instanced entities: See previous section.</li>
</ul>
<h1><a class="anchor" id="ThreadingCustomTasks"></a>
Using Ogre's threading system for custom tasks</h1>
<p>While often users may want to user their own threading system; it is possible to ask <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to process their own task using its worker threads. Users need to inherit from <code>UniformScalableTask</code> and call <code>SceneManager::executeUserScalableTask</code>.</p>
<p>The following example prints a message to the console from the multipler worker threads:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_ogre_uniform_scalable_task_8h.html">Threading/OgreUniformScalableTask.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyThreadedTask : <span class="keyword">public</span> <a class="code hl_class" href="class_ogre_1_1_uniform_scalable_task.html">Ogre::UniformScalableTask</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="class_ogre_1_1_uniform_scalable_task.html#ad338932c0cd004166628573d83cf260f">execute</a>( <span class="keywordtype">size_t</span> threadId, <span class="keywordtype">size_t</span> numThreads )</div>
<div class="line">    {</div>
<div class="line">        printf( <span class="stringliteral">&quot;Hello world from thread %i&quot;</span>,threadId );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// assumes Ogre is initialized and sceneMgr is a valid ptr</span></div>
<div class="line">    <a class="code hl_class" href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a> *sceneMgr;</div>
<div class="line"> </div>
<div class="line">    MyThreadedTask myThreadedTask;</div>
<div class="line">    sceneMgr-&gt;<a class="code hl_function" href="class_ogre_1_1_scene_manager.html#a040241bad11b74f5ba8971fb146f8c6d">executeUserScalableTask</a>( myThreadedTask,<span class="keyword">true</span> );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_ogre_uniform_scalable_task_8h_html"><div class="ttname"><a href="_ogre_uniform_scalable_task_8h.html">OgreUniformScalableTask.h</a></div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a></div><div class="ttdoc">Manages the organisation and rendering of a 'scene' i.e.</div><div class="ttdef"><b>Definition</b> OgreSceneManager.h:235</div></div>
<div class="ttc" id="aclass_ogre_1_1_scene_manager_html_a040241bad11b74f5ba8971fb146f8c6d"><div class="ttname"><a href="class_ogre_1_1_scene_manager.html#a040241bad11b74f5ba8971fb146f8c6d">Ogre::SceneManager::executeUserScalableTask</a></div><div class="ttdeci">void executeUserScalableTask(UniformScalableTask *task, bool bBlock)</div><div class="ttdoc">Processes a user-defined UniformScalableTask in the worker threads spawned by SceneManager.</div></div>
<div class="ttc" id="aclass_ogre_1_1_uniform_scalable_task_html"><div class="ttname"><a href="class_ogre_1_1_uniform_scalable_task.html">Ogre::UniformScalableTask</a></div><div class="ttdoc">A uniform task is a highly parallelizable task that can be divided in many threads where all threads ...</div><div class="ttdef"><b>Definition</b> OgreUniformScalableTask.h:46</div></div>
<div class="ttc" id="aclass_ogre_1_1_uniform_scalable_task_html_ad338932c0cd004166628573d83cf260f"><div class="ttname"><a href="class_ogre_1_1_uniform_scalable_task.html#ad338932c0cd004166628573d83cf260f">Ogre::UniformScalableTask::execute</a></div><div class="ttdeci">virtual void execute(size_t threadId, size_t numThreads)=0</div><div class="ttdoc">Overload this function to perform whatever you want.</div></div>
</div><!-- fragment --><p>Parameter <code>threadId</code> is guaranteed to be in range [0; numThreads) while parameter <code>numThreads</code> is the total number of worker threads spawned by that SceneManager.</p>
<p><code>executeUserScalableTask</code> will block until all threads are done. If you do not wish to block; you can pass false to the second argument and then call <code>waitForPendingUserScalableTask</code> to block until done:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// assumes Ogre is intialized and sceneMgr is a valid ptr</span></div>
<div class="line">    SceneManager *sceneMgr;</div>
<div class="line"> </div>
<div class="line">    MyThreadedTask myThreadedTask;</div>
<div class="line">    sceneMgr-&gt;executeUserScalableTask( myThreadedTask, <span class="keyword">false</span> );</div>
<div class="line"> </div>
<div class="line">    doSomeWork();</div>
<div class="line">    printf( <span class="stringliteral">&quot;I am going to sleep now&quot;</span> );</div>
<div class="line"> </div>
<div class="line">    sceneMgr-&gt;waitForPendingUserScalableTask();</div>
<div class="line"> </div>
<div class="line">    printf( <span class="stringliteral">&quot;All worker threads finished. Resuming execution of main thread&quot;</span> );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj; Attention!</p>
<p>You <b>must</b> call <em>waitForPendingUserScalableTask</em> after calling <em>executeUserScalableTask</em>( myThreadedTask, false ) before <em>executeUserScalableTask</em> can be called again. Otherwise deadlocks are bound to happen and <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> makes no integrity checks. Queuing or scheduling of multiples tasks is not supported. This system is for synchronous multithreading, not for asynchronous tasks. </p>
</blockquote>
<h1><a class="anchor" id="ThreadSafetySceneNodes"></a>
Thread safety of SceneNodes</h1>
<p>In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x; SceneNodes weren't thread safe at all, not even <code>setPosition</code> or <code>_getDerivedPosition</code>.</p>
<p>In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.x, the following <b>operations are not thread safe</b>:</p>
<ul>
<li><b>Creating or destroying nodes/entities</b>. Don't create a SceneNode while there are scene nodes being used in other threads. It can screw the unique ID and their assignment into the global vector we use to keep track of created nodes. Furthermore The node's memory manager may ran out of memory in its pool and reconstruct the Transform's SoA pointers (it's similar to how <code>std::vector</code> invalidates all iterators when resizing). If that happens, all SceneNodes will be in an inconsistent state. Inversely, if too many nodes have been removed, the manager may decide it's time for a cleanup, in which case many SceneNodes can become in an inconsistent state until the cleanup finishes. How large the pool reserve is can be tweaked, and how often the manager performs can also be tweaked (<code>NodeMemoryManager</code>), though. If the user knows what he's doing the race condition might be possible to avoid. Note other SceneManager implementations may have to fulfill their own needs and introduce race conditions of their own we can't predict.</li>
<li><b>Changing parent / child relationships</b>. Attaching/detaching a node from another one causes its SoA memory to migrate to a different node memory manager, which can trigger a cleanup and/or one of the managers rans out of memory and has to reconstruct.</li>
<li><b>Calling _getDerivedPositionUpdated &amp; Co (all functions that end in "Updated")</b>. These functions will update the derived transforms all way up to the ultimate parent (i.e. root). However in SIMD builds, these updates are performed on 4 nodes at a time (the actual number is not 4, but rather depends on <code>ARRAY_PACKED_REALS</code>). Calling this function could only be thread safe if all all four nodes are in the same thread AND their parents are also on the same thread (parents may not share the same block, thus worst case scenario <code>4 * 4 = 16</code> parent nodes have to be in the same thread, not to mention their parents too <code>4 * 4 * 4 = 64</code>) AND the children of these parents are not calling <code>_getDerivedPositionUpdated</code> too from a different thread.</li>
</ul>
<p>The following operations are thread-safe:</p>
<ul>
<li><b>Calling getPosition &amp; Co (getOrientation, getScale, getInheritOrientation, etc), _getDerivedPosition &amp; Co (_getDerivedOrientation, etc)</b> unless you're calling <code>getPosition</code> and <code>setPosition</code> to the same Node from different threads.</li>
<li><b>Calling setPosition, setOrientation, setScale</b>. Note on SIMD builds, 4 Nodes can easily share the same 64 byte line, thus it is advisable that all 4 Nodes to be sent to the same thread to reduce the number of false cache sharing performance hits. Calling setPosition to the same Node from different threads is not supported.</li>
<li><b>Calling _setDerivedPosition, _setDerivedOrientation, _setDerivedScale</b> (which assumes the derived transforms are up to date)</li>
</ul>
<p>With <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0; it is now possible to transfer the position &amp; orientation from a physics engine to <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> Scene Nodes using a parallel for. <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x limitations forced this update to be done in a single thread. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
