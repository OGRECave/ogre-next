<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::ConstBufferPacked Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;latest</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_const_buffer_packed.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_const_buffer_packed-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::ConstBufferPacked Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Represents constant buffers (also known as Uniform Buffers in GL)  
 <a href="class_ogre_1_1_const_buffer_packed.html#details">More...</a></p>

<p><code>#include &lt;OgreConstBufferPacked.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::ConstBufferPacked:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_const_buffer_packed__inherit__graph.svg" width="851" height="299"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac4c0ecc5b5189f3821deb162916b6fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_const_buffer_packed.html#aac4c0ecc5b5189f3821deb162916b6fd">ConstBufferPacked</a> (size_t internalBufferStartBytes, size_t numElements, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> bytesPerElement, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numElementsPadding, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow, <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, <a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> *bufferInterface)</td></tr>
<tr class="separator:aac4c0ecc5b5189f3821deb162916b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37ea9428b44a71cb1871a81575dbb05"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#aa37ea9428b44a71cb1871a81575dbb05">_getFinalBufferStart</a> () const</td></tr>
<tr class="separator:aa37ea9428b44a71cb1871a81575dbb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85870bfb2bd749e510c657c741fe34fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a85870bfb2bd749e510c657c741fe34fe">_getInternalBufferStart</a> () const</td></tr>
<tr class="separator:a85870bfb2bd749e510c657c741fe34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5103334929d2d6f7b7f0d060755b6b93"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a5103334929d2d6f7b7f0d060755b6b93">_getInternalNumElements</a> () const</td></tr>
<tr class="separator:a5103334929d2d6f7b7f0d060755b6b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa8e912c5d5a7f8105bac4d34ef1fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a9faa8e912c5d5a7f8105bac4d34ef1fb">_getInternalTotalSizeBytes</a> () const</td></tr>
<tr class="separator:a9faa8e912c5d5a7f8105bac4d34ef1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfd9629389ccf2aedec4b37f5a1b403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a7cfd9629389ccf2aedec4b37f5a1b403">_setBufferInterface</a> (<a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> *bufferInterface)</td></tr>
<tr class="memdesc:a7cfd9629389ccf2aedec4b37f5a1b403"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <a href="class_ogre_1_1_buffer_packed.html#a7cfd9629389ccf2aedec4b37f5a1b403">More...</a><br /></td></tr>
<tr class="separator:a7cfd9629389ccf2aedec4b37f5a1b403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564935579f2252627f46dff29142e7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a564935579f2252627f46dff29142e7ff">_setShadowCopy</a> (void *copy)</td></tr>
<tr class="memdesc:a564935579f2252627f46dff29142e7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will not delete the existing shadow copy so it can be used for other purposes if it is not needed call OGRE_FREE_SIMD( m-&gt;<a class="el" href="class_ogre_1_1_buffer_packed.html#a1b7bf642c5f9e50f76b64f0f02766bb8">getShadowCopy()</a>, MEMCATEGORY_GEOMETRY ) before calling this function.  <a href="class_ogre_1_1_buffer_packed.html#a564935579f2252627f46dff29142e7ff">More...</a><br /></td></tr>
<tr class="separator:a564935579f2252627f46dff29142e7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0112a692634211043593b7fd20440c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a1b0112a692634211043593b7fd20440c">advanceFrame</a> ()</td></tr>
<tr class="separator:a1b0112a692634211043593b7fd20440c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ebc58e115b22366cd335aae75ac32b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_const_buffer_packed.html#aa4ebc58e115b22366cd335aae75ac32b">bindBufferCS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot)=0</td></tr>
<tr class="separator:aa4ebc58e115b22366cd335aae75ac32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436cc723379e0e67c4e5d22c74d9ba37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_const_buffer_packed.html#a436cc723379e0e67c4e5d22c74d9ba37">bindBufferDS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot)=0</td></tr>
<tr class="separator:a436cc723379e0e67c4e5d22c74d9ba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b27c3cb36b31d0a5392e43e035bdfca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_const_buffer_packed.html#a3b27c3cb36b31d0a5392e43e035bdfca">bindBufferGS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot)=0</td></tr>
<tr class="separator:a3b27c3cb36b31d0a5392e43e035bdfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed96e493b0376c743afa5351c6c96c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_const_buffer_packed.html#a7fed96e493b0376c743afa5351c6c96c">bindBufferHS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot)=0</td></tr>
<tr class="separator:a7fed96e493b0376c743afa5351c6c96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3101b4be513445b4095ad7ee8b7da265"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_const_buffer_packed.html#a3101b4be513445b4095ad7ee8b7da265">bindBufferPS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot)=0</td></tr>
<tr class="separator:a3101b4be513445b4095ad7ee8b7da265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecf6ab68e08468525626cfd253edfef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_const_buffer_packed.html#a4ecf6ab68e08468525626cfd253edfef">bindBufferVS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot)=0</td></tr>
<tr class="memdesc:a4ecf6ab68e08468525626cfd253edfef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the constant buffer to the given slot in the Vertex/Pixel/Geometry/Hull/Domain/Compute Shader.  <a href="class_ogre_1_1_const_buffer_packed.html#a4ecf6ab68e08468525626cfd253edfef">More...</a><br /></td></tr>
<tr class="separator:a4ecf6ab68e08468525626cfd253edfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162e23ff6f3cb7f90ed129d3906c14e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a162e23ff6f3cb7f90ed129d3906c14e4">copyTo</a> (<a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *dstBuffer, size_t dstElemStart=0, size_t srcElemStart=0, size_t srcNumElems=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="memdesc:a162e23ff6f3cb7f90ed129d3906c14e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of this buffer to another, using GPU -&gt; GPU transfers.  <a href="class_ogre_1_1_buffer_packed.html#a162e23ff6f3cb7f90ed129d3906c14e4">More...</a><br /></td></tr>
<tr class="separator:a162e23ff6f3cb7f90ed129d3906c14e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645fc6a5e5b03d62f276bcc235f28f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a645fc6a5e5b03d62f276bcc235f28f80">getBufferInterface</a> () const</td></tr>
<tr class="separator:a645fc6a5e5b03d62f276bcc235f28f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9634ab16d39a3f581e65ddc5945e7872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ab66e67b60d5f40dacf69ea55b82868ab">BufferPackedTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_const_buffer_packed.html#a9634ab16d39a3f581e65ddc5945e7872">getBufferPackedType</a> () const override</td></tr>
<tr class="memdesc:a9634ab16d39a3f581e65ddc5945e7872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful to query which one is the derived class.  <a href="class_ogre_1_1_const_buffer_packed.html#a9634ab16d39a3f581e65ddc5945e7872">More...</a><br /></td></tr>
<tr class="separator:a9634ab16d39a3f581e65ddc5945e7872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f44e7867f5ff341d8660fd5cae8ff68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a6f44e7867f5ff341d8660fd5cae8ff68">getBufferType</a> () const</td></tr>
<tr class="separator:a6f44e7867f5ff341d8660fd5cae8ff68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d74a62dabdc8e40db8f23e268e8fabe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a9d74a62dabdc8e40db8f23e268e8fabe">getBytesPerElement</a> () const</td></tr>
<tr class="separator:a9d74a62dabdc8e40db8f23e268e8fabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec44373d3656928fe7a8cc9a16c7b03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a447e51d7625af79716667cebcfa6da57">MappingState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a7ec44373d3656928fe7a8cc9a16c7b03">getMappingState</a> () const</td></tr>
<tr class="memdesc:a7ec44373d3656928fe7a8cc9a16c7b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping state.  <a href="class_ogre_1_1_buffer_packed.html#a7ec44373d3656928fe7a8cc9a16c7b03">More...</a><br /></td></tr>
<tr class="separator:a7ec44373d3656928fe7a8cc9a16c7b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024eb2f73c90ee052b3b1b275b0c83ef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a024eb2f73c90ee052b3b1b275b0c83ef">getNumElements</a> () const</td></tr>
<tr class="separator:a024eb2f73c90ee052b3b1b275b0c83ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df92c5e54775c1f7f3359fedf79d3e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a7df92c5e54775c1f7f3359fedf79d3e6">getOriginalBufferType</a> ()</td></tr>
<tr class="memdesc:a7df92c5e54775c1f7f3359fedf79d3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this buffer has been reinterpreted from an <a class="el" href="class_ogre_1_1_uav_buffer_packed.html" title="Represents UAV buffers (also known as SSBOs in OpenGL) Uav buffers are supported in DX10/DX10....">UavBufferPacked</a>, returns the original version, otherwise returns 'this'.  <a href="class_ogre_1_1_buffer_packed.html#a7df92c5e54775c1f7f3359fedf79d3e6">More...</a><br /></td></tr>
<tr class="separator:a7df92c5e54775c1f7f3359fedf79d3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7bf642c5f9e50f76b64f0f02766bb8"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a1b7bf642c5f9e50f76b64f0f02766bb8">getShadowCopy</a> () const</td></tr>
<tr class="separator:a1b7bf642c5f9e50f76b64f0f02766bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce07a6d2e0d181085bcdb7c2b49051"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#ab9ce07a6d2e0d181085bcdb7c2b49051">getTotalSizeBytes</a> () const</td></tr>
<tr class="separator:ab9ce07a6d2e0d181085bcdb7c2b49051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c781040cdfc2c1d3ac9fc3a7cd9097"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a63c781040cdfc2c1d3ac9fc3a7cd9097">isCurrentlyMapped</a> () const</td></tr>
<tr class="memdesc:a63c781040cdfc2c1d3ac9fc3a7cd9097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the buffer is currently mapped.  <a href="class_ogre_1_1_buffer_packed.html#a63c781040cdfc2c1d3ac9fc3a7cd9097">More...</a><br /></td></tr>
<tr class="separator:a63c781040cdfc2c1d3ac9fc3a7cd9097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24625894d83ec3f90972a350f27e60a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_gpu_tracked_resource.html#ab24625894d83ec3f90972a350f27e60a">isTextureGpu</a> () const</td></tr>
<tr class="separator:ab24625894d83ec3f90972a350f27e60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a2ccddbb2fc851304ae81eb78243ed"><td class="memItemLeft" align="right" valign="top">void *<a class="el" href="_ogre_platform_8h.html#a59a62dcc672b5775f3bd2a8d08bb60a4">RESTRICT_ALIAS_RETURN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed">map</a> (size_t elementStart, size_t elementCount, bool bAdvanceFrame=true)</td></tr>
<tr class="memdesc:a24a2ccddbb2fc851304ae81eb78243ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the specified region to a pointer the CPU can access.  <a href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed">More...</a><br /></td></tr>
<tr class="separator:a24a2ccddbb2fc851304ae81eb78243ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c6682bd4adc315782091679d230cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aef9bfd2a5567613e99bc8d7eae1c1bf9">AsyncTicketPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a80c6682bd4adc315782091679d230cee">readRequest</a> (size_t elementStart, size_t elementCount)</td></tr>
<tr class="memdesc:a80c6682bd4adc315782091679d230cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Async data read request.  <a href="class_ogre_1_1_buffer_packed.html#a80c6682bd4adc315782091679d230cee">More...</a><br /></td></tr>
<tr class="separator:a80c6682bd4adc315782091679d230cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1e2da7aed186b9fd6c4f88a4f9734b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a8a1e2da7aed186b9fd6c4f88a4f9734b">regressFrame</a> ()</td></tr>
<tr class="memdesc:a8a1e2da7aed186b9fd6c4f88a4f9734b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the opposite of.  <a href="class_ogre_1_1_buffer_packed.html#a8a1e2da7aed186b9fd6c4f88a4f9734b">More...</a><br /></td></tr>
<tr class="separator:a8a1e2da7aed186b9fd6c4f88a4f9734b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e02f6b2fa2c16340c1a9359926b481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a73e02f6b2fa2c16340c1a9359926b481">unmap</a> (<a class="el" href="namespace_ogre.html#a118de288d2577e6d95183777f40e57c7">UnmapOptions</a> unmapOption, size_t flushStartElem=0, size_t flushSizeElem=0)</td></tr>
<tr class="memdesc:a73e02f6b2fa2c16340c1a9359926b481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps or flushes the region mapped with.  <a href="class_ogre_1_1_buffer_packed.html#a73e02f6b2fa2c16340c1a9359926b481">More...</a><br /></td></tr>
<tr class="separator:a73e02f6b2fa2c16340c1a9359926b481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6fb3d387685e50e2b5069164b95e6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a0c6fb3d387685e50e2b5069164b95e6b">upload</a> (const void *data, size_t elementStart, size_t elementCount)</td></tr>
<tr class="memdesc:a0c6fb3d387685e50e2b5069164b95e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the provided data to the GPU.  <a href="class_ogre_1_1_buffer_packed.html#a0c6fb3d387685e50e2b5069164b95e6b">More...</a><br /></td></tr>
<tr class="separator:a0c6fb3d387685e50e2b5069164b95e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents constant buffers (also known as Uniform Buffers in GL) </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aac4c0ecc5b5189f3821deb162916b6fd" name="aac4c0ecc5b5189f3821deb162916b6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4c0ecc5b5189f3821deb162916b6fd">&#9670;&#160;</a></span>ConstBufferPacked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ConstBufferPacked::ConstBufferPacked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>internalBufferStartBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>bytesPerElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numElementsPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> *&#160;</td>
          <td class="paramname"><em>bufferInterface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa37ea9428b44a71cb1871a81575dbb05" name="aa37ea9428b44a71cb1871a81575dbb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37ea9428b44a71cb1871a81575dbb05">&#9670;&#160;</a></span>_getFinalBufferStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::BufferPacked::_getFinalBufferStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85870bfb2bd749e510c657c741fe34fe" name="a85870bfb2bd749e510c657c741fe34fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85870bfb2bd749e510c657c741fe34fe">&#9670;&#160;</a></span>_getInternalBufferStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::BufferPacked::_getInternalBufferStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5103334929d2d6f7b7f0d060755b6b93" name="a5103334929d2d6f7b7f0d060755b6b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5103334929d2d6f7b7f0d060755b6b93">&#9670;&#160;</a></span>_getInternalNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::BufferPacked::_getInternalNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9faa8e912c5d5a7f8105bac4d34ef1fb" name="a9faa8e912c5d5a7f8105bac4d34ef1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faa8e912c5d5a7f8105bac4d34ef1fb">&#9670;&#160;</a></span>_getInternalTotalSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::BufferPacked::_getInternalTotalSizeBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cfd9629389ccf2aedec4b37f5a1b403" name="a7cfd9629389ccf2aedec4b37f5a1b403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfd9629389ccf2aedec4b37f5a1b403">&#9670;&#160;</a></span>_setBufferInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BufferPacked::_setBufferInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> *&#160;</td>
          <td class="paramname"><em>bufferInterface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use. </p>

</div>
</div>
<a id="a564935579f2252627f46dff29142e7ff" name="a564935579f2252627f46dff29142e7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564935579f2252627f46dff29142e7ff">&#9670;&#160;</a></span>_setShadowCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BufferPacked::_setShadowCopy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will not delete the existing shadow copy so it can be used for other purposes if it is not needed call OGRE_FREE_SIMD( m-&gt;<a class="el" href="class_ogre_1_1_buffer_packed.html#a1b7bf642c5f9e50f76b64f0f02766bb8">getShadowCopy()</a>, MEMCATEGORY_GEOMETRY ) before calling this function. </p>
<p >This will also not automatically upload the shadow data to the GPU. The user must call upload or use a staging buffer themselves to achieve this. </p>

</div>
</div>
<a id="a1b0112a692634211043593b7fd20440c" name="a1b0112a692634211043593b7fd20440c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0112a692634211043593b7fd20440c">&#9670;&#160;</a></span>advanceFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BufferPacked::advanceFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed" title="Maps the specified region to a pointer the CPU can access.">map</a>. Do NOT call this function more than once per frame, or if you've called <a class="el" href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed" title="Maps the specified region to a pointer the CPU can access.">map</a>( <a class="el" href="class_ogre_1_1_buffer_packed.html#a1b0112a692634211043593b7fd20440c">advanceFrame</a> = true ) </dd></dl>

</div>
</div>
<a id="aa4ebc58e115b22366cd335aae75ac32b" name="aa4ebc58e115b22366cd335aae75ac32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ebc58e115b22366cd335aae75ac32b">&#9670;&#160;</a></span>bindBufferCS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ConstBufferPacked::bindBufferCS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_g_l_e_s2_const_buffer_packed.html#a935e6ecfd85c181f447dabe176902311">Ogre::GLES2ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_d3_d11_const_buffer_packed.html#af6b0bdca05f9d3a66a24eb2c7e7ef6db">Ogre::D3D11ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_const_buffer_packed.html#a1258d298e61d1a3d08234e064e1ce9f2">Ogre::GL3PlusConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_metal_const_buffer_packed.html#ae86f96309a2c8bf47cd4ffe1d66cfb55">Ogre::MetalConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_const_buffer_packed.html#a52a6f2d065480ac4eeb292907052c3f8">Ogre::NULLConstBufferPacked</a>, and <a class="el" href="class_ogre_1_1_vulkan_const_buffer_packed.html#a05e5d39d735e641e55b42192f5eb9573">Ogre::VulkanConstBufferPacked</a>.</p>

</div>
</div>
<a id="a436cc723379e0e67c4e5d22c74d9ba37" name="a436cc723379e0e67c4e5d22c74d9ba37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436cc723379e0e67c4e5d22c74d9ba37">&#9670;&#160;</a></span>bindBufferDS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ConstBufferPacked::bindBufferDS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_g_l_e_s2_const_buffer_packed.html#ab414e6b212eaa072483b70a229397c78">Ogre::GLES2ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_d3_d11_const_buffer_packed.html#aa2f78e029215c18d7fcb2741aecf3ad6">Ogre::D3D11ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_const_buffer_packed.html#ab16fb0fcc7cda569141dd5a0cb9768e3">Ogre::GL3PlusConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_const_buffer_packed.html#af8e0948bb27dc0e3bb4f8577f9159050">Ogre::NULLConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_vulkan_const_buffer_packed.html#a1ca7103c677acbae7f1162d9226f7cf9">Ogre::VulkanConstBufferPacked</a>, and <a class="el" href="class_ogre_1_1_metal_const_buffer_packed.html#a8a1730b39848d307b45d2c7cf10bb702">Ogre::MetalConstBufferPacked</a>.</p>

</div>
</div>
<a id="a3b27c3cb36b31d0a5392e43e035bdfca" name="a3b27c3cb36b31d0a5392e43e035bdfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b27c3cb36b31d0a5392e43e035bdfca">&#9670;&#160;</a></span>bindBufferGS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ConstBufferPacked::bindBufferGS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_g_l_e_s2_const_buffer_packed.html#a575b74e82e8e97e99d877d09eabed721">Ogre::GLES2ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_d3_d11_const_buffer_packed.html#ac7e5032909beb35de56dfd775e0377e5">Ogre::D3D11ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_const_buffer_packed.html#a81e03bbd39b98d828a2393f29003f343">Ogre::GL3PlusConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_const_buffer_packed.html#aeb7ed16df0aa8e53338f9efc6652d960">Ogre::NULLConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_vulkan_const_buffer_packed.html#af4270a5a844a5c710c17b66fc1ab73ac">Ogre::VulkanConstBufferPacked</a>, and <a class="el" href="class_ogre_1_1_metal_const_buffer_packed.html#a2ab4a590964125845dfc243c336302c5">Ogre::MetalConstBufferPacked</a>.</p>

</div>
</div>
<a id="a7fed96e493b0376c743afa5351c6c96c" name="a7fed96e493b0376c743afa5351c6c96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fed96e493b0376c743afa5351c6c96c">&#9670;&#160;</a></span>bindBufferHS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ConstBufferPacked::bindBufferHS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_g_l_e_s2_const_buffer_packed.html#a9d4d2809101efe6849f1a96ccdcf6098">Ogre::GLES2ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_d3_d11_const_buffer_packed.html#aec5f4746f69f9ef251c90aa43b316a6d">Ogre::D3D11ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_const_buffer_packed.html#afb702a303b8f00c931ba5485ed013b7a">Ogre::GL3PlusConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_const_buffer_packed.html#a9697bddeb3ef9e697e3beeba3db51fb7">Ogre::NULLConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_vulkan_const_buffer_packed.html#a931d8c1e2953a1b8e6ead25f04e389d6">Ogre::VulkanConstBufferPacked</a>, and <a class="el" href="class_ogre_1_1_metal_const_buffer_packed.html#afb0a478d5c451c291aaa7b79f29b1193">Ogre::MetalConstBufferPacked</a>.</p>

</div>
</div>
<a id="a3101b4be513445b4095ad7ee8b7da265" name="a3101b4be513445b4095ad7ee8b7da265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3101b4be513445b4095ad7ee8b7da265">&#9670;&#160;</a></span>bindBufferPS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ConstBufferPacked::bindBufferPS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_g_l_e_s2_const_buffer_packed.html#ac255bc746b982be28a88759b93c0935b">Ogre::GLES2ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_d3_d11_const_buffer_packed.html#ada038e6bce0a8fcd08381c9d9586b6c9">Ogre::D3D11ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_const_buffer_packed.html#a90c9fcc88926579e4f21380fd7446506">Ogre::GL3PlusConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_metal_const_buffer_packed.html#ac34e677fd05ab5b34b87cc2d1c401330">Ogre::MetalConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_const_buffer_packed.html#a809f5b877ed47b4b6673c6095ea13b44">Ogre::NULLConstBufferPacked</a>, and <a class="el" href="class_ogre_1_1_vulkan_const_buffer_packed.html#aa0ff2b43221cdf1a64593694a69d4f1a">Ogre::VulkanConstBufferPacked</a>.</p>

</div>
</div>
<a id="a4ecf6ab68e08468525626cfd253edfef" name="a4ecf6ab68e08468525626cfd253edfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecf6ab68e08468525626cfd253edfef">&#9670;&#160;</a></span>bindBufferVS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ConstBufferPacked::bindBufferVS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the constant buffer to the given slot in the Vertex/Pixel/Geometry/Hull/Domain/Compute Shader. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Not all RS API separate by shader stage. For best compatibility, don't assign two different buffers at the same slot for different stages (just leave the slot empty on the stages you don't use). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot to asign this constant buffer. In D3D11 it's called 'slot'. In GLSL it's called it's called 'binding' </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_g_l_e_s2_const_buffer_packed.html#a3ceb22a0a5e09ed878794af65b464e16">Ogre::GLES2ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_d3_d11_const_buffer_packed.html#a260d231d0de588060ac3ca2df22fd2b6">Ogre::D3D11ConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_const_buffer_packed.html#aee38d28b3f7f86c5d045a9bba886d574">Ogre::GL3PlusConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_metal_const_buffer_packed.html#ad1763ab43f35c191bc43f66396f34471">Ogre::MetalConstBufferPacked</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_const_buffer_packed.html#ac346c1f0fd2821517b13fc6869413474">Ogre::NULLConstBufferPacked</a>, and <a class="el" href="class_ogre_1_1_vulkan_const_buffer_packed.html#a5783ca5d6f969a822c869ee2c072f2da">Ogre::VulkanConstBufferPacked</a>.</p>

</div>
</div>
<a id="a162e23ff6f3cb7f90ed129d3906c14e4" name="a162e23ff6f3cb7f90ed129d3906c14e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162e23ff6f3cb7f90ed129d3906c14e4">&#9670;&#160;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BufferPacked::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstElemStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcElemStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcNumElems</em> = <code>std::numeric_limits&lt;&#160;size_t&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of this buffer to another, using GPU -&gt; GPU transfers. </p>
<p >In simple terms it is similar to doing: memcpy( dstBuffer + dstElemStart, this + srcElemStart, srcNumElems ); </p><dl class="section remark"><dt>Remarks</dt><dd>When both src and dst have different values for <a class="el" href="class_ogre_1_1_buffer_packed.html#a9d74a62dabdc8e40db8f23e268e8fabe">BufferPacked::getBytesPerElement()</a> then srcNumElems * this-&gt;<a class="el" href="class_ogre_1_1_buffer_packed.html#a9d74a62dabdc8e40db8f23e268e8fabe">getBytesPerElement()</a> must be divisible by dstBuffer-&gt;<a class="el" href="class_ogre_1_1_buffer_packed.html#a9d74a62dabdc8e40db8f23e268e8fabe">getBytesPerElement()</a></dd></dl>
<p>If dst has a shadow buffer, then src must have it too. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstBuffer</td><td>Buffer to copy to. Must be of type BT_DEFAULT </td></tr>
    <tr><td class="paramname">dstElemStart</td><td>The offset for dstBuffer. It must be in the unit of measure of dstBuffer. e.g. actual offset in bytes is dstElemStart * dstBuffer-&gt;<a class="el" href="class_ogre_1_1_buffer_packed.html#a9d74a62dabdc8e40db8f23e268e8fabe">getBytesPerElement()</a> </td></tr>
    <tr><td class="paramname">srcElemStart</td><td>The offset of this buffer to start from </td></tr>
    <tr><td class="paramname">srcNumElems</td><td>The number of elements to copy, in units of measure of srcBuffer. When this value is out of bounds, it gets clamped. See remarks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a645fc6a5e5b03d62f276bcc235f28f80" name="a645fc6a5e5b03d62f276bcc235f28f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645fc6a5e5b03d62f276bcc235f28f80">&#9670;&#160;</a></span>getBufferInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> * Ogre::BufferPacked::getBufferInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9634ab16d39a3f581e65ddc5945e7872" name="a9634ab16d39a3f581e65ddc5945e7872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9634ab16d39a3f581e65ddc5945e7872">&#9670;&#160;</a></span>getBufferPackedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ab66e67b60d5f40dacf69ea55b82868ab">BufferPackedTypes</a> Ogre::ConstBufferPacked::getBufferPackedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Useful to query which one is the derived class. </p>

<p>Implements <a class="el" href="class_ogre_1_1_buffer_packed.html#afbc4c709944ab85c397957fefc5fc773">Ogre::BufferPacked</a>.</p>

<p class="reference">References <a class="el" href="namespace_ogre.html#ab66e67b60d5f40dacf69ea55b82868abaf5a318a2db173c61556b5f4438d9a15b">Ogre::BP_TYPE_CONST</a>.</p>

</div>
</div>
<a id="a6f44e7867f5ff341d8660fd5cae8ff68" name="a6f44e7867f5ff341d8660fd5cae8ff68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f44e7867f5ff341d8660fd5cae8ff68">&#9670;&#160;</a></span>getBufferType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> Ogre::BufferPacked::getBufferType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d74a62dabdc8e40db8f23e268e8fabe" name="a9d74a62dabdc8e40db8f23e268e8fabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d74a62dabdc8e40db8f23e268e8fabe">&#9670;&#160;</a></span>getBytesPerElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::BufferPacked::getBytesPerElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ec44373d3656928fe7a8cc9a16c7b03" name="a7ec44373d3656928fe7a8cc9a16c7b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec44373d3656928fe7a8cc9a16c7b03">&#9670;&#160;</a></span>getMappingState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a447e51d7625af79716667cebcfa6da57">MappingState</a> Ogre::BufferPacked::getMappingState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mapping state. </p>
<p >Note that if you call map with MS_PERSISTENT_INCOHERENT or MS_PERSISTENT_COHERENT, then call unmap( UO_KEEP_PERSISTENT ); the returned value will still be MS_PERSISTENT_INCOHERENT/_COHERENT when persistent mapping is supported. This differs from isCurrentlyMapped </p>

</div>
</div>
<a id="a024eb2f73c90ee052b3b1b275b0c83ef" name="a024eb2f73c90ee052b3b1b275b0c83ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024eb2f73c90ee052b3b1b275b0c83ef">&#9670;&#160;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::BufferPacked::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7df92c5e54775c1f7f3359fedf79d3e6" name="a7df92c5e54775c1f7f3359fedf79d3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df92c5e54775c1f7f3359fedf79d3e6">&#9670;&#160;</a></span>getOriginalBufferType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> * Ogre::BufferPacked::getOriginalBufferType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this buffer has been reinterpreted from an <a class="el" href="class_ogre_1_1_uav_buffer_packed.html" title="Represents UAV buffers (also known as SSBOs in OpenGL) Uav buffers are supported in DX10/DX10....">UavBufferPacked</a>, returns the original version, otherwise returns 'this'. </p>

</div>
</div>
<a id="a1b7bf642c5f9e50f76b64f0f02766bb8" name="a1b7bf642c5f9e50f76b64f0f02766bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7bf642c5f9e50f76b64f0f02766bb8">&#9670;&#160;</a></span>getShadowCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * Ogre::BufferPacked::getShadowCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9ce07a6d2e0d181085bcdb7c2b49051" name="ab9ce07a6d2e0d181085bcdb7c2b49051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ce07a6d2e0d181085bcdb7c2b49051">&#9670;&#160;</a></span>getTotalSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::BufferPacked::getTotalSizeBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63c781040cdfc2c1d3ac9fc3a7cd9097" name="a63c781040cdfc2c1d3ac9fc3a7cd9097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c781040cdfc2c1d3ac9fc3a7cd9097">&#9670;&#160;</a></span>isCurrentlyMapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BufferPacked::isCurrentlyMapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the buffer is currently mapped. </p>
<p >If you've persistently mapped the buffer and then called unmap( UO_KEEP_PERSISTENT ); this function will return false; which differs from getMappingState's behavior. </p>

</div>
</div>
<a id="ab24625894d83ec3f90972a350f27e60a" name="ab24625894d83ec3f90972a350f27e60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24625894d83ec3f90972a350f27e60a">&#9670;&#160;</a></span>isTextureGpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::GpuTrackedResource::isTextureGpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_texture_gpu.html#abdcab7d39a3d28af67cccee42f37c73f">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a24a2ccddbb2fc851304ae81eb78243ed" name="a24a2ccddbb2fc851304ae81eb78243ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a2ccddbb2fc851304ae81eb78243ed">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void *<a class="el" href="_ogre_platform_8h.html#a59a62dcc672b5775f3bd2a8d08bb60a4">RESTRICT_ALIAS_RETURN</a> Ogre::BufferPacked::map </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAdvanceFrame</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the specified region to a pointer the CPU can access. </p>
<p >Only dynamic buffers can use this function. The region [elementStart; elementStart + elementCount) will be mapped. </p><dl class="section remark"><dt>Remarks</dt><dd>You can only map once per frame, regardless of parameters (except for advanceFrame). map( 0, 1 ) followed by map( 1, 1 ); is invalid. If you plan modifying elements 0 and 1; you should call map( 0, 2 ) </dd></dl>
<dl class="section user"><dt></dt><dd>Note that even if you use persistent mapping, you still need to call </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a73e02f6b2fa2c16340c1a9359926b481" title="Unmaps or flushes the region mapped with.">unmap</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementStart</td><td>Start of the region to be mapped, in elements. Normally you want this to be 0. </td></tr>
    <tr><td class="paramname">elementCount</td><td>Length of the region to map, in elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a024eb2f73c90ee052b3b1b275b0c83ef">getNumElements</a> to <a class="el" href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed" title="Maps the specified region to a pointer the CPU can access.">map</a> the whole range. Can't be 0. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bAdvanceFrame</td><td>When true, the Buffer will be usable after unmapping it (or earlier if persistent mapped). However you won't be able to call <a class="el" href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed" title="Maps the specified region to a pointer the CPU can access.">map()</a> again until the next frame. Calling this with false allows to call map multiple times. However ater calling unmap, you must call advanceFrame. THIS IS ONLY FOR VERY ADVANCED USERS. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80c6682bd4adc315782091679d230cee" name="a80c6682bd4adc315782091679d230cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c6682bd4adc315782091679d230cee">&#9670;&#160;</a></span>readRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aef9bfd2a5567613e99bc8d7eae1c1bf9">AsyncTicketPtr</a> Ogre::BufferPacked::readRequest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Async data read request. </p>
<p >A ticket will be returned. Once the async transfer finishes, you can use the ticket to read the data from CPU. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_async_ticket.html" title="In Ogre 2.0 data structures, reading data from GPU back to CPU is asynchronous.">AsyncTicket</a> </dd></dl>

</div>
</div>
<a id="a8a1e2da7aed186b9fd6c4f88a4f9734b" name="a8a1e2da7aed186b9fd6c4f88a4f9734b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1e2da7aed186b9fd6c4f88a4f9734b">&#9670;&#160;</a></span>regressFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BufferPacked::regressFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the opposite of. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a1b0112a692634211043593b7fd20440c">advanceFrame</a>. Only call this after having called <a class="el" href="class_ogre_1_1_buffer_packed.html#a1b0112a692634211043593b7fd20440c">advanceFrame</a>. i.e. restore the buffer to the state it was before calling <a class="el" href="class_ogre_1_1_buffer_packed.html#a1b0112a692634211043593b7fd20440c">advanceFrame</a>. </dd></dl>

</div>
</div>
<a id="a73e02f6b2fa2c16340c1a9359926b481" name="a73e02f6b2fa2c16340c1a9359926b481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e02f6b2fa2c16340c1a9359926b481">&#9670;&#160;</a></span>unmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BufferPacked::unmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a118de288d2577e6d95183777f40e57c7">UnmapOptions</a>&#160;</td>
          <td class="paramname"><em>unmapOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>flushStartElem</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>flushSizeElem</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps or flushes the region mapped with. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed" title="Maps the specified region to a pointer the CPU can access.">map</a>. Alternatively, you can flush a smaller region (i.e. you didn't know which regions you were to update when mapping, but now that you're done, you know). The region being flushed is [flushStart; flushStart + flushSize) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unmapOption</td><td>When using persistent mapping, UO_KEEP_PERSISTENT will keep the map alive; but you will have to call map again to use it. This requirement allows <a class="el" href="namespace_ogre.html">Ogre</a> to:<ol type="1">
<li>Synchronize if needed (avoid mapping a region that is still in use)</li>
<li>Emulate persistent mapping on Hardware/Drivers that don't support it. </li>
</ol>
</td></tr>
    <tr><td class="paramname">flushStartElem</td><td>In elements, 0-based index (based on the mapped region) on where to start flushing from. Default is 0. </td></tr>
    <tr><td class="paramname">flushSizeElem</td><td>The length of the flushing region, which can't be bigger than 'elementCount' passed to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed" title="Maps the specified region to a pointer the CPU can access.">map</a>. When this value is 0, we flush until the end of the buffer starting from flushStartElem </dd></dl>

</div>
</div>
<a id="a0c6fb3d387685e50e2b5069164b95e6b" name="a0c6fb3d387685e50e2b5069164b95e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6fb3d387685e50e2b5069164b95e6b">&#9670;&#160;</a></span>upload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::BufferPacked::upload </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the provided data to the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to transfer to the GPU. Caller is responsible for freeing the pointer. "data" starts at offset zero. i.e. dst[elementStart * mBytesPerElement] = data[0]; </td></tr>
    <tr><td class="paramname">elementStart</td><td>The start region, usually zero. </td></tr>
    <tr><td class="paramname">elementCount</td><td>Size, in number of elements, of data. Must be less than <a class="el" href="class_ogre_1_1_buffer_packed.html#a024eb2f73c90ee052b3b1b275b0c83ef">getNumElements()</a> - elementStart </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_const_buffer_packed_8h.html">OgreConstBufferPacked.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
