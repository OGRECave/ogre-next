<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::ArrayVector3 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_array_vector3.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1_array_vector3-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::ArrayVector3 Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___math.html">Math</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Cache-friendly array of 3-dimensional represented as a SoA array.  
 <a href="class_ogre_1_1_array_vector3.html#details">More...</a></p>

<p><code>#include &lt;OgreArrayVector3SSE2.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a648c9686db201b1e04e38d0dbaff416e" id="r_a648c9686db201b1e04e38d0dbaff416e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a648c9686db201b1e04e38d0dbaff416e">ArrayVector3</a> ()</td></tr>
<tr class="separator:a648c9686db201b1e04e38d0dbaff416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c9686db201b1e04e38d0dbaff416e" id="r_a648c9686db201b1e04e38d0dbaff416e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a648c9686db201b1e04e38d0dbaff416e">ArrayVector3</a> ()</td></tr>
<tr class="separator:a648c9686db201b1e04e38d0dbaff416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c9686db201b1e04e38d0dbaff416e" id="r_a648c9686db201b1e04e38d0dbaff416e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a648c9686db201b1e04e38d0dbaff416e">ArrayVector3</a> ()</td></tr>
<tr class="separator:a648c9686db201b1e04e38d0dbaff416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d13d0e2cd250d894339d3f83b4e7a8" id="r_a26d13d0e2cd250d894339d3f83b4e7a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a26d13d0e2cd250d894339d3f83b4e7a8">ArrayVector3</a> (<a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkX, <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkY, <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkZ)</td></tr>
<tr class="separator:a26d13d0e2cd250d894339d3f83b4e7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d13d0e2cd250d894339d3f83b4e7a8" id="r_a26d13d0e2cd250d894339d3f83b4e7a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a26d13d0e2cd250d894339d3f83b4e7a8">ArrayVector3</a> (<a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkX, <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkY, <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkZ)</td></tr>
<tr class="separator:a26d13d0e2cd250d894339d3f83b4e7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d13d0e2cd250d894339d3f83b4e7a8" id="r_a26d13d0e2cd250d894339d3f83b4e7a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a26d13d0e2cd250d894339d3f83b4e7a8">ArrayVector3</a> (<a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkX, <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkY, <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> chunkZ)</td></tr>
<tr class="separator:a26d13d0e2cd250d894339d3f83b4e7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4950c21ce53c92acca289072479877f7" id="r_a4950c21ce53c92acca289072479877f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4950c21ce53c92acca289072479877f7">absDotProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:a4950c21ce53c92acca289072479877f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the absolute dot (scalar) product of this vector with another.    <br /></td></tr>
<tr class="separator:a4950c21ce53c92acca289072479877f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4950c21ce53c92acca289072479877f7" id="r_a4950c21ce53c92acca289072479877f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4950c21ce53c92acca289072479877f7">absDotProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:a4950c21ce53c92acca289072479877f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the absolute dot (scalar) product of this vector with another.    <br /></td></tr>
<tr class="separator:a4950c21ce53c92acca289072479877f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4950c21ce53c92acca289072479877f7" id="r_a4950c21ce53c92acca289072479877f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4950c21ce53c92acca289072479877f7">absDotProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:a4950c21ce53c92acca289072479877f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the absolute dot (scalar) product of this vector with another.    <br /></td></tr>
<tr class="separator:a4950c21ce53c92acca289072479877f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805a9b00aaa5a7814c5223c889ec5444" id="r_a805a9b00aaa5a7814c5223c889ec5444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a805a9b00aaa5a7814c5223c889ec5444">Cmov4</a> (<a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;replacement)</td></tr>
<tr class="memdesc:a805a9b00aaa5a7814c5223c889ec5444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move update.  <br /></td></tr>
<tr class="separator:a805a9b00aaa5a7814c5223c889ec5444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805a9b00aaa5a7814c5223c889ec5444" id="r_a805a9b00aaa5a7814c5223c889ec5444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a805a9b00aaa5a7814c5223c889ec5444">Cmov4</a> (<a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;replacement)</td></tr>
<tr class="memdesc:a805a9b00aaa5a7814c5223c889ec5444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move update.  <br /></td></tr>
<tr class="separator:a805a9b00aaa5a7814c5223c889ec5444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805a9b00aaa5a7814c5223c889ec5444" id="r_a805a9b00aaa5a7814c5223c889ec5444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a805a9b00aaa5a7814c5223c889ec5444">Cmov4</a> (<a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;replacement)</td></tr>
<tr class="memdesc:a805a9b00aaa5a7814c5223c889ec5444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move update.  <br /></td></tr>
<tr class="separator:a805a9b00aaa5a7814c5223c889ec5444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40431a5fffe7c96ecf4fce6dd455e5ff" id="r_a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a40431a5fffe7c96ecf4fce6dd455e5ff">CmovRobust</a> (<a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;replacement)</td></tr>
<tr class="memdesc:a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move update.  <br /></td></tr>
<tr class="separator:a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40431a5fffe7c96ecf4fce6dd455e5ff" id="r_a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a40431a5fffe7c96ecf4fce6dd455e5ff">CmovRobust</a> (<a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;replacement)</td></tr>
<tr class="memdesc:a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move update.  <br /></td></tr>
<tr class="separator:a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40431a5fffe7c96ecf4fce6dd455e5ff" id="r_a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a40431a5fffe7c96ecf4fce6dd455e5ff">CmovRobust</a> (<a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;replacement)</td></tr>
<tr class="memdesc:a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move update.  <br /></td></tr>
<tr class="separator:a40431a5fffe7c96ecf4fce6dd455e5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb882c4c156ca3eb74f28334e5d31df3" id="r_adb882c4c156ca3eb74f28334e5d31df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#adb882c4c156ca3eb74f28334e5d31df3">collapseMax</a> () const</td></tr>
<tr class="memdesc:adb882c4c156ca3eb74f28334e5d31df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes each Vector and returns one returns a single vector.  <br /></td></tr>
<tr class="separator:adb882c4c156ca3eb74f28334e5d31df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb882c4c156ca3eb74f28334e5d31df3" id="r_adb882c4c156ca3eb74f28334e5d31df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#adb882c4c156ca3eb74f28334e5d31df3">collapseMax</a> () const</td></tr>
<tr class="memdesc:adb882c4c156ca3eb74f28334e5d31df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes each Vector and returns one returns a single vector.  <br /></td></tr>
<tr class="separator:adb882c4c156ca3eb74f28334e5d31df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb882c4c156ca3eb74f28334e5d31df3" id="r_adb882c4c156ca3eb74f28334e5d31df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#adb882c4c156ca3eb74f28334e5d31df3">collapseMax</a> () const</td></tr>
<tr class="memdesc:adb882c4c156ca3eb74f28334e5d31df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes each Vector and returns one returns a single vector.  <br /></td></tr>
<tr class="separator:adb882c4c156ca3eb74f28334e5d31df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab255c905ea93eca9f7eeb09d19f62019" id="r_ab255c905ea93eca9f7eeb09d19f62019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab255c905ea93eca9f7eeb09d19f62019">collapseMin</a> () const</td></tr>
<tr class="memdesc:ab255c905ea93eca9f7eeb09d19f62019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes each Vector and returns one returns a single vector.  <br /></td></tr>
<tr class="separator:ab255c905ea93eca9f7eeb09d19f62019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab255c905ea93eca9f7eeb09d19f62019" id="r_ab255c905ea93eca9f7eeb09d19f62019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab255c905ea93eca9f7eeb09d19f62019">collapseMin</a> () const</td></tr>
<tr class="memdesc:ab255c905ea93eca9f7eeb09d19f62019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes each Vector and returns one returns a single vector.  <br /></td></tr>
<tr class="separator:ab255c905ea93eca9f7eeb09d19f62019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab255c905ea93eca9f7eeb09d19f62019" id="r_ab255c905ea93eca9f7eeb09d19f62019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab255c905ea93eca9f7eeb09d19f62019">collapseMin</a> () const</td></tr>
<tr class="memdesc:ab255c905ea93eca9f7eeb09d19f62019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes each Vector and returns one returns a single vector.  <br /></td></tr>
<tr class="separator:ab255c905ea93eca9f7eeb09d19f62019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2c866ac1fd2332b80d5049409f5f8" id="r_a34f2c866ac1fd2332b80d5049409f5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a34f2c866ac1fd2332b80d5049409f5f8">crossProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rkVector) const</td></tr>
<tr class="memdesc:a34f2c866ac1fd2332b80d5049409f5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cross-product of 2 vectors, i.e.    <br /></td></tr>
<tr class="separator:a34f2c866ac1fd2332b80d5049409f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2c866ac1fd2332b80d5049409f5f8" id="r_a34f2c866ac1fd2332b80d5049409f5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a34f2c866ac1fd2332b80d5049409f5f8">crossProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rkVector) const</td></tr>
<tr class="memdesc:a34f2c866ac1fd2332b80d5049409f5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cross-product of 2 vectors, i.e.    <br /></td></tr>
<tr class="separator:a34f2c866ac1fd2332b80d5049409f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2c866ac1fd2332b80d5049409f5f8" id="r_a34f2c866ac1fd2332b80d5049409f5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a34f2c866ac1fd2332b80d5049409f5f8">crossProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rkVector) const</td></tr>
<tr class="memdesc:a34f2c866ac1fd2332b80d5049409f5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cross-product of 2 vectors, i.e.    <br /></td></tr>
<tr class="separator:a34f2c866ac1fd2332b80d5049409f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e9b0e7599217aeebb8ad30b9a62bb" id="r_a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a6e8e9b0e7599217aeebb8ad30b9a62bb">distance</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance to another vector.    <br /></td></tr>
<tr class="separator:a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e9b0e7599217aeebb8ad30b9a62bb" id="r_a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a6e8e9b0e7599217aeebb8ad30b9a62bb">distance</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance to another vector.    <br /></td></tr>
<tr class="separator:a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e9b0e7599217aeebb8ad30b9a62bb" id="r_a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a6e8e9b0e7599217aeebb8ad30b9a62bb">distance</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance to another vector.    <br /></td></tr>
<tr class="separator:a6e8e9b0e7599217aeebb8ad30b9a62bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af126fffa83c6d1bf3d6d3a2d67979430" id="r_af126fffa83c6d1bf3d6d3a2d67979430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#af126fffa83c6d1bf3d6d3a2d67979430">dotProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:af126fffa83c6d1bf3d6d3a2d67979430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot (scalar) product of this vector with another.    <br /></td></tr>
<tr class="separator:af126fffa83c6d1bf3d6d3a2d67979430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af126fffa83c6d1bf3d6d3a2d67979430" id="r_af126fffa83c6d1bf3d6d3a2d67979430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#af126fffa83c6d1bf3d6d3a2d67979430">dotProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:af126fffa83c6d1bf3d6d3a2d67979430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot (scalar) product of this vector with another.    <br /></td></tr>
<tr class="separator:af126fffa83c6d1bf3d6d3a2d67979430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af126fffa83c6d1bf3d6d3a2d67979430" id="r_af126fffa83c6d1bf3d6d3a2d67979430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#af126fffa83c6d1bf3d6d3a2d67979430">dotProduct</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:af126fffa83c6d1bf3d6d3a2d67979430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot (scalar) product of this vector with another.    <br /></td></tr>
<tr class="separator:af126fffa83c6d1bf3d6d3a2d67979430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec06d68161d4123b3fad14fb72fd9c5" id="r_aaec06d68161d4123b3fad14fb72fd9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aaec06d68161d4123b3fad14fb72fd9c5">getAsVector3</a> (size_t index) const</td></tr>
<tr class="memdesc:aaec06d68161d4123b3fad14fb72fd9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefer using.  <br /></td></tr>
<tr class="separator:aaec06d68161d4123b3fad14fb72fd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec06d68161d4123b3fad14fb72fd9c5" id="r_aaec06d68161d4123b3fad14fb72fd9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aaec06d68161d4123b3fad14fb72fd9c5">getAsVector3</a> (size_t index) const</td></tr>
<tr class="memdesc:aaec06d68161d4123b3fad14fb72fd9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefer using.  <br /></td></tr>
<tr class="separator:aaec06d68161d4123b3fad14fb72fd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec06d68161d4123b3fad14fb72fd9c5" id="r_aaec06d68161d4123b3fad14fb72fd9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aaec06d68161d4123b3fad14fb72fd9c5">getAsVector3</a> (size_t index) const</td></tr>
<tr class="memdesc:aaec06d68161d4123b3fad14fb72fd9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefer using.  <br /></td></tr>
<tr class="separator:aaec06d68161d4123b3fad14fb72fd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad261d645fdf7f488ad9cca7a9a0e986f" id="r_ad261d645fdf7f488ad9cca7a9a0e986f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ad261d645fdf7f488ad9cca7a9a0e986f">getAsVector3</a> (<a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;out, size_t index) const</td></tr>
<tr class="separator:ad261d645fdf7f488ad9cca7a9a0e986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad261d645fdf7f488ad9cca7a9a0e986f" id="r_ad261d645fdf7f488ad9cca7a9a0e986f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ad261d645fdf7f488ad9cca7a9a0e986f">getAsVector3</a> (<a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;out, size_t index) const</td></tr>
<tr class="separator:ad261d645fdf7f488ad9cca7a9a0e986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad261d645fdf7f488ad9cca7a9a0e986f" id="r_ad261d645fdf7f488ad9cca7a9a0e986f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ad261d645fdf7f488ad9cca7a9a0e986f">getAsVector3</a> (<a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;out, size_t index) const</td></tr>
<tr class="separator:ad261d645fdf7f488ad9cca7a9a0e986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b7a214726ba5ac0e7c39493e8baed0" id="r_ab5b7a214726ba5ac0e7c39493e8baed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab5b7a214726ba5ac0e7c39493e8baed0">getMaxComponent</a> () const</td></tr>
<tr class="memdesc:ab5b7a214726ba5ac0e7c39493e8baed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the biggest value between x, y, z; max( x, y, z )  <br /></td></tr>
<tr class="separator:ab5b7a214726ba5ac0e7c39493e8baed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b7a214726ba5ac0e7c39493e8baed0" id="r_ab5b7a214726ba5ac0e7c39493e8baed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab5b7a214726ba5ac0e7c39493e8baed0">getMaxComponent</a> () const</td></tr>
<tr class="memdesc:ab5b7a214726ba5ac0e7c39493e8baed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the biggest value between x, y, z; max( x, y, z )  <br /></td></tr>
<tr class="separator:ab5b7a214726ba5ac0e7c39493e8baed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b7a214726ba5ac0e7c39493e8baed0" id="r_ab5b7a214726ba5ac0e7c39493e8baed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab5b7a214726ba5ac0e7c39493e8baed0">getMaxComponent</a> () const</td></tr>
<tr class="memdesc:ab5b7a214726ba5ac0e7c39493e8baed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the biggest value between x, y, z; max( x, y, z )  <br /></td></tr>
<tr class="separator:ab5b7a214726ba5ac0e7c39493e8baed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d62ed0f1cc257fc715822ad330958b2" id="r_a4d62ed0f1cc257fc715822ad330958b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4d62ed0f1cc257fc715822ad330958b2">getMinComponent</a> () const</td></tr>
<tr class="memdesc:a4d62ed0f1cc257fc715822ad330958b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest value between x, y, z; min( x, y, z )  <br /></td></tr>
<tr class="separator:a4d62ed0f1cc257fc715822ad330958b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d62ed0f1cc257fc715822ad330958b2" id="r_a4d62ed0f1cc257fc715822ad330958b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4d62ed0f1cc257fc715822ad330958b2">getMinComponent</a> () const</td></tr>
<tr class="memdesc:a4d62ed0f1cc257fc715822ad330958b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest value between x, y, z; min( x, y, z )  <br /></td></tr>
<tr class="separator:a4d62ed0f1cc257fc715822ad330958b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d62ed0f1cc257fc715822ad330958b2" id="r_a4d62ed0f1cc257fc715822ad330958b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4d62ed0f1cc257fc715822ad330958b2">getMinComponent</a> () const</td></tr>
<tr class="memdesc:a4d62ed0f1cc257fc715822ad330958b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest value between x, y, z; min( x, y, z )  <br /></td></tr>
<tr class="separator:a4d62ed0f1cc257fc715822ad330958b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35066b918a9ad1bb9c3cb1d99fa2bba0" id="r_a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a35066b918a9ad1bb9c3cb1d99fa2bba0">inverseLeaveZeroes</a> ()</td></tr>
<tr class="memdesc:a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of the vectors: 1.0f / v; But if original is zero, the zero is left (0 / 0 = 0).  <br /></td></tr>
<tr class="separator:a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35066b918a9ad1bb9c3cb1d99fa2bba0" id="r_a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a35066b918a9ad1bb9c3cb1d99fa2bba0">inverseLeaveZeroes</a> ()</td></tr>
<tr class="memdesc:a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of the vectors: 1.0f / v; But if original is zero, the zero is left (0 / 0 = 0).  <br /></td></tr>
<tr class="separator:a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35066b918a9ad1bb9c3cb1d99fa2bba0" id="r_a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a35066b918a9ad1bb9c3cb1d99fa2bba0">inverseLeaveZeroes</a> ()</td></tr>
<tr class="memdesc:a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of the vectors: 1.0f / v; But if original is zero, the zero is left (0 / 0 = 0).  <br /></td></tr>
<tr class="separator:a35066b918a9ad1bb9c3cb1d99fa2bba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea08253517e4019d26c9fdbaf211aaaa" id="r_aea08253517e4019d26c9fdbaf211aaaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aea08253517e4019d26c9fdbaf211aaaa">isNaN</a> () const</td></tr>
<tr class="separator:aea08253517e4019d26c9fdbaf211aaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea08253517e4019d26c9fdbaf211aaaa" id="r_aea08253517e4019d26c9fdbaf211aaaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aea08253517e4019d26c9fdbaf211aaaa">isNaN</a> () const</td></tr>
<tr class="separator:aea08253517e4019d26c9fdbaf211aaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea08253517e4019d26c9fdbaf211aaaa" id="r_aea08253517e4019d26c9fdbaf211aaaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aea08253517e4019d26c9fdbaf211aaaa">isNaN</a> () const</td></tr>
<tr class="separator:aea08253517e4019d26c9fdbaf211aaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ddabbf07ee074fb9f92faa2a19da1" id="r_adf3ddabbf07ee074fb9f92faa2a19da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#adf3ddabbf07ee074fb9f92faa2a19da1">length</a> () const</td></tr>
<tr class="memdesc:adf3ddabbf07ee074fb9f92faa2a19da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length (magnitude) of the vector.    <br /></td></tr>
<tr class="separator:adf3ddabbf07ee074fb9f92faa2a19da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ddabbf07ee074fb9f92faa2a19da1" id="r_adf3ddabbf07ee074fb9f92faa2a19da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#adf3ddabbf07ee074fb9f92faa2a19da1">length</a> () const</td></tr>
<tr class="memdesc:adf3ddabbf07ee074fb9f92faa2a19da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length (magnitude) of the vector.    <br /></td></tr>
<tr class="separator:adf3ddabbf07ee074fb9f92faa2a19da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ddabbf07ee074fb9f92faa2a19da1" id="r_adf3ddabbf07ee074fb9f92faa2a19da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#adf3ddabbf07ee074fb9f92faa2a19da1">length</a> () const</td></tr>
<tr class="memdesc:adf3ddabbf07ee074fb9f92faa2a19da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length (magnitude) of the vector.    <br /></td></tr>
<tr class="separator:adf3ddabbf07ee074fb9f92faa2a19da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01d1a2ad3c795ed608ed191c84de476" id="r_ae01d1a2ad3c795ed608ed191c84de476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ae01d1a2ad3c795ed608ed191c84de476">loadFromAoS</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> src)</td></tr>
<tr class="memdesc:ae01d1a2ad3c795ed608ed191c84de476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 4 ARRAY_PACKED_REALS reals into this <a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a>.  <br /></td></tr>
<tr class="separator:ae01d1a2ad3c795ed608ed191c84de476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01d1a2ad3c795ed608ed191c84de476" id="r_ae01d1a2ad3c795ed608ed191c84de476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ae01d1a2ad3c795ed608ed191c84de476">loadFromAoS</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> src)</td></tr>
<tr class="memdesc:ae01d1a2ad3c795ed608ed191c84de476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 4 ARRAY_PACKED_REALS reals into this <a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a>.  <br /></td></tr>
<tr class="separator:ae01d1a2ad3c795ed608ed191c84de476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01d1a2ad3c795ed608ed191c84de476" id="r_ae01d1a2ad3c795ed608ed191c84de476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ae01d1a2ad3c795ed608ed191c84de476">loadFromAoS</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> src)</td></tr>
<tr class="memdesc:ae01d1a2ad3c795ed608ed191c84de476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 4 ARRAY_PACKED_REALS reals into this <a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a>.  <br /></td></tr>
<tr class="separator:ae01d1a2ad3c795ed608ed191c84de476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456e979750ed64f62fe083f04447264d" id="r_a456e979750ed64f62fe083f04447264d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a456e979750ed64f62fe083f04447264d">makeCeil</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;cmp)</td></tr>
<tr class="memdesc:a456e979750ed64f62fe083f04447264d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this vector's components to the maximum of its own and the ones of the passed in vector.    <br /></td></tr>
<tr class="separator:a456e979750ed64f62fe083f04447264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456e979750ed64f62fe083f04447264d" id="r_a456e979750ed64f62fe083f04447264d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a456e979750ed64f62fe083f04447264d">makeCeil</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;cmp)</td></tr>
<tr class="memdesc:a456e979750ed64f62fe083f04447264d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this vector's components to the maximum of its own and the ones of the passed in vector.    <br /></td></tr>
<tr class="separator:a456e979750ed64f62fe083f04447264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456e979750ed64f62fe083f04447264d" id="r_a456e979750ed64f62fe083f04447264d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a456e979750ed64f62fe083f04447264d">makeCeil</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;cmp)</td></tr>
<tr class="memdesc:a456e979750ed64f62fe083f04447264d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this vector's components to the maximum of its own and the ones of the passed in vector.    <br /></td></tr>
<tr class="separator:a456e979750ed64f62fe083f04447264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab573b7c18f1f76071a3f40b0e1bfd9ea" id="r_ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab573b7c18f1f76071a3f40b0e1bfd9ea">makeFloor</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;cmp)</td></tr>
<tr class="memdesc:ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this vector's components to the minimum of its own and the ones of the passed in vector.    <br /></td></tr>
<tr class="separator:ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab573b7c18f1f76071a3f40b0e1bfd9ea" id="r_ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab573b7c18f1f76071a3f40b0e1bfd9ea">makeFloor</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;cmp)</td></tr>
<tr class="memdesc:ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this vector's components to the minimum of its own and the ones of the passed in vector.    <br /></td></tr>
<tr class="separator:ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab573b7c18f1f76071a3f40b0e1bfd9ea" id="r_ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab573b7c18f1f76071a3f40b0e1bfd9ea">makeFloor</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;cmp)</td></tr>
<tr class="memdesc:ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this vector's components to the minimum of its own and the ones of the passed in vector.    <br /></td></tr>
<tr class="separator:ab573b7c18f1f76071a3f40b0e1bfd9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee72f680790a341db04fac3be6c5691" id="r_a3ee72f680790a341db04fac3be6c5691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a3ee72f680790a341db04fac3be6c5691">midPoint</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:a3ee72f680790a341db04fac3be6c5691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector at a point half way between this and the passed in vector.    <br /></td></tr>
<tr class="separator:a3ee72f680790a341db04fac3be6c5691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee72f680790a341db04fac3be6c5691" id="r_a3ee72f680790a341db04fac3be6c5691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a3ee72f680790a341db04fac3be6c5691">midPoint</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:a3ee72f680790a341db04fac3be6c5691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector at a point half way between this and the passed in vector.    <br /></td></tr>
<tr class="separator:a3ee72f680790a341db04fac3be6c5691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee72f680790a341db04fac3be6c5691" id="r_a3ee72f680790a341db04fac3be6c5691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a3ee72f680790a341db04fac3be6c5691">midPoint</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;vec) const</td></tr>
<tr class="memdesc:a3ee72f680790a341db04fac3be6c5691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector at a point half way between this and the passed in vector.    <br /></td></tr>
<tr class="separator:a3ee72f680790a341db04fac3be6c5691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00894c807c4cb587c081cc108701f29" id="r_ab00894c807c4cb587c081cc108701f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab00894c807c4cb587c081cc108701f29">normalise</a> ()</td></tr>
<tr class="memdesc:ab00894c807c4cb587c081cc108701f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlike <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a>, this function does not return the length of the vector because such value was not cached and was never available.  <br /></td></tr>
<tr class="separator:ab00894c807c4cb587c081cc108701f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00894c807c4cb587c081cc108701f29" id="r_ab00894c807c4cb587c081cc108701f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab00894c807c4cb587c081cc108701f29">normalise</a> ()</td></tr>
<tr class="memdesc:ab00894c807c4cb587c081cc108701f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlike <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a>, this function does not return the length of the vector because such value was not cached and was never available.  <br /></td></tr>
<tr class="separator:ab00894c807c4cb587c081cc108701f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00894c807c4cb587c081cc108701f29" id="r_ab00894c807c4cb587c081cc108701f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab00894c807c4cb587c081cc108701f29">normalise</a> ()</td></tr>
<tr class="memdesc:ab00894c807c4cb587c081cc108701f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlike <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a>, this function does not return the length of the vector because such value was not cached and was never available.  <br /></td></tr>
<tr class="separator:ab00894c807c4cb587c081cc108701f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693f10951d2ab75eae3eb5d59e1e1197" id="r_a693f10951d2ab75eae3eb5d59e1e1197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a693f10951d2ab75eae3eb5d59e1e1197">normalisedCopy</a> () const</td></tr>
<tr class="memdesc:a693f10951d2ab75eae3eb5d59e1e1197"><td class="mdescLeft">&#160;</td><td class="mdescRight">As normalise, except that this vector is unaffected and the normalised vector is returned as a copy.    <br /></td></tr>
<tr class="separator:a693f10951d2ab75eae3eb5d59e1e1197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693f10951d2ab75eae3eb5d59e1e1197" id="r_a693f10951d2ab75eae3eb5d59e1e1197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a693f10951d2ab75eae3eb5d59e1e1197">normalisedCopy</a> () const</td></tr>
<tr class="memdesc:a693f10951d2ab75eae3eb5d59e1e1197"><td class="mdescLeft">&#160;</td><td class="mdescRight">As normalise, except that this vector is unaffected and the normalised vector is returned as a copy.    <br /></td></tr>
<tr class="separator:a693f10951d2ab75eae3eb5d59e1e1197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693f10951d2ab75eae3eb5d59e1e1197" id="r_a693f10951d2ab75eae3eb5d59e1e1197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a693f10951d2ab75eae3eb5d59e1e1197">normalisedCopy</a> () const</td></tr>
<tr class="memdesc:a693f10951d2ab75eae3eb5d59e1e1197"><td class="mdescLeft">&#160;</td><td class="mdescRight">As normalise, except that this vector is unaffected and the normalised vector is returned as a copy.    <br /></td></tr>
<tr class="separator:a693f10951d2ab75eae3eb5d59e1e1197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f296f292d0bea684a41a38fdbfdd3" id="r_a003f296f292d0bea684a41a38fdbfdd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a003f296f292d0bea684a41a38fdbfdd3">operator*=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a003f296f292d0bea684a41a38fdbfdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f296f292d0bea684a41a38fdbfdd3" id="r_a003f296f292d0bea684a41a38fdbfdd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a003f296f292d0bea684a41a38fdbfdd3">operator*=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a003f296f292d0bea684a41a38fdbfdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f296f292d0bea684a41a38fdbfdd3" id="r_a003f296f292d0bea684a41a38fdbfdd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a003f296f292d0bea684a41a38fdbfdd3">operator*=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a003f296f292d0bea684a41a38fdbfdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d240293db14723529e48511e740457e" id="r_a0d240293db14723529e48511e740457e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a0d240293db14723529e48511e740457e">operator*=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a0d240293db14723529e48511e740457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d240293db14723529e48511e740457e" id="r_a0d240293db14723529e48511e740457e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a0d240293db14723529e48511e740457e">operator*=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a0d240293db14723529e48511e740457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d240293db14723529e48511e740457e" id="r_a0d240293db14723529e48511e740457e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a0d240293db14723529e48511e740457e">operator*=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a0d240293db14723529e48511e740457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08483bf68f3a83c2256bbacb4c13505f" id="r_a08483bf68f3a83c2256bbacb4c13505f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a08483bf68f3a83c2256bbacb4c13505f">operator*=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="separator:a08483bf68f3a83c2256bbacb4c13505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08483bf68f3a83c2256bbacb4c13505f" id="r_a08483bf68f3a83c2256bbacb4c13505f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a08483bf68f3a83c2256bbacb4c13505f">operator*=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="separator:a08483bf68f3a83c2256bbacb4c13505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac65bfcb4e385ac60b021ebc14f386ed" id="r_aac65bfcb4e385ac60b021ebc14f386ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aac65bfcb4e385ac60b021ebc14f386ed">operator+</a> () const</td></tr>
<tr class="separator:aac65bfcb4e385ac60b021ebc14f386ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac65bfcb4e385ac60b021ebc14f386ed" id="r_aac65bfcb4e385ac60b021ebc14f386ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aac65bfcb4e385ac60b021ebc14f386ed">operator+</a> () const</td></tr>
<tr class="separator:aac65bfcb4e385ac60b021ebc14f386ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac65bfcb4e385ac60b021ebc14f386ed" id="r_aac65bfcb4e385ac60b021ebc14f386ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aac65bfcb4e385ac60b021ebc14f386ed">operator+</a> () const</td></tr>
<tr class="separator:aac65bfcb4e385ac60b021ebc14f386ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e27c2ec4412788016f4c389536fdea" id="r_aa6e27c2ec4412788016f4c389536fdea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aa6e27c2ec4412788016f4c389536fdea">operator+=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:aa6e27c2ec4412788016f4c389536fdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e27c2ec4412788016f4c389536fdea" id="r_aa6e27c2ec4412788016f4c389536fdea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aa6e27c2ec4412788016f4c389536fdea">operator+=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:aa6e27c2ec4412788016f4c389536fdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e27c2ec4412788016f4c389536fdea" id="r_aa6e27c2ec4412788016f4c389536fdea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#aa6e27c2ec4412788016f4c389536fdea">operator+=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:aa6e27c2ec4412788016f4c389536fdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e028c8ddea0849816bd5838276b2d84" id="r_a4e028c8ddea0849816bd5838276b2d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4e028c8ddea0849816bd5838276b2d84">operator+=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a4e028c8ddea0849816bd5838276b2d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e028c8ddea0849816bd5838276b2d84" id="r_a4e028c8ddea0849816bd5838276b2d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4e028c8ddea0849816bd5838276b2d84">operator+=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a4e028c8ddea0849816bd5838276b2d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e028c8ddea0849816bd5838276b2d84" id="r_a4e028c8ddea0849816bd5838276b2d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4e028c8ddea0849816bd5838276b2d84">operator+=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a4e028c8ddea0849816bd5838276b2d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af899eb2447629726f0021c24174e2d8d" id="r_af899eb2447629726f0021c24174e2d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#af899eb2447629726f0021c24174e2d8d">operator+=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="separator:af899eb2447629726f0021c24174e2d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af899eb2447629726f0021c24174e2d8d" id="r_af899eb2447629726f0021c24174e2d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#af899eb2447629726f0021c24174e2d8d">operator+=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="separator:af899eb2447629726f0021c24174e2d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cb4ba8c5f808cc1dff2244cf47b38f" id="r_a62cb4ba8c5f808cc1dff2244cf47b38f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a62cb4ba8c5f808cc1dff2244cf47b38f">operator-</a> () const</td></tr>
<tr class="separator:a62cb4ba8c5f808cc1dff2244cf47b38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cb4ba8c5f808cc1dff2244cf47b38f" id="r_a62cb4ba8c5f808cc1dff2244cf47b38f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a62cb4ba8c5f808cc1dff2244cf47b38f">operator-</a> () const</td></tr>
<tr class="separator:a62cb4ba8c5f808cc1dff2244cf47b38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cb4ba8c5f808cc1dff2244cf47b38f" id="r_a62cb4ba8c5f808cc1dff2244cf47b38f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a62cb4ba8c5f808cc1dff2244cf47b38f">operator-</a> () const</td></tr>
<tr class="separator:a62cb4ba8c5f808cc1dff2244cf47b38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc0bf26201ccf0eaca2292a27420526" id="r_a4bc0bf26201ccf0eaca2292a27420526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4bc0bf26201ccf0eaca2292a27420526">operator-=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a4bc0bf26201ccf0eaca2292a27420526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc0bf26201ccf0eaca2292a27420526" id="r_a4bc0bf26201ccf0eaca2292a27420526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4bc0bf26201ccf0eaca2292a27420526">operator-=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a4bc0bf26201ccf0eaca2292a27420526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc0bf26201ccf0eaca2292a27420526" id="r_a4bc0bf26201ccf0eaca2292a27420526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4bc0bf26201ccf0eaca2292a27420526">operator-=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a4bc0bf26201ccf0eaca2292a27420526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d76edf0716fe7260a288e0c879c6547" id="r_a1d76edf0716fe7260a288e0c879c6547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a1d76edf0716fe7260a288e0c879c6547">operator-=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a1d76edf0716fe7260a288e0c879c6547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d76edf0716fe7260a288e0c879c6547" id="r_a1d76edf0716fe7260a288e0c879c6547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a1d76edf0716fe7260a288e0c879c6547">operator-=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a1d76edf0716fe7260a288e0c879c6547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d76edf0716fe7260a288e0c879c6547" id="r_a1d76edf0716fe7260a288e0c879c6547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a1d76edf0716fe7260a288e0c879c6547">operator-=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a1d76edf0716fe7260a288e0c879c6547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4377bd6a0f3c34d7fe96abac787a9720" id="r_a4377bd6a0f3c34d7fe96abac787a9720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4377bd6a0f3c34d7fe96abac787a9720">operator-=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="separator:a4377bd6a0f3c34d7fe96abac787a9720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4377bd6a0f3c34d7fe96abac787a9720" id="r_a4377bd6a0f3c34d7fe96abac787a9720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4377bd6a0f3c34d7fe96abac787a9720">operator-=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="separator:a4377bd6a0f3c34d7fe96abac787a9720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce091c241e52986e45298af2cc53c8" id="r_a63ce091c241e52986e45298af2cc53c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a63ce091c241e52986e45298af2cc53c8">operator/=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a63ce091c241e52986e45298af2cc53c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce091c241e52986e45298af2cc53c8" id="r_a63ce091c241e52986e45298af2cc53c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a63ce091c241e52986e45298af2cc53c8">operator/=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a63ce091c241e52986e45298af2cc53c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce091c241e52986e45298af2cc53c8" id="r_a63ce091c241e52986e45298af2cc53c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a63ce091c241e52986e45298af2cc53c8">operator/=</a> (const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> fScalar)</td></tr>
<tr class="separator:a63ce091c241e52986e45298af2cc53c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448dcf1a6d8eb4298a3dbb687afb7970" id="r_a448dcf1a6d8eb4298a3dbb687afb7970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a448dcf1a6d8eb4298a3dbb687afb7970">operator/=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a448dcf1a6d8eb4298a3dbb687afb7970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448dcf1a6d8eb4298a3dbb687afb7970" id="r_a448dcf1a6d8eb4298a3dbb687afb7970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a448dcf1a6d8eb4298a3dbb687afb7970">operator/=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a448dcf1a6d8eb4298a3dbb687afb7970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448dcf1a6d8eb4298a3dbb687afb7970" id="r_a448dcf1a6d8eb4298a3dbb687afb7970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a448dcf1a6d8eb4298a3dbb687afb7970">operator/=</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;a)</td></tr>
<tr class="separator:a448dcf1a6d8eb4298a3dbb687afb7970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b512047e8401f1ad418413535df5b10" id="r_a9b512047e8401f1ad418413535df5b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a9b512047e8401f1ad418413535df5b10">operator/=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="separator:a9b512047e8401f1ad418413535df5b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b512047e8401f1ad418413535df5b10" id="r_a9b512047e8401f1ad418413535df5b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a9b512047e8401f1ad418413535df5b10">operator/=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="separator:a9b512047e8401f1ad418413535df5b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d9a2a7f22c66fd901e5432f095a98" id="r_a628d9a2a7f22c66fd901e5432f095a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a628d9a2a7f22c66fd901e5432f095a98">operator=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="memdesc:a628d9a2a7f22c66fd901e5432f095a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies only one vector, by looking at the indexes.  <br /></td></tr>
<tr class="separator:a628d9a2a7f22c66fd901e5432f095a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d9a2a7f22c66fd901e5432f095a98" id="r_a628d9a2a7f22c66fd901e5432f095a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a628d9a2a7f22c66fd901e5432f095a98">operator=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="memdesc:a628d9a2a7f22c66fd901e5432f095a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies only one vector, by looking at the indexes.  <br /></td></tr>
<tr class="separator:a628d9a2a7f22c66fd901e5432f095a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d9a2a7f22c66fd901e5432f095a98" id="r_a628d9a2a7f22c66fd901e5432f095a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a628d9a2a7f22c66fd901e5432f095a98">operator=</a> (const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fScalar)</td></tr>
<tr class="memdesc:a628d9a2a7f22c66fd901e5432f095a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies only one vector, by looking at the indexes.  <br /></td></tr>
<tr class="separator:a628d9a2a7f22c66fd901e5432f095a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4b1144edb284bf280697046e2738c5" id="r_a5b4b1144edb284bf280697046e2738c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a5b4b1144edb284bf280697046e2738c5">perpendicular</a> () const</td></tr>
<tr class="memdesc:a5b4b1144edb284bf280697046e2738c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector perpendicular to this vector (eg an 'up' vector).    <br /></td></tr>
<tr class="separator:a5b4b1144edb284bf280697046e2738c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4b1144edb284bf280697046e2738c5" id="r_a5b4b1144edb284bf280697046e2738c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a5b4b1144edb284bf280697046e2738c5">perpendicular</a> () const</td></tr>
<tr class="memdesc:a5b4b1144edb284bf280697046e2738c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector perpendicular to this vector (eg an 'up' vector).    <br /></td></tr>
<tr class="separator:a5b4b1144edb284bf280697046e2738c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4b1144edb284bf280697046e2738c5" id="r_a5b4b1144edb284bf280697046e2738c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a5b4b1144edb284bf280697046e2738c5">perpendicular</a> () const</td></tr>
<tr class="memdesc:a5b4b1144edb284bf280697046e2738c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector perpendicular to this vector (eg an 'up' vector).    <br /></td></tr>
<tr class="separator:a5b4b1144edb284bf280697046e2738c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb25fa53f5ca3dbf7170874e60288fc" id="r_a8fb25fa53f5ca3dbf7170874e60288fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a8fb25fa53f5ca3dbf7170874e60288fc">primaryAxis</a> () const</td></tr>
<tr class="memdesc:a8fb25fa53f5ca3dbf7170874e60288fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the primary (dominant) axis from this direction vector.    <br /></td></tr>
<tr class="separator:a8fb25fa53f5ca3dbf7170874e60288fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb25fa53f5ca3dbf7170874e60288fc" id="r_a8fb25fa53f5ca3dbf7170874e60288fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a8fb25fa53f5ca3dbf7170874e60288fc">primaryAxis</a> () const</td></tr>
<tr class="memdesc:a8fb25fa53f5ca3dbf7170874e60288fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the primary (dominant) axis from this direction vector.    <br /></td></tr>
<tr class="separator:a8fb25fa53f5ca3dbf7170874e60288fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb25fa53f5ca3dbf7170874e60288fc" id="r_a8fb25fa53f5ca3dbf7170874e60288fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a8fb25fa53f5ca3dbf7170874e60288fc">primaryAxis</a> () const</td></tr>
<tr class="memdesc:a8fb25fa53f5ca3dbf7170874e60288fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the primary (dominant) axis from this direction vector.    <br /></td></tr>
<tr class="separator:a8fb25fa53f5ca3dbf7170874e60288fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ab388de60346a25db6a88ef83ab658" id="r_ab6ab388de60346a25db6a88ef83ab658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab6ab388de60346a25db6a88ef83ab658">reflect</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;normal) const</td></tr>
<tr class="memdesc:ab6ab388de60346a25db6a88ef83ab658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a reflection vector to the plane with the given normal .    <br /></td></tr>
<tr class="separator:ab6ab388de60346a25db6a88ef83ab658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ab388de60346a25db6a88ef83ab658" id="r_ab6ab388de60346a25db6a88ef83ab658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab6ab388de60346a25db6a88ef83ab658">reflect</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;normal) const</td></tr>
<tr class="memdesc:ab6ab388de60346a25db6a88ef83ab658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a reflection vector to the plane with the given normal .    <br /></td></tr>
<tr class="separator:ab6ab388de60346a25db6a88ef83ab658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ab388de60346a25db6a88ef83ab658" id="r_ab6ab388de60346a25db6a88ef83ab658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ab6ab388de60346a25db6a88ef83ab658">reflect</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;normal) const</td></tr>
<tr class="memdesc:ab6ab388de60346a25db6a88ef83ab658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a reflection vector to the plane with the given normal .    <br /></td></tr>
<tr class="separator:ab6ab388de60346a25db6a88ef83ab658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c34e42bf951a4dfd877241c2ac9e3f8" id="r_a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a8c34e42bf951a4dfd877241c2ac9e3f8">setAll</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all packed vectors to the same value as the scalar input vector.  <br /></td></tr>
<tr class="separator:a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c34e42bf951a4dfd877241c2ac9e3f8" id="r_a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a8c34e42bf951a4dfd877241c2ac9e3f8">setAll</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all packed vectors to the same value as the scalar input vector.  <br /></td></tr>
<tr class="separator:a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c34e42bf951a4dfd877241c2ac9e3f8" id="r_a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a8c34e42bf951a4dfd877241c2ac9e3f8">setAll</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;v)</td></tr>
<tr class="memdesc:a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all packed vectors to the same value as the scalar input vector.  <br /></td></tr>
<tr class="separator:a8c34e42bf951a4dfd877241c2ac9e3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4043d5a0b54859eea5b1173feab2a653" id="r_a4043d5a0b54859eea5b1173feab2a653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4043d5a0b54859eea5b1173feab2a653">setFromVector3</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;v, size_t index)</td></tr>
<tr class="separator:a4043d5a0b54859eea5b1173feab2a653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4043d5a0b54859eea5b1173feab2a653" id="r_a4043d5a0b54859eea5b1173feab2a653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4043d5a0b54859eea5b1173feab2a653">setFromVector3</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;v, size_t index)</td></tr>
<tr class="separator:a4043d5a0b54859eea5b1173feab2a653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4043d5a0b54859eea5b1173feab2a653" id="r_a4043d5a0b54859eea5b1173feab2a653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a4043d5a0b54859eea5b1173feab2a653">setFromVector3</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;v, size_t index)</td></tr>
<tr class="separator:a4043d5a0b54859eea5b1173feab2a653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f04199290a76d2e1df59007b739f670" id="r_a2f04199290a76d2e1df59007b739f670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a2f04199290a76d2e1df59007b739f670">setToSign</a> ()</td></tr>
<tr class="memdesc:a2f04199290a76d2e1df59007b739f670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the vector to (sign(x), sign(y), sign(z))  <br /></td></tr>
<tr class="separator:a2f04199290a76d2e1df59007b739f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f04199290a76d2e1df59007b739f670" id="r_a2f04199290a76d2e1df59007b739f670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a2f04199290a76d2e1df59007b739f670">setToSign</a> ()</td></tr>
<tr class="memdesc:a2f04199290a76d2e1df59007b739f670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the vector to (sign(x), sign(y), sign(z))  <br /></td></tr>
<tr class="separator:a2f04199290a76d2e1df59007b739f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f04199290a76d2e1df59007b739f670" id="r_a2f04199290a76d2e1df59007b739f670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a2f04199290a76d2e1df59007b739f670">setToSign</a> ()</td></tr>
<tr class="memdesc:a2f04199290a76d2e1df59007b739f670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the vector to (sign(x), sign(y), sign(z))  <br /></td></tr>
<tr class="separator:a2f04199290a76d2e1df59007b739f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101ace91b0add48e5fcc959f6a037fd4" id="r_a101ace91b0add48e5fcc959f6a037fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a101ace91b0add48e5fcc959f6a037fd4">squaredDistance</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a101ace91b0add48e5fcc959f6a037fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the distance to another vector.    <br /></td></tr>
<tr class="separator:a101ace91b0add48e5fcc959f6a037fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101ace91b0add48e5fcc959f6a037fd4" id="r_a101ace91b0add48e5fcc959f6a037fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a101ace91b0add48e5fcc959f6a037fd4">squaredDistance</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a101ace91b0add48e5fcc959f6a037fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the distance to another vector.    <br /></td></tr>
<tr class="separator:a101ace91b0add48e5fcc959f6a037fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101ace91b0add48e5fcc959f6a037fd4" id="r_a101ace91b0add48e5fcc959f6a037fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a101ace91b0add48e5fcc959f6a037fd4">squaredDistance</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a101ace91b0add48e5fcc959f6a037fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the distance to another vector.    <br /></td></tr>
<tr class="separator:a101ace91b0add48e5fcc959f6a037fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6afb89604e05e1240f4cfc2e9695591" id="r_af6afb89604e05e1240f4cfc2e9695591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#af6afb89604e05e1240f4cfc2e9695591">squaredLength</a> () const</td></tr>
<tr class="memdesc:af6afb89604e05e1240f4cfc2e9695591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the length(magnitude) of the vector.    <br /></td></tr>
<tr class="separator:af6afb89604e05e1240f4cfc2e9695591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6afb89604e05e1240f4cfc2e9695591" id="r_af6afb89604e05e1240f4cfc2e9695591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#af6afb89604e05e1240f4cfc2e9695591">squaredLength</a> () const</td></tr>
<tr class="memdesc:af6afb89604e05e1240f4cfc2e9695591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the length(magnitude) of the vector.    <br /></td></tr>
<tr class="separator:af6afb89604e05e1240f4cfc2e9695591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6afb89604e05e1240f4cfc2e9695591" id="r_af6afb89604e05e1240f4cfc2e9695591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#af6afb89604e05e1240f4cfc2e9695591">squaredLength</a> () const</td></tr>
<tr class="memdesc:af6afb89604e05e1240f4cfc2e9695591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the length(magnitude) of the vector.    <br /></td></tr>
<tr class="separator:af6afb89604e05e1240f4cfc2e9695591"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afb4e1c7d15b5819e3cdb720bc133fb96" id="r_afb4e1c7d15b5819e3cdb720bc133fb96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96">Cmov4</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;arg1, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;arg2, <a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask)</td></tr>
<tr class="memdesc:afb4e1c7d15b5819e3cdb720bc133fb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move.  <br /></td></tr>
<tr class="separator:afb4e1c7d15b5819e3cdb720bc133fb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4e1c7d15b5819e3cdb720bc133fb96" id="r_afb4e1c7d15b5819e3cdb720bc133fb96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96">Cmov4</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;arg1, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;arg2, <a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask)</td></tr>
<tr class="memdesc:afb4e1c7d15b5819e3cdb720bc133fb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move.  <br /></td></tr>
<tr class="separator:afb4e1c7d15b5819e3cdb720bc133fb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4e1c7d15b5819e3cdb720bc133fb96" id="r_afb4e1c7d15b5819e3cdb720bc133fb96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96">Cmov4</a> (const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;arg1, const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;arg2, <a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a> mask)</td></tr>
<tr class="memdesc:afb4e1c7d15b5819e3cdb720bc133fb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional move.  <br /></td></tr>
<tr class="separator:afb4e1c7d15b5819e3cdb720bc133fb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad37aed4b430c6d8b50b47d5eac29cb7d" id="r_ad37aed4b430c6d8b50b47d5eac29cb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#ad37aed4b430c6d8b50b47d5eac29cb7d">mChunkBase</a> [3]</td></tr>
<tr class="separator:ad37aed4b430c6d8b50b47d5eac29cb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1850e46810eb005235fc6dcb7ebf6c9e" id="r_a1850e46810eb005235fc6dcb7ebf6c9e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a1850e46810eb005235fc6dcb7ebf6c9e">NEGATIVE_UNIT_X</a></td></tr>
<tr class="separator:a1850e46810eb005235fc6dcb7ebf6c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f41d14e17ce0511a5907f310c452da8" id="r_a6f41d14e17ce0511a5907f310c452da8"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a6f41d14e17ce0511a5907f310c452da8">NEGATIVE_UNIT_Y</a></td></tr>
<tr class="separator:a6f41d14e17ce0511a5907f310c452da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7793b69af40e78f5774688451894718d" id="r_a7793b69af40e78f5774688451894718d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a7793b69af40e78f5774688451894718d">NEGATIVE_UNIT_Z</a></td></tr>
<tr class="separator:a7793b69af40e78f5774688451894718d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430a0a90f2cdab4764844a276636a2d9" id="r_a430a0a90f2cdab4764844a276636a2d9"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a430a0a90f2cdab4764844a276636a2d9">UNIT_SCALE</a></td></tr>
<tr class="separator:a430a0a90f2cdab4764844a276636a2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811d19510f8352453fa8f86d8c226a49" id="r_a811d19510f8352453fa8f86d8c226a49"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a811d19510f8352453fa8f86d8c226a49">UNIT_X</a></td></tr>
<tr class="separator:a811d19510f8352453fa8f86d8c226a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a152308d886080433232254917bb4bb" id="r_a6a152308d886080433232254917bb4bb"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a6a152308d886080433232254917bb4bb">UNIT_Y</a></td></tr>
<tr class="separator:a6a152308d886080433232254917bb4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcb417792cf81b60dcfaa0ec77b150f" id="r_a1fcb417792cf81b60dcfaa0ec77b150f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a1fcb417792cf81b60dcfaa0ec77b150f">UNIT_Z</a></td></tr>
<tr class="separator:a1fcb417792cf81b60dcfaa0ec77b150f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c9bb82113607b3f57b5c35a72a9c7d" id="r_a03c9bb82113607b3f57b5c35a72a9c7d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_array_vector3.html#a03c9bb82113607b3f57b5c35a72a9c7d">ZERO</a></td></tr>
<tr class="separator:a03c9bb82113607b3f57b5c35a72a9c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cache-friendly array of 3-dimensional represented as a SoA array. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a> is a SIMD &amp; cache-friendly version of <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector.">Vector3</a>. An operation on an <a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a> is done on 4 vectors at a time (the actual amount is defined by ARRAY_PACKED_REALS) Assuming ARRAY_PACKED_REALS == 4, the memory layout will be as following: mChunkBase mChunkBase + 3 XXXX YYYY ZZZZ XXXX YYYY ZZZZ Extracting one vector (XYZ) needs 48 bytes, which is within the 64 byte size of common cache lines. Architectures where the cache line == 32 bytes may want to set ARRAY_PACKED_REALS = 2 depending on their needs </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a648c9686db201b1e04e38d0dbaff416e" name="a648c9686db201b1e04e38d0dbaff416e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c9686db201b1e04e38d0dbaff416e">&#9670;&#160;</a></span>ArrayVector3() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ArrayVector3::ArrayVector3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26d13d0e2cd250d894339d3f83b4e7a8" name="a26d13d0e2cd250d894339d3f83b4e7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d13d0e2cd250d894339d3f83b4e7a8">&#9670;&#160;</a></span>ArrayVector3() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ArrayVector3::ArrayVector3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a648c9686db201b1e04e38d0dbaff416e" name="a648c9686db201b1e04e38d0dbaff416e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c9686db201b1e04e38d0dbaff416e">&#9670;&#160;</a></span>ArrayVector3() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ArrayVector3::ArrayVector3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26d13d0e2cd250d894339d3f83b4e7a8" name="a26d13d0e2cd250d894339d3f83b4e7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d13d0e2cd250d894339d3f83b4e7a8">&#9670;&#160;</a></span>ArrayVector3() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ArrayVector3::ArrayVector3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a648c9686db201b1e04e38d0dbaff416e" name="a648c9686db201b1e04e38d0dbaff416e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c9686db201b1e04e38d0dbaff416e">&#9670;&#160;</a></span>ArrayVector3() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ArrayVector3::ArrayVector3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26d13d0e2cd250d894339d3f83b4e7a8" name="a26d13d0e2cd250d894339d3f83b4e7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d13d0e2cd250d894339d3f83b4e7a8">&#9670;&#160;</a></span>ArrayVector3() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ArrayVector3::ArrayVector3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>chunkZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4950c21ce53c92acca289072479877f7" name="a4950c21ce53c92acca289072479877f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4950c21ce53c92acca289072479877f7">&#9670;&#160;</a></span>absDotProduct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::absDotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the absolute dot (scalar) product of this vector with another.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function work similar dotProduct, except it use absolute value of each component of the vector to computing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector with which to calculate the absolute dot product (together with this one). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Real representing the absolute dot product value.   </dd></dl>

</div>
</div>
<a id="a4950c21ce53c92acca289072479877f7" name="a4950c21ce53c92acca289072479877f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4950c21ce53c92acca289072479877f7">&#9670;&#160;</a></span>absDotProduct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::absDotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the absolute dot (scalar) product of this vector with another.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function work similar dotProduct, except it use absolute value of each component of the vector to computing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector with which to calculate the absolute dot product (together with this one). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Real representing the absolute dot product value.   </dd></dl>

</div>
</div>
<a id="a4950c21ce53c92acca289072479877f7" name="a4950c21ce53c92acca289072479877f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4950c21ce53c92acca289072479877f7">&#9670;&#160;</a></span>absDotProduct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::absDotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the absolute dot (scalar) product of this vector with another.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function work similar dotProduct, except it use absolute value of each component of the vector to computing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector with which to calculate the absolute dot product (together with this one). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Real representing the absolute dot product value.   </dd></dl>

</div>
</div>
<a id="a805a9b00aaa5a7814c5223c889ec5444" name="a805a9b00aaa5a7814c5223c889ec5444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805a9b00aaa5a7814c5223c889ec5444">&#9670;&#160;</a></span>Cmov4() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::Cmov4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move update. </p>
<p>Changes each of the four vectors contained in 'this' with the replacement provided:</p>
<p>this[i] = mask[i] != 0 ? this[i] : replacement[i] </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_mathlib_c.html#ad1247bb457f65e41e895b4567fe27299" title="Branchless conditional move for 4 floating point values.">MathlibC::Cmov4</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. Use this version if you want to decide whether to keep current result or overwrite with a replacement (performance optimization). i.e. a = Cmov4( a, b ) If this vector hasn't been assigned yet any value and want to decide between two ArrayVector3s, i.e. a = Cmov4( b, c ) then see <a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96" title="Conditional move.">Cmov4( const ArrayVector3 &amp;arg1, const ArrayVector3 &amp;arg2, ArrayMaskR mask )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacement</td><td>Vectors to be used as replacement if the mask is zero. </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a805a9b00aaa5a7814c5223c889ec5444" name="a805a9b00aaa5a7814c5223c889ec5444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805a9b00aaa5a7814c5223c889ec5444">&#9670;&#160;</a></span>Cmov4() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::Cmov4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move update. </p>
<p>Changes each of the four vectors contained in 'this' with the replacement provided:</p>
<p>this[i] = mask[i] != 0 ? this[i] : replacement[i] </p><dl class="section see"><dt>See also</dt><dd>MathlibNEON::Cmov4 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. Use this version if you want to decide whether to keep current result or overwrite with a replacement (performance optimization). i.e. a = Cmov4( a, b ) If this vector hasn't been assigned yet any value and want to decide between two ArrayVector3s, i.e. a = Cmov4( b, c ) then see <a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96" title="Conditional move.">Cmov4( const ArrayVector3 &amp;arg1, const ArrayVector3 &amp;arg2, ArrayMaskR mask )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacement</td><td>Vectors to be used as replacement if the mask is zero. </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a805a9b00aaa5a7814c5223c889ec5444" name="a805a9b00aaa5a7814c5223c889ec5444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805a9b00aaa5a7814c5223c889ec5444">&#9670;&#160;</a></span>Cmov4() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::Cmov4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move update. </p>
<p>Changes each of the four vectors contained in 'this' with the replacement provided:</p>
<p>this[i] = mask[i] != 0 ? this[i] : replacement[i] </p><dl class="section see"><dt>See also</dt><dd>MathlibSSE2::Cmov4 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. Use this version if you want to decide whether to keep current result or overwrite with a replacement (performance optimization). i.e. a = Cmov4( a, b ) If this vector hasn't been assigned yet any value and want to decide between two ArrayVector3s, i.e. a = Cmov4( b, c ) then see <a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96" title="Conditional move.">Cmov4( const ArrayVector3 &amp;arg1, const ArrayVector3 &amp;arg2, ArrayMaskR mask )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacement</td><td>Vectors to be used as replacement if the mask is zero. </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb4e1c7d15b5819e3cdb720bc133fb96" name="afb4e1c7d15b5819e3cdb720bc133fb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4e1c7d15b5819e3cdb720bc133fb96">&#9670;&#160;</a></span>Cmov4() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::Cmov4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move. </p>
<p>Selects between arg1 &amp; arg2 according to mask:</p>
<p>this[i] = mask[i] != 0 ? arg1[i] : arg2[i] </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_mathlib_c.html#ad1247bb457f65e41e895b4567fe27299" title="Branchless conditional move for 4 floating point values.">MathlibC::Cmov4</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. If you wanted to do a = cmov4( a, b ), then consider using the update version see <a class="el" href="class_ogre_1_1_array_vector3.html#a805a9b00aaa5a7814c5223c889ec5444" title="Conditional move update.">Cmov4( ArrayMaskR mask, const ArrayVector3 &amp;replacement )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg1</td><td>First array of Vectors </td></tr>
    <tr><td class="paramname">arg2</td><td>Second array of Vectors </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb4e1c7d15b5819e3cdb720bc133fb96" name="afb4e1c7d15b5819e3cdb720bc133fb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4e1c7d15b5819e3cdb720bc133fb96">&#9670;&#160;</a></span>Cmov4() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::Cmov4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move. </p>
<p>Selects between arg1 &amp; arg2 according to mask:</p>
<p>this[i] = mask[i] != 0 ? arg1[i] : arg2[i] </p><dl class="section see"><dt>See also</dt><dd>MathlibNEON::Cmov4 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. If you wanted to do a = cmov4( a, b ), then consider using the update version see <a class="el" href="class_ogre_1_1_array_vector3.html#a805a9b00aaa5a7814c5223c889ec5444" title="Conditional move update.">Cmov4( ArrayMaskR mask, const ArrayVector3 &amp;replacement )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg1</td><td>First array of Vectors </td></tr>
    <tr><td class="paramname">arg2</td><td>Second array of Vectors </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb4e1c7d15b5819e3cdb720bc133fb96" name="afb4e1c7d15b5819e3cdb720bc133fb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4e1c7d15b5819e3cdb720bc133fb96">&#9670;&#160;</a></span>Cmov4() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::Cmov4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move. </p>
<p>Selects between arg1 &amp; arg2 according to mask:</p>
<p>this[i] = mask[i] != 0 ? arg1[i] : arg2[i] </p><dl class="section see"><dt>See also</dt><dd>MathlibSSE2::Cmov4 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. If you wanted to do a = cmov4( a, b ), then consider using the update version see <a class="el" href="class_ogre_1_1_array_vector3.html#a805a9b00aaa5a7814c5223c889ec5444" title="Conditional move update.">Cmov4( ArrayMaskR mask, const ArrayVector3 &amp;replacement )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg1</td><td>First array of Vectors </td></tr>
    <tr><td class="paramname">arg2</td><td>Second array of Vectors </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40431a5fffe7c96ecf4fce6dd455e5ff" name="a40431a5fffe7c96ecf4fce6dd455e5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40431a5fffe7c96ecf4fce6dd455e5ff">&#9670;&#160;</a></span>CmovRobust() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::CmovRobust </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move update. </p>
<p>Changes each of the four vectors contained in 'this' with the replacement provided:</p>
<p>this[i] = mask[i] != 0 ? this[i] : replacement[i] </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_mathlib_c.html#adcfb12520c51062df3faff5b12db8a2d" title="Robust, branchless conditional move for a 128-bit value.">MathlibC::CmovRobust</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. Use this version if you want to decide whether to keep current result or overwrite with a replacement (performance optimization). i.e. a = CmovRobust( a, b ) If this vector hasn't been assigned yet any value and want to decide between two ArrayVector3s, i.e. a = Cmov4( b, c ) then see <a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96" title="Conditional move.">Cmov4( const ArrayVector3 &amp;arg1, const ArrayVector3 &amp;arg2, ArrayMaskR mask )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacement</td><td>Vectors to be used as replacement if the mask is zero. </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40431a5fffe7c96ecf4fce6dd455e5ff" name="a40431a5fffe7c96ecf4fce6dd455e5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40431a5fffe7c96ecf4fce6dd455e5ff">&#9670;&#160;</a></span>CmovRobust() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::CmovRobust </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move update. </p>
<p>Changes each of the four vectors contained in 'this' with the replacement provided:</p>
<p>this[i] = mask[i] != 0 ? this[i] : replacement[i] </p><dl class="section see"><dt>See also</dt><dd>MathlibNEON::CmovRobust </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. Use this version if you want to decide whether to keep current result or overwrite with a replacement (performance optimization). i.e. a = CmovRobust( a, b ) If this vector hasn't been assigned yet any value and want to decide between two ArrayVector3s, i.e. a = Cmov4( b, c ) then see <a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96" title="Conditional move.">Cmov4( const ArrayVector3 &amp;arg1, const ArrayVector3 &amp;arg2, ArrayMaskR mask )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacement</td><td>Vectors to be used as replacement if the mask is zero. </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40431a5fffe7c96ecf4fce6dd455e5ff" name="a40431a5fffe7c96ecf4fce6dd455e5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40431a5fffe7c96ecf4fce6dd455e5ff">&#9670;&#160;</a></span>CmovRobust() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::CmovRobust </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3d9f5c00761ed1ff7885a805d82f942c">ArrayMaskR</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional move update. </p>
<p>Changes each of the four vectors contained in 'this' with the replacement provided:</p>
<p>this[i] = mask[i] != 0 ? this[i] : replacement[i] </p><dl class="section see"><dt>See also</dt><dd>MathlibSSE2::CmovRobust </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If mask param contains anything other than 0's or 0xffffffff's the result is undefined. Use this version if you want to decide whether to keep current result or overwrite with a replacement (performance optimization). i.e. a = CmovRobust( a, b ) If this vector hasn't been assigned yet any value and want to decide between two ArrayVector3s, i.e. a = Cmov4( b, c ) then see <a class="el" href="class_ogre_1_1_array_vector3.html#afb4e1c7d15b5819e3cdb720bc133fb96" title="Conditional move.">Cmov4( const ArrayVector3 &amp;arg1, const ArrayVector3 &amp;arg2, ArrayMaskR mask )</a>; instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacement</td><td>Vectors to be used as replacement if the mask is zero. </td></tr>
    <tr><td class="paramname">mask</td><td>mask filled with either 0's or 0xFFFFFFFF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb882c4c156ca3eb74f28334e5d31df3" name="adb882c4c156ca3eb74f28334e5d31df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb882c4c156ca3eb74f28334e5d31df3">&#9670;&#160;</a></span>collapseMax() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::collapseMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes each Vector and returns one returns a single vector. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful when calculating bounding boxes, since it can be done independently in SIMD form, and once it is done, merge the results from the simd vectors into one </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector.x = max( vector[0].x, vector[1].x, vector[2].x, vector[3].x ) Vector.y = max( vector[0].y, vector[1].y, vector[2].y, vector[3].y ) Vector.z = max( vector[0].z, vector[1].z, vector[2].z, vector[3].z ) </dd></dl>

</div>
</div>
<a id="adb882c4c156ca3eb74f28334e5d31df3" name="adb882c4c156ca3eb74f28334e5d31df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb882c4c156ca3eb74f28334e5d31df3">&#9670;&#160;</a></span>collapseMax() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::collapseMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes each Vector and returns one returns a single vector. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful when calculating bounding boxes, since it can be done independently in SIMD form, and once it is done, merge the results from the simd vectors into one </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector.x = max( vector[0].x, vector[1].x, vector[2].x, vector[3].x ) Vector.y = max( vector[0].y, vector[1].y, vector[2].y, vector[3].y ) Vector.z = max( vector[0].z, vector[1].z, vector[2].z, vector[3].z ) </dd></dl>

</div>
</div>
<a id="adb882c4c156ca3eb74f28334e5d31df3" name="adb882c4c156ca3eb74f28334e5d31df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb882c4c156ca3eb74f28334e5d31df3">&#9670;&#160;</a></span>collapseMax() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::collapseMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes each Vector and returns one returns a single vector. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful when calculating bounding boxes, since it can be done independently in SIMD form, and once it is done, merge the results from the simd vectors into one </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector.x = max( vector[0].x, vector[1].x, vector[2].x, vector[3].x ) Vector.y = max( vector[0].y, vector[1].y, vector[2].y, vector[3].y ) Vector.z = max( vector[0].z, vector[1].z, vector[2].z, vector[3].z ) </dd></dl>

</div>
</div>
<a id="ab255c905ea93eca9f7eeb09d19f62019" name="ab255c905ea93eca9f7eeb09d19f62019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab255c905ea93eca9f7eeb09d19f62019">&#9670;&#160;</a></span>collapseMin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::collapseMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes each Vector and returns one returns a single vector. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful when calculating bounding boxes, since it can be done independently in SIMD form, and once it is done, merge the results from the simd vectors into one </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector.x = min( vector[0].x, vector[1].x, vector[2].x, vector[3].x ) Vector.y = min( vector[0].y, vector[1].y, vector[2].y, vector[3].y ) Vector.z = min( vector[0].z, vector[1].z, vector[2].z, vector[3].z ) </dd></dl>

</div>
</div>
<a id="ab255c905ea93eca9f7eeb09d19f62019" name="ab255c905ea93eca9f7eeb09d19f62019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab255c905ea93eca9f7eeb09d19f62019">&#9670;&#160;</a></span>collapseMin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::collapseMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes each Vector and returns one returns a single vector. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful when calculating bounding boxes, since it can be done independently in SIMD form, and once it is done, merge the results from the simd vectors into one </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector.x = min( vector[0].x, vector[1].x, vector[2].x, vector[3].x ) Vector.y = min( vector[0].y, vector[1].y, vector[2].y, vector[3].y ) Vector.z = min( vector[0].z, vector[1].z, vector[2].z, vector[3].z ) </dd></dl>

</div>
</div>
<a id="ab255c905ea93eca9f7eeb09d19f62019" name="ab255c905ea93eca9f7eeb09d19f62019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab255c905ea93eca9f7eeb09d19f62019">&#9670;&#160;</a></span>collapseMin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::collapseMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes each Vector and returns one returns a single vector. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful when calculating bounding boxes, since it can be done independently in SIMD form, and once it is done, merge the results from the simd vectors into one </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector.x = min( vector[0].x, vector[1].x, vector[2].x, vector[3].x ) Vector.y = min( vector[0].y, vector[1].y, vector[2].y, vector[3].y ) Vector.z = min( vector[0].z, vector[1].z, vector[2].z, vector[3].z ) </dd></dl>

</div>
</div>
<a id="a34f2c866ac1fd2332b80d5049409f5f8" name="a34f2c866ac1fd2332b80d5049409f5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f2c866ac1fd2332b80d5049409f5f8">&#9670;&#160;</a></span>crossProduct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::crossProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rkVector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cross-product of 2 vectors, i.e.   </p>
<p>the vector that lies perpendicular to them both. </p><dl class="section remark"><dt>Remarks</dt><dd>The cross-product is normally used to calculate the normal vector of a plane, by calculating the cross-product of 2 non-equivalent vectors which lie on the plane (e.g. 2 edges of a triangle). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkVector</td><td>Vector which, together with this one, will be used to calculate the cross-product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector which is the result of the cross-product. This vector will <b>NOT</b> be normalised, to maximise efficiency<ul>
<li>call <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise</a> on the result if you wish this to be done. As for which side the resultant vector will be on, the returned vector will be on the side from which the arc from 'this' to rkVector is anticlockwise, e.g. UNIT_Y.crossProduct(UNIT_Z) = UNIT_X, whilst UNIT_Z.crossProduct(UNIT_Y) = -UNIT_X. This is because OGRE uses a right-handed coordinate system. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>For a clearer explanation, look a the left and the bottom edges of your monitor's screen. Assume that the first vector is the left edge and the second vector is the bottom edge, both of them starting from the lower-left corner of the screen. The resulting vector is going to be perpendicular to both of them and will go <em>inside</em> the screen, towards the cathode tube (assuming you're using a CRT monitor, of course).   </dd></dl>

</div>
</div>
<a id="a34f2c866ac1fd2332b80d5049409f5f8" name="a34f2c866ac1fd2332b80d5049409f5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f2c866ac1fd2332b80d5049409f5f8">&#9670;&#160;</a></span>crossProduct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::crossProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rkVector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cross-product of 2 vectors, i.e.   </p>
<p>the vector that lies perpendicular to them both. </p><dl class="section remark"><dt>Remarks</dt><dd>The cross-product is normally used to calculate the normal vector of a plane, by calculating the cross-product of 2 non-equivalent vectors which lie on the plane (e.g. 2 edges of a triangle). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkVector</td><td>Vector which, together with this one, will be used to calculate the cross-product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector which is the result of the cross-product. This vector will <b>NOT</b> be normalised, to maximise efficiency<ul>
<li>call <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise</a> on the result if you wish this to be done. As for which side the resultant vector will be on, the returned vector will be on the side from which the arc from 'this' to rkVector is anticlockwise, e.g. UNIT_Y.crossProduct(UNIT_Z) = UNIT_X, whilst UNIT_Z.crossProduct(UNIT_Y) = -UNIT_X. This is because OGRE uses a right-handed coordinate system. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>For a clearer explanation, look a the left and the bottom edges of your monitor's screen. Assume that the first vector is the left edge and the second vector is the bottom edge, both of them starting from the lower-left corner of the screen. The resulting vector is going to be perpendicular to both of them and will go <em>inside</em> the screen, towards the cathode tube (assuming you're using a CRT monitor, of course).   </dd></dl>

</div>
</div>
<a id="a34f2c866ac1fd2332b80d5049409f5f8" name="a34f2c866ac1fd2332b80d5049409f5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f2c866ac1fd2332b80d5049409f5f8">&#9670;&#160;</a></span>crossProduct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::crossProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rkVector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cross-product of 2 vectors, i.e.   </p>
<p>the vector that lies perpendicular to them both. </p><dl class="section remark"><dt>Remarks</dt><dd>The cross-product is normally used to calculate the normal vector of a plane, by calculating the cross-product of 2 non-equivalent vectors which lie on the plane (e.g. 2 edges of a triangle). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkVector</td><td>Vector which, together with this one, will be used to calculate the cross-product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector which is the result of the cross-product. This vector will <b>NOT</b> be normalised, to maximise efficiency<ul>
<li>call <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise</a> on the result if you wish this to be done. As for which side the resultant vector will be on, the returned vector will be on the side from which the arc from 'this' to rkVector is anticlockwise, e.g. UNIT_Y.crossProduct(UNIT_Z) = UNIT_X, whilst UNIT_Z.crossProduct(UNIT_Y) = -UNIT_X. This is because OGRE uses a right-handed coordinate system. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>For a clearer explanation, look a the left and the bottom edges of your monitor's screen. Assume that the first vector is the left edge and the second vector is the bottom edge, both of them starting from the lower-left corner of the screen. The resulting vector is going to be perpendicular to both of them and will go <em>inside</em> the screen, towards the cathode tube (assuming you're using a CRT monitor, of course).   </dd></dl>

</div>
</div>
<a id="a6e8e9b0e7599217aeebb8ad30b9a62bb" name="a6e8e9b0e7599217aeebb8ad30b9a62bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8e9b0e7599217aeebb8ad30b9a62bb">&#9670;&#160;</a></span>distance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance to another vector.   </p>
<dl class="section warning"><dt>Warning</dt><dd>This operation requires a square root and is expensive in terms of CPU operations. If you don't need to know the exact distance (e.g. for just comparing distances) use <a class="el" href="class_ogre_1_1_array_vector3.html#a101ace91b0add48e5fcc959f6a037fd4" title="Returns the square of the distance to another vector.">squaredDistance()</a> instead.   </dd></dl>

</div>
</div>
<a id="a6e8e9b0e7599217aeebb8ad30b9a62bb" name="a6e8e9b0e7599217aeebb8ad30b9a62bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8e9b0e7599217aeebb8ad30b9a62bb">&#9670;&#160;</a></span>distance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance to another vector.   </p>
<dl class="section warning"><dt>Warning</dt><dd>This operation requires a square root and is expensive in terms of CPU operations. If you don't need to know the exact distance (e.g. for just comparing distances) use <a class="el" href="class_ogre_1_1_array_vector3.html#a101ace91b0add48e5fcc959f6a037fd4" title="Returns the square of the distance to another vector.">squaredDistance()</a> instead.   </dd></dl>

</div>
</div>
<a id="a6e8e9b0e7599217aeebb8ad30b9a62bb" name="a6e8e9b0e7599217aeebb8ad30b9a62bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8e9b0e7599217aeebb8ad30b9a62bb">&#9670;&#160;</a></span>distance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance to another vector.   </p>
<dl class="section warning"><dt>Warning</dt><dd>This operation requires a square root and is expensive in terms of CPU operations. If you don't need to know the exact distance (e.g. for just comparing distances) use <a class="el" href="class_ogre_1_1_array_vector3.html#a101ace91b0add48e5fcc959f6a037fd4" title="Returns the square of the distance to another vector.">squaredDistance()</a> instead.   </dd></dl>

</div>
</div>
<a id="af126fffa83c6d1bf3d6d3a2d67979430" name="af126fffa83c6d1bf3d6d3a2d67979430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af126fffa83c6d1bf3d6d3a2d67979430">&#9670;&#160;</a></span>dotProduct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::dotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot (scalar) product of this vector with another.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>The dot product can be used to calculate the angle between 2 vectors. If both are unit vectors, the dot product is the cosine of the angle; otherwise the dot product must be divided by the product of the lengths of both vectors to get the cosine of the angle. This result can further be used to calculate the distance of a point from a plane. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector with which to calculate the dot product (together with this one). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A float representing the dot product value.   </dd></dl>

</div>
</div>
<a id="af126fffa83c6d1bf3d6d3a2d67979430" name="af126fffa83c6d1bf3d6d3a2d67979430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af126fffa83c6d1bf3d6d3a2d67979430">&#9670;&#160;</a></span>dotProduct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::dotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot (scalar) product of this vector with another.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>The dot product can be used to calculate the angle between 2 vectors. If both are unit vectors, the dot product is the cosine of the angle; otherwise the dot product must be divided by the product of the lengths of both vectors to get the cosine of the angle. This result can further be used to calculate the distance of a point from a plane. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector with which to calculate the dot product (together with this one). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A float representing the dot product value.   </dd></dl>

</div>
</div>
<a id="af126fffa83c6d1bf3d6d3a2d67979430" name="af126fffa83c6d1bf3d6d3a2d67979430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af126fffa83c6d1bf3d6d3a2d67979430">&#9670;&#160;</a></span>dotProduct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::dotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot (scalar) product of this vector with another.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>The dot product can be used to calculate the angle between 2 vectors. If both are unit vectors, the dot product is the cosine of the angle; otherwise the dot product must be divided by the product of the lengths of both vectors to get the cosine of the angle. This result can further be used to calculate the distance of a point from a plane. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector with which to calculate the dot product (together with this one). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A float representing the dot product value.   </dd></dl>

</div>
</div>
<a id="aaec06d68161d4123b3fad14fb72fd9c5" name="aaec06d68161d4123b3fad14fb72fd9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec06d68161d4123b3fad14fb72fd9c5">&#9670;&#160;</a></span>getAsVector3() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::getAsVector3 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefer using. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_array_vector3.html#ad261d645fdf7f488ad9cca7a9a0e986f">getAsVector3()</a> because this function may have more overhead (the other one is faster) </dd></dl>

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>.</p>

</div>
</div>
<a id="aaec06d68161d4123b3fad14fb72fd9c5" name="aaec06d68161d4123b3fad14fb72fd9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec06d68161d4123b3fad14fb72fd9c5">&#9670;&#160;</a></span>getAsVector3() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::getAsVector3 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefer using. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_array_vector3.html#ad261d645fdf7f488ad9cca7a9a0e986f">getAsVector3()</a> because this function may have more overhead (the other one is faster) </dd></dl>

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>.</p>

</div>
</div>
<a id="aaec06d68161d4123b3fad14fb72fd9c5" name="aaec06d68161d4123b3fad14fb72fd9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec06d68161d4123b3fad14fb72fd9c5">&#9670;&#160;</a></span>getAsVector3() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ArrayVector3::getAsVector3 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefer using. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_array_vector3.html#ad261d645fdf7f488ad9cca7a9a0e986f">getAsVector3()</a> because this function may have more overhead (the other one is faster) </dd></dl>

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>.</p>

</div>
</div>
<a id="ad261d645fdf7f488ad9cca7a9a0e986f" name="ad261d645fdf7f488ad9cca7a9a0e986f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad261d645fdf7f488ad9cca7a9a0e986f">&#9670;&#160;</a></span>getAsVector3() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::getAsVector3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>, <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_bone_transform.html#a1ba3bd60d7b62b8bf22106fff26b302a">Ogre::BoneTransform::copy()</a>, <a class="el" href="struct_ogre_1_1_transform.html#a6b4b819f764fb26b97c1f528e60f7e3f">Ogre::Transform::copy()</a>, and <a class="el" href="class_ogre_1_1_array_sphere.html#ade0be53d896930c25b138721b9c3dfaf">Ogre::ArraySphere::getAsSphere()</a>.</p>

</div>
</div>
<a id="ad261d645fdf7f488ad9cca7a9a0e986f" name="ad261d645fdf7f488ad9cca7a9a0e986f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad261d645fdf7f488ad9cca7a9a0e986f">&#9670;&#160;</a></span>getAsVector3() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::getAsVector3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>, <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

</div>
</div>
<a id="ad261d645fdf7f488ad9cca7a9a0e986f" name="ad261d645fdf7f488ad9cca7a9a0e986f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad261d645fdf7f488ad9cca7a9a0e986f">&#9670;&#160;</a></span>getAsVector3() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::getAsVector3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>, <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

</div>
</div>
<a id="ab5b7a214726ba5ac0e7c39493e8baed0" name="ab5b7a214726ba5ac0e7c39493e8baed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b7a214726ba5ac0e7c39493e8baed0">&#9670;&#160;</a></span>getMaxComponent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::getMaxComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the biggest value between x, y, z; max( x, y, z ) </p>

</div>
</div>
<a id="ab5b7a214726ba5ac0e7c39493e8baed0" name="ab5b7a214726ba5ac0e7c39493e8baed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b7a214726ba5ac0e7c39493e8baed0">&#9670;&#160;</a></span>getMaxComponent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::getMaxComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the biggest value between x, y, z; max( x, y, z ) </p>

</div>
</div>
<a id="ab5b7a214726ba5ac0e7c39493e8baed0" name="ab5b7a214726ba5ac0e7c39493e8baed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b7a214726ba5ac0e7c39493e8baed0">&#9670;&#160;</a></span>getMaxComponent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::getMaxComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the biggest value between x, y, z; max( x, y, z ) </p>

</div>
</div>
<a id="a4d62ed0f1cc257fc715822ad330958b2" name="a4d62ed0f1cc257fc715822ad330958b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d62ed0f1cc257fc715822ad330958b2">&#9670;&#160;</a></span>getMinComponent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::getMinComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest value between x, y, z; min( x, y, z ) </p>

</div>
</div>
<a id="a4d62ed0f1cc257fc715822ad330958b2" name="a4d62ed0f1cc257fc715822ad330958b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d62ed0f1cc257fc715822ad330958b2">&#9670;&#160;</a></span>getMinComponent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::getMinComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest value between x, y, z; min( x, y, z ) </p>

</div>
</div>
<a id="a4d62ed0f1cc257fc715822ad330958b2" name="a4d62ed0f1cc257fc715822ad330958b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d62ed0f1cc257fc715822ad330958b2">&#9670;&#160;</a></span>getMinComponent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::getMinComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest value between x, y, z; min( x, y, z ) </p>

</div>
</div>
<a id="a35066b918a9ad1bb9c3cb1d99fa2bba0" name="a35066b918a9ad1bb9c3cb1d99fa2bba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35066b918a9ad1bb9c3cb1d99fa2bba0">&#9670;&#160;</a></span>inverseLeaveZeroes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::inverseLeaveZeroes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse of the vectors: 1.0f / v; But if original is zero, the zero is left (0 / 0 = 0). </p>
<p>Example: Bfore inverseLeaveZero: x = 0; y = 2; z = 3; After inverseLeaveZero x = 0; y = 0.5; z = 0.3333; </p>

</div>
</div>
<a id="a35066b918a9ad1bb9c3cb1d99fa2bba0" name="a35066b918a9ad1bb9c3cb1d99fa2bba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35066b918a9ad1bb9c3cb1d99fa2bba0">&#9670;&#160;</a></span>inverseLeaveZeroes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::inverseLeaveZeroes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse of the vectors: 1.0f / v; But if original is zero, the zero is left (0 / 0 = 0). </p>
<p>Example: Bfore inverseLeaveZero: x = 0; y = 2; z = 3; After inverseLeaveZero x = 0; y = 0.5; z = 0.3333; </p>

</div>
</div>
<a id="a35066b918a9ad1bb9c3cb1d99fa2bba0" name="a35066b918a9ad1bb9c3cb1d99fa2bba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35066b918a9ad1bb9c3cb1d99fa2bba0">&#9670;&#160;</a></span>inverseLeaveZeroes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::inverseLeaveZeroes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse of the vectors: 1.0f / v; But if original is zero, the zero is left (0 / 0 = 0). </p>
<p>Example: Bfore inverseLeaveZero: x = 0; y = 2; z = 3; After inverseLeaveZero x = 0; y = 0.5; z = 0.3333; </p>

</div>
</div>
<a id="aea08253517e4019d26c9fdbaf211aaaa" name="aea08253517e4019d26c9fdbaf211aaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea08253517e4019d26c9fdbaf211aaaa">&#9670;&#160;</a></span>isNaN() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::ArrayVector3::isNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_vector3.html#a07ceddb4d4a444a2e3ae083553c6175e" title="Check whether this vector contains valid values.">Vector3::isNaN()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Return value differs from <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector.">Vector3</a>'s counterpart. We return an int bits 0-4 are set for each NaN of each vector inside. if the int is non-zero, there is a NaN. </dd></dl>

</div>
</div>
<a id="aea08253517e4019d26c9fdbaf211aaaa" name="aea08253517e4019d26c9fdbaf211aaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea08253517e4019d26c9fdbaf211aaaa">&#9670;&#160;</a></span>isNaN() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::ArrayVector3::isNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_vector3.html#a07ceddb4d4a444a2e3ae083553c6175e" title="Check whether this vector contains valid values.">Vector3::isNaN()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Return value differs from <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector.">Vector3</a>'s counterpart. We return an int bits 0-4 are set for each NaN of each vector inside. if the int is non-zero, there is a NaN. </dd></dl>

</div>
</div>
<a id="aea08253517e4019d26c9fdbaf211aaaa" name="aea08253517e4019d26c9fdbaf211aaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea08253517e4019d26c9fdbaf211aaaa">&#9670;&#160;</a></span>isNaN() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::ArrayVector3::isNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_vector3.html#a07ceddb4d4a444a2e3ae083553c6175e" title="Check whether this vector contains valid values.">Vector3::isNaN()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Return value differs from <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector.">Vector3</a>'s counterpart. We return an int bits 0-4 are set for each NaN of each vector inside. if the int is non-zero, there is a NaN. </dd></dl>

</div>
</div>
<a id="adf3ddabbf07ee074fb9f92faa2a19da1" name="adf3ddabbf07ee074fb9f92faa2a19da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3ddabbf07ee074fb9f92faa2a19da1">&#9670;&#160;</a></span>length() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length (magnitude) of the vector.   </p>
<dl class="section warning"><dt>Warning</dt><dd>This operation requires a square root and is expensive in terms of CPU operations. If you don't need to know the exact length (e.g. for just comparing lengths) use <a class="el" href="class_ogre_1_1_array_vector3.html#af6afb89604e05e1240f4cfc2e9695591" title="Returns the square of the length(magnitude) of the vector.">squaredLength()</a> instead.   </dd></dl>

</div>
</div>
<a id="adf3ddabbf07ee074fb9f92faa2a19da1" name="adf3ddabbf07ee074fb9f92faa2a19da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3ddabbf07ee074fb9f92faa2a19da1">&#9670;&#160;</a></span>length() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length (magnitude) of the vector.   </p>
<dl class="section warning"><dt>Warning</dt><dd>This operation requires a square root and is expensive in terms of CPU operations. If you don't need to know the exact length (e.g. for just comparing lengths) use <a class="el" href="class_ogre_1_1_array_vector3.html#af6afb89604e05e1240f4cfc2e9695591" title="Returns the square of the length(magnitude) of the vector.">squaredLength()</a> instead.   </dd></dl>

</div>
</div>
<a id="adf3ddabbf07ee074fb9f92faa2a19da1" name="adf3ddabbf07ee074fb9f92faa2a19da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3ddabbf07ee074fb9f92faa2a19da1">&#9670;&#160;</a></span>length() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length (magnitude) of the vector.   </p>
<dl class="section warning"><dt>Warning</dt><dd>This operation requires a square root and is expensive in terms of CPU operations. If you don't need to know the exact length (e.g. for just comparing lengths) use <a class="el" href="class_ogre_1_1_array_vector3.html#af6afb89604e05e1240f4cfc2e9695591" title="Returns the square of the length(magnitude) of the vector.">squaredLength()</a> instead.   </dd></dl>

</div>
</div>
<a id="ae01d1a2ad3c795ed608ed191c84de476" name="ae01d1a2ad3c795ed608ed191c84de476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01d1a2ad3c795ed608ed191c84de476">&#9670;&#160;</a></span>loadFromAoS() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::loadFromAoS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts 4 ARRAY_PACKED_REALS reals into this <a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>'src' must be aligned and assumed to have enough memory for ARRAY_PACKED_REALS <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector.">Vector3</a> See <a class="el" href="class_ogre_1_1_frustum.html#ab77b3b9a504518e7e8252cb789e74ff1">Frustum::getCustomWorldSpaceCorners</a> implementation for an actual, advanced use case. </dd></dl>

</div>
</div>
<a id="ae01d1a2ad3c795ed608ed191c84de476" name="ae01d1a2ad3c795ed608ed191c84de476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01d1a2ad3c795ed608ed191c84de476">&#9670;&#160;</a></span>loadFromAoS() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::loadFromAoS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts 4 ARRAY_PACKED_REALS reals into this <a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>'src' must be aligned and assumed to have enough memory for ARRAY_PACKED_REALS <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector.">Vector3</a> i.e. on SSE2 you can construct src as: <a class="el" href="_ogre_platform_8h.html#af405686ffe3dd6aa1b9683a99e5990ed">OGRE_ALIGNED_DECL( Real, vals[ARRAY_PACKED_REALS * 4], OGRE_SIMD_ALIGNMENT )</a> = { x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, x3, y3, z3, 0, } See <a class="el" href="class_ogre_1_1_frustum.html#ab77b3b9a504518e7e8252cb789e74ff1">Frustum::getCustomWorldSpaceCorners</a> implementation for an actual, advanced use case. </dd></dl>

</div>
</div>
<a id="ae01d1a2ad3c795ed608ed191c84de476" name="ae01d1a2ad3c795ed608ed191c84de476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01d1a2ad3c795ed608ed191c84de476">&#9670;&#160;</a></span>loadFromAoS() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::loadFromAoS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts 4 ARRAY_PACKED_REALS reals into this <a class="el" href="class_ogre_1_1_array_vector3.html" title="Cache-friendly array of 3-dimensional represented as a SoA array.">ArrayVector3</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>'src' must be aligned and assumed to have enough memory for ARRAY_PACKED_REALS <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector.">Vector3</a> i.e. on SSE2 you can construct src as: <a class="el" href="_ogre_platform_8h.html#af405686ffe3dd6aa1b9683a99e5990ed">OGRE_ALIGNED_DECL( Real, vals[ARRAY_PACKED_REALS * 4], OGRE_SIMD_ALIGNMENT )</a> = { x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, x3, y3, z3, 0, } See <a class="el" href="class_ogre_1_1_frustum.html#ab77b3b9a504518e7e8252cb789e74ff1">Frustum::getCustomWorldSpaceCorners</a> implementation for an actual, advanced use case. </dd></dl>

</div>
</div>
<a id="a456e979750ed64f62fe083f04447264d" name="a456e979750ed64f62fe083f04447264d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456e979750ed64f62fe083f04447264d">&#9670;&#160;</a></span>makeCeil() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::makeCeil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this vector's components to the maximum of its own and the ones of the passed in vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>'Maximum' in this case means the combination of the highest value of x, y and z from both vectors. Highest is taken just numerically, not magnitude, so 1 &gt; -3.   </dd></dl>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_array_ray.html#a1e8cbbda73ce427f9c5418b2552f819e">Ogre::ArrayRay::intersects()</a>.</p>

</div>
</div>
<a id="a456e979750ed64f62fe083f04447264d" name="a456e979750ed64f62fe083f04447264d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456e979750ed64f62fe083f04447264d">&#9670;&#160;</a></span>makeCeil() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::makeCeil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this vector's components to the maximum of its own and the ones of the passed in vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>'Maximum' in this case means the combination of the highest value of x, y and z from both vectors. Highest is taken just numerically, not magnitude, so 1 &gt; -3.   </dd></dl>

</div>
</div>
<a id="a456e979750ed64f62fe083f04447264d" name="a456e979750ed64f62fe083f04447264d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456e979750ed64f62fe083f04447264d">&#9670;&#160;</a></span>makeCeil() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::makeCeil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this vector's components to the maximum of its own and the ones of the passed in vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>'Maximum' in this case means the combination of the highest value of x, y and z from both vectors. Highest is taken just numerically, not magnitude, so 1 &gt; -3.   </dd></dl>

</div>
</div>
<a id="ab573b7c18f1f76071a3f40b0e1bfd9ea" name="ab573b7c18f1f76071a3f40b0e1bfd9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab573b7c18f1f76071a3f40b0e1bfd9ea">&#9670;&#160;</a></span>makeFloor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::makeFloor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this vector's components to the minimum of its own and the ones of the passed in vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>'Minimum' in this case means the combination of the lowest value of x, y and z from both vectors. Lowest is taken just numerically, not magnitude, so -1 &lt; 0.   </dd></dl>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_array_ray.html#a1e8cbbda73ce427f9c5418b2552f819e">Ogre::ArrayRay::intersects()</a>.</p>

</div>
</div>
<a id="ab573b7c18f1f76071a3f40b0e1bfd9ea" name="ab573b7c18f1f76071a3f40b0e1bfd9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab573b7c18f1f76071a3f40b0e1bfd9ea">&#9670;&#160;</a></span>makeFloor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::makeFloor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this vector's components to the minimum of its own and the ones of the passed in vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>'Minimum' in this case means the combination of the lowest value of x, y and z from both vectors. Lowest is taken just numerically, not magnitude, so -1 &lt; 0.   </dd></dl>

</div>
</div>
<a id="ab573b7c18f1f76071a3f40b0e1bfd9ea" name="ab573b7c18f1f76071a3f40b0e1bfd9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab573b7c18f1f76071a3f40b0e1bfd9ea">&#9670;&#160;</a></span>makeFloor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::makeFloor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this vector's components to the minimum of its own and the ones of the passed in vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>'Minimum' in this case means the combination of the lowest value of x, y and z from both vectors. Lowest is taken just numerically, not magnitude, so -1 &lt; 0.   </dd></dl>

</div>
</div>
<a id="a3ee72f680790a341db04fac3be6c5691" name="a3ee72f680790a341db04fac3be6c5691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee72f680790a341db04fac3be6c5691">&#9670;&#160;</a></span>midPoint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::midPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector at a point half way between this and the passed in vector.   </p>

</div>
</div>
<a id="a3ee72f680790a341db04fac3be6c5691" name="a3ee72f680790a341db04fac3be6c5691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee72f680790a341db04fac3be6c5691">&#9670;&#160;</a></span>midPoint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::midPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector at a point half way between this and the passed in vector.   </p>

</div>
</div>
<a id="a3ee72f680790a341db04fac3be6c5691" name="a3ee72f680790a341db04fac3be6c5691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee72f680790a341db04fac3be6c5691">&#9670;&#160;</a></span>midPoint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::midPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector at a point half way between this and the passed in vector.   </p>

</div>
</div>
<a id="ab00894c807c4cb587c081cc108701f29" name="ab00894c807c4cb587c081cc108701f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00894c807c4cb587c081cc108701f29">&#9670;&#160;</a></span>normalise() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::normalise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlike <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a>, this function does not return the length of the vector because such value was not cached and was never available. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a> </dd></dl>

</div>
</div>
<a id="ab00894c807c4cb587c081cc108701f29" name="ab00894c807c4cb587c081cc108701f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00894c807c4cb587c081cc108701f29">&#9670;&#160;</a></span>normalise() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::normalise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlike <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a>, this function does not return the length of the vector because such value was not cached and was never available. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a> </dd></dl>

</div>
</div>
<a id="ab00894c807c4cb587c081cc108701f29" name="ab00894c807c4cb587c081cc108701f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00894c807c4cb587c081cc108701f29">&#9670;&#160;</a></span>normalise() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::normalise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlike <a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a>, this function does not return the length of the vector because such value was not cached and was never available. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_vector3.html#a9e572a5cc4e1ed826839e5281d8f1d3b" title="Normalises the vector.">Vector3::normalise()</a> </dd></dl>

</div>
</div>
<a id="a693f10951d2ab75eae3eb5d59e1e1197" name="a693f10951d2ab75eae3eb5d59e1e1197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693f10951d2ab75eae3eb5d59e1e1197">&#9670;&#160;</a></span>normalisedCopy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::normalisedCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As normalise, except that this vector is unaffected and the normalised vector is returned as a copy.   </p>

</div>
</div>
<a id="a693f10951d2ab75eae3eb5d59e1e1197" name="a693f10951d2ab75eae3eb5d59e1e1197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693f10951d2ab75eae3eb5d59e1e1197">&#9670;&#160;</a></span>normalisedCopy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::normalisedCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As normalise, except that this vector is unaffected and the normalised vector is returned as a copy.   </p>

</div>
</div>
<a id="a693f10951d2ab75eae3eb5d59e1e1197" name="a693f10951d2ab75eae3eb5d59e1e1197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693f10951d2ab75eae3eb5d59e1e1197">&#9670;&#160;</a></span>normalisedCopy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::normalisedCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As normalise, except that this vector is unaffected and the normalised vector is returned as a copy.   </p>

</div>
</div>
<a id="a003f296f292d0bea684a41a38fdbfdd3" name="a003f296f292d0bea684a41a38fdbfdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003f296f292d0bea684a41a38fdbfdd3">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a003f296f292d0bea684a41a38fdbfdd3" name="a003f296f292d0bea684a41a38fdbfdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003f296f292d0bea684a41a38fdbfdd3">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a003f296f292d0bea684a41a38fdbfdd3" name="a003f296f292d0bea684a41a38fdbfdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003f296f292d0bea684a41a38fdbfdd3">&#9670;&#160;</a></span>operator*=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d240293db14723529e48511e740457e" name="a0d240293db14723529e48511e740457e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d240293db14723529e48511e740457e">&#9670;&#160;</a></span>operator*=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d240293db14723529e48511e740457e" name="a0d240293db14723529e48511e740457e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d240293db14723529e48511e740457e">&#9670;&#160;</a></span>operator*=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d240293db14723529e48511e740457e" name="a0d240293db14723529e48511e740457e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d240293db14723529e48511e740457e">&#9670;&#160;</a></span>operator*=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08483bf68f3a83c2256bbacb4c13505f" name="a08483bf68f3a83c2256bbacb4c13505f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08483bf68f3a83c2256bbacb4c13505f">&#9670;&#160;</a></span>operator*=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08483bf68f3a83c2256bbacb4c13505f" name="a08483bf68f3a83c2256bbacb4c13505f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08483bf68f3a83c2256bbacb4c13505f">&#9670;&#160;</a></span>operator*=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac65bfcb4e385ac60b021ebc14f386ed" name="aac65bfcb4e385ac60b021ebc14f386ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac65bfcb4e385ac60b021ebc14f386ed">&#9670;&#160;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp; Ogre::ArrayVector3::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac65bfcb4e385ac60b021ebc14f386ed" name="aac65bfcb4e385ac60b021ebc14f386ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac65bfcb4e385ac60b021ebc14f386ed">&#9670;&#160;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp; Ogre::ArrayVector3::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac65bfcb4e385ac60b021ebc14f386ed" name="aac65bfcb4e385ac60b021ebc14f386ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac65bfcb4e385ac60b021ebc14f386ed">&#9670;&#160;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp; Ogre::ArrayVector3::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6e27c2ec4412788016f4c389536fdea" name="aa6e27c2ec4412788016f4c389536fdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e27c2ec4412788016f4c389536fdea">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6e27c2ec4412788016f4c389536fdea" name="aa6e27c2ec4412788016f4c389536fdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e27c2ec4412788016f4c389536fdea">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6e27c2ec4412788016f4c389536fdea" name="aa6e27c2ec4412788016f4c389536fdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e27c2ec4412788016f4c389536fdea">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e028c8ddea0849816bd5838276b2d84" name="a4e028c8ddea0849816bd5838276b2d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e028c8ddea0849816bd5838276b2d84">&#9670;&#160;</a></span>operator+=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e028c8ddea0849816bd5838276b2d84" name="a4e028c8ddea0849816bd5838276b2d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e028c8ddea0849816bd5838276b2d84">&#9670;&#160;</a></span>operator+=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e028c8ddea0849816bd5838276b2d84" name="a4e028c8ddea0849816bd5838276b2d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e028c8ddea0849816bd5838276b2d84">&#9670;&#160;</a></span>operator+=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af899eb2447629726f0021c24174e2d8d" name="af899eb2447629726f0021c24174e2d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af899eb2447629726f0021c24174e2d8d">&#9670;&#160;</a></span>operator+=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af899eb2447629726f0021c24174e2d8d" name="af899eb2447629726f0021c24174e2d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af899eb2447629726f0021c24174e2d8d">&#9670;&#160;</a></span>operator+=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62cb4ba8c5f808cc1dff2244cf47b38f" name="a62cb4ba8c5f808cc1dff2244cf47b38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cb4ba8c5f808cc1dff2244cf47b38f">&#9670;&#160;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62cb4ba8c5f808cc1dff2244cf47b38f" name="a62cb4ba8c5f808cc1dff2244cf47b38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cb4ba8c5f808cc1dff2244cf47b38f">&#9670;&#160;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62cb4ba8c5f808cc1dff2244cf47b38f" name="a62cb4ba8c5f808cc1dff2244cf47b38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cb4ba8c5f808cc1dff2244cf47b38f">&#9670;&#160;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bc0bf26201ccf0eaca2292a27420526" name="a4bc0bf26201ccf0eaca2292a27420526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc0bf26201ccf0eaca2292a27420526">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bc0bf26201ccf0eaca2292a27420526" name="a4bc0bf26201ccf0eaca2292a27420526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc0bf26201ccf0eaca2292a27420526">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bc0bf26201ccf0eaca2292a27420526" name="a4bc0bf26201ccf0eaca2292a27420526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc0bf26201ccf0eaca2292a27420526">&#9670;&#160;</a></span>operator-=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d76edf0716fe7260a288e0c879c6547" name="a1d76edf0716fe7260a288e0c879c6547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d76edf0716fe7260a288e0c879c6547">&#9670;&#160;</a></span>operator-=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d76edf0716fe7260a288e0c879c6547" name="a1d76edf0716fe7260a288e0c879c6547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d76edf0716fe7260a288e0c879c6547">&#9670;&#160;</a></span>operator-=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d76edf0716fe7260a288e0c879c6547" name="a1d76edf0716fe7260a288e0c879c6547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d76edf0716fe7260a288e0c879c6547">&#9670;&#160;</a></span>operator-=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4377bd6a0f3c34d7fe96abac787a9720" name="a4377bd6a0f3c34d7fe96abac787a9720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4377bd6a0f3c34d7fe96abac787a9720">&#9670;&#160;</a></span>operator-=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4377bd6a0f3c34d7fe96abac787a9720" name="a4377bd6a0f3c34d7fe96abac787a9720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4377bd6a0f3c34d7fe96abac787a9720">&#9670;&#160;</a></span>operator-=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ce091c241e52986e45298af2cc53c8" name="a63ce091c241e52986e45298af2cc53c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ce091c241e52986e45298af2cc53c8">&#9670;&#160;</a></span>operator/=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ce091c241e52986e45298af2cc53c8" name="a63ce091c241e52986e45298af2cc53c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ce091c241e52986e45298af2cc53c8">&#9670;&#160;</a></span>operator/=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ce091c241e52986e45298af2cc53c8" name="a63ce091c241e52986e45298af2cc53c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ce091c241e52986e45298af2cc53c8">&#9670;&#160;</a></span>operator/=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a448dcf1a6d8eb4298a3dbb687afb7970" name="a448dcf1a6d8eb4298a3dbb687afb7970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448dcf1a6d8eb4298a3dbb687afb7970">&#9670;&#160;</a></span>operator/=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a448dcf1a6d8eb4298a3dbb687afb7970" name="a448dcf1a6d8eb4298a3dbb687afb7970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448dcf1a6d8eb4298a3dbb687afb7970">&#9670;&#160;</a></span>operator/=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a448dcf1a6d8eb4298a3dbb687afb7970" name="a448dcf1a6d8eb4298a3dbb687afb7970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448dcf1a6d8eb4298a3dbb687afb7970">&#9670;&#160;</a></span>operator/=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b512047e8401f1ad418413535df5b10" name="a9b512047e8401f1ad418413535df5b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b512047e8401f1ad418413535df5b10">&#9670;&#160;</a></span>operator/=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b512047e8401f1ad418413535df5b10" name="a9b512047e8401f1ad418413535df5b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b512047e8401f1ad418413535df5b10">&#9670;&#160;</a></span>operator/=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a628d9a2a7f22c66fd901e5432f095a98" name="a628d9a2a7f22c66fd901e5432f095a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628d9a2a7f22c66fd901e5432f095a98">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp; Ogre::ArrayVector3::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies only one vector, by looking at the indexes. </p>

</div>
</div>
<a id="a628d9a2a7f22c66fd901e5432f095a98" name="a628d9a2a7f22c66fd901e5432f095a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628d9a2a7f22c66fd901e5432f095a98">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp; Ogre::ArrayVector3::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies only one vector, by looking at the indexes. </p>

</div>
</div>
<a id="a628d9a2a7f22c66fd901e5432f095a98" name="a628d9a2a7f22c66fd901e5432f095a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628d9a2a7f22c66fd901e5432f095a98">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp; Ogre::ArrayVector3::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>fScalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies only one vector, by looking at the indexes. </p>

</div>
</div>
<a id="a5b4b1144edb284bf280697046e2738c5" name="a5b4b1144edb284bf280697046e2738c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4b1144edb284bf280697046e2738c5">&#9670;&#160;</a></span>perpendicular() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::perpendicular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector perpendicular to this vector (eg an 'up' vector).   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a> class.   </dd></dl>

</div>
</div>
<a id="a5b4b1144edb284bf280697046e2738c5" name="a5b4b1144edb284bf280697046e2738c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4b1144edb284bf280697046e2738c5">&#9670;&#160;</a></span>perpendicular() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::perpendicular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector perpendicular to this vector (eg an 'up' vector).   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a> class.   </dd></dl>

</div>
</div>
<a id="a5b4b1144edb284bf280697046e2738c5" name="a5b4b1144edb284bf280697046e2738c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4b1144edb284bf280697046e2738c5">&#9670;&#160;</a></span>perpendicular() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::perpendicular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector perpendicular to this vector (eg an 'up' vector).   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the <a class="el" href="class_ogre_1_1_quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a> class.   </dd></dl>

</div>
</div>
<a id="a8fb25fa53f5ca3dbf7170874e60288fc" name="a8fb25fa53f5ca3dbf7170874e60288fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb25fa53f5ca3dbf7170874e60288fc">&#9670;&#160;</a></span>primaryAxis() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::primaryAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the primary (dominant) axis from this direction vector.   </p>

</div>
</div>
<a id="a8fb25fa53f5ca3dbf7170874e60288fc" name="a8fb25fa53f5ca3dbf7170874e60288fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb25fa53f5ca3dbf7170874e60288fc">&#9670;&#160;</a></span>primaryAxis() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::primaryAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the primary (dominant) axis from this direction vector.   </p>

</div>
</div>
<a id="a8fb25fa53f5ca3dbf7170874e60288fc" name="a8fb25fa53f5ca3dbf7170874e60288fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb25fa53f5ca3dbf7170874e60288fc">&#9670;&#160;</a></span>primaryAxis() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::primaryAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the primary (dominant) axis from this direction vector.   </p>

</div>
</div>
<a id="ab6ab388de60346a25db6a88ef83ab658" name="ab6ab388de60346a25db6a88ef83ab658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ab388de60346a25db6a88ef83ab658">&#9670;&#160;</a></span>reflect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::reflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a reflection vector to the plane with the given normal .   </p>
<dl class="section remark"><dt>Remarks</dt><dd>NB assumes 'this' is pointing AWAY FROM the plane, invert if it is not.   </dd></dl>

</div>
</div>
<a id="ab6ab388de60346a25db6a88ef83ab658" name="ab6ab388de60346a25db6a88ef83ab658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ab388de60346a25db6a88ef83ab658">&#9670;&#160;</a></span>reflect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::reflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a reflection vector to the plane with the given normal .   </p>
<dl class="section remark"><dt>Remarks</dt><dd>NB assumes 'this' is pointing AWAY FROM the plane, invert if it is not.   </dd></dl>

</div>
</div>
<a id="ab6ab388de60346a25db6a88ef83ab658" name="ab6ab388de60346a25db6a88ef83ab658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ab388de60346a25db6a88ef83ab658">&#9670;&#160;</a></span>reflect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::reflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a reflection vector to the plane with the given normal .   </p>
<dl class="section remark"><dt>Remarks</dt><dd>NB assumes 'this' is pointing AWAY FROM the plane, invert if it is not.   </dd></dl>

</div>
</div>
<a id="a8c34e42bf951a4dfd877241c2ac9e3f8" name="a8c34e42bf951a4dfd877241c2ac9e3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c34e42bf951a4dfd877241c2ac9e3f8">&#9670;&#160;</a></span>setAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all packed vectors to the same value as the scalar input vector. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_array_aabb.html#ac00b7f25584c4bedd763ccc2bb5cb815">Ogre::ArrayAabb::setAll()</a>.</p>

</div>
</div>
<a id="a8c34e42bf951a4dfd877241c2ac9e3f8" name="a8c34e42bf951a4dfd877241c2ac9e3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c34e42bf951a4dfd877241c2ac9e3f8">&#9670;&#160;</a></span>setAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all packed vectors to the same value as the scalar input vector. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

</div>
</div>
<a id="a8c34e42bf951a4dfd877241c2ac9e3f8" name="a8c34e42bf951a4dfd877241c2ac9e3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c34e42bf951a4dfd877241c2ac9e3f8">&#9670;&#160;</a></span>setAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all packed vectors to the same value as the scalar input vector. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

</div>
</div>
<a id="a4043d5a0b54859eea5b1173feab2a653" name="a4043d5a0b54859eea5b1173feab2a653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4043d5a0b54859eea5b1173feab2a653">&#9670;&#160;</a></span>setFromVector3() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setFromVector3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>, <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_bone_transform.html#a1ba3bd60d7b62b8bf22106fff26b302a">Ogre::BoneTransform::copy()</a>, <a class="el" href="struct_ogre_1_1_transform.html#a6b4b819f764fb26b97c1f528e60f7e3f">Ogre::Transform::copy()</a>, and <a class="el" href="class_ogre_1_1_array_sphere.html#a3879f5cb5cad88a5a7e5d9e7a6761480">Ogre::ArraySphere::setFromSphere()</a>.</p>

</div>
</div>
<a id="a4043d5a0b54859eea5b1173feab2a653" name="a4043d5a0b54859eea5b1173feab2a653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4043d5a0b54859eea5b1173feab2a653">&#9670;&#160;</a></span>setFromVector3() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setFromVector3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>, <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

</div>
</div>
<a id="a4043d5a0b54859eea5b1173feab2a653" name="a4043d5a0b54859eea5b1173feab2a653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4043d5a0b54859eea5b1173feab2a653">&#9670;&#160;</a></span>setFromVector3() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setFromVector3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="_ogre_array_config_8h.html#aae6e6e54870826a15444682ed7bae799">ARRAY_PACKED_REALS</a>, <a class="el" href="class_ogre_1_1_vector3.html#a27be092ad0b7e0504ddf4db5cd565f14">Ogre::Vector3::x</a>, <a class="el" href="class_ogre_1_1_vector3.html#a05ca4492ce30a049ae4102e3f5e85aff">Ogre::Vector3::y</a>, and <a class="el" href="class_ogre_1_1_vector3.html#ab1f9e7702256f32156be4d7e0fdafd7e">Ogre::Vector3::z</a>.</p>

</div>
</div>
<a id="a2f04199290a76d2e1df59007b739f670" name="a2f04199290a76d2e1df59007b739f670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f04199290a76d2e1df59007b739f670">&#9670;&#160;</a></span>setToSign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setToSign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the vector to (sign(x), sign(y), sign(z)) </p>
<dl class="section remark"><dt>Remarks</dt><dd>For reference, sign( x ) = x &gt;= 0 ? 1.0 : -1.0 sign( -0.0f ) may return 1 or -1 depending on implementation </dd></dl>
<dl class="section user"><dt></dt><dd>SSE2 implementation: Does distinguish between -0 &amp; 0 C implementation: Does not distinguish between -0 &amp; 0 </dd></dl>

</div>
</div>
<a id="a2f04199290a76d2e1df59007b739f670" name="a2f04199290a76d2e1df59007b739f670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f04199290a76d2e1df59007b739f670">&#9670;&#160;</a></span>setToSign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setToSign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the vector to (sign(x), sign(y), sign(z)) </p>
<dl class="section remark"><dt>Remarks</dt><dd>For reference, sign( x ) = x &gt;= 0 ? 1.0 : -1.0 sign( -0.0f ) may return 1 or -1 depending on implementation </dd></dl>
<dl class="section user"><dt></dt><dd>SSE2 implementation: Does distinguish between -0 &amp; 0 C implementation: Does not distinguish between -0 &amp; 0 </dd></dl>

</div>
</div>
<a id="a2f04199290a76d2e1df59007b739f670" name="a2f04199290a76d2e1df59007b739f670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f04199290a76d2e1df59007b739f670">&#9670;&#160;</a></span>setToSign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ArrayVector3::setToSign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the vector to (sign(x), sign(y), sign(z)) </p>
<dl class="section remark"><dt>Remarks</dt><dd>For reference, sign( x ) = x &gt;= 0 ? 1.0 : -1.0 sign( -0.0f ) may return 1 or -1 depending on implementation </dd></dl>
<dl class="section user"><dt></dt><dd>SSE2 implementation: Does distinguish between -0 &amp; 0 C implementation: Does not distinguish between -0 &amp; 0 </dd></dl>

</div>
</div>
<a id="a101ace91b0add48e5fcc959f6a037fd4" name="a101ace91b0add48e5fcc959f6a037fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101ace91b0add48e5fcc959f6a037fd4">&#9670;&#160;</a></span>squaredDistance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::squaredDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square of the distance to another vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is for efficiency - calculating the actual distance to another vector requires a square root, which is expensive in terms of the operations required. This method returns the square of the distance to another vector, i.e. the same as the distance but before the square root is taken. Use this if you want to find the longest / shortest distance without incurring the square root.   </dd></dl>

</div>
</div>
<a id="a101ace91b0add48e5fcc959f6a037fd4" name="a101ace91b0add48e5fcc959f6a037fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101ace91b0add48e5fcc959f6a037fd4">&#9670;&#160;</a></span>squaredDistance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::squaredDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square of the distance to another vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is for efficiency - calculating the actual distance to another vector requires a square root, which is expensive in terms of the operations required. This method returns the square of the distance to another vector, i.e. the same as the distance but before the square root is taken. Use this if you want to find the longest / shortest distance without incurring the square root.   </dd></dl>

</div>
</div>
<a id="a101ace91b0add48e5fcc959f6a037fd4" name="a101ace91b0add48e5fcc959f6a037fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101ace91b0add48e5fcc959f6a037fd4">&#9670;&#160;</a></span>squaredDistance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::squaredDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square of the distance to another vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is for efficiency - calculating the actual distance to another vector requires a square root, which is expensive in terms of the operations required. This method returns the square of the distance to another vector, i.e. the same as the distance but before the square root is taken. Use this if you want to find the longest / shortest distance without incurring the square root.   </dd></dl>

</div>
</div>
<a id="af6afb89604e05e1240f4cfc2e9695591" name="af6afb89604e05e1240f4cfc2e9695591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6afb89604e05e1240f4cfc2e9695591">&#9670;&#160;</a></span>squaredLength() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::squaredLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square of the length(magnitude) of the vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is for efficiency - calculating the actual length of a vector requires a square root, which is expensive in terms of the operations required. This method returns the square of the length of the vector, i.e. the same as the length but before the square root is taken. Use this if you want to find the longest / shortest vector without incurring the square root.   </dd></dl>

</div>
</div>
<a id="af6afb89604e05e1240f4cfc2e9695591" name="af6afb89604e05e1240f4cfc2e9695591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6afb89604e05e1240f4cfc2e9695591">&#9670;&#160;</a></span>squaredLength() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::squaredLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square of the length(magnitude) of the vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is for efficiency - calculating the actual length of a vector requires a square root, which is expensive in terms of the operations required. This method returns the square of the length of the vector, i.e. the same as the length but before the square root is taken. Use this if you want to find the longest / shortest vector without incurring the square root.   </dd></dl>

</div>
</div>
<a id="af6afb89604e05e1240f4cfc2e9695591" name="af6afb89604e05e1240f4cfc2e9695591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6afb89604e05e1240f4cfc2e9695591">&#9670;&#160;</a></span>squaredLength() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::squaredLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square of the length(magnitude) of the vector.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is for efficiency - calculating the actual length of a vector requires a square root, which is expensive in terms of the operations required. This method returns the square of the length of the vector, i.e. the same as the length but before the square root is taken. Use this if you want to find the longest / shortest vector without incurring the square root.   </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad37aed4b430c6d8b50b47d5eac29cb7d" name="ad37aed4b430c6d8b50b47d5eac29cb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37aed4b430c6d8b50b47d5eac29cb7d">&#9670;&#160;</a></span>mChunkBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aac03185a5fd1c914eec2116588790352">ArrayReal</a> Ogre::ArrayVector3::mChunkBase</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_array_ray.html#a1e8cbbda73ce427f9c5418b2552f819e">Ogre::ArrayRay::intersects()</a>, and <a class="el" href="class_ogre_1_1_array_sphere.html#a2e3cf4710ceeebd71e01eb77bdd882d4">Ogre::ArraySphere::setAll()</a>.</p>

</div>
</div>
<a id="a1850e46810eb005235fc6dcb7ebf6c9e" name="a1850e46810eb005235fc6dcb7ebf6c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1850e46810eb005235fc6dcb7ebf6c9e">&#9670;&#160;</a></span>NEGATIVE_UNIT_X</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::NEGATIVE_UNIT_X</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f41d14e17ce0511a5907f310c452da8" name="a6f41d14e17ce0511a5907f310c452da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f41d14e17ce0511a5907f310c452da8">&#9670;&#160;</a></span>NEGATIVE_UNIT_Y</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::NEGATIVE_UNIT_Y</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7793b69af40e78f5774688451894718d" name="a7793b69af40e78f5774688451894718d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7793b69af40e78f5774688451894718d">&#9670;&#160;</a></span>NEGATIVE_UNIT_Z</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::NEGATIVE_UNIT_Z</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a430a0a90f2cdab4764844a276636a2d9" name="a430a0a90f2cdab4764844a276636a2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430a0a90f2cdab4764844a276636a2d9">&#9670;&#160;</a></span>UNIT_SCALE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::UNIT_SCALE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a811d19510f8352453fa8f86d8c226a49" name="a811d19510f8352453fa8f86d8c226a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811d19510f8352453fa8f86d8c226a49">&#9670;&#160;</a></span>UNIT_X</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::UNIT_X</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a152308d886080433232254917bb4bb" name="a6a152308d886080433232254917bb4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a152308d886080433232254917bb4bb">&#9670;&#160;</a></span>UNIT_Y</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::UNIT_Y</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fcb417792cf81b60dcfaa0ec77b150f" name="a1fcb417792cf81b60dcfaa0ec77b150f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcb417792cf81b60dcfaa0ec77b150f">&#9670;&#160;</a></span>UNIT_Z</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::UNIT_Z</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03c9bb82113607b3f57b5c35a72a9c7d" name="a03c9bb82113607b3f57b5c35a72a9c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c9bb82113607b3f57b5c35a72a9c7d">&#9670;&#160;</a></span>ZERO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a> Ogre::ArrayVector3::ZERO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_ogre_array_vector3_c_8h.html">OgreArrayVector3C.h</a></li>
<li><a class="el" href="_ogre_array_vector3_n_e_o_n_8h.html">OgreArrayVector3NEON.h</a></li>
<li><a class="el" href="_ogre_array_vector3_s_s_e2_8h.html">OgreArrayVector3SSE2.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_array_vector3.html">ArrayVector3</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
