<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('hlms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">HLMS: High Level Material System</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#HlmsChanges">Fundamental changes</a><ul><li class="level2"><a href="#HlmsChangesViewports">Viewports and Scissor tests</a></li>
<li class="level2"><a href="#HlmsChangesBlocks">A lot of data is stored in &quot;Blocks&quot;</a></li>
<li class="level2"><a href="#HlmsChangesMaterialsAlive">Materials are still alive</a></li>
<li class="level2"><a href="#HlmsChangesFFP">Fixed Function has been removed</a></li>
</ul>
</li>
<li class="level1"><a href="#HlmsComponents">The three components</a></li>
<li class="level1"><a href="#HlmsBlocks">Blocks</a><ul><li class="level2"><a href="#HlmsBlocksDatablocks">Datablocks</a></li>
<li class="level2"><a href="#HlmsBlocksMacroblocks">Macroblocks</a></li>
<li class="level2"><a href="#HlmsBlocksBlendblocks">Blendblocks</a></li>
<li class="level2"><a href="#HlmsBlocksSampleblocks">Samplerblocks</a></li>
</ul>
</li>
<li class="level1"><a href="#HlmsTemplates">Hlms templates</a></li>
<li class="level1"><a href="#HlmsPreprocessor">The Hlms preprocessor</a><ul><li class="level2"><a href="#HlmsPreprocessorSyntax">Preprocessor syntax</a><ul><li class="level3"><a href="#HlmsPreprocessorSyntaxProperty">@property( expression )</a></li>
<li class="level3"><a href="#HlmsPreprocessorSyntaxForeach">@foreach( count, scopedVar, [start] )</a></li>
<li class="level3"><a href="#HlmsPreprocessorSyntaxCounter">@counter( variable )</a></li>
<li class="level3"><a href="#HlmsPreprocessorSyntaxValue">@value( variable )</a></li>
<li class="level3"><a href="#HlmsPreprocessorSyntaxSetEtc">@set add sub mul div mod min max</a></li>
<li class="level3"><a href="#HlmsPreprocessorSyntaxPiece">@piece( nameOfPiece )</a></li>
<li class="level3"><a href="#HlmsPreprocessorSyntaxInsertpiece">@insertpiece( nameOfPiece )</a></li>
<li class="level3"><a href="#HlmsPreprocessorSyntaxUndefpiece">@undefpiece( nameOfPiece )</a></li>
<li class="level3"><a href="#HlmsPreprocessorSyntaxPsetEtc">@pset padd psub pmul pdiv pmod pmin pmax</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#HlmsCreationOfShaders">Creation of shaders</a><ul><li class="level2"><a href="#HlmsCreationOfShadersCpp">C++ interaction with shader templates</a></li>
<li class="level2"><a href="#HlmsCreationOfShadersConventions">Common conventions</a></li>
<li class="level2"><a href="#HlmsCreationOfShadersHotReloading">Hot reloading</a></li>
<li class="level2"><a href="#HlmsCreationOfShadersDisablingStage">Disabling a stage</a></li>
<li class="level2"><a href="#HlmsCreationOfShadersCustomizing">Customizing an existing implementation</a><ul><li class="level3"><a href="#autotoc_md109">Examples:</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#HlmsRuntimeRendering">Run-time rendering</a><ul><li class="level2"><a href="#HlmsRuntimeRenderingPreparePassHash">preparePassHash</a></li>
<li class="level2"><a href="#HlmsRuntimeRenderingFillBuffersFor">fillBuffersFor</a></li>
<li class="level2"><a href="#autotoc_md110">Multithreaded Shader Compilation</a></li>
</ul>
</li>
<li class="level1"><a href="#UsingHlmsImplementation">Using the HLMS implementations</a><ul><li class="level2"><a href="#UsingHlmsImplementationInitialization">Initialization</a></li>
<li class="level2"><a href="#UsingHlmsImplementationDeinitilization">Deinitialization</a></li>
<li class="level2"><a href="#UsingHlmsImplementationCreatingDatablock">Creating a datablock</a></li>
</ul>
</li>
<li class="level1"><a href="#HlmsTextureManager">The Hlms Texture Manager</a><ul><li class="level2"><a href="#HlmsTextureManagerAutomaticBatching">Automatic batching</a><ul><li class="level3"><a href="#HlmsTextureManagerAutomaticBatchingTextureTypes">Texture types</a></li>
<li class="level3"><a href="#HlmsTextureManagerAutomaticBatchingAutoParams">Automatic parameters</a></li>
<li class="level3"><a href="#HlmsTextureManagerAutomaticBatchingLoadingTwice">Loading a texture twice (i.e. with a different format) via aliasing</a></li>
</ul>
</li>
<li class="level2"><a href="#HlmsTextureManagerTexturePacks">Manual: Texture packs</a></li>
<li class="level2"><a href="#HlmsTextureManagerWatchOutMemory">Watching out for memory consumption</a><ul><li class="level3"><a href="#HlmsTextureManagerWatchOutMemoryConsiderations">Additional memory considerations</a></li>
<li class="level3"><a href="#setWorkerThreadMinimumBudget">setWorkerThreadMinimumBudget warning</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#HlmsTroubleshooting">Troubleshooting</a><ul><li class="level2"><a href="#HlmsTroubleshootingShadow">My shadows don&#39;t show up or are very glitchy</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md111">Precision / Quality</a></li>
</ul>
</div>
<div class="textblock"><p>The HLMS (often stylized Hlms) is the new material system used in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0. It's more user friendly and performs faster.</p>
<p>HLMS stands for "High Level Material System", because for the user, the HLMS means just define the material and start looking at it (no need for coding or shader knowledge!). But on retrospective, tweaking the shader code for an HLMS is much low level than the old Materials have ever been (and that makes them very powerful).</p>
<h1><a class="anchor" id="HlmsChanges"></a>
Fundamental changes</h1>
<h2><a class="anchor" id="HlmsChangesViewports"></a>
Viewports and Scissor tests</h2>
<p>Viewports now contain information about the scissor rectangle. Back in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x; Direct3D 9's support for scissor testing was optional, which caused lots of headaches. As a result, users could only use low-level function <code>RenderSystem::setScissorTest</code> for manually manipulating the scissor rect.</p>
<p>In OpenGL, it was even messier because setting and enabling the scissor rect was needed to perform buffer clears on partial regions of the framebuffer; which could override user's manual input, potentially breaking applications that worked fine using Direct3D.</p>
<p>Fortunately, all targetted APIs by <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0 support scissor tests, and thus it is now properly supported. As a result:</p>
<ul>
<li>Viewports hold the information about the scissor rectangle (see <code>Viewport::setScissors</code>)</li>
<li>Enabling and disabling scissor testing is controlled via Macroblocks.</li>
<li><code>RenderSystem::setScissorTest</code> was removed.</li>
<li><code>RSC_SCISSOR_TEST</code> flag was removed.</li>
</ul>
<h2><a class="anchor" id="HlmsChangesBlocks"></a>
A lot of data is stored in "Blocks"</h2>
<p>Described in detail in the <a class="el" href="hlms.html#HlmsBlocks">Blocks section</a>, many parameters have been grouped into blocks. Changing depth checks means changing the whole Macroblock.</p>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that's a half truth and an awesome side effect. I've been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduces API overhead in practice (as long as you keep sorting by state), and they're right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it's much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can't afford. <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won't be used in practice.</li>
</ol>
<p>Of course it's not perfect, it can't fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you'll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We're aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I'm not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="HlmsChangesMaterialsAlive"></a>
Materials are still alive</h2>
<p>Let me get this straight: You should be using the HLMS. The usual "Materials" are slow. Very slow. They're inefficient and not suitable for rendering most of your models.</p>
<p>However, materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template's syntax or a C++ module when you can just write a script and start coding? The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it's fast, and will check for syntax errors!), but it's most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don't need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they're at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can't optimize. But it doesn't matter much either, because it's not like there are 100 fullscreen passes. Usually there's less than 10.</li>
</ul>
<p>Under the hood there is an HLMS C++ implementation (<code>HLMS_LOW_LEVEL</code>) that acts just as a proxy to the material. The HLMS is an integral part of <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0, not just a fancy add-in.</p>
<p>Materials have been refactored, and thus your old code may need a few changes. Most notably Macroblocks &amp; Blendblocks have been added to Materials, thus functions like <code>Pass::setDepthCheck</code> &amp; Co have been replaced by a two calls: <code>Pass::setMacroblock</code> &amp; <code>Pass::setBlendblock</code>.</p>
<h2><a class="anchor" id="HlmsChangesFFP"></a>
Fixed Function has been removed</h2>
<p>With FFP being removed, multitexturing and pass splitting functionality was cut as well. The HLMS default systems handle these.</p>
<h1><a class="anchor" id="HlmsComponents"></a>
The three components</h1>
<ol type="1">
<li><b>Scripts.</b> To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). You can also do this from C++ obviously. Everybody will be using this part.</li>
<li><b>Shader template.</b> The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn't contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you're not forced to use it. Here's a simple example of the preprocessor. I won't be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li><b>C++ classes implementation.</b> The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constants data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it's harder to use than good ol' Materials because those used to be data-driven: there are no <code>AutoParamsSource</code> here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniform buffers sorted by update frequency. Very advanced user will be using this part.</li>
</ol>
<p>Based on your skillset and needs, you can pick which parts you want to tinker with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS (Physically Based Shading) type has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders. There is also an "Unlit" implementation, specifically meant to deal with GUI and simple particle FXs (ignores normals &amp; lighting, manages multiple UVs, can mix multiple texture with photoshop-like blend modes, can animate the UVs, etc).</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg" style="pointer-events: none;"></object>
</div>
    <h1><a class="anchor" id="HlmsBlocks"></a>
Blocks</h1>
<p>We're introducing the concept of blocks, most of them are immutable. Being immutable means you can't change the Macro- Blend- &amp; Samplerblocks after being created. If you want to make a change, you have to create a new block and assign the new one. The previous one won't be destroyed until asked explicitly.</p>
<p>Technically on OpenGL render systems (GL3+, GLES2) you could <code>const_cast</code> the pointers, change the block's parameters (mind you, the pointer is shared by other datablocks, so you will be changing them as well as side effect) and it would probably work. But it will definitely fail on D3D11 render system. <br  />
</p>
<p>For more information refer to the <a class="el" href="_j_s_o_n-_materials.html">JSON Materials</a> page.</p>
<h2><a class="anchor" id="HlmsBlocksDatablocks"></a>
Datablocks</h2>
<p>A Datablock is a "material" from the user's perspective. It is the only mutable block. It holds data (i.e. material properties) that will be passed directly to the shaders, and also holds which Macroblock, Blendblocks and Samplerblocks are assigned to it.</p>
<p>Most Hlms implementations will create a derived class for Datablocks to hold their data. For example, <code>HlmsPbs</code> creates a datablock called <code>HlmsPbsDatablock</code>. This datablock contains roughness and fresnel values, which do not make any sense in (e.g.) a GUI implementation.</p>
<h2><a class="anchor" id="HlmsBlocksMacroblocks"></a>
Macroblocks</h2>
<p>Named like that because most entities end up using the macroblock. Except for transparents, we sort by macroblock first. These contain information like depth check &amp; depth write, culling mode, polygon mode (point, wireframe, solid). They're quite analogous to <code>D3D11_RASTERIZER_DESC</code>. And not without reason: under the hood Macroblocks hold a ID3D11RasterizerState, and thanks to render queue's sorting, we change them as little as possible. In other words, reduce API overhead. On GL backends, we just change the individual states on each block change. Macroblocks can be shared by many Datablocks.</p>
<p>Even in OpenGL, there are performance benefits, because there are enumeration translations (i.e. <code>CMPF_LESS -&gt; GL_LESS</code>) that are performed and cached when the macroblock gets created, instead of doing it every time the setting changes.</p>
<h2><a class="anchor" id="HlmsBlocksBlendblocks"></a>
Blendblocks</h2>
<p>Blendblocks are like Macroblocks, but they hold alpha blending operation information (blend factors: One, One_Minus_Src_Alpha; blending modes: add, substract, min, max. etc). They're analogous to D3D11_BLEND_DESC. We also sort by blendblocks to reduce state changes.</p>
<h2><a class="anchor" id="HlmsBlocksSampleblocks"></a>
Samplerblocks</h2>
<p>Samplerblocks hold information about texture units, like filtering options, addressing modes (wrap, clamp, etc), LOD bias, anisotropy, border colour, etc. They're analogous to <code>D3D11_SAMPLER_DESC</code>.</p>
<p>GL3+ and D3D11 both support samplerblocks natively[^12]. On GLES2, the functionality is emulated (still performance has improved since we can cache the samplerblock's GL value translations and whether a texture has already set to a given samplerblock's paremeters).</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg" style="pointer-events: none;"></object>
</div>
    <p>The diagram shows a typical layout of a datablock. Note that Samplerblocks do not live inside base HlmsDatablock, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<p>Macroblocks and Blendblocks on the other hand, we just need one per material.</p>
<h1><a class="anchor" id="HlmsTemplates"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names <code>VertexShader_vs</code>, <code>PixelShader_ps</code>, <code>GeometryShader_gs</code>, <code>HullShader_hs</code>, <code>DomainShader_ds</code> will be fully parsed and compiled into the shader. If an implementation only provides <code>VertexShader_vs.glsl</code>, <code>PixelShader_ps.glsl</code> only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string <code>piece_vs</code> in their filenames will be parsed only for collecting pieces (more on <em>pieces</em> later). Likewise the words <code>piece_ps</code>, <code>piece_gs</code>, <code>piece_hs</code>, <code>piece_ds</code> correspond to the pieces for their respective shader stages. Note that you can concatenate, thus <code>MyUtilities_piece_vs_piece_ps.glsl</code> will be collected both in the vertex and pixel shader stages. You can use <code>piece_all</code> as a shortcut to collect from a piece file in all stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and produces valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h1><a class="anchor" id="HlmsPreprocessor"></a>
The Hlms preprocessor</h1>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line"><span class="keyword">@property</span>( IncludeLighting )</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* code here */</span></div>
<div class="line"> </div>
<div class="line">@end</div>
</div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* code here */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>You can also evaluate <code>IncludeLighting</code> to anything other than zero and non-zero, i.e.</p>
<div class="fragment"><div class="line"><span class="keyword">@property</span>( IncludeLighting == 2 )</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* code here */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@property</span>( IncludeLighting == AnotherVariable )</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* code here 2 */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --><p>This first snippet will be included if IncludeLighting == 2. And the secon snippet will be included if IncludeLighting == AnotherVariable.</p>
<p>Note that if both IncludeLighting and AnotherVariable are not defined, it will evaluate to <code>0 == 0</code> and thus be included.</p>
<p>All comparison operations: <code>== != &lt; &lt;= &gt;= &gt;</code> are supported.</p>
<h2><a class="anchor" id="HlmsPreprocessorSyntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<p>Note: @ takes precedence over comment //. If you comment out with // a line that has @, it will <em>not</em> be commented out.</p>
<h3><a class="anchor" id="HlmsPreprocessorSyntaxProperty"></a>
@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finalized with @end. The expression is case sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands <code>&amp;&amp; || !</code> are valid.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">@property</span>( hlms_skeleton )</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Skeleton animation code here</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div>
<div class="line"> </div>
<div class="line">@end</div>
</div><!-- fragment --><p>Hlms supports <code>@else</code> code:</p>
<div class="fragment"><div class="line"><span class="keyword">@property</span>( hlms_skeleton )</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Skeleton animation code here</span></div>
<div class="line"> </div>
<div class="line">@<span class="keywordflow">else</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//Non-Skeleton code here</span></div>
<div class="line"> </div>
<div class="line">@end</div>
</div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid:</p>
<div class="fragment"><div class="line">diffuse = surfaceDiffuse <span class="keyword">@property</span>( hasLights )* lightDiffuse<span class="keyword">@end</span> ;</div>
</div><!-- fragment --><p>Which will print:</p>
<div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div>
<div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div>
</div><!-- fragment --><h3><a class="anchor" id="HlmsPreprocessorSyntaxForeach"></a>
@foreach( count, scopedVar, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated <code>count - start</code> times. Must be finalized with <code>@end</code>.</p>
<ul>
<li><code>count</code> The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li><code>scopedVar</code> is a variable that can be used to print the current iteration of the loop while inside the block. i.e. <code>@scopedVar</code> will be converted into a number in the range [start; count).</li>
<li><code>start</code> Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Expression   </th><th class="markdownTableHeadNone">Output    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">@foreach( 4, n ) <br  />
&emsp; @n@end   </td><td class="markdownTableBodyNone"><br  />
0<br  />
1<br  />
2<br  />
3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">@foreach( 4, n ) @n@end   </td><td class="markdownTableBodyNone">0 1 2 3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">@foreach( 4, n )<br  />
&emsp;@n<br  />
@end   </td><td class="markdownTableBodyNone"><br  />
0<br  />
<br  />
1<br  />
<br  />
2<br  />
<br  />
3<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">@foreach( 4, n, 2 ) @n@end   </td><td class="markdownTableBodyNone">2 3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">@pset( myStartVar, 1 )<br  />
@pset( myCountVar, 3 )<br  />
@foreach( myStartVar, n, myCountVar )<br  />
&emsp;@n@end   </td><td class="markdownTableBodyNone">1<br  />
2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">@foreach( 2, n )<br  />
&emsp;@insertpiece( pieceName@n )@end   </td><td class="markdownTableBodyNone">@insertpiece( pieceName0 )<br  />
 @insertpiece( pieceName1 )   </td></tr>
</table>
<blockquote class="doxtable">
<p>&zwj; Attention #1!</p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. <code>@foreach( 1, i )@insertpiece( pieceName )@end</code> will print <code>0nsertpiece( pieceName )</code> which is probably not what you intended.</p>
<p>Attention #2!</p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div>
<div class="line"> </div>
<div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Code</span></div>
<div class="line"> </div>
<div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@property</span>( myVar )</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line"> </div>
<div class="line">@end</div>
</div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3><a class="anchor" id="HlmsPreprocessorSyntaxCounter"></a>
@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples:</p>
<div class="fragment"><div class="line">Expression          Output</div>
<div class="line"> </div>
<div class="line">@counter( myVar )   0</div>
<div class="line">                    </div>
<div class="line">@counter( myVar )   1</div>
<div class="line">                    </div>
<div class="line">@counter( myVar )   2</div>
</div><!-- fragment --><h3><a class="anchor" id="HlmsPreprocessorSyntaxValue"></a>
@value( variable )</h3>
<p>Printes the current value of variable without incrementing it. If the variable hasn't been declared, prints 0.</p>
<div class="fragment"><div class="line">Expression          Output</div>
<div class="line"> </div>
<div class="line">@value( myVar )     0</div>
<div class="line">                    </div>
<div class="line">@value( myVar )     0</div>
<div class="line">                    </div>
<div class="line">@counter( myVar )   0</div>
<div class="line">                    </div>
<div class="line">@value( myVar )     1</div>
<div class="line">                    </div>
<div class="line">@value( myVar )     1</div>
</div><!-- fragment --><h3><a class="anchor" id="HlmsPreprocessorSyntaxSetEtc"></a>
@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form <code>@add(a, b)</code> meaning a += b; or in the form <code>@add( a, b, c )</code> meaning a = b + c</p>
<p>Useful in combination with <code>@counter</code> and <code>@value</code></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Expression   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Math    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">@set( myVar, 1 ) <br  />
 @value( myVar )   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">myVar = 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">@add( myVar, 5 )<br  />
 @value( myVar )   </td><td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">myVar = 1 + 5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">@div( myVar, 2 ) <br  />
 @value( myVar )   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">myVar = 6 / 2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">@mul( myVar, myVar )<br  />
 @value( myVar )   </td><td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">myVar = 3 * 3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">@mod( myVar, 5 ) <br  />
 @value( myVar )   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">myVar = 9 % 5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">@add( myVar, 1, 1 ) <br  />
 @value( myVar )   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">myVar = 1 + 1   </td></tr>
</table>
<h3><a class="anchor" id="HlmsPreprocessorSyntaxPiece"></a>
@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with <code>@insertpiece</code>. Pieces can also be defined from C++ or <a class="el" href="hlms.html#HlmsTemplates">collected</a> from piece template files.</p>
<p>Trying to define a piece twice will result in error and may produce incorrect output.</p>
<p>Example:</p>
<div class="fragment"><div class="line">Expression                        Output</div>
<div class="line"> </div>
<div class="line">@piece( VertexTransform )         </div>
<div class="line">                                  </div>
<div class="line">outPos = worldViewProj * inPos   </div>
<div class="line">                                  </div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --><h3><a class="anchor" id="HlmsPreprocessorSyntaxInsertpiece"></a>
@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example:</p>
<div class="fragment"><div class="line">Expression                                                     Output</div>
<div class="line"> </div>
<div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div>
<div class="line">                                                               </div>
<div class="line">void main()                                                    {</div>
<div class="line">                                                               </div>
<div class="line">{                                                              outPos = worldViewProj * inPos</div>
<div class="line">                                                               </div>
<div class="line">@insertpiece( VertexTransform )                                }</div>
<div class="line">                                                               </div>
<div class="line">@insertpiece( InexistentPiece )                                </div>
<div class="line">                                                               </div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="HlmsPreprocessorSyntaxUndefpiece"></a>
@undefpiece( nameOfPiece )</h3>
<p>Undefines an existing piece, probably so you can override it with customizations. Note: undefpiece is parsed per file, before pieces from that file are collected, and its effects are global wide. It's only useful for undefining pieces defined in previous files.</p>
<p>If the piece is not defined, no error or warning is given. Parsing continues normally.</p>
<p>Example:</p>
<table class="doxtable">
<tr>
<th>Original_piece_vs.glsl </th><th>Overrider_piece_vs.glsl  </th></tr>
<tr>
<td><div class="fragment"><div class="line">@piece( Hello )<span class="comment">//Hello World@end</span></div>
<div class="line"> </div>
<div class="line">@piece( VertexOut )@insertpiece( Hello )</div>
<div class="line">outPos = vec4( 1.0, 1.0, 1.0, 1.0 );</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment -->  </td><td><div class="fragment"><div class="line">@undefpiece( Hello )</div>
<div class="line">@piece( Hello )<span class="comment">//Overriden@end</span></div>
</div><!-- fragment -->   </td></tr>
</table>
<table class="doxtable">
<tr>
<th>VertexShader_vs.glsl </th><th>Output  </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    @insertpiece( VertexOut )</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//Overriden</span></div>
<div class="line">    outPos = vec4( 1.0, 1.0, 1.0, 1.0 );</div>
<div class="line">}</div>
</div><!-- fragment -->   </td></tr>
</table>
<p>Note that despite we already had <code>Hello</code> inserted inside <code>VertexOut</code>; and that we only overrode <code>Hello</code> (not <code>VertexOut</code>) and yet the final output showed the overriden <code>Hello</code> version.</p>
<h3><a class="anchor" id="HlmsPreprocessorSyntaxPsetEtc"></a>
@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a class="el" href="hlms.html#HlmsPreprocessorSyntaxSetEtc">the family of math functions without the 'p' prefix</a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect <code>hlms_normal</code> is never being set, try <code>@pset(
hlms_normal, 1 )</code></p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value(
myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="HlmsCreationOfShaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropriately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <code>Renderable::setDatablock()</code>, what happens is that <code>Hlms::calculateHashFor</code> will get called and this function evaluates both the mesh and datablock compatibility. If they're incompatible (i.e. the Datablock or the Hlms implementation requires the mesh to have certain feature. e.g. the Datablock needs 2 UV sets bu the mesh only has one set of UVs) it throws.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mRenderableCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg" style="pointer-events: none;"></object>
</div>
    <p>Later on during rendering, at the start of each render pass, a similar process is done, which ends up generating a <a class="el" href="hlms.html#HlmsRuntimeRenderingPreparePassHash">pass hash</a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg" style="pointer-events: none;"></object>
</div>
    <h2><a class="anchor" id="HlmsCreationOfShadersCpp"></a>
C++ interaction with shader templates</h2>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <code>Hlms::setProperty( "key", value )</code> to set "key" to the given value. This value can be read by <code>@property</code>, <code>@foreach</code>, <code>@add/sub/mul/div/mod</code>, <code>@counter</code>, <code>@value</code> and <code>@padd/psub/pmul/pdiv/pmod</code></p>
<p>To create pieces (or read them) you need to pass your custom <code>Hlms::PiecesMap</code> to <code>Hlms::addRenderableCache</code>.</p>
<p>The recommended place to do this is in <code>Hlms::calculateHashForPreCreate</code> and <code>Hlms::calculateHashForPreCaster.</code> Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding a similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload <code>Hlms::calculateHashFor</code> which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function <code>Hlms::createShaderCacheEntry</code> is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself. See the HlmsLowLevel implementation which overrides the Hlms entirely and acts as a mere proxy to the old Material system from <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x; the flexibility is really high.</p>
<h2><a class="anchor" id="HlmsCreationOfShadersConventions"></a>
Common conventions</h2>
<p>Properties starting with <code>hlms_</code> prefix are common to all or most Hlms implementations. i.e. <code>hlms_skeleton</code> is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' <code>IdString</code>s (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid <code>mat4</code> and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in <code>underscore_case</code> are set from C++; properties in <code>camelCase</code> are set from the template.</p>
<p>Properties and pieces starting with <code>custom_</code> are for user customizations of the template.</p>
<p>TBD</p>
<h2><a class="anchor" id="HlmsCreationOfShadersHotReloading"></a>
Hot reloading</h2>
<p>Hlms supports modifying the template files externally and reloading them, taking immediate effect. Call <code>Hlms::reloadFrom</code> to achieve this. How to get notified when the files were changed is up to the user.</p>
<h2><a class="anchor" id="HlmsCreationOfShadersDisablingStage"></a>
Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no <code>GeometryShader_gs.glsl</code> file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property <code>hlms_disable_stage</code> to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting <code>hlms_disable_stage</code> is not an early out or an abort.</p>
<h2><a class="anchor" id="HlmsCreationOfShadersCustomizing"></a>
Customizing an existing implementation</h2>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be achieved by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of the customizations don't require such intrusive approach.</p>
<p><b>Note:</b> For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside <code>Hlms::fillBuffersFor</code> is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a class="el" href="hlms.html#UsingHlmsImplementationInitialization">Hlms Initialization</a>. pass a set of piece files in a folder by pushing the folder to <code>ArchiveVec</code>. The files in that folder will be parsed first, in order (<code>archiveVec[0]</code> then <code>archiveVec[1]</code>, ... <code>archiveVec[N-1]</code>); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no <code>custom_</code> pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div>
<div class="line"> </div>
<div class="line">@pset( BRDF\_CookTorrance, 0 )</div>
<div class="line"> </div>
<div class="line">@pset( BRDF\_Default, 0 )</div>
<div class="line"> </div>
<div class="line">@piece( DeclareBRDF )</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Your BRDF code declaration here</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --><ol type="1">
<li>Via listener, through <code>HlmsListener</code>. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload <code>HlmsPbs</code>. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload <code>HlmsPbs::createDatablockImpl</code> to create these custom datablocks).</li>
<li>Directly modify <code>HlmsPbs</code>, <code>HlmsPbsDatablock</code> and the template.</li>
</ol>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variable   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_passBuffer   </td><td class="markdownTableBodyNone">Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_materialBuffer   </td><td class="markdownTableBodyNone">TBD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_VStoPS   </td><td class="markdownTableBodyNone">Piece where users can add more interpolants for passing data from the vertex to the pixel shader.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_vs_attributes   </td><td class="markdownTableBodyNone">Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_vs_uniformDeclaration   </td><td class="markdownTableBodyNone">Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_vs_uniformStructDeclaration   </td><td class="markdownTableBodyNone">TBD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_vs_posMaterialLoad   </td><td class="markdownTableBodyNone">TBD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_vs_preTransform   </td><td class="markdownTableBodyNone">TBD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_vs_preExecution   </td><td class="markdownTableBodyNone">Executed before <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>'s code from the Vertex Shader.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_vs_posExecution   </td><td class="markdownTableBodyNone">Executed after all code from the Vertex Shader has been performed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_ps_uniformDeclaration   </td><td class="markdownTableBodyNone">Same as custom_vs_uniformDeclaration, but for the Pixel Shader    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_ps_uniformStructDeclaration   </td><td class="markdownTableBodyNone">TBD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_ps_preExecution   </td><td class="markdownTableBodyNone">Executed before <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>'s code from the Pixel Shader.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_ps_posMaterialLoad   </td><td class="markdownTableBodyNone">Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_ps_posSampleNormal   </td><td class="markdownTableBodyNone">TBD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_ps_preLights   </td><td class="markdownTableBodyNone">Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_ps_posExecution   </td><td class="markdownTableBodyNone">Executed after all code from the Pixel Shader has been performed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_ps_uv_modifier_macros   </td><td class="markdownTableBodyNone">PBS specific. Allows you to override the macros defined in Samples/Media/Hlms/Pbs/Any/UvModifierMacros_piece_ps.any so you can apply custom transformations to each UV. e.g. <code>#undef UV_DIFFUSE #define UV_DIFFUSE( x ) ((x) * 2.0)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_ps_functions   </td><td class="markdownTableBodyNone">Used to declare functions outside the main body of the shader    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom_ps_pixelData   </td><td class="markdownTableBodyNone">Declare additional data in <code>struct PixelData</code> from Pixel Shader    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom_ps_output_types   </td><td class="markdownTableBodyNone">Declare additional outputs for MRT (Multiple Render Targets). The variable rtv_target can be used to continue where standard Hlms left off (almost always 1). You don't have to use it if you are certain you aren't using features that required rtv_target to go &gt; 1.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md109"></a>
Examples:</h3>
<div class="fragment"><div class="line">// Add an extra float output (e.g. to be used with PFG_R32_FLOAT).</div>
<div class="line">@piece( custom_ps_output_types )</div>
<div class="line">@property( syntax == glsl || syntax == glslvk )</div>
<div class="line">    layout(location = @counter(rtv_target)) out float outPs_colour@counter(rtv_target);</div>
<div class="line">@end</div>
<div class="line"> </div>
<div class="line">@property( syntax == hlsl )</div>
<div class="line">    float outPs_colour@counter(rtv_target) : SV_Target@counter(rtv_target);</div>
<div class="line">@end</div>
<div class="line"> </div>
<div class="line">@property( syntax == metal )</div>
<div class="line">    float outPs_colour@counter(rtv_target) : [[ color(@counter(rtv_target)) ]];</div>
<div class="line">@end</div>
<div class="line">@end</div>
</div><!-- fragment --><div class="fragment"><div class="line">// Alternatively just assume it&#39;s always 1, since you&#39;re in control of the compositor.</div>
<div class="line">@piece( custom_ps_output_types )</div>
<div class="line">@property( syntax == glsl || syntax == glslvk )</div>
<div class="line">    layout(location = 1) out float outPs_colour1;</div>
<div class="line">@end</div>
<div class="line"> </div>
<div class="line">@property( syntax == hlsl )</div>
<div class="line">    float outPs_colour1 : SV_Target1;</div>
<div class="line">@end</div>
<div class="line"> </div>
<div class="line">@property( syntax == metal )</div>
<div class="line">    float outPs_colour1 : [[ color(1) ]];</div>
<div class="line">@end</div>
<div class="line">@end</div>
</div><!-- fragment --><p>See ScreenSpaceReflections on how to setup an MRT compositor. Or see this <a href="https://forums.ogre3d.org/viewtopic.php?p=557199#p557199">forum post reply</a>. Also see the <a class="el" href="compositor.html#CompositorRTV">RTV section</a> and the <a class="el" href="compositor.html#CompositorRtv_Examples">Examples</a> of the manual.</p>
<h1><a class="anchor" id="HlmsRuntimeRendering"></a>
Run-time rendering</h1>
<h2><a class="anchor" id="HlmsRuntimeRenderingPreparePassHash"></a>
preparePassHash</h2>
<p>This function gets called once per <code>render_scene</code> pass (note there can be multiple <code>render_scene</code> passes per frame) even if no Renderable actually uses your Hlms implementation.</p>
<p>In this function you can read the scene state and bake all the necessary data that will be shared for all the objects, like forward lights, shadow mapped lights, view and projection matrices, depth ranges, etc.</p>
<p>The function returns a cache + hash specific for the pass that will be merged with the Renderable's hash and the result will be used to compile the shader to be used.</p>
<h2><a class="anchor" id="HlmsRuntimeRenderingFillBuffersFor"></a>
fillBuffersFor</h2>
<p>This function gets executed for every Renderable that is going to be rendered. Implementations are meant to read the Renderable's data and fill their GPU data structures, like world matrix, bone matrices (if skeletally animated), set the textures. They can rely on parameters like <code>lastCache</code> and <code>lastTextureHash</code> to obtain information about the previously rendered object and avoid setting again many shared paremeters.</p>
<h2><a class="anchor" id="autotoc_md110"></a>
Multithreaded Shader Compilation</h2>
<p>For details see the dedicated section <a class="el" href="_hlms_threading.html">Multithreaded Shader Compilation</a>.</p>
<h1><a class="anchor" id="UsingHlmsImplementation"></a>
Using the HLMS implementations</h1>
<h2><a class="anchor" id="UsingHlmsImplementationInitialization"></a>
Initialization</h2>
<p>Before parsing the resources, i.e. before <code>ResourceGroupManager::initialiseAllResourceGroups</code> is called, you need to setup the proper Hlms.</p>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> is shipped with four implementations:</p>
<ul>
<li>PBS: Stands for Physically Based Shading. The most common for most of your material needs.</li>
<li>Unlit: Basic system with no lighting or skeleton skinning. Great for GUI, billboards, particle FXs. Supports multiple texture layering with photoshop-like blending modes.</li>
<li>PBS Mobile: Same as PBS, but written for GLES2 (i.e. old Android and iOS devices, WebGL)</li>
<li>Unlit Mobile: Sames as Unlit, but written for GLES2.</li>
</ul>
<p>First need to create each implementation, specifying the location of the shader templates.</p>
<div class="fragment"><div class="line">Archive *archiveLibrary = <a class="code hl_function" href="class_ogre_1_1_archive_manager.html#a2774a9f593600e518b1b5252d5186c61">Ogre::ArchiveManager::getSingletonPtr</a>()-&gt;<a class="code hl_function" href="class_ogre_1_1_archive_manager.html#af73507a6125a506605a3bd7e36376ce4">load</a>(</div>
<div class="line">                <span class="stringliteral">&quot;/home/myuser/OgreSDK/Samples/Media/Hlms/Common/GLSL&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;FileSystem&quot;</span>, <span class="keyword">true</span> );</div>
<div class="line">ArchiveVec library;</div>
<div class="line">library.push_back( archiveLibrary );</div>
<div class="line"> </div>
<div class="line">Archive *archivePbs = ArchiveManager::getSingletonPtr()-&gt;load(</div>
<div class="line">                <span class="stringliteral">&quot;/home/myuser/OgreSDK/Samples/Media/Hlms/Pbs/GLSL&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;FileSystem&quot;</span>, <span class="keyword">true</span> );</div>
<div class="line">HlmsPbs *hlmsPbs = <a class="code hl_define" href="_ogre_memory_allocator_config_8h.html#ab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> HlmsPbs( archivePbs, &amp;library );</div>
<div class="ttc" id="a_ogre_memory_allocator_config_8h_html_ab5fc1358fd5a889de0a06d07e45df1ff"><div class="ttname"><a href="_ogre_memory_allocator_config_8h.html#ab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a></div><div class="ttdeci">#define OGRE_NEW</div><div class="ttdoc">new / delete for classes deriving from AllocatedObject (alignment determined by per-class policy)</div><div class="ttdef"><b>Definition</b> OgreMemoryAllocatorConfig.h:368</div></div>
<div class="ttc" id="aclass_ogre_1_1_archive_manager_html_a2774a9f593600e518b1b5252d5186c61"><div class="ttname"><a href="class_ogre_1_1_archive_manager.html#a2774a9f593600e518b1b5252d5186c61">Ogre::ArchiveManager::getSingletonPtr</a></div><div class="ttdeci">static ArchiveManager * getSingletonPtr()</div><div class="ttdoc">Override standard Singleton retrieval.</div></div>
<div class="ttc" id="aclass_ogre_1_1_archive_manager_html_af73507a6125a506605a3bd7e36376ce4"><div class="ttname"><a href="class_ogre_1_1_archive_manager.html#af73507a6125a506605a3bd7e36376ce4">Ogre::ArchiveManager::load</a></div><div class="ttdeci">Archive * load(const String &amp;filename, const String &amp;archiveType, bool readOnly)</div><div class="ttdoc">Opens an archive for file reading.</div></div>
</div><!-- fragment --><p>Notice that 'Archive' is a well known file system interface. Advanced users could use their own filesystem implementations and store template shaders in custom packed file formats (i.e. encrypted zip files).</p>
<p>Immediately afterwards, you will need to register the Hlms:</p>
<div class="fragment"><div class="line">Root::getSingleton().getHlmsManager()-&gt;registerHlms( hlmsPbs );</div>
</div><!-- fragment --><p>And that's it.</p>
<h2><a class="anchor" id="UsingHlmsImplementationDeinitilization"></a>
Deinitialization</h2>
<p>The function registerHlms accepts a boolean parameter named <code>deleteOnExit</code> which is true by default.</p>
<p>When true, <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will automatically call <code>OGRE_DELETE hlmsPbs</code> on shutdown (when unregisterHlms gets called) and most of the time you don't need to worry.</p>
<p>If you set this parameter to false, you will have to free the memory yourself after calling unregisterHlms. No renderable should be using any datablock created by that Hlms once it is destroyed; otherwise you will leave dangling pointers. On debug mode, <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will assert if it detects a Renderable using a datablock that is being destroyed.</p>
<p>Reasons for setting the parameter to false could include: the Hlms implementation lives in a different DLL and cannot be freed from OgreMain.dll; the Hlms implementation was allocated with a different allocator; you want to keep the Hlms alive even after unregistering, you like to do stuff manually, etc.</p>
<h2><a class="anchor" id="UsingHlmsImplementationCreatingDatablock"></a>
Creating a datablock</h2>
<p>To create your own datablocks, you can use the following snippet, which will create a new datablock with default macroblock and blendblock parameters:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> visibleToManager = <span class="keyword">true</span>;</div>
<div class="line">HlmsPbsDatablock *datablock = <span class="keyword">reinterpret_cast&lt;</span>HlmsPbsDatablock*<span class="keyword">&gt;</span>(</div>
<div class="line">            hlmsPbs-&gt;createDatablock( <span class="stringliteral">&quot;myRealName&quot;</span>, <span class="stringliteral">&quot;myHumanReadableName&quot;</span>,</div>
<div class="line">                          HlmsMacroblock(), HlmsBlendblock(),</div>
<div class="line">                          HlmsParamVec(), visibleToManager ) );</div>
</div><!-- fragment --><p>The last parameter, <code>visibleToManager</code>, specifies whether the HlmsManager will see this Hlms when asking for its name.</p>
<p>For example, both PBS and Unlit implementations may have a material named "Green". However only one can be visible to the manager; let's assume that the PBS one was made visible.</p>
<p>When you call <code>Renderable::setDatablock( "Green" )</code>, the HlmsManager will look for the one that is visible to it. To assign the Unlit version of "Green" instead of the PBS one, you will have to call the overload that specifies the pointer, and grab the datablock from the implementation itself: <code>Renderable::setDatablock( hlmsUnlit-&gt;getDatablock( "Green" ) )</code>;</p>
<p>The function createDatablock allows two names: the hashed string and the human readable one. Most of the time you want them to be the same, but this isn't enforced. Note that the human readable name doesn't affect the functionality in any way. Its only purpose is to allow material editors and other GUIs based on <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to display the material's name; since IdString destroys the original string in Release mode.</p>
<p>HlmsParamVec is an array/vector of key-value string pairs to specify custom parameters on creation. Valid values depend on the implementation. You should see the Constructor's documentation for more information on them.</p>
<h1><a class="anchor" id="HlmsTextureManager"></a>
The Hlms Texture Manager</h1>
<p>Most of the time optional, the Hlms uses its own texture manager to improve rendering performance.</p>
<p>Its main function is to pack texture together to reduce the amount of API overhead during rendering. The Hlms Texture Manager runs <em>on top</em> of the original TextureManager and is <em>not</em> meant to replace it.</p>
<p>On desktop, it will pack texture together using texture arrays. On mobile, it will use UV atlas instead. Ideally we would use bindless textures on desktop, however lack of D3D11 API (and D3D10 hardware) support for this feature makes this task very difficult.</p>
<h2><a class="anchor" id="HlmsTextureManagerAutomaticBatching"></a>
Automatic batching</h2>
<p>By default, the manager will batch together all textures as they keep getting loaded.</p>
<p>The function <code>HlmsTextureManager::createOrRetrieveTexture</code> will first see if the texture has already been loaded. If it has, it will return the texture array or uv atlas; enclosed in the following structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TextureLocation</div>
<div class="line">{</div>
<div class="line">    TexturePtr  texture;</div>
<div class="line">    uint16      xIdx;</div>
<div class="line">    uint16      yIdx;</div>
<div class="line">    uint16      divisor;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The texture pointer is the actual atlas/array texture.</p>
<p>On Desktop, only xIdx is used, which indicates which slice in the array contains our texture.</p>
<p>In order to sample in the pixel shader, one needs to perform:</p>
<div class="fragment"><div class="line"><span class="comment">// GLSL</span></div>
<div class="line">vec4 colour = texture( myArrayTex, vec3( uv.xy, <span class="keywordtype">float</span>(xIdx) ) );</div>
<div class="line"><span class="comment">// HLSL</span></div>
<div class="line">float4 colour myArrayTex.Sample( mySampler, float3( uv.xy, <span class="keywordtype">float</span>(xIdx) ) );</div>
</div><!-- fragment --><p>On Mobile, xIdx indicates the horizontal offset of the UV needed to sample the texture, and yIdx the vertical offset. Both values have to be divided by divisor in order to be in the usual [0; 1] range of UVs.</p>
<p>For example, suppose four 512x512 are packed together into a 1024x1024 texture:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">A (512x512)   </th><th class="markdownTableHeadNone">B (512x512)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">B (512x512)   </td><td class="markdownTableBodyNone">C (512x512)   </td></tr>
</table>
<p>If you ask for texture "B", then xIdx = 1, yIdx = 0, divisor = 2. In order to sample in the pixel shader we will need to do:</p>
<div class="fragment"><div class="line">vec4 colour = texture2D( myTex, (uv.xy + vec2( xIdx, yIdx )) / divisor );</div>
</div><!-- fragment --><p><b>Only textures of the same format and resolution will be packed together, both in Desktop and Mobile</b>. The Manager will automatically convert all RGB/BGR/ARGB/RGBA/BGRA/etc variants as ARGB (or ABGR depending on the platform's default) to avoid unnecessary limitations on the texture combinations that can be packed together.</p>
<p>When the texture is being loaded for the first time, the manager will try to insert it into the first available array/atlas it sees, or else create a new one. Several parameters affect the creation of the texture array/atlas, which can be configured in:</p>
<div class="fragment"><div class="line">DefaultTextureParameters mDefaultTextureParameters[NUM_TEXTURE_TYPES];</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj; Attention #1!</p>
<p>Automatic batching works 'on the fly'. You should load related textures together to prevent completely unrelated textures getting packed in the same array/atlas while the related ones end up in different arrays/atlas.</p>
<p>Since the ResourceManager parses folders in order, you should store all hlms material definitions classified by folders so that they get loaded closely and increase the chance of packing everything that is related together. </p>
</blockquote>
<h3><a class="anchor" id="HlmsTextureManagerAutomaticBatchingTextureTypes"></a>
Texture types</h3>
<p>The texture types are like "profiles" of batching/packing configurations, and only apply for textures being loaded for the first time. <b>The texture type is ignored when such texture has already been loaded, and beware that it may have been packed with different settings</b>. If you need to load it with different parameters, see <a class="el" href="hlms.html#HlmsTextureManagerAutomaticBatchingLoadingTwice">Loading a texture twice via aliasing</a>.</p>
<p>The following types are defined:</p>
<ul>
<li>TEXTURE_TYPE_DIFFUSE</li>
<li>TEXTURE_TYPE_MONOCHROME</li>
<li>TEXTURE_TYPE_NORMALS</li>
<li>TEXTURE_TYPE_ENV_MAP</li>
<li>TEXTURE_TYPE_DETAIL</li>
<li>TEXTURE_TYPE_DETAIL_NORMAL_MAP</li>
</ul>
<p>The reasons to have multiple profiles are simple:</p>
<ol type="1">
<li>Some textures, i.e. normal maps, require to be transformed to a special format, like BC5 or UV88 (two-component normalized signed 8-bit format). The Manager will convert the texture to those formats before packing.</li>
<li>Roughness textures are usually monochrome and users may want to ensure that they get loaded with the optimal pixel format for them (i.e. <code>PF_L8</code>) even if the original is stored as a 32-bit RGBA PNG file. Furthermore, sRGB (gamma correction) is disabled for these textures.</li>
<li>Detail maps and their normal maps are usually meant to be tileable. Therefore on mobile, UV atlas is disabled.</li>
</ol>
<p>Desktop-only Hlms implementations already skip the use of <code>TEXTURE_TYPE_DETAIL</code> &amp; <code>TEXTURE_TYPE_DETAIL_NORMAL_MAP</code> enumerations since they're only useful in Mobile; and use <code>TEXTURE_TYPE_DIFFUSE</code> and <code>TEXTURE_TYPE_NORMALS</code> instead.</p>
<h3><a class="anchor" id="HlmsTextureManagerAutomaticBatchingAutoParams"></a>
Automatic parameters</h3>
<p>The packing algorithm uses multiple criteria to determine whether it should pack a texture or not:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Threshold</div>
<div class="line">{</div>
<div class="line">    uint32      minTextureSize;</div>
<div class="line">    uint32      maxTexturesPerArray;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> vector&lt;Threshold&gt;::type ThresholdVec;</div>
<div class="line"><span class="keyword">struct </span>DefaultTextureParameters</div>
<div class="line">{</div>
<div class="line">    PixelFormat pixelFormat;</div>
<div class="line">    uint16      maxTexturesPerArray;</div>
<div class="line">    <span class="keywordtype">bool</span>        mipmaps;</div>
<div class="line">    <span class="keywordtype">bool</span>        hwGammaCorrection;</div>
<div class="line">    PackingMethod packingMethod;</div>
<div class="line">    <span class="keywordtype">bool</span>        isNormalMap;</div>
<div class="line">    <span class="keywordtype">bool</span>        packNonPow2;</div>
<div class="line">    <span class="keywordtype">float</span>       packMaxRatio;</div>
<div class="line">    ThresholdVec    textureArraysTresholds;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The comments and the code itself should be self-explanatory. The setting <code>pixelFormat</code> allows to force a conversion to a particular format. When left as <code>PF_UNKNOWN</code>, the texture's original format will be used (except for RGB/BGR/ARGB/BGRA/etc variations).</p>
<p>The setting <code>maxTexturesPerArray</code> controls the maximum number of textures that can be packed together. Note the actual number may be lower either due to hardware limitations (i.e. you can't make an uv atlas with 16 512x512 textures on a GPU that has a maximum texture resolution of 1024x1024) or due to the <code>textureArraysTresholds</code> parameter (which only applies on Desktop).</p>
<p>The parameters <code>packNonPow2</code> and <code>packMaxRatio</code> operate under the assumption that such textures are rare and therefore should not be packed to prevent memory waste.</p>
<p>The setting isNormalMap should only be used for normal mapping: the manager will automatically convert unsigned formats [0; 1] to signed formats [-1; 1] except for the Z component (Blue channel).</p>
<h3><a class="anchor" id="HlmsTextureManagerAutomaticBatchingLoadingTwice"></a>
Loading a texture twice (i.e. with a different format) via aliasing</h3>
<p>There are cases where you want to load textures with different profiles. For example, you may want to load a normal map as a normal map (signed format) but at the same time allow viewing its raw contents as if you were to look at them with an image viewer (unsigned format). This is not common in-game, but very common within resource editors.</p>
<p>You achieve this via <em>aliasing</em>. Aliasing allows you to load the same texture twice (or more), under two different names; and therefore with different profiles. This is the definition of <code>createOrRetrieveTexture</code>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">TextureLocation createOrRetrieveTexture( <span class="keyword">const</span> String &amp;aliasName,</div>
<div class="line">                                         <span class="keyword">const</span> String &amp;texName,</div>
<div class="line">                                         TextureMapType mapType );</div>
</div><!-- fragment --><p>The alias name is an arbitrary name and must be unique. The "texName" is the actual name of the texture to load. For example, we may want to load MyNormalMap.dds as a normal map, and as a raw texture:</p>
<div class="fragment"><div class="line">TextureLocation texLoc;</div>
<div class="line">texLoc = createOrRetrieveTexture( <span class="stringliteral">&quot;As Normal Map&quot;</span>, <span class="stringliteral">&quot;MyNormalMap.dds&quot;</span>,</div>
<div class="line">                                                  TEXTURE_TYPE_NORMALS );</div>
<div class="line">texLoc = createOrRetrieveTexture( <span class="stringliteral">&quot;As Raw Map&quot;</span>, <span class="stringliteral">&quot;MyNormalMap.dds&quot;</span>,</div>
<div class="line">                                  TEXTURE_TYPE_DIFFUSE );</div>
</div><!-- fragment --><p>Now the texture is loaded twice in the GPU. Set the datablock's texture to the name "As Raw Map" to view it, and the name "As Normal Map" to use it as a normal map.</p>
<p>Note that if you try to use the name "MyNormalMap.dds" in the datablock, you will load the texture again for a 3rd time; as this will create an alias "MyNormalMap.dds" to the texture "MyNormalMap.dds".</p>
<p>Aliasing is also useful when you've got textures stored on disk with a very technical name, but address them with a fancy, more user friendly name.</p>
<h2><a class="anchor" id="HlmsTextureManagerTexturePacks"></a>
Manual: Texture packs</h2>
<p>The user can design their own texture packs. The Manager will never try to modify them automatically.</p>
<p>The reasons to use texture packs are varied:</p>
<ul>
<li>Guarantee related textures are loaded together in the same array.</li>
<li>Improve loading time by baking as much information as possible offline.</li>
<li>Certain formats can't be batched at runtime for UV atlas (i.e. PVRTC2) and thus it needs to be done offline.</li>
</ul>
<p>TBD</p>
<h2><a class="anchor" id="HlmsTextureManagerWatchOutMemory"></a>
Watching out for memory consumption</h2>
<p>Incorrectly configuring the Hlms Texture Manager or having a messy Asset folder can easily cause weird crashes or cause GPU out of memory exceptions.</p>
<p>For example one single 4096x4096 texture at 32 bpp requires 64MB. A <code>maxTexturesPerArray</code> of 8 means that <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will attempt to request 512MB of consecutive GPU memory. This requires at least a 1GB GPU, and even then, it may not be possible due to fragmentation, staging resources, or even CPU-side virtual address exhaustion in 32-bit executables on 32-bit OSes.</p>
<p>To prevent this particular case, the <code>textureArraysTresholds</code> parameter will kick in; and will clamp <code>maxTexturesPerArray</code> to 1.</p>
<p>Nonetheless, special attention needs to be taken to ensure maximum occupancy of each array.</p>
<p>The function <code>HlmsTextureManager::dumpMemoryUsage</code> is a powerful tool that will dump all loaded textures to the log in CSV format using '|' as separator for further analysis in MS Excel or OpenOffice Calc.</p>
<p>The following is an example of the dump's output:</p>
<div class="fragment"><div class="line">17:40:45: ================================Start dump of HlmsTextureManager================================</div>
<div class="line"> </div>
<div class="line">17:40:45: |\#|Type|Width|Height|Depth|Format|HW Gamma|Mipmaps|Size in bytes|Num. active textures|Total texture capacity|Texture Names</div>
<div class="line"> </div>
<div class="line">17:40:45: |0|DIFFUSE|256|256|40|PF\_A8R8G8B8|Yes|8|13980960|7|40|axes.png|New\_Ogre\_Border.png|ProfileCurrentBar.png|ProfileAvgBar.png|ProfileMinBar.png|ProfileMaxBar.png|sinbad\_sword.tga</div>
<div class="line"> </div>
<div class="line">17:40:45: |1|DIFFUSE|256|128|40|PF\_DXT5|Yes|8|1749120|2|40|New\_Ogre\_Border\_Center.dds|ogretext.dds</div>
<div class="line"> </div>
<div class="line">17:40:45: |2|DIFFUSE|32|32|40|PF\_A8R8G8B8|Yes|5|218400|1|40|New\_Ogre\_Border\_Break.png</div>
<div class="line"> </div>
<div class="line">17:40:45: |3|DIFFUSE|512|512|20|PF\_A8R8G8B8|Yes|9|27962000|2|20|sinbad\_body.tga|sinbad\_clothes.tga</div>
<div class="line"> </div>
<div class="line">17:40:45: |4|DIFFUSE|1024|1024|10|PF\_A8R8G8B8|Yes|10|55924040|1|10|Adrianne\_Body.png</div>
<div class="line"> </div>
<div class="line">17:40:45: |5|DIFFUSE|2048|2048|2|PF\_A8R8G8B8|Yes|11|44739240|1|2|Adrianne\_Head.png</div>
<div class="line"> </div>
<div class="line">17:40:45: |6|DIFFUSE|512|512|20|PF\_A8R8G8B8|Yes|9|27962000|1|20|Hair02\_Noise.dds</div>
<div class="line"> </div>
<div class="line">17:40:45: |7|DIFFUSE|512|256|40|PF\_A8R8G8B8|Yes|9|27962080|1|40|Adrianne\_Eye.png</div>
<div class="line"> </div>
<div class="line">17:40:45: |0|NORMALS|1024|1024|10|PF\_R8G8\_SNORM|No|10|27962020|1|10|Adrianne\_Body\_nm.png</div>
<div class="line"> </div>
<div class="line">17:40:45: |1|NORMALS|2048|2048|2|PF\_R8G8\_SNORM|No|11|22369620|1|2|Adrianne\_Head\_nm.png</div>
<div class="line"> </div>
<div class="line">17:40:45: |Size in MBs per category:</div>
<div class="line"> </div>
<div class="line">17:40:45: |DIFFUSE|191.21</div>
<div class="line"> </div>
<div class="line">17:40:45: |MONOCHROME|0</div>
<div class="line"> </div>
<div class="line">17:40:45: |NORMALS|48</div>
<div class="line"> </div>
<div class="line">17:40:45: |ENV\_MAP|0</div>
<div class="line"> </div>
<div class="line">17:40:45: |DETAIL|0</div>
<div class="line"> </div>
<div class="line">17:40:45: |DETAIL\_NORMAL\_MAP|0</div>
<div class="line"> </div>
<div class="line">17:40:45: |Total MBs used:|239.21</div>
<div class="line"> </div>
<div class="line">17:40:45: ================================End dump of HlmsTextureManager================================</div>
</div><!-- fragment --><p>You should copy the dump, open OpenOffice Calc, and hit paste. It will open a text import dialog. It's important that you select '|' as separator:</p>
<div class="image">
<img src="import_texture_usage.png" alt=""/>
</div>
    <p>Once you hit OK, you should see the formatted output:</p>
<p>Now that you have it on spreadsheet, you can add more columns and perform additional useful statistics:</p>
<div class="image">
<img src="texture_stats.png" alt=""/>
</div>
    <ul>
<li>=J2 / K2 will give you the % of occupancy per texture.</li>
<li>=I2 / K2 will give you the size of each individual texture (and not the whole array)</li>
<li>=J2 / K2 * J2 will give you the size actually being used.</li>
<li>The sum of all the texture memory actually being used used divided by the total texture memory will give you the total % of occupancy</li>
</ul>
<div class="image">
<img src="texture_stats2.png" alt=""/>
</div>
    <p>In this very simple example, we have very few textures thus heavily underusing the reserved space. We only use 19.69% of the memory the Hlms Texture Manager actually requested! That's just 47MB out of the 239MB.</p>
<p>You can also rely on autofilters and sort functionality (sort by biggest unused space first!) from spreadsheets to narrow down inefficiencies.</p>
<p>From this example we can gather:</p>
<ul>
<li>We have <em>very</em> few textures, thus we should change the defaults in <code>DefaultTextureParameters</code>. Real world applications won't usually have this problem though.</li>
<li>We have a lot of heterogenous data: Mixed ARGB formats with compressed DXT1, lots of different resolutions. We should aim to make these homoegenous.</li>
</ul>
<p>The following is a more real-life example (edited):</p>
<div class="image">
<img src="texture_stats3.png" alt=""/>
</div>
    <p>We can gather:</p>
<ul>
<li>There's a high amount of non-power-of-2 textures that need to be taken care of.</li>
<li>Texture #41 is the only 2048x2048 L8 texture, causing the biggest waste.</li>
<li>There are many textures that are 256x512 and then many that are 512x256. The artitsts should be consistent; or an export script should take care of this.</li>
<li>A lot of textures are not compressed when they could or should be.</li>
<li>There are many DXT5/BC3 files that need verification that this compression scheme is actually needed (or if DXT1 is better).</li>
<li>Overall occupancy is relatively good, but it can be improved.</li>
<li>Can't be seen in the screenshot, but taking a look at the file names reveals that there are a lot of files that aren't being used as they're not for use in-game or old assets; there are also jpg files.</li>
</ul>
<h3><a class="anchor" id="HlmsTextureManagerWatchOutMemoryConsiderations"></a>
Additional memory considerations</h3>
<p>D3D11 &amp; GL3+ RenderSystems have slightly different strategies for uploading memory. This means that if your memory budget is very tight, one RS can succeed where the other can fail with an out of memory error.</p>
<p>Something to be aware of is that D3D11 doesn't support formats like A8 and <code>LA88</code> textures (see <code>D3D11Mappings::_getPF</code>; those that return <code>UNKNOWN</code>) while OpenGL does; so the D3D11 RS tries to emulate them using an <code>RGBA8888</code> texture, which is 2 to 4 times the original memory footprint. These subtle overlooks can cause D3D11 to consume significantly more memory. Fortunately this significant difference are often easy to see with Windows' Task Manager.</p>
<p>One way to fix this problem, if using Unlit shaders, is to use <code>PF_R8G8</code> and using Unlit's shader with <code>setTextureSwizzle( 0, R_MASK, R_MASK,
R_MASK, G_MASK )</code>.</p>
<p>Additionally, texture arrays mean that either the whole array is GPU resident, or no texture from the array is. Traditionally D3D11 &amp; GL drivers keep track of which textures are needed for rendering. This made possible to load 1GB of texture data in a 256MB GPU without failing; because it isn't very common to use all 1GB at once in the same frame, thus the driver would page in and out what is necessary, leaving the rest in system RAM. This is known as <b>residency</b>.</p>
<p>Texture arrays make residency control coarser. As a result, packing unrelated textures in the same array will force the driver to keep these unneeded textures resident (e.g. Level A &amp; Level X textures packed together), and this can result in more frequent out of GPU memory exceptions.</p>
<p>In the future <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> should have its own residency control solution, particularly since it is needed by Vulkan &amp; D3D12; but at the time being <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will naively try to load all textures. Suboptimal HlmsTextureManager settings can cause residency problems in OpenGL &amp; D3D11, in addition to the waste mentioned in the previous section.</p>
<p>Although modern cards have &gt;= 1GB of available GPU memory, there still has to be room for geometry and RTTs (Render To Texture). Remember to keep an eye on your memory consumption at all times.</p>
<h3><a class="anchor" id="setWorkerThreadMinimumBudget"></a>
setWorkerThreadMinimumBudget warning</h3>
<p>If you're here, it's because you saw this warning in the Ogre.log:</p>
<div class="fragment"><div class="line">setWorkerThreadMinimumBudget called with minNumSlices = 1 and minResolution = 4096</div>
<div class="line">which can be suboptimal given that maxSplitResolution = 2048</div>
</div><!-- fragment --><p>First, it's nothing serious.</p>
<p>Second:</p>
<ul>
<li><code>maxSplitResolution</code> indicates when a texture is considered "too big". If it's too big, then it will be considered as an abnormality. This affects how we allocate memory for streaming.<ul>
<li>The problem is that a 4096x4096 RGBA8_UNORM texture is 64MB. If we'd expect this to be normal, then we expect a lot of textures like that to be streamed in and may reserve a lot of memory for a long of time, even if it goes unused.</li>
<li>It is important to note that <a href="https://en.wikipedia.org/wiki/Graphics_address_remapping_table">GART/GTT size is 256 MB</a>, so with just one 4096² texture we're already close to that limit. Drivers can handle more, but they more work and having so much memory mapped either causes slowdowns, out of memory errors, or reveals driver bugs. <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/display/resizable-bar-support">Resizable BAR</a> is meant to address this, but it's too recent (e.g. AMD calls it Smart Access Memory aka SAM, and you need Ryzen 5xxxx + AMD Radeon 6xxxx XT; they came out end of last year, if you manage to buy one).<ul>
<li>It shouldn't be a problem on Vulkan because we explicitly control which heap is used, and we <a href="https://github.com/OGRECave/ogre-next/blob/646f6ecd774af6b1690bc2169bc013b459499dc5/RenderSystems/Vulkan/src/Vao/OgreVulkanVaoManager.cpp#L384">try to avoid</a> the <a href="https://vulkan.gpuinfo.org/displayreport.php?id=11317#memory">GPU-local, CPU visible</a> heap for staging area.</li>
</ul>
</li>
<li>If you load many 4096² textures we should handle it fine, but quickly after the textures stop coming in, we'll deallocate resources because we don't expect this to repeat again soon (and if it repeats, then we'll reallocate).</li>
<li>A better approximation would be to use total memory in bytes instead of a single texture dimension. Unfortunately D3D11 uses the notion of StagingTextures, and while a 4096x16 texture consumes little memory (which GL, Vulkan, Metal and D3D12 would handle just fine, because all transfers are 1D instead of 2D and 3D), D3D11 needs a StagingTexture of 4096x16 or bigger, causing a lot of waste. So it's better to consider this 4096x16 texture an abnormality too.<ul>
<li>To explain why: Let's say there's a 4096x16 texture; and a 4096² was already available. We will consume a fraction of that, and leave 4096x4080 for next transfers. If two 2048² appear in a row, that D3D11 StagingTexture can be reused. That means the 4096² staging texture was used for 3 transfers.</li>
<li>But if a 4096² appears after the 4096x16 (instead of two 2048²) then we need to allocate another StagingTexture of 4096². And that's how memory consumption can easily blow up if the 4096x16 isn't considered an abnormality</li>
</ul>
</li>
</ul>
</li>
<li><code>minResolution = 4096; minNumSlices = 2;</code> means if we encounter a 4096x4096 texture, we should reserve GPU memory to allocate two of them together (i.e. we'll create a 2D texture array of 4096x4096x2). That means, we expect them to be at least 2 4096x4096 textures. Which sort of contradicts the previous statement that 4096² textures are an abnormality.<ul>
<li>Originally minNumSlices was 1 for 4096; but it was raised to 2 because 4096² textures are not <em>that</em> uncommon. Larger values like 4 would blow up memory consumption with diminishing returns (the point of packing textures together is to reduce texture state switches to avoid being CPU bound. But if you have many 4096² textures, then you're likely to be GPU-bound by bandwidth)</li>
<li>However it is common these 4096² textures to be compressed or single channel. That means actual consumption is between 16-32MB per texture. These are fine.</li>
</ul>
</li>
</ul>
<p>OK, now that I laid out the reasoning, perhaps the warning is too exaggerated in your case. Perhaps it's not. minNumSlices &gt; 1 and minResolution &gt;= maxSplitResolution are not entirely contradictory.</p>
<p>But having minNumSlices &gt; very_large and minResolution &gt;= maxSplitResolution may indicate something is incorrectly setup (but not necessarily. If you're very tight on memory you may wanna treat lots of textures as spikes; and hurt streaming performance in exchange for... not crashing your app because you're already close to the memory limit)</p>
<h1><a class="anchor" id="HlmsTroubleshooting"></a>
Troubleshooting</h1>
<h2><a class="anchor" id="HlmsTroubleshootingShadow"></a>
My shadows don't show up or are very glitchy</h2>
<ol type="1">
<li>For directional lights, try to use PSSM with at least 3 splits. A <code>pssm_lambda</code> of 0.95 often gives good results, but this may vary per scene.</li>
<li>Use sane defaults for shadow mapping. For example call:</li>
</ol>
<div class="fragment"><div class="line">mSceneManager-&gt;setShadowDirectionalLightExtrusionDistance( 500.0f );</div>
<div class="line">mSceneManager-&gt;setShadowFarDistance( 500.0f );</div>
</div><!-- fragment --><ol type="1">
<li>The default shadow bias for every material is 0.01f. Perhaps this is too much/little for you? Adjust it via <code>HlmsDatablock::mShadowConstantBias</code>.</li>
<li>Use <code>PF_FLOAT32_R</code> for rendering shadow maps until you get it to look correct. Then you can start worrying about lowering precision to get better performance.</li>
<li>Checkout the <code>Sample_ShadowMapDebugging</code> sample on how to debug shadows. Those techniques may give you useful hints about what's going on.</li>
</ol>
<p>[^12]: GL3+ and GLES3: extension ARB_sampler_objects. D3D11: ID3D11SamplerState</p>
<h1><a class="anchor" id="autotoc_md111"></a>
Precision / Quality</h1>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.4 added <code>Hlms::setPrecisionMode</code> with the following options:</p>
<ul>
<li><code>PrecisionFull32</code><ul>
<li><code>midf</code> datatype maps to float (i.e. 32-bit)</li>
<li>This setting is always supported</li>
</ul>
</li>
<li><code>PrecisionMidf16</code><ul>
<li><code>midf</code> datatype maps to float16_t (i.e. forced 16-bit)</li>
<li>It forces the driver to produce 16-bit code, even if unoptimal</li>
<li>Great for testing quality downgrades caused by 16-bit support</li>
<li>This depends on <code>RSC_SHADER_FLOAT16</code></li>
<li>If unsupported, we fallback to <code>PrecisionRelaxed</code></li>
<li>If unsupported, we then fallback to <code>PrecisionFull32</code></li>
</ul>
</li>
<li><code>PrecisionRelaxed</code><ul>
<li><code>midf</code> datatype maps to mediump float / min16float</li>
<li>The driver is allowed to work in either 16-bit or 32-bit code</li>
<li>This depends on <code>RSC_SHADER_RELAXED_FLOAT</code></li>
<li>If unsupported, we fallback to <code>PrecisionMidf16</code></li>
<li>If unsupported, we then fallback to <code>PrecisionFull32</code></li>
</ul>
</li>
</ul>
<p>We use the keyword "midf" because "half" is already taken on Metal.</p>
<p>The default is <code>PrecisionFull32</code> which always works and ensures no quality problems.</p>
<p><code>PrecisionMidf16</code> &amp; <code>PrecisionRelaxed</code> may need more testing but may help with either performance or battery usage in mobile at the cost of quality which may be unnoticeable on most cases.</p>
<p><code>PrecisionRelaxed</code> is supported by D3D11 however it's force-disabled because of fxc bugs.</p>
<p>Only Vulkan and Metal can currently take advantage of these settings and is likely to stay that way.</p>
<p>Support is very new: we've encountered various bugs (in drivers, in <a href="https://github.com/KhronosGroup/SPIRV-Reflect/issues/134">spirv-reflect</a>, in <a href="https://twitter.com/matiasgoldberg/status/1485758709473189888">fxc</a>, in <a href="https://github.com/baldurk/renderdoc/issues/2466">RenderDoc</a>) <b>so users are advised to test this option thoroughly before deploying it to end users.</b></p>
<p>Metal is likely the API with best half 16-bit support at the moment. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_rendering.html">Rendering</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
