<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::Hlms Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_hlms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1_hlms-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::Hlms Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>HLMS stands for "High Level Material System".  
 <a href="class_ogre_1_1_hlms.html#details">More...</a></p>

<p><code>#include &lt;OgreHlms.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::Hlms:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_hlms__inherit__graph.svg" width="599" height="271"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_hlms_1_1_datablock_custom_piece_file.html">DatablockCustomPieceFile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_hlms_1_1_datablock_entry.html">DatablockEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_hlms_1_1_library.html">Library</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af48f2ddfdb19ffc1bca099ab8602b361" id="r_af48f2ddfdb19ffc1bca099ab8602b361"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#af48f2ddfdb19ffc1bca099ab8602b361">CachedCustomPieceFileStatus</a> { <a class="el" href="class_ogre_1_1_hlms.html#af48f2ddfdb19ffc1bca099ab8602b361a37396b0dc949a8417950a6b058033172">CCPFS_Success</a>
, <a class="el" href="class_ogre_1_1_hlms.html#af48f2ddfdb19ffc1bca099ab8602b361ad760b55e4d3bc80fc4cbefdd574490ff">CCPFS_OutOfDate</a>
, <a class="el" href="class_ogre_1_1_hlms.html#af48f2ddfdb19ffc1bca099ab8602b361adad26ddd15ee5571d3444ee3c48f2350">CCPFS_CriticalError</a>
 }</td></tr>
<tr class="separator:af48f2ddfdb19ffc1bca099ab8602b361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dce5b85aebcbea8289ab4938ae9aea5" id="r_a6dce5b85aebcbea8289ab4938ae9aea5"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>, <a class="el" href="struct_ogre_1_1_hlms_1_1_datablock_custom_piece_file.html">DatablockCustomPieceFile</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a6dce5b85aebcbea8289ab4938ae9aea5">DatablockCustomPieceFileMap</a></td></tr>
<tr class="separator:a6dce5b85aebcbea8289ab4938ae9aea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38ae89227591ab06dac2f033300e7c0" id="r_ab38ae89227591ab06dac2f033300e7c0"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>, <a class="el" href="struct_ogre_1_1_hlms_1_1_datablock_entry.html">DatablockEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ab38ae89227591ab06dac2f033300e7c0">HlmsDatablockMap</a></td></tr>
<tr class="separator:ab38ae89227591ab06dac2f033300e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6515668f13ae08887b8104c7133e5c29" id="r_a6515668f13ae08887b8104c7133e5c29"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="struct_ogre_1_1_hlms_1_1_library.html">Library</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a6515668f13ae08887b8104c7133e5c29">LibraryVec</a></td></tr>
<tr class="separator:a6515668f13ae08887b8104c7133e5c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e629e7a87a40040e12d2bfb4ff80d58" id="r_a6e629e7a87a40040e12d2bfb4ff80d58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a6e629e7a87a40040e12d2bfb4ff80d58">LightGatheringMode</a> { <a class="el" href="class_ogre_1_1_hlms.html#a6e629e7a87a40040e12d2bfb4ff80d58a6461fe4856b648eb0bc6ec35df2e4712">LightGatherForward</a>
, <a class="el" href="class_ogre_1_1_hlms.html#a6e629e7a87a40040e12d2bfb4ff80d58a792d2cdce23b4018b9c149540ebb1a93">LightGatherForwardPlus</a>
, <a class="el" href="class_ogre_1_1_hlms.html#a6e629e7a87a40040e12d2bfb4ff80d58a1aba1d888e0aa8e695416e9ad2af44b9">LightGatherDeferred</a>
, <a class="el" href="class_ogre_1_1_hlms.html#a6e629e7a87a40040e12d2bfb4ff80d58aa53123a5601281132955a27422df66bc">LightGatherNone</a>
 }</td></tr>
<tr class="separator:a6e629e7a87a40040e12d2bfb4ff80d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0365b8787bb8b348fb7b715c056954f" id="r_aa0365b8787bb8b348fb7b715c056954f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954f">PrecisionMode</a> { <a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954fa796424c11f74d0fae5691990af64f4fb">PrecisionFull32</a>
, <a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954faf7e50da9f4dde4015fcb939953caafa5">PrecisionMidf16</a>
, <a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954fa6406fc71b451777b3a7fc3932a86ac23">PrecisionRelaxed</a>
 }</td></tr>
<tr class="separator:aa0365b8787bb8b348fb7b715c056954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95b467bb6efd01598aa3116ebdd41381" id="r_a95b467bb6efd01598aa3116ebdd41381"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a95b467bb6efd01598aa3116ebdd41381">Hlms</a> (<a class="el" href="group___resources.html#ga11d7536f610632f563befe49447d8107">HlmsTypes</a> type, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName, <a class="el" href="class_ogre_1_1_archive.html">Archive</a> *dataFolder, <a class="el" href="group___resources.html#gac56fd5a93b0000f2487e2ca968784df3">ArchiveVec</a> *libraryFolders)</td></tr>
<tr class="separator:a95b467bb6efd01598aa3116ebdd41381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f79b87545791d5d706a3bae0840fbf" id="r_a35f79b87545791d5d706a3bae0840fbf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a35f79b87545791d5d706a3bae0840fbf">~Hlms</a> ()</td></tr>
<tr class="separator:a35f79b87545791d5d706a3bae0840fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94ec29fa0a6809a46dbf78d921f79c9" id="r_af94ec29fa0a6809a46dbf78d921f79c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#af94ec29fa0a6809a46dbf78d921f79c9">_addDatablockCustomPieceFile</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup)</td></tr>
<tr class="memdesc:af94ec29fa0a6809a46dbf78d921f79c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_hlms_datablock.html#ad5d6a40c19c3cf34fd7d538d397723df" title="Same as setCustomPieceFile() but sources the code from memory instead of from disk.">HlmsDatablock::setCustomPieceCodeFromMemory</a> &amp; <a class="el" href="class_ogre_1_1_hlms_datablock.html#ae8e2bd9a26e0aa0a6b133b4c063ceeda" title="Sets the filename of a piece file to be parsed from disk.">HlmsDatablock::setCustomPieceFile</a>.  <br /></td></tr>
<tr class="separator:af94ec29fa0a6809a46dbf78d921f79c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa351fe8acb93f1b008e178fae5a6f8f8" id="r_aa351fe8acb93f1b008e178fae5a6f8f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms.html#af48f2ddfdb19ffc1bca099ab8602b361">CachedCustomPieceFileStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aa351fe8acb93f1b008e178fae5a6f8f8">_addDatablockCustomPieceFile</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup, const <a class="el" href="namespace_ogre.html#af7c8391e4119084465186113a849f065">uint64</a> sourceCodeHash[2])</td></tr>
<tr class="separator:aa351fe8acb93f1b008e178fae5a6f8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8ce577b216ecd2b2cf0e64ed233298" id="r_acd8ce577b216ecd2b2cf0e64ed233298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#acd8ce577b216ecd2b2cf0e64ed233298">_addDatablockCustomPieceFileFromMemory</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;sourceCode)</td></tr>
<tr class="separator:acd8ce577b216ecd2b2cf0e64ed233298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8744fe92c019a0f47330772904f4c58" id="r_ab8744fe92c019a0f47330772904f4c58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ab8744fe92c019a0f47330772904f4c58">_changeRenderSystem</a> (<a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *newRs)</td></tr>
<tr class="separator:ab8744fe92c019a0f47330772904f4c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa833178056ec974abfed8302f82e9e7a" id="r_aa833178056ec974abfed8302f82e9e7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aa833178056ec974abfed8302f82e9e7a">_clearShaderCache</a> ()</td></tr>
<tr class="separator:aa833178056ec974abfed8302f82e9e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab373a8f13dd34e0c8e9cf534254c90be" id="r_ab373a8f13dd34e0c8e9cf534254c90be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ab373a8f13dd34e0c8e9cf534254c90be">_collectSamplerblocks</a> (set&lt; const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> * &gt;::type &amp;outSamplerblocks, const <a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *datablock) const</td></tr>
<tr class="separator:ab373a8f13dd34e0c8e9cf534254c90be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9789ec1cdc22bd63d2469c3b9a0664" id="r_aae9789ec1cdc22bd63d2469c3b9a0664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aae9789ec1cdc22bd63d2469c3b9a0664">_compileShaderFromPreprocessedSource</a> (const RenderableCache &amp;mergedCache, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> source[<a class="el" href="group___general.html#gga7049ce296bb4883feab25251d3865035a0bf893209b217d59e15abaf48092d132">NumShaderTypes</a>], const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shaderCounter, size_t tid)</td></tr>
<tr class="separator:aae9789ec1cdc22bd63d2469c3b9a0664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21a6701b5269533881eadfde2ce94f1" id="r_ae21a6701b5269533881eadfde2ce94f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ae21a6701b5269533881eadfde2ce94f1">_getProperty</a> (size_t tid, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> defaultVal=0) const</td></tr>
<tr class="separator:ae21a6701b5269533881eadfde2ce94f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db23de0342377671bb1a83915a2d1f2" id="r_a2db23de0342377671bb1a83915a2d1f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a2db23de0342377671bb1a83915a2d1f2">_loadJson</a> (const <a class="el" href="namespacerapidjson.html#aa65fc9fb381b2cbc54f98673eadd6505">rapidjson::Value</a> &amp;jsonValue, const <a class="el" href="struct_ogre_1_1_hlms_json_1_1_named_blocks.html">HlmsJson::NamedBlocks</a> &amp;blocks, <a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *datablock, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup, <a class="el" href="class_ogre_1_1_hlms_json_listener.html">HlmsJsonListener</a> *listener, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;additionalTextureExtension) const</td></tr>
<tr class="memdesc:a2db23de0342377671bb1a83915a2d1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads datablock values from a JSON value.  <br /></td></tr>
<tr class="separator:a2db23de0342377671bb1a83915a2d1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0353d49f366e8b0e5f928e55b86e55" id="r_a5d0353d49f366e8b0e5f928e55b86e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a5d0353d49f366e8b0e5f928e55b86e55">_notifyManager</a> (<a class="el" href="class_ogre_1_1_hlms_manager.html">HlmsManager</a> *manager)</td></tr>
<tr class="separator:a5d0353d49f366e8b0e5f928e55b86e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee5970f2c0c19635182ba56c516fd70" id="r_a3ee5970f2c0c19635182ba56c516fd70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a3ee5970f2c0c19635182ba56c516fd70">_saveJson</a> (const <a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *datablock, <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;outString, <a class="el" href="class_ogre_1_1_hlms_json_listener.html">HlmsJsonListener</a> *listener, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;additionalTextureExtension) const</td></tr>
<tr class="separator:a3ee5970f2c0c19635182ba56c516fd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282fe10007225bb20cf3cd416af538cf" id="r_a282fe10007225bb20cf3cd416af538cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a282fe10007225bb20cf3cd416af538cf">_setNumThreads</a> (size_t numThreads)</td></tr>
<tr class="separator:a282fe10007225bb20cf3cd416af538cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1ac2143a8c3669741e1c18702c8d03" id="r_aba1ac2143a8c3669741e1c18702c8d03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aba1ac2143a8c3669741e1c18702c8d03">_setProperty</a> (size_t tid, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> value)</td></tr>
<tr class="memdesc:aba1ac2143a8c3669741e1c18702c8d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging stuff. I.e. the Command line uses it for testing manually set properties.  <br /></td></tr>
<tr class="separator:aba1ac2143a8c3669741e1c18702c8d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7312a5ead5f0dce741cbc7ec9872e3" id="r_a1a7312a5ead5f0dce741cbc7ec9872e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a1a7312a5ead5f0dce741cbc7ec9872e3">_setShadersGenerated</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadersGenerated)</td></tr>
<tr class="separator:a1a7312a5ead5f0dce741cbc7ec9872e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab44bf49e523f61ade8520785740585e" id="r_aab44bf49e523f61ade8520785740585e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aab44bf49e523f61ade8520785740585e">_setTextureReg</a> (size_t tid, <a class="el" href="group___general.html#ga7049ce296bb4883feab25251d3865035">ShaderType</a> shaderType, const char *texName, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> texUnit)</td></tr>
<tr class="separator:aab44bf49e523f61ade8520785740585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440ded6d3f0269ad77e8c9670f95131a" id="r_a440ded6d3f0269ad77e8c9670f95131a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a440ded6d3f0269ad77e8c9670f95131a">_tagShaderCodeCacheUpToDate</a> ()</td></tr>
<tr class="separator:a440ded6d3f0269ad77e8c9670f95131a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b1ed80ecf35fa559da066bbdef5d20" id="r_ad2b1ed80ecf35fa559da066bbdef5d20"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ad2b1ed80ecf35fa559da066bbdef5d20">analyzeBarriers</a> (<a class="el" href="class_ogre_1_1_barrier_solver.html">BarrierSolver</a> &amp;barrierSolver, <a class="el" href="group___resources.html#gab881163687bedff909edce16d11d9127">ResourceTransitionArray</a> &amp;resourceTransitions, <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *renderingCamera, const bool bCasterPass)</td></tr>
<tr class="separator:ad2b1ed80ecf35fa559da066bbdef5d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b71158453ed0a2411a92ecf767af130" id="r_a5b71158453ed0a2411a92ecf767af130"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a5b71158453ed0a2411a92ecf767af130">calculateHashFor</a> (<a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *renderable, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> &amp;outHash, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> &amp;outCasterHash)</td></tr>
<tr class="memdesc:a5b71158453ed0a2411a92ecf767af130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the renderable when either it changes the material, or its properties change (e.g., the mesh's uvs are stripped)  <br /></td></tr>
<tr class="separator:a5b71158453ed0a2411a92ecf767af130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef77fcae4df5d51475d7e5ff3baafd8" id="r_a0ef77fcae4df5d51475d7e5ff3baafd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a0ef77fcae4df5d51475d7e5ff3baafd8">compileShaderCode</a> (ShaderCodeCache &amp;codeCache, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shaderCounter, size_t tid)</td></tr>
<tr class="memdesc:a0ef77fcae4df5d51475d7e5ff3baafd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles input properties and adds it to the shader code cache.  <br /></td></tr>
<tr class="separator:a0ef77fcae4df5d51475d7e5ff3baafd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa61df0f4d69b0bfdacbe3d089175b35" id="r_afa61df0f4d69b0bfdacbe3d089175b35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#afa61df0f4d69b0bfdacbe3d089175b35">compileStubEntry</a> (const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;passCache, <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *reservedStubEntry, <a class="el" href="namespace_ogre.html#af7c8391e4119084465186113a849f065">uint64</a> deadline, <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> queuedRenderable, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> renderableHash, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> finalHash, size_t tid)</td></tr>
<tr class="memdesc:afa61df0f4d69b0bfdacbe3d089175b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_parallel_hlms_compile_queue.html">ParallelHlmsCompileQueue</a> to finish the job started in <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a>  <br /></td></tr>
<tr class="separator:afa61df0f4d69b0bfdacbe3d089175b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029b71d6801fc4acbb682d362cf4a1bd" id="r_a029b71d6801fc4acbb682d362cf4a1bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a029b71d6801fc4acbb682d362cf4a1bd">createDatablock</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;refName, const <a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> &amp;macroblockRef, const <a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> &amp;blendblockRef, const <a class="el" href="group___resources.html#ga26539e1c24ff9cadeb6f54139ad7dc54">HlmsParamVec</a> &amp;paramVec, bool visibleToManager=true, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:a029b71d6801fc4acbb682d362cf4a1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unique datablock that can be shared by multiple renderables.  <br /></td></tr>
<tr class="separator:a029b71d6801fc4acbb682d362cf4a1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ed9de97ae0b9d5b5c12648e17df989" id="r_a60ed9de97ae0b9d5b5c12648e17df989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a60ed9de97ae0b9d5b5c12648e17df989">destroyAllDatablocks</a> ()</td></tr>
<tr class="memdesc:a60ed9de97ae0b9d5b5c12648e17df989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all datablocks created with <a class="el" href="class_ogre_1_1_hlms.html#a029b71d6801fc4acbb682d362cf4a1bd" title="Creates a unique datablock that can be shared by multiple renderables.">createDatablock()</a>.  <br /></td></tr>
<tr class="separator:a60ed9de97ae0b9d5b5c12648e17df989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e458f42a60363648a6b1ce368feb4b" id="r_a42e458f42a60363648a6b1ce368feb4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a42e458f42a60363648a6b1ce368feb4b">destroyDatablock</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name)</td></tr>
<tr class="memdesc:a42e458f42a60363648a6b1ce368feb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a datablocks given its name.  <br /></td></tr>
<tr class="separator:a42e458f42a60363648a6b1ce368feb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd39fa103178d48aa78e8a1fd57e6e2b" id="r_abd39fa103178d48aa78e8a1fd57e6e2b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#abd39fa103178d48aa78e8a1fd57e6e2b">fillBuffersFor</a> (const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *cache, const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;queuedRenderable, bool casterPass, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lastCacheHash, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lastTextureHash)=0</td></tr>
<tr class="memdesc:abd39fa103178d48aa78e8a1fd57e6e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the constant buffers.  <br /></td></tr>
<tr class="separator:abd39fa103178d48aa78e8a1fd57e6e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b85e21a687586586bba5c3302c34d7" id="r_a68b85e21a687586586bba5c3302c34d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a68b85e21a687586586bba5c3302c34d7">fillBuffersForV1</a> (const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *cache, const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;queuedRenderable, bool casterPass, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lastCacheHash, <a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *commandBuffer)=0</td></tr>
<tr class="separator:a68b85e21a687586586bba5c3302c34d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be0f56ad3a2e3568112812a44c05b2c" id="r_a9be0f56ad3a2e3568112812a44c05b2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a9be0f56ad3a2e3568112812a44c05b2c">fillBuffersForV2</a> (const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *cache, const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;queuedRenderable, bool casterPass, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lastCacheHash, <a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *commandBuffer)=0</td></tr>
<tr class="separator:a9be0f56ad3a2e3568112812a44c05b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d9a980c64b142e90e9fffde15a7112" id="r_a51d9a980c64b142e90e9fffde15a7112"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a51d9a980c64b142e90e9fffde15a7112">frameEnded</a> ()</td></tr>
<tr class="memdesc:a51d9a980c64b142e90e9fffde15a7112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the frame has fully ended (ALL passes have been executed to all RTTs)  <br /></td></tr>
<tr class="separator:a51d9a980c64b142e90e9fffde15a7112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fcc2f3f94f0d57958062871daf6c19" id="r_aa8fcc2f3f94f0d57958062871daf6c19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aa8fcc2f3f94f0d57958062871daf6c19">getAreaLightsApproxLimit</a> () const</td></tr>
<tr class="separator:aa8fcc2f3f94f0d57958062871daf6c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1300e74a8d4b63c9e9887fe73058232" id="r_af1300e74a8d4b63c9e9887fe73058232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#af1300e74a8d4b63c9e9887fe73058232">getAreaLightsLtcLimit</a> () const</td></tr>
<tr class="separator:af1300e74a8d4b63c9e9887fe73058232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e0c86645deec3214413f1d34293614" id="r_af6e0c86645deec3214413f1d34293614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#af6e0c86645deec3214413f1d34293614">getDatablock</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name) const</td></tr>
<tr class="memdesc:af6e0c86645deec3214413f1d34293614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an existing datablock based on its name (.  <br /></td></tr>
<tr class="separator:af6e0c86645deec3214413f1d34293614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9af91650fdbcc1d675c1e5d5d5e5306" id="r_ab9af91650fdbcc1d675c1e5d5d5e5306"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_hlms_1_1_datablock_custom_piece_file.html">DatablockCustomPieceFile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ab9af91650fdbcc1d675c1e5d5d5e5306">getDatablockCustomPieceData</a> (<a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> filenameHashId) const</td></tr>
<tr class="memdesc:ab9af91650fdbcc1d675c1e5d5d5e5306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the data we know about filenameHashId. Can be nullptr if not found.  <br /></td></tr>
<tr class="separator:ab9af91650fdbcc1d675c1e5d5d5e5306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5eaec54a8512d44e5e5f8dd6936ff94" id="r_aa5eaec54a8512d44e5e5f8dd6936ff94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aa5eaec54a8512d44e5e5f8dd6936ff94">getDatablockCustomPieceFileNameStr</a> (<a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> filenameHashId) const</td></tr>
<tr class="separator:aa5eaec54a8512d44e5e5f8dd6936ff94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d2cdcc6f6434e6998eb1c240fc8759" id="r_a73d2cdcc6f6434e6998eb1c240fc8759"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_hlms.html#ab38ae89227591ab06dac2f033300e7c0">HlmsDatablockMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a73d2cdcc6f6434e6998eb1c240fc8759">getDatablockMap</a> () const</td></tr>
<tr class="memdesc:a73d2cdcc6f6434e6998eb1c240fc8759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all datablocks owned by this <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a>, including the default one.  <br /></td></tr>
<tr class="separator:a73d2cdcc6f6434e6998eb1c240fc8759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6576e38225d9205b428bb909d93c5bfb" id="r_a6576e38225d9205b428bb909d93c5bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_archive.html">Archive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a6576e38225d9205b428bb909d93c5bfb">getDataFolder</a> ()</td></tr>
<tr class="separator:a6576e38225d9205b428bb909d93c5bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df1057f374a54432b012c5e0309107a" id="r_a9df1057f374a54432b012c5e0309107a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a9df1057f374a54432b012c5e0309107a">getDefaultDatablock</a> () const</td></tr>
<tr class="memdesc:a9df1057f374a54432b012c5e0309107a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Datablock to use when another datablock failed or none was specified.    <br /></td></tr>
<tr class="separator:a9df1057f374a54432b012c5e0309107a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cb7a1925140a038342fdd79cb9cfe1" id="r_a16cb7a1925140a038342fdd79cb9cfe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a16cb7a1925140a038342fdd79cb9cfe1">getDefaultPaths</a> (<a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;outDataFolderPath, <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;outLibraryFoldersPaths, const <a class="el" href="class_ogre_1_1_config_file.html">ConfigFile</a> &amp;configFile)</td></tr>
<tr class="memdesc:a16cb7a1925140a038342fdd79cb9cfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the other <a class="el" href="class_ogre_1_1_hlms.html#a16cb7a1925140a038342fdd79cb9cfe1" title="Same as the other getDefaultPaths() overload but it automatically fills the hlmsTypeName param.">getDefaultPaths()</a> overload but it automatically fills the hlmsTypeName param.  <br /></td></tr>
<tr class="separator:a16cb7a1925140a038342fdd79cb9cfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124fd6d17116915b6c407d8743b436cb" id="r_a124fd6d17116915b6c407d8743b436cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a124fd6d17116915b6c407d8743b436cb">getFastShaderBuildHack</a> () const</td></tr>
<tr class="memdesc:a124fd6d17116915b6c407d8743b436cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if shaders are being compiled with Fast Shader Build Hack (D3D11 only)  <br /></td></tr>
<tr class="separator:a124fd6d17116915b6c407d8743b436cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad004bde573064ae48aba462dfcaa536e" id="r_ad004bde573064ae48aba462dfcaa536e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ad004bde573064ae48aba462dfcaa536e">getFilenameAndResourceGroup</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> const **outFilename, <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> const **outResourceGroup) const</td></tr>
<tr class="memdesc:ad004bde573064ae48aba462dfcaa536e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the filaname &amp; resource group a datablock was created from, and is associated with its hashed name (this was passed as in <a class="el" href="class_ogre_1_1_hlms.html#a029b71d6801fc4acbb682d362cf4a1bd" title="Creates a unique datablock that can be shared by multiple renderables.">createDatablock()</a>).  <br /></td></tr>
<tr class="separator:ad004bde573064ae48aba462dfcaa536e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af316fb5991958874cbdd34323c57fc91" id="r_af316fb5991958874cbdd34323c57fc91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_manager.html">HlmsManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#af316fb5991958874cbdd34323c57fc91">getHlmsManager</a> () const</td></tr>
<tr class="separator:af316fb5991958874cbdd34323c57fc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd7501298e4479520c59036bc4a6724" id="r_a5bd7501298e4479520c59036bc4a6724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_listener.html">HlmsListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a5bd7501298e4479520c59036bc4a6724">getListener</a> () const</td></tr>
<tr class="memdesc:a5bd7501298e4479520c59036bc4a6724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current listener.  <br /></td></tr>
<tr class="separator:a5bd7501298e4479520c59036bc4a6724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebbb13548a00b54a8143d86ab2afcf6" id="r_a2ebbb13548a00b54a8143d86ab2afcf6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6">getMaterial</a> (<a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> const *lastReturnedValue, const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;passCache, const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;queuedRenderable, bool casterPass, <a class="el" href="class_ogre_1_1_parallel_hlms_compile_queue.html">ParallelHlmsCompileQueue</a> *parallelQueue)</td></tr>
<tr class="memdesc:a2ebbb13548a00b54a8143d86ab2afcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> filled with the GPU programs to be used by the given renderable.  <br /></td></tr>
<tr class="separator:a2ebbb13548a00b54a8143d86ab2afcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6543944cdb6e2eddc17075e31db2db5" id="r_aa6543944cdb6e2eddc17075e31db2db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aa6543944cdb6e2eddc17075e31db2db5">getMaterialSerial01</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lastReturnedValue, const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;passCache, const size_t passCacheIdx, const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;queuedRenderable, bool casterPass, <a class="el" href="class_ogre_1_1_parallel_hlms_compile_queue.html">ParallelHlmsCompileQueue</a> &amp;parallelQueue)</td></tr>
<tr class="memdesc:aa6543944cdb6e2eddc17075e31db2db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is extremely similar to <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> except it's been designed to be always in parallel and to be used by warm_up passes.  <br /></td></tr>
<tr class="separator:aa6543944cdb6e2eddc17075e31db2db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0d8509660561e244edcd5ac2b4364f" id="r_a9d0d8509660561e244edcd5ac2b4364f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a9d0d8509660561e244edcd5ac2b4364f">getMaxNonCasterDirectionalLights</a> () const</td></tr>
<tr class="separator:a9d0d8509660561e244edcd5ac2b4364f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a39abc97918a7952311bd944e6e1e7f" id="r_a6a39abc97918a7952311bd944e6e1e7f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a6a39abc97918a7952311bd944e6e1e7f">getNameStr</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name) const</td></tr>
<tr class="memdesc:a6a39abc97918a7952311bd944e6e1e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string name associated with its hashed name (this was passed as refName in <a class="el" href="class_ogre_1_1_hlms.html#a029b71d6801fc4acbb682d362cf4a1bd" title="Creates a unique datablock that can be shared by multiple renderables.">createDatablock()</a>).  <br /></td></tr>
<tr class="separator:a6a39abc97918a7952311bd944e6e1e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c3c59d5048bcbdd3d7364710451b1f" id="r_ac3c3c59d5048bcbdd3d7364710451b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ac3c3c59d5048bcbdd3d7364710451b1f">getParticleSystemConstSlot</a> () const</td></tr>
<tr class="separator:ac3c3c59d5048bcbdd3d7364710451b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e2d6842bad07409f827628be81570e" id="r_a58e2d6842bad07409f827628be81570e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a58e2d6842bad07409f827628be81570e">getParticleSystemSlot</a> () const</td></tr>
<tr class="separator:a58e2d6842bad07409f827628be81570e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09e06cb91f99f8e8fe0d0928ae64d22" id="r_aa09e06cb91f99f8e8fe0d0928ae64d22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_hlms.html#a6515668f13ae08887b8104c7133e5c29">LibraryVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aa09e06cb91f99f8e8fe0d0928ae64d22">getPiecesLibrary</a> () const</td></tr>
<tr class="separator:aa09e06cb91f99f8e8fe0d0928ae64d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14556592a9642bdea61b6a2298aaf53b" id="r_a14556592a9642bdea61b6a2298aaf53b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___resources.html#gac56fd5a93b0000f2487e2ca968784df3">ArchiveVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a14556592a9642bdea61b6a2298aaf53b">getPiecesLibraryAsArchiveVec</a> () const</td></tr>
<tr class="separator:a14556592a9642bdea61b6a2298aaf53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31405ce224d30e5eff4900ba02f6fecd" id="r_a31405ce224d30e5eff4900ba02f6fecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954f">PrecisionMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a31405ce224d30e5eff4900ba02f6fecd">getPrecisionMode</a> () const</td></tr>
<tr class="memdesc:a31405ce224d30e5eff4900ba02f6fecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns requested precision mode (i.e., value passed to setPrecisionMode) See getSupportedPrecisionMode.  <br /></td></tr>
<tr class="separator:a31405ce224d30e5eff4900ba02f6fecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4551924c6b8aa1260e5d553c6b83e314" id="r_a4551924c6b8aa1260e5d553c6b83e314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a4551924c6b8aa1260e5d553c6b83e314">getRenderSystem</a> () const</td></tr>
<tr class="separator:a4551924c6b8aa1260e5d553c6b83e314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238f9c88f9122e99a617be7461e45c11" id="r_a238f9c88f9122e99a617be7461e45c11"><td class="memItemLeft" align="right" valign="top">const ShaderCodeCacheVec &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a238f9c88f9122e99a617be7461e45c11">getShaderCodeCache</a> () const</td></tr>
<tr class="separator:a238f9c88f9122e99a617be7461e45c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1beb8469205bfc6146705506ced9b8c" id="r_ab1beb8469205bfc6146705506ced9b8c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ab1beb8469205bfc6146705506ced9b8c">getShaderProfile</a> () const</td></tr>
<tr class="separator:ab1beb8469205bfc6146705506ced9b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905909d0752107d11db3fb6d27c2d615" id="r_a905909d0752107d11db3fb6d27c2d615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a905909d0752107d11db3fb6d27c2d615">getShaderSyntax</a> () const</td></tr>
<tr class="separator:a905909d0752107d11db3fb6d27c2d615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade989fe1d9b95aa73a7885211f764041" id="r_ade989fe1d9b95aa73a7885211f764041"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ade989fe1d9b95aa73a7885211f764041">getStaticBranchingLights</a> () const</td></tr>
<tr class="separator:ade989fe1d9b95aa73a7885211f764041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d03f2b9bb51c0eb4d3583c20a2ec27" id="r_a14d03f2b9bb51c0eb4d3583c20a2ec27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954f">PrecisionMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a14d03f2b9bb51c0eb4d3583c20a2ec27">getSupportedPrecisionMode</a> () const</td></tr>
<tr class="memdesc:a14d03f2b9bb51c0eb4d3583c20a2ec27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some GPUs don't support all precision modes.  <br /></td></tr>
<tr class="separator:a14d03f2b9bb51c0eb4d3583c20a2ec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0ec84d5e6078c5627f40e95d8d8ca3" id="r_a7a0ec84d5e6078c5627f40e95d8d8ca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a7a0ec84d5e6078c5627f40e95d8d8ca3">getTemplateChecksum</a> (<a class="el" href="namespace_ogre.html#af7c8391e4119084465186113a849f065">uint64</a> outHash[2]) const</td></tr>
<tr class="separator:a7a0ec84d5e6078c5627f40e95d8d8ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508e017c803859196fc55860b7ddfc0f" id="r_a508e017c803859196fc55860b7ddfc0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___resources.html#ga11d7536f610632f563befe49447d8107">HlmsTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a508e017c803859196fc55860b7ddfc0f">getType</a> () const</td></tr>
<tr class="separator:a508e017c803859196fc55860b7ddfc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f828092b41b6224285937a71c69350" id="r_a10f828092b41b6224285937a71c69350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a10f828092b41b6224285937a71c69350">getTypeName</a> () const</td></tr>
<tr class="separator:a10f828092b41b6224285937a71c69350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ea98bcf58eda73fb8afb5a6de98edd" id="r_a14ea98bcf58eda73fb8afb5a6de98edd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a14ea98bcf58eda73fb8afb5a6de98edd">getTypeNameStr</a> () const</td></tr>
<tr class="separator:a14ea98bcf58eda73fb8afb5a6de98edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412a9493da6ff386a74c43aa7f53722f" id="r_a412a9493da6ff386a74c43aa7f53722f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a412a9493da6ff386a74c43aa7f53722f">isDatablockCustomPieceFileCacheable</a> (<a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> filenameHashId) const</td></tr>
<tr class="separator:a412a9493da6ff386a74c43aa7f53722f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e7dcce06295d710b64917bb19e1f52" id="r_a87e7dcce06295d710b64917bb19e1f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a87e7dcce06295d710b64917bb19e1f52">isShaderCodeCacheDirty</a> () const</td></tr>
<tr class="memdesc:a87e7dcce06295d710b64917bb19e1f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Users can check this function to tell if <a class="el" href="class_ogre_1_1_hlms_disk_cache.html" title="This class allows saving the current state of an Hlms to disk: both its compiled shaders with source ...">HlmsDiskCache</a> needs saving.  <br /></td></tr>
<tr class="separator:a87e7dcce06295d710b64917bb19e1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dbc640402f792b8d2da9889a4a9e19" id="r_ae4dbc640402f792b8d2da9889a4a9e19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ae4dbc640402f792b8d2da9889a4a9e19">parseOffline</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;inBuffer, <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;outBuffer, size_t tid)</td></tr>
<tr class="memdesc:ae4dbc640402f792b8d2da9889a4a9e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">For standalone parsing.  <br /></td></tr>
<tr class="separator:ae4dbc640402f792b8d2da9889a4a9e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666c0da0880cf52f84e31f03e4736cac" id="r_a666c0da0880cf52f84e31f03e4736cac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a666c0da0880cf52f84e31f03e4736cac">postCommandBufferExecution</a> (<a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *commandBuffer)</td></tr>
<tr class="memdesc:a666c0da0880cf52f84e31f03e4736cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets called after executing the command buffer.  <br /></td></tr>
<tr class="separator:a666c0da0880cf52f84e31f03e4736cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365579c231d6fd0d32a567a3a1b6582a" id="r_a365579c231d6fd0d32a567a3a1b6582a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a365579c231d6fd0d32a567a3a1b6582a">preCommandBufferExecution</a> (<a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *commandBuffer)</td></tr>
<tr class="memdesc:a365579c231d6fd0d32a567a3a1b6582a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets called right before executing the command buffer.  <br /></td></tr>
<tr class="separator:a365579c231d6fd0d32a567a3a1b6582a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e82fb2e682366cc721e521ee41d64d" id="r_ad3e82fb2e682366cc721e521ee41d64d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ad3e82fb2e682366cc721e521ee41d64d">preparePassHash</a> (const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">Ogre::CompositorShadowNode</a> *shadowNode, bool casterPass, bool dualParaboloid, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager)</td></tr>
<tr class="memdesc:ad3e82fb2e682366cc721e521ee41d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called every frame by the Render Queue to cache the properties needed by this pass.  <br /></td></tr>
<tr class="separator:ad3e82fb2e682366cc721e521ee41d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2513b676def18667eb5579abfa50820a" id="r_a2513b676def18667eb5579abfa50820a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a2513b676def18667eb5579abfa50820a">reloadFrom</a> (<a class="el" href="class_ogre_1_1_archive.html">Archive</a> *newDataFolder, <a class="el" href="group___resources.html#gac56fd5a93b0000f2487e2ca968784df3">ArchiveVec</a> *libraryFolders=0)</td></tr>
<tr class="memdesc:a2513b676def18667eb5579abfa50820a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all the cached shaders and in the next opportunity will recreate them from the new location.  <br /></td></tr>
<tr class="separator:a2513b676def18667eb5579abfa50820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f184b28b72445e50b59bcca8b16a3a6" id="r_a4f184b28b72445e50b59bcca8b16a3a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a4f184b28b72445e50b59bcca8b16a3a6">saveAllTexturesFromDatablocks</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;folderPath, set&lt; <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &gt;::type &amp;savedTextures, bool saveOitd, bool saveOriginal, <a class="el" href="class_ogre_1_1_hlms_texture_export_listener.html">HlmsTextureExportListener</a> *listener)</td></tr>
<tr class="separator:a4f184b28b72445e50b59bcca8b16a3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebca7da0789967e8fde70d95fa74ac0c" id="r_aebca7da0789967e8fde70d95fa74ac0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#aebca7da0789967e8fde70d95fa74ac0c">setAreaLightForwardSettings</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> areaLightsApproxLimit, <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> areaLightsLtcLimit)</td></tr>
<tr class="memdesc:aebca7da0789967e8fde70d95fa74ac0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Area lights use regular Forward.  <br /></td></tr>
<tr class="separator:aebca7da0789967e8fde70d95fa74ac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd6a05326ef3082d1d88fa5c3ec8c61" id="r_a5bd6a05326ef3082d1d88fa5c3ec8c61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a5bd6a05326ef3082d1d88fa5c3ec8c61">setDebugOutputPath</a> (bool enableDebugOutput, bool outputProperties, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;path=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>)</td></tr>
<tr class="memdesc:a5bd6a05326ef3082d1d88fa5c3ec8c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to output the automatically generated shaders (which are usually made from templates) on the given folder for inspection, analyzing, debugging, etc.  <br /></td></tr>
<tr class="separator:a5bd6a05326ef3082d1d88fa5c3ec8c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761bbbb8ac57759c2d2529a5d485c8c5" id="r_a761bbbb8ac57759c2d2529a5d485c8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a761bbbb8ac57759c2d2529a5d485c8c5">setListener</a> (<a class="el" href="class_ogre_1_1_hlms_listener.html">HlmsListener</a> *listener)</td></tr>
<tr class="memdesc:a761bbbb8ac57759c2d2529a5d485c8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a listener to extend an existing <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> implementation's with custom code, without having to rewrite it or modify the source code directly.  <br /></td></tr>
<tr class="separator:a761bbbb8ac57759c2d2529a5d485c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144d4a10a6e3a7a1c580d72913ec1cd8" id="r_a144d4a10a6e3a7a1c580d72913ec1cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a144d4a10a6e3a7a1c580d72913ec1cd8">setMaxNonCasterDirectionalLights</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> maxLights)</td></tr>
<tr class="memdesc:a144d4a10a6e3a7a1c580d72913ec1cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-caster directional lights are hardcoded into shaders.  <br /></td></tr>
<tr class="separator:a144d4a10a6e3a7a1c580d72913ec1cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7b3dc16d494d83e9608cdb68f4512d" id="r_afd7b3dc16d494d83e9608cdb68f4512d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#afd7b3dc16d494d83e9608cdb68f4512d">setPrecisionMode</a> (<a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954f">PrecisionMode</a> precisionMode)</td></tr>
<tr class="memdesc:afd7b3dc16d494d83e9608cdb68f4512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the precision mode of <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a>.  <br /></td></tr>
<tr class="separator:afd7b3dc16d494d83e9608cdb68f4512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fdb3fe8b4889d911d41468dabf4400" id="r_a46fdb3fe8b4889d911d41468dabf4400"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a46fdb3fe8b4889d911d41468dabf4400">setStaticBranchingLights</a> (bool staticBranchingLights)</td></tr>
<tr class="memdesc:a46fdb3fe8b4889d911d41468dabf4400"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default shadow-caster spot and point lights are hardcoded into shaders.  <br /></td></tr>
<tr class="separator:a46fdb3fe8b4889d911d41468dabf4400"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe88631b1f9786d345bbc28a93358481" id="r_abe88631b1f9786d345bbc28a93358481"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#abe88631b1f9786d345bbc28a93358481">_setHasParticleFX2Plugin</a> (bool bHasPfx2Plugin)</td></tr>
<tr class="separator:abe88631b1f9786d345bbc28a93358481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1defa4d9cc3c6a15993e4ee9d0a2f4dc" id="r_a1defa4d9cc3c6a15993e4ee9d0a2f4dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a1defa4d9cc3c6a15993e4ee9d0a2f4dc">findParamInVec</a> (const <a class="el" href="group___resources.html#ga26539e1c24ff9cadeb6f54139ad7dc54">HlmsParamVec</a> &amp;paramVec, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;inOut)</td></tr>
<tr class="memdesc:a1defa4d9cc3c6a15993e4ee9d0a2f4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the parameter with key 'key' in the given 'paramVec'.  <br /></td></tr>
<tr class="separator:a1defa4d9cc3c6a15993e4ee9d0a2f4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38964d793fc96af144a64ac09154439a" id="r_a38964d793fc96af144a64ac09154439a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a38964d793fc96af144a64ac09154439a">getDefaultPaths</a> (<a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;outDataFolderPath, <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;outLibraryFoldersPaths, const <a class="el" href="class_ogre_1_1_config_file.html">ConfigFile</a> &amp;configFile, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;hlmsTypeName)</td></tr>
<tr class="memdesc:a38964d793fc96af144a64ac09154439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_ogre_1_1_hlms_pbs.html#acb5d8056ff22979cf55adb67521c6f13" title="Fill the provided string and string vector with all the sub-folder needed to instantiate an HlmsPbs o...">HlmsPbs::getDefaultPaths</a> but retrieves the files &amp; folders from cfg file.  <br /></td></tr>
<tr class="separator:a38964d793fc96af144a64ac09154439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cbb0af420992ea18745ae2093ca78a" id="r_ac3cbb0af420992ea18745ae2093ca78a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#ac3cbb0af420992ea18745ae2093ca78a">getProperty</a> (const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;properties, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> defaultVal=0)</td></tr>
<tr class="memdesc:ac3cbb0af420992ea18745ae2093ca78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility helper, mostly useful to <a class="el" href="class_ogre_1_1_hlms_listener.html" title="Listener that can be hooked to an Hlms implementation for extending it with custom code.">HlmsListener</a> implementations.  <br /></td></tr>
<tr class="separator:ac3cbb0af420992ea18745ae2093ca78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9f48ab9315af6e69d98844ddabddb" id="r_a0ba9f48ab9315af6e69d98844ddabddb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a0ba9f48ab9315af6e69d98844ddabddb">hasParticleFX2Plugin</a> ()</td></tr>
<tr class="separator:a0ba9f48ab9315af6e69d98844ddabddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c00acdba7c9a0bcab3c6a0a48d587f" id="r_a85c00acdba7c9a0bcab3c6a0a48d587f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a85c00acdba7c9a0bcab3c6a0a48d587f">setProperty</a> (<a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;properties, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> value)</td></tr>
<tr class="memdesc:a85c00acdba7c9a0bcab3c6a0a48d587f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility helper, mostly useful to <a class="el" href="class_ogre_1_1_hlms_listener.html" title="Listener that can be hooked to an Hlms implementation for extending it with custom code.">HlmsListener</a> implementations.  <br /></td></tr>
<tr class="separator:a85c00acdba7c9a0bcab3c6a0a48d587f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3b41b85c9b51fe6794d25e95bd5ea31f" id="r_a3b41b85c9b51fe6794d25e95bd5ea31f"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms.html#a3b41b85c9b51fe6794d25e95bd5ea31f">kNoTid</a> = 0u</td></tr>
<tr class="memdesc:a3b41b85c9b51fe6794d25e95bd5ea31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For single-threaded operations.  <br /></td></tr>
<tr class="separator:a3b41b85c9b51fe6794d25e95bd5ea31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>HLMS stands for "High Level Material System". </p>
<p>The <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> has multiple caches:</p>
<p>mRenderableCache This cache contains all the properties set to a <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> class and can be evaluated early, when a <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> is assigned a datablock i.e. inside <a class="el" href="class_ogre_1_1_renderable.html#a8096988a16728c8b7e32495146111c62" title="Assigns a datablock (i.e.">Renderable::setDatablock</a>. Contains properties such as whether the material has normal mapping, if the mesh has UV sets, evaluates if the material requires tangents for normal mapping, etc. The main function in charge of filling this cache is <a class="el" href="class_ogre_1_1_hlms.html#a5b71158453ed0a2411a92ecf767af130" title="Called by the renderable when either it changes the material, or its properties change (e....">Hlms::calculateHashFor</a></p>
<p>mPassCache This cache contains per-pass information, such as how many lights are in the scene, whether this is a shadow mapping pass, etc. The main function in charge of filling this cache is <a class="el" href="class_ogre_1_1_hlms.html#ad3e82fb2e682366cc721e521ee41d64d" title="Called every frame by the Render Queue to cache the properties needed by this pass.">Hlms::preparePassHash</a></p>
<p>mShaderCodeCache Contains a cache of unique shaders (from <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> templates -&gt; actual valid shader code) based on the properties merged from mRenderableCache &amp; mPassCache. However it is possible that two shaders are exactly the same and thus be duplicated, this can happen if two combinations of properties end up producing the exact same code. The Microcode cache (<a class="el" href="class_ogre_1_1_gpu_program_manager.html#aa21d703ad5720d87243b2cbb8b7dc02a" title="Set if the microcode of a shader should be saved to a cache.">GpuProgramManager::setSaveMicrocodesToCache</a>) can help with that issue.</p>
<p>mShaderCache Contains a cache of the PSOs. The difference between this and mShaderCodeCache is that PSOs require additional information, such as <a class="el" href="struct_ogre_1_1_hlms_macroblock.html" title="A macro block contains settings that will rarely change, and thus are common to many materials.">HlmsMacroblock</a>. <a class="el" href="struct_ogre_1_1_hlms_blendblock.html" title="A blend block contains settings that rarely change, and thus are common to many materials.">HlmsBlendblock</a>. For more information of all that is required, see <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6dce5b85aebcbea8289ab4938ae9aea5" name="a6dce5b85aebcbea8289ab4938ae9aea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dce5b85aebcbea8289ab4938ae9aea5">&#9670;&#160;</a></span>DatablockCustomPieceFileMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>, <a class="el" href="struct_ogre_1_1_hlms_1_1_datablock_custom_piece_file.html">DatablockCustomPieceFile</a>&gt; <a class="el" href="class_ogre_1_1_hlms.html#a6dce5b85aebcbea8289ab4938ae9aea5">Ogre::Hlms::DatablockCustomPieceFileMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab38ae89227591ab06dac2f033300e7c0" name="ab38ae89227591ab06dac2f033300e7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38ae89227591ab06dac2f033300e7c0">&#9670;&#160;</a></span>HlmsDatablockMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>, <a class="el" href="struct_ogre_1_1_hlms_1_1_datablock_entry.html">DatablockEntry</a>&gt; <a class="el" href="class_ogre_1_1_hlms.html#ab38ae89227591ab06dac2f033300e7c0">Ogre::Hlms::HlmsDatablockMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6515668f13ae08887b8104c7133e5c29" name="a6515668f13ae08887b8104c7133e5c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6515668f13ae08887b8104c7133e5c29">&#9670;&#160;</a></span>LibraryVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="struct_ogre_1_1_hlms_1_1_library.html">Library</a>&gt;::type <a class="el" href="class_ogre_1_1_hlms.html#a6515668f13ae08887b8104c7133e5c29">Ogre::Hlms::LibraryVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af48f2ddfdb19ffc1bca099ab8602b361" name="af48f2ddfdb19ffc1bca099ab8602b361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48f2ddfdb19ffc1bca099ab8602b361">&#9670;&#160;</a></span>CachedCustomPieceFileStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hlms.html#af48f2ddfdb19ffc1bca099ab8602b361">Ogre::Hlms::CachedCustomPieceFileStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af48f2ddfdb19ffc1bca099ab8602b361a37396b0dc949a8417950a6b058033172" name="af48f2ddfdb19ffc1bca099ab8602b361a37396b0dc949a8417950a6b058033172"></a>CCPFS_Success&#160;</td><td class="fielddoc"><p>Everything ok. </p>
</td></tr>
<tr><td class="fieldname"><a id="af48f2ddfdb19ffc1bca099ab8602b361ad760b55e4d3bc80fc4cbefdd574490ff" name="af48f2ddfdb19ffc1bca099ab8602b361ad760b55e4d3bc80fc4cbefdd574490ff"></a>CCPFS_OutOfDate&#160;</td><td class="fielddoc"><p>Recompile the cache from the templates. </p>
</td></tr>
<tr><td class="fieldname"><a id="af48f2ddfdb19ffc1bca099ab8602b361adad26ddd15ee5571d3444ee3c48f2350" name="af48f2ddfdb19ffc1bca099ab8602b361adad26ddd15ee5571d3444ee3c48f2350"></a>CCPFS_CriticalError&#160;</td><td class="fielddoc"><p>The cache contains unrecoverable errors. Do not use the cache. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6e629e7a87a40040e12d2bfb4ff80d58" name="a6e629e7a87a40040e12d2bfb4ff80d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e629e7a87a40040e12d2bfb4ff80d58">&#9670;&#160;</a></span>LightGatheringMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hlms.html#a6e629e7a87a40040e12d2bfb4ff80d58">Ogre::Hlms::LightGatheringMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6e629e7a87a40040e12d2bfb4ff80d58a6461fe4856b648eb0bc6ec35df2e4712" name="a6e629e7a87a40040e12d2bfb4ff80d58a6461fe4856b648eb0bc6ec35df2e4712"></a>LightGatherForward&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6e629e7a87a40040e12d2bfb4ff80d58a792d2cdce23b4018b9c149540ebb1a93" name="a6e629e7a87a40040e12d2bfb4ff80d58a792d2cdce23b4018b9c149540ebb1a93"></a>LightGatherForwardPlus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6e629e7a87a40040e12d2bfb4ff80d58a1aba1d888e0aa8e695416e9ad2af44b9" name="a6e629e7a87a40040e12d2bfb4ff80d58a1aba1d888e0aa8e695416e9ad2af44b9"></a>LightGatherDeferred&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6e629e7a87a40040e12d2bfb4ff80d58aa53123a5601281132955a27422df66bc" name="a6e629e7a87a40040e12d2bfb4ff80d58aa53123a5601281132955a27422df66bc"></a>LightGatherNone&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa0365b8787bb8b348fb7b715c056954f" name="aa0365b8787bb8b348fb7b715c056954f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0365b8787bb8b348fb7b715c056954f">&#9670;&#160;</a></span>PrecisionMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954f">Ogre::Hlms::PrecisionMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa0365b8787bb8b348fb7b715c056954fa796424c11f74d0fae5691990af64f4fb" name="aa0365b8787bb8b348fb7b715c056954fa796424c11f74d0fae5691990af64f4fb"></a>PrecisionFull32&#160;</td><td class="fielddoc"><p>midf datatype maps to float (i.e., 32-bit) This setting is always supported </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0365b8787bb8b348fb7b715c056954faf7e50da9f4dde4015fcb939953caafa5" name="aa0365b8787bb8b348fb7b715c056954faf7e50da9f4dde4015fcb939953caafa5"></a>PrecisionMidf16&#160;</td><td class="fielddoc"><p>midf datatype maps to float16_t (i.e., forced 16-bit) </p>
<pre class="fragment">        It forces the driver to produce 16-bit code, even if unoptimal
        Great for testing quality downgrades caused by 16-bit support

        - This depends on RSC_SHADER_FLOAT16.
        - If unsupported, we fallback to PrecisionRelaxed (RSC_SHADER_RELAXED_FLOAT)
        - If unsupported, we then fallback to PrecisionFull32 
</pre> </td></tr>
<tr><td class="fieldname"><a id="aa0365b8787bb8b348fb7b715c056954fa6406fc71b451777b3a7fc3932a86ac23" name="aa0365b8787bb8b348fb7b715c056954fa6406fc71b451777b3a7fc3932a86ac23"></a>PrecisionRelaxed&#160;</td><td class="fielddoc"><p>midf datatype maps to mediump float / min16float </p>
<pre class="fragment">        The driver is allowed to work in either 16-bit or 32-bit code

        - This depends on RSC_SHADER_RELAXED_FLOAT.
        - If unsupported, we fallback to PrecisionMidf16 (RSC_SHADER_FLOAT16)
        - If unsupported, we then fallback to PrecisionFull32 
</pre> </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a95b467bb6efd01598aa3116ebdd41381" name="a95b467bb6efd01598aa3116ebdd41381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b467bb6efd01598aa3116ebdd41381">&#9670;&#160;</a></span>Hlms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Hlms::Hlms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga11d7536f610632f563befe49447d8107">HlmsTypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_archive.html">Archive</a> *&#160;</td>
          <td class="paramname"><em>dataFolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___resources.html#gac56fd5a93b0000f2487e2ca968784df3">ArchiveVec</a> *&#160;</td>
          <td class="paramname"><em>libraryFolders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libraryFolders</td><td>Path to folders to be processed first for collecting pieces. Will be processed in order. Pointer can be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35f79b87545791d5d706a3bae0840fbf" name="a35f79b87545791d5d706a3bae0840fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f79b87545791d5d706a3bae0840fbf">&#9670;&#160;</a></span>~Hlms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::Hlms::~Hlms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af94ec29fa0a6809a46dbf78d921f79c9" name="af94ec29fa0a6809a46dbf78d921f79c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94ec29fa0a6809a46dbf78d921f79c9">&#9670;&#160;</a></span>_addDatablockCustomPieceFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_addDatablockCustomPieceFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_hlms_datablock.html#ad5d6a40c19c3cf34fd7d538d397723df" title="Same as setCustomPieceFile() but sources the code from memory instead of from disk.">HlmsDatablock::setCustomPieceCodeFromMemory</a> &amp; <a class="el" href="class_ogre_1_1_hlms_datablock.html#ae8e2bd9a26e0aa0a6b133b4c063ceeda" title="Sets the filename of a piece file to be parsed from disk.">HlmsDatablock::setCustomPieceFile</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the file. </td></tr>
    <tr><td class="paramname">resourceGroup</td><td>The name of the resource group in which to look for the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa351fe8acb93f1b008e178fae5a6f8f8" name="aa351fe8acb93f1b008e178fae5a6f8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa351fe8acb93f1b008e178fae5a6f8f8">&#9670;&#160;</a></span>_addDatablockCustomPieceFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms.html#af48f2ddfdb19ffc1bca099ab8602b361">CachedCustomPieceFileStatus</a> Ogre::Hlms::_addDatablockCustomPieceFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af7c8391e4119084465186113a849f065">uint64</a>&#160;</td>
          <td class="paramname"><em>sourceCodeHash</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>See <a class="el" href="class_ogre_1_1_hlms.html#af94ec29fa0a6809a46dbf78d921f79c9" title="See HlmsDatablock::setCustomPieceCodeFromMemory &amp; HlmsDatablock::setCustomPieceFile.">_addDatablockCustomPieceFile()</a> overload. Unlike the other overload, file not found errors are ignored. </td></tr>
    <tr><td class="paramname">resourceGroup</td><td>The name of the resource group in which to look for the file. </td></tr>
    <tr><td class="paramname">templateHash</td><td>The expected hash of the file. File won't be added if the hash does not match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See CachedCustomPieceFileStatus. </dd></dl>

</div>
</div>
<a id="acd8ce577b216ecd2b2cf0e64ed233298" name="acd8ce577b216ecd2b2cf0e64ed233298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8ce577b216ecd2b2cf0e64ed233298">&#9670;&#160;</a></span>_addDatablockCustomPieceFileFromMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_addDatablockCustomPieceFileFromMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the file. </td></tr>
    <tr><td class="paramname">sourceCode</td><td>The contents of the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8744fe92c019a0f47330772904f4c58" name="ab8744fe92c019a0f47330772904f4c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8744fe92c019a0f47330772904f4c58">&#9670;&#160;</a></span>_changeRenderSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::_changeRenderSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>newRs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_buffer_manager.html#a9705e42784838362eaa8363a54d2ea5a">Ogre::HlmsBufferManager</a>, <a class="el" href="class_ogre_1_1_hlms_pbs.html#a9eb22852387ffa8381efffe3ebd3d290">Ogre::HlmsPbs</a>, <a class="el" href="class_ogre_1_1_hlms_unlit.html#ae95a3c1c22574cda6ddf881aa4c80afe">Ogre::HlmsUnlit</a>, and <a class="el" href="class_ogre_1_1_hlms_compute.html#a964f0071ede668af8abf6431f74309e3">Ogre::HlmsCompute</a>.</p>

</div>
</div>
<a id="aa833178056ec974abfed8302f82e9e7a" name="aa833178056ec974abfed8302f82e9e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa833178056ec974abfed8302f82e9e7a">&#9670;&#160;</a></span>_clearShaderCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_clearShaderCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab373a8f13dd34e0c8e9cf534254c90be" name="ab373a8f13dd34e0c8e9cf534254c90be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab373a8f13dd34e0c8e9cf534254c90be">&#9670;&#160;</a></span>_collectSamplerblocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::_collectSamplerblocks </td>
          <td>(</td>
          <td class="paramtype">set&lt; const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> * &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>outSamplerblocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *&#160;</td>
          <td class="paramname"><em>datablock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_pbs.html#afbaea834078cd2afbd21bbc0f12adc97">Ogre::HlmsPbs</a>, and <a class="el" href="class_ogre_1_1_hlms_unlit.html#afc17f2d125a4c0d9fafeac14c5fbf48f">Ogre::HlmsUnlit</a>.</p>

</div>
</div>
<a id="aae9789ec1cdc22bd63d2469c3b9a0664" name="aae9789ec1cdc22bd63d2469c3b9a0664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9789ec1cdc22bd63d2469c3b9a0664">&#9670;&#160;</a></span>_compileShaderFromPreprocessedSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_compileShaderFromPreprocessedSource </td>
          <td>(</td>
          <td class="paramtype">const RenderableCache &amp;&#160;</td>
          <td class="paramname"><em>mergedCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td>
          <td class="paramname"><em>source</em>[NumShaderTypes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shaderCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae21a6701b5269533881eadfde2ce94f1" name="ae21a6701b5269533881eadfde2ce94f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21a6701b5269533881eadfde2ce94f1">&#9670;&#160;</a></span>_getProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> Ogre::Hlms::_getProperty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>defaultVal</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2db23de0342377671bb1a83915a2d1f2" name="a2db23de0342377671bb1a83915a2d1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db23de0342377671bb1a83915a2d1f2">&#9670;&#160;</a></span>_loadJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::_loadJson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacerapidjson.html#aa65fc9fb381b2cbc54f98673eadd6505">rapidjson::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>jsonValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_json_1_1_named_blocks.html">HlmsJson::NamedBlocks</a> &amp;&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *&#160;</td>
          <td class="paramname"><em>datablock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_json_listener.html">HlmsJsonListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>additionalTextureExtension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads datablock values from a JSON value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_json.html" title="HLMS stands for &quot;High Level Material System&quot;.">HlmsJson</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonValue</td><td>JSON Object containing the definition of this datablock. </td></tr>
    <tr><td class="paramname">blocks</td><td>All the loaded Macro-, Blend- &amp; Samplerblocks the JSON has defined and may be referenced by the datablock declaration. </td></tr>
    <tr><td class="paramname">datablock</td><td>Datablock to fill the values. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_pbs.html#aadaf315a6b056bfdb63b91e5b54d200b">Ogre::HlmsPbs</a>, and <a class="el" href="class_ogre_1_1_hlms_unlit.html#ab541cfb7afbd02b244145c6a5878b248">Ogre::HlmsUnlit</a>.</p>

</div>
</div>
<a id="a5d0353d49f366e8b0e5f928e55b86e55" name="a5d0353d49f366e8b0e5f928e55b86e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0353d49f366e8b0e5f928e55b86e55">&#9670;&#160;</a></span>_notifyManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_notifyManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_manager.html">HlmsManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ee5970f2c0c19635182ba56c516fd70" name="a3ee5970f2c0c19635182ba56c516fd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee5970f2c0c19635182ba56c516fd70">&#9670;&#160;</a></span>_saveJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::_saveJson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *&#160;</td>
          <td class="paramname"><em>datablock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>outString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_json_listener.html">HlmsJsonListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>additionalTextureExtension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_pbs.html#a806008625446a15a1d50c95f66a01422">Ogre::HlmsPbs</a>, and <a class="el" href="class_ogre_1_1_hlms_unlit.html#a7039a46c62473463ee6611e040392593">Ogre::HlmsUnlit</a>.</p>

</div>
</div>
<a id="abe88631b1f9786d345bbc28a93358481" name="abe88631b1f9786d345bbc28a93358481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe88631b1f9786d345bbc28a93358481">&#9670;&#160;</a></span>_setHasParticleFX2Plugin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Hlms::_setHasParticleFX2Plugin </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bHasPfx2Plugin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a282fe10007225bb20cf3cd416af538cf" name="a282fe10007225bb20cf3cd416af538cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282fe10007225bb20cf3cd416af538cf">&#9670;&#160;</a></span>_setNumThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_setNumThreads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba1ac2143a8c3669741e1c18702c8d03" name="aba1ac2143a8c3669741e1c18702c8d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1ac2143a8c3669741e1c18702c8d03">&#9670;&#160;</a></span>_setProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_setProperty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For debugging stuff. I.e. the Command line uses it for testing manually set properties. </p>

</div>
</div>
<a id="a1a7312a5ead5f0dce741cbc7ec9872e3" name="a1a7312a5ead5f0dce741cbc7ec9872e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7312a5ead5f0dce741cbc7ec9872e3">&#9670;&#160;</a></span>_setShadersGenerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_setShadersGenerated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadersGenerated</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab44bf49e523f61ade8520785740585e" name="aab44bf49e523f61ade8520785740585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab44bf49e523f61ade8520785740585e">&#9670;&#160;</a></span>_setTextureReg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_setTextureReg </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga7049ce296bb4883feab25251d3865035">ShaderType</a>&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>texName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a440ded6d3f0269ad77e8c9670f95131a" name="a440ded6d3f0269ad77e8c9670f95131a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440ded6d3f0269ad77e8c9670f95131a">&#9670;&#160;</a></span>_tagShaderCodeCacheUpToDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::_tagShaderCodeCacheUpToDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2b1ed80ecf35fa559da066bbdef5d20" name="ad2b1ed80ecf35fa559da066bbdef5d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b1ed80ecf35fa559da066bbdef5d20">&#9670;&#160;</a></span>analyzeBarriers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::analyzeBarriers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_barrier_solver.html">BarrierSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>barrierSolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___resources.html#gab881163687bedff909edce16d11d9127">ResourceTransitionArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceTransitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>renderingCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bCasterPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_pbs.html#ace2e73ab887ae311947f23e066d96162">Ogre::HlmsPbs</a>.</p>

</div>
</div>
<a id="a5b71158453ed0a2411a92ecf767af130" name="a5b71158453ed0a2411a92ecf767af130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b71158453ed0a2411a92ecf767af130">&#9670;&#160;</a></span>calculateHashFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::calculateHashFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>renderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>outHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>outCasterHash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the renderable when either it changes the material, or its properties change (e.g., the mesh's uvs are stripped) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderable</td><td>The renderable the material will be used on. </td></tr>
    <tr><td class="paramname">outHash</td><td>A hash. This hash references property parameters that are already cached. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_low_level.html#a4abdeda754a9c16304d9b2009c21aa62">Ogre::HlmsLowLevel</a>.</p>

</div>
</div>
<a id="a0ef77fcae4df5d51475d7e5ff3baafd8" name="a0ef77fcae4df5d51475d7e5ff3baafd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef77fcae4df5d51475d7e5ff3baafd8">&#9670;&#160;</a></span>compileShaderCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::compileShaderCode </td>
          <td>(</td>
          <td class="paramtype">ShaderCodeCache &amp;&#160;</td>
          <td class="paramname"><em>codeCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shaderCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles input properties and adds it to the shader code cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codeCache</td><td>[in/out] All variables must be filled except for ShaderCodeCache::shaders which is the output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa61df0f4d69b0bfdacbe3d089175b35" name="afa61df0f4d69b0bfdacbe3d089175b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa61df0f4d69b0bfdacbe3d089175b35">&#9670;&#160;</a></span>compileStubEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::compileStubEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;&#160;</td>
          <td class="paramname"><em>passCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *&#160;</td>
          <td class="paramname"><em>reservedStubEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af7c8391e4119084465186113a849f065">uint64</a>&#160;</td>
          <td class="paramname"><em>deadline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a>&#160;</td>
          <td class="paramname"><em>queuedRenderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>renderableHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>finalHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_parallel_hlms_compile_queue.html">ParallelHlmsCompileQueue</a> to finish the job started in <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">passCache</td><td>See lastReturnedValue from <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> </td></tr>
    <tr><td class="paramname">reservedStubEntry</td><td>The stub cache entry (return value of <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a>) to fill. </td></tr>
    <tr><td class="paramname">deadline</td><td>Deadline in ms, after which long shader compilation could be skipped to avoid frame stutter. </td></tr>
    <tr><td class="paramname">queuedRenderable</td><td>See <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> </td></tr>
    <tr><td class="paramname">renderableHash</td><td></td></tr>
    <tr><td class="paramname">finalHash</td><td></td></tr>
    <tr><td class="paramname">tid</td><td>Thread idx of caller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a029b71d6801fc4acbb682d362cf4a1bd" name="a029b71d6801fc4acbb682d362cf4a1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029b71d6801fc4acbb682d362cf4a1bd">&#9670;&#160;</a></span>createDatablock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> * Ogre::Hlms::createDatablock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>refName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> &amp;&#160;</td>
          <td class="paramname"><em>macroblockRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> &amp;&#160;</td>
          <td class="paramname"><em>blendblockRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga26539e1c24ff9cadeb6f54139ad7dc54">HlmsParamVec</a> &amp;&#160;</td>
          <td class="paramname"><em>paramVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visibleToManager</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a unique datablock that can be shared by multiple renderables. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The name of the datablock must be in paramVec["name"] and must be unique Throws if a datablock with the same name paramVec["name"] already exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the Datablock, must be unique within all <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> types, not just this one. 99% you want this to be IdString( refName ); however this is not enforced. </td></tr>
    <tr><td class="paramname">refName</td><td>Name of the Datablock. The engine doesn't use this value at all. It is only useful for UI editors which want to enumerate all existing datablocks and display its name to the user. </td></tr>
    <tr><td class="paramname">macroblockRef</td><td>see <a class="el" href="class_ogre_1_1_hlms_manager.html#a064c7cfc9fb3ac1e9690f6c39a5d1449" title="Creates a macroblock that matches the same parameter as the input.">HlmsManager::getMacroblock</a> </td></tr>
    <tr><td class="paramname">blendblockRef</td><td>see <a class="el" href="class_ogre_1_1_hlms_manager.html#a38fca7caf3b7ab2ce0365a1392f98af5" title="See HlmsManager::getMacroblock.">HlmsManager::getBlendblock</a> </td></tr>
    <tr><td class="paramname">paramVec</td><td>Key - String Value list of paramters. MUST BE SORTED. </td></tr>
    <tr><td class="paramname">visibleToManager</td><td>When false, <a class="el" href="class_ogre_1_1_hlms_manager.html#a41cdb9c3f864cccc6736928779862722" title="Retrieves an exisiting datablock (i.e.">HlmsManager::getDatablock</a> won't find this datablock. True by default </td></tr>
    <tr><td class="paramname">filename</td><td>Filename in which it was defined, so that this information can be retrieved later by the user if needed. This is only for informational purposes. </td></tr>
    <tr><td class="paramname">resourceGroup</td><td>ResourceGroup. See filename param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to created Datablock </dd></dl>

</div>
</div>
<a id="a60ed9de97ae0b9d5b5c12648e17df989" name="a60ed9de97ae0b9d5b5c12648e17df989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ed9de97ae0b9d5b5c12648e17df989">&#9670;&#160;</a></span>destroyAllDatablocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::destroyAllDatablocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys all datablocks created with <a class="el" href="class_ogre_1_1_hlms.html#a029b71d6801fc4acbb682d362cf4a1bd" title="Creates a unique datablock that can be shared by multiple renderables.">createDatablock()</a>. </p>
<p>Caller is responsible for ensuring those pointers aren't still in use (i.e. dangling pointers) The default datablock will be recreated. </p>

</div>
</div>
<a id="a42e458f42a60363648a6b1ce368feb4b" name="a42e458f42a60363648a6b1ce368feb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e458f42a60363648a6b1ce368feb4b">&#9670;&#160;</a></span>destroyDatablock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::destroyDatablock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a datablocks given its name. </p>
<p>Caller is responsible for ensuring those pointers aren't still in use (i.e. dangling pointers) </p><dl class="section remark"><dt>Remarks</dt><dd>Throws if no datablock with the given name exists. </dd></dl>

</div>
</div>
<a id="abd39fa103178d48aa78e8a1fd57e6e2b" name="abd39fa103178d48aa78e8a1fd57e6e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd39fa103178d48aa78e8a1fd57e6e2b">&#9670;&#160;</a></span>fillBuffersFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Hlms::fillBuffersFor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;&#160;</td>
          <td class="paramname"><em>queuedRenderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lastCacheHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lastTextureHash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the constant buffers. </p>
<p>Gets executed right before drawing the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Current cache of Shaders to be used. </td></tr>
    <tr><td class="paramname">queuedRenderable</td><td>The Renderable-MovableObject pair about to be rendered. </td></tr>
    <tr><td class="paramname">casterPass</td><td>Whether this is a shadow mapping caster pass. </td></tr>
    <tr><td class="paramname">lastCacheHash</td><td>The hash of the cache of shaders that was the used by the previous renderable. </td></tr>
    <tr><td class="paramname">lastTextureHash</td><td>Last Texture Hash, used to let the <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> know whether the textures should be changed again </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New Texture hash (may be equal or different to lastTextureHash). </dd></dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_hlms_pbs.html#afa450596a77dea7e3579acb6c5711bd9">Ogre::HlmsPbs</a>, <a class="el" href="class_ogre_1_1_hlms_unlit.html#a41c1e5dfb11c966ff791d6f3932518da">Ogre::HlmsUnlit</a>, <a class="el" href="class_ogre_1_1_hlms_compute.html#a35057572019147d8656524e54a73914b">Ogre::HlmsCompute</a>, and <a class="el" href="class_ogre_1_1_hlms_low_level.html#a8f77b843c02cb5f77e5283ad761ec5d5">Ogre::HlmsLowLevel</a>.</p>

</div>
</div>
<a id="a68b85e21a687586586bba5c3302c34d7" name="a68b85e21a687586586bba5c3302c34d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b85e21a687586586bba5c3302c34d7">&#9670;&#160;</a></span>fillBuffersForV1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Hlms::fillBuffersForV1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;&#160;</td>
          <td class="paramname"><em>queuedRenderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lastCacheHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>commandBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_hlms_pbs.html#aa40906e15543bd389ad94d6f3c28de83">Ogre::HlmsPbs</a>, <a class="el" href="class_ogre_1_1_hlms_unlit.html#a0b54d304eff90f782789ea42b97a5a92">Ogre::HlmsUnlit</a>, <a class="el" href="class_ogre_1_1_hlms_compute.html#acb0f598df416024e5893b12a77f0e7d4">Ogre::HlmsCompute</a>, and <a class="el" href="class_ogre_1_1_hlms_low_level.html#aa2b26a6fb059312873ad3d37fae51a0d">Ogre::HlmsLowLevel</a>.</p>

</div>
</div>
<a id="a9be0f56ad3a2e3568112812a44c05b2c" name="a9be0f56ad3a2e3568112812a44c05b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be0f56ad3a2e3568112812a44c05b2c">&#9670;&#160;</a></span>fillBuffersForV2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Hlms::fillBuffersForV2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;&#160;</td>
          <td class="paramname"><em>queuedRenderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lastCacheHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>commandBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_hlms_pbs.html#a450d4c518a53e896462a726334d74857">Ogre::HlmsPbs</a>, <a class="el" href="class_ogre_1_1_hlms_unlit.html#acaa8c8a9f4dd48b27d4b5fb3b4914218">Ogre::HlmsUnlit</a>, <a class="el" href="class_ogre_1_1_hlms_compute.html#a289fc643da6927c17dd2be2c279f9ce3">Ogre::HlmsCompute</a>, and <a class="el" href="class_ogre_1_1_hlms_low_level.html#a2a0487bee500794db0f338e4d2732be9">Ogre::HlmsLowLevel</a>.</p>

</div>
</div>
<a id="a1defa4d9cc3c6a15993e4ee9d0a2f4dc" name="a1defa4d9cc3c6a15993e4ee9d0a2f4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1defa4d9cc3c6a15993e4ee9d0a2f4dc">&#9670;&#160;</a></span>findParamInVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::Hlms::findParamInVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga26539e1c24ff9cadeb6f54139ad7dc54">HlmsParamVec</a> &amp;&#160;</td>
          <td class="paramname"><em>paramVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>inOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the parameter with key 'key' in the given 'paramVec'. </p>
<p>If found, outputs the value to 'inOut', otherwise leaves 'inOut' as is. </p><dl class="section return"><dt>Returns</dt><dd>True if the key was found (inOut was modified), false otherwise </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Assumes paramVec is sorted by key. </dd></dl>

</div>
</div>
<a id="a51d9a980c64b142e90e9fffde15a7112" name="a51d9a980c64b142e90e9fffde15a7112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d9a980c64b142e90e9fffde15a7112">&#9670;&#160;</a></span>frameEnded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::frameEnded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the frame has fully ended (ALL passes have been executed to all RTTs) </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_buffer_manager.html#a71e750856bd4443659457fb4cabbace9">Ogre::HlmsBufferManager</a>, <a class="el" href="class_ogre_1_1_hlms_pbs.html#a1dc0353ce9d6e59300c23d7de5b2d4fe">Ogre::HlmsPbs</a>, and <a class="el" href="class_ogre_1_1_hlms_unlit.html#a066cbfd96608e16d4f59a7aa704ca3bc">Ogre::HlmsUnlit</a>.</p>

</div>
</div>
<a id="aa8fcc2f3f94f0d57958062871daf6c19" name="aa8fcc2f3f94f0d57958062871daf6c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fcc2f3f94f0d57958062871daf6c19">&#9670;&#160;</a></span>getAreaLightsApproxLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::Hlms::getAreaLightsApproxLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1300e74a8d4b63c9e9887fe73058232" name="af1300e74a8d4b63c9e9887fe73058232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1300e74a8d4b63c9e9887fe73058232">&#9670;&#160;</a></span>getAreaLightsLtcLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::Hlms::getAreaLightsLtcLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6e0c86645deec3214413f1d34293614" name="af6e0c86645deec3214413f1d34293614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e0c86645deec3214413f1d34293614">&#9670;&#160;</a></span>getDatablock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> * Ogre::Hlms::getDatablock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an existing datablock based on its name (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms.html#a029b71d6801fc4acbb682d362cf4a1bd" title="Creates a unique datablock that can be shared by multiple renderables.">createDatablock</a>) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The datablock associated with that name. Null pointer if not found. Doesn't throw. </dd></dl>

</div>
</div>
<a id="ab9af91650fdbcc1d675c1e5d5d5e5306" name="ab9af91650fdbcc1d675c1e5d5d5e5306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9af91650fdbcc1d675c1e5d5d5e5306">&#9670;&#160;</a></span>getDatablockCustomPieceData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_hlms_1_1_datablock_custom_piece_file.html">DatablockCustomPieceFile</a> * Ogre::Hlms::getDatablockCustomPieceData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>filenameHashId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all the data we know about filenameHashId. Can be nullptr if not found. </p>

</div>
</div>
<a id="aa5eaec54a8512d44e5e5f8dd6936ff94" name="aa5eaec54a8512d44e5e5f8dd6936ff94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5eaec54a8512d44e5e5f8dd6936ff94">&#9670;&#160;</a></span>getDatablockCustomPieceFileNameStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp; Ogre::Hlms::getDatablockCustomPieceFileNameStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>filenameHashId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73d2cdcc6f6434e6998eb1c240fc8759" name="a73d2cdcc6f6434e6998eb1c240fc8759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d2cdcc6f6434e6998eb1c240fc8759">&#9670;&#160;</a></span>getDatablockMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_hlms.html#ab38ae89227591ab06dac2f033300e7c0">HlmsDatablockMap</a> &amp; Ogre::Hlms::getDatablockMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all datablocks owned by this <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a>, including the default one. </p>

</div>
</div>
<a id="a6576e38225d9205b428bb909d93c5bfb" name="a6576e38225d9205b428bb909d93c5bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6576e38225d9205b428bb909d93c5bfb">&#9670;&#160;</a></span>getDataFolder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_archive.html">Archive</a> * Ogre::Hlms::getDataFolder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9df1057f374a54432b012c5e0309107a" name="a9df1057f374a54432b012c5e0309107a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df1057f374a54432b012c5e0309107a">&#9670;&#160;</a></span>getDefaultDatablock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> * Ogre::Hlms::getDefaultDatablock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Datablock to use when another datablock failed or none was specified.   </p>

</div>
</div>
<a id="a16cb7a1925140a038342fdd79cb9cfe1" name="a16cb7a1925140a038342fdd79cb9cfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cb7a1925140a038342fdd79cb9cfe1">&#9670;&#160;</a></span>getDefaultPaths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::getDefaultPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>outDataFolderPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>outLibraryFoldersPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_config_file.html">ConfigFile</a> &amp;&#160;</td>
          <td class="paramname"><em>configFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the other <a class="el" href="class_ogre_1_1_hlms.html#a16cb7a1925140a038342fdd79cb9cfe1" title="Same as the other getDefaultPaths() overload but it automatically fills the hlmsTypeName param.">getDefaultPaths()</a> overload but it automatically fills the hlmsTypeName param. </p>

</div>
</div>
<a id="a38964d793fc96af144a64ac09154439a" name="a38964d793fc96af144a64ac09154439a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38964d793fc96af144a64ac09154439a">&#9670;&#160;</a></span>getDefaultPaths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Hlms::getDefaultPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>outDataFolderPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>outLibraryFoldersPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_config_file.html">ConfigFile</a> &amp;&#160;</td>
          <td class="paramname"><em>configFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>hlmsTypeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="class_ogre_1_1_hlms_pbs.html#acb5d8056ff22979cf55adb67521c6f13" title="Fill the provided string and string vector with all the sub-folder needed to instantiate an HlmsPbs o...">HlmsPbs::getDefaultPaths</a> but retrieves the files &amp; folders from cfg file. </p>
<p>The syntax is as follows: </p><div class="fragment"><div class="line">[pbs]</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1_hlms_1_1_library.html">Library</a>=<a class="code hl_class" href="class_ogre_1_1_hlms.html">Hlms</a>/Common/[SHADER_SYNTAX]</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1_hlms_1_1_library.html">Library</a>=<a class="code hl_class" href="class_ogre_1_1_hlms.html">Hlms</a>/Common/<a class="code hl_class" href="class_ogre_1_1_any.html">Any</a></div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1_hlms_1_1_library.html">Library</a>=<a class="code hl_class" href="class_ogre_1_1_hlms.html">Hlms</a>/Pbs/<a class="code hl_class" href="class_ogre_1_1_any.html">Any</a></div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1_hlms_1_1_library.html">Library</a>=<a class="code hl_class" href="class_ogre_1_1_hlms.html">Hlms</a>/Pbs/<a class="code hl_class" href="class_ogre_1_1_any.html">Any</a>/Atmosphere</div>
<div class="line"><a class="code hl_struct" href="struct_ogre_1_1_hlms_1_1_library.html">Library</a>=<a class="code hl_class" href="class_ogre_1_1_hlms.html">Hlms</a>/Pbs/<a class="code hl_class" href="class_ogre_1_1_any.html">Any</a>/Main</div>
<div class="line">Main=<a class="code hl_class" href="class_ogre_1_1_hlms.html">Hlms</a>/Pbs/[SHADER_SYNTAX]</div>
<div class="ttc" id="aclass_ogre_1_1_any_html"><div class="ttname"><a href="class_ogre_1_1_any.html">Ogre::Any</a></div><div class="ttdoc">Variant type that can hold Any other type.</div><div class="ttdef"><b>Definition</b> OgreAny.h:65</div></div>
<div class="ttc" id="aclass_ogre_1_1_hlms_html"><div class="ttname"><a href="class_ogre_1_1_hlms.html">Ogre::Hlms</a></div><div class="ttdoc">HLMS stands for &quot;High Level Material System&quot;.</div><div class="ttdef"><b>Definition</b> OgreHlms.h:88</div></div>
<div class="ttc" id="astruct_ogre_1_1_hlms_1_1_library_html"><div class="ttname"><a href="struct_ogre_1_1_hlms_1_1_library.html">Ogre::Hlms::Library</a></div><div class="ttdef"><b>Definition</b> OgreHlms.h:259</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outDataFolderPath</td><td></td></tr>
    <tr><td class="paramname">outLibraryFoldersPaths</td><td></td></tr>
    <tr><td class="paramname">configFile</td><td></td></tr>
    <tr><td class="paramname">hlmsTypeName</td><td>Name of the <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a>. e.g. "pbs", "unlit". See <a class="el" href="class_ogre_1_1_hlms.html#a14ea98bcf58eda73fb8afb5a6de98edd">getTypeNameStr()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a124fd6d17116915b6c407d8743b436cb" name="a124fd6d17116915b6c407d8743b436cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124fd6d17116915b6c407d8743b436cb">&#9670;&#160;</a></span>getFastShaderBuildHack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Hlms::getFastShaderBuildHack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if shaders are being compiled with Fast Shader Build Hack (D3D11 only) </p>

</div>
</div>
<a id="ad004bde573064ae48aba462dfcaa536e" name="ad004bde573064ae48aba462dfcaa536e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad004bde573064ae48aba462dfcaa536e">&#9670;&#160;</a></span>getFilenameAndResourceGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::getFilenameAndResourceGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> const **&#160;</td>
          <td class="paramname"><em>outFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> const **&#160;</td>
          <td class="paramname"><em>outResourceGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the filaname &amp; resource group a datablock was created from, and is associated with its hashed name (this was passed as in <a class="el" href="class_ogre_1_1_hlms.html#a029b71d6801fc4acbb682d362cf4a1bd" title="Creates a unique datablock that can be shared by multiple renderables.">createDatablock()</a>). </p>
<p>Returns null ptr if not found. Note that it may also be a valid pointer but contain an empty string. The reason this String doesn't live in <a class="el" href="class_ogre_1_1_hlms_datablock.html" title="An hlms datablock contains individual information about a specific material.">HlmsDatablock</a> is to prevent cache trashing (datablocks are hot iterated every frame, and the filename &amp; resource groups are rarely ever used). </p><dl class="section user"><dt></dt><dd>Usage: <div class="fragment"><div class="line"><a class="code hl_typedef" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <span class="keyword">const</span> *filename;</div>
<div class="line"><a class="code hl_typedef" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <span class="keyword">const</span> *resourceGroup;</div>
<div class="line">datablock-&gt;getFilenameAndResourceGroup( &amp;filename, &amp;resourceGroup );</div>
<div class="line"><span class="keywordflow">if</span>( filename &amp;&amp; resourceGroup &amp;&amp; !filename-&gt;empty() &amp;&amp; !resourceGroup-&gt;empty() )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//Valid filename &amp; resource group.</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespace_ogre_html_af73bbdc8bed8a3e6fcd56bb8fa188c45"><div class="ttname"><a href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a></div><div class="ttdeci">_StringBase String</div><div class="ttdef"><b>Definition</b> OgreCommon.h:40</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af316fb5991958874cbdd34323c57fc91" name="af316fb5991958874cbdd34323c57fc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af316fb5991958874cbdd34323c57fc91">&#9670;&#160;</a></span>getHlmsManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_manager.html">HlmsManager</a> * Ogre::Hlms::getHlmsManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bd7501298e4479520c59036bc4a6724" name="a5bd7501298e4479520c59036bc4a6724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd7501298e4479520c59036bc4a6724">&#9670;&#160;</a></span>getListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_listener.html">HlmsListener</a> * Ogre::Hlms::getListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current listener. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms.html#a761bbbb8ac57759c2d2529a5d485c8c5" title="Sets a listener to extend an existing Hlms implementation&#39;s with custom code, without having to rewri...">setListener()</a>; </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the default listener is being used (that does nothing) then null is returned. </dd></dl>

</div>
</div>
<a id="a2ebbb13548a00b54a8143d86ab2afcf6" name="a2ebbb13548a00b54a8143d86ab2afcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebbb13548a00b54a8143d86ab2afcf6">&#9670;&#160;</a></span>getMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> * Ogre::Hlms::getMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> const *&#160;</td>
          <td class="paramname"><em>lastReturnedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;&#160;</td>
          <td class="paramname"><em>passCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;&#160;</td>
          <td class="paramname"><em>queuedRenderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_parallel_hlms_compile_queue.html">ParallelHlmsCompileQueue</a> *&#160;</td>
          <td class="paramname"><em>parallelQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> filled with the GPU programs to be used by the given renderable. </p>
<p>If the shaders have already been created (i.e. whether for this renderable, or another one) it gets them from a cache. Otherwise we create it. It assumes that renderable-&gt;setHlms( this, parameters ) has already called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastReturnedValue</td><td>The last value returned by getMaterial. </td></tr>
    <tr><td class="paramname">passCache</td><td>The cache returned by <a class="el" href="class_ogre_1_1_hlms.html#ad3e82fb2e682366cc721e521ee41d64d" title="Called every frame by the Render Queue to cache the properties needed by this pass.">preparePassHash()</a>. </td></tr>
    <tr><td class="paramname">renderable</td><td>The renderable the caller wants us to give the shaders. </td></tr>
    <tr><td class="paramname">movableObject</td><td>The <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> owner of the renderable (we need it to know if renderable should cast shadows) </td></tr>
    <tr><td class="paramname">casterPass</td><td>True if this pass is the shadow mapping caster pass, false otherwise </td></tr>
    <tr><td class="paramname">parallelQueue</td><td>If non-null, the returned pointer will be a stub pointer; and caller is expected to call <a class="el" href="class_ogre_1_1_hlms.html#afa61df0f4d69b0bfdacbe3d089175b35" title="Called by ParallelHlmsCompileQueue to finish the job started in getMaterial()">compileStubEntry()</a> from a worker thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Structure containing all necessary shaders </dd></dl>

</div>
</div>
<a id="aa6543944cdb6e2eddc17075e31db2db5" name="aa6543944cdb6e2eddc17075e31db2db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6543944cdb6e2eddc17075e31db2db5">&#9670;&#160;</a></span>getMaterialSerial01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Hlms::getMaterialSerial01 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lastReturnedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;&#160;</td>
          <td class="paramname"><em>passCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>passCacheIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;&#160;</td>
          <td class="paramname"><em>queuedRenderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_parallel_hlms_compile_queue.html">ParallelHlmsCompileQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>parallelQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is extremely similar to <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> except it's been designed to be always in parallel and to be used by warm_up passes. </p>
<p>The main difference is that <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> starts firing shaders for parallel compilation as soon as they are seen, while this function accumulates as much as possible (even crossing multiple warm_up passes if they are in Collect mode) and then fire everything at once.</p>
<p>This can result in greater throughput. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastReturnedValue</td><td>Hash of the last value we've returned. </td></tr>
    <tr><td class="paramname">passCache</td><td>See <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> </td></tr>
    <tr><td class="paramname">passCacheIdx</td><td>We can't send a permanent reference of passCache to parallelQueue, because the passCache won't survive that long. So we send instead and index that parallelQueue will later use to send the right pass cache to <a class="el" href="class_ogre_1_1_hlms.html#afa61df0f4d69b0bfdacbe3d089175b35" title="Called by ParallelHlmsCompileQueue to finish the job started in getMaterial()">compileStubEntry()</a> </td></tr>
    <tr><td class="paramname">queuedRenderable</td><td>See <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> </td></tr>
    <tr><td class="paramname">casterPass</td><td>See <a class="el" href="class_ogre_1_1_hlms.html#a2ebbb13548a00b54a8143d86ab2afcf6" title="Retrieves an HlmsCache filled with the GPU programs to be used by the given renderable.">getMaterial()</a> </td></tr>
    <tr><td class="paramname">parallelQueue</td><td>[in/out] Queue to push our work to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash the shader will end up with. Caller must track whether we've already returned this value. </dd></dl>

</div>
</div>
<a id="a9d0d8509660561e244edcd5ac2b4364f" name="a9d0d8509660561e244edcd5ac2b4364f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0d8509660561e244edcd5ac2b4364f">&#9670;&#160;</a></span>getMaxNonCasterDirectionalLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::Hlms::getMaxNonCasterDirectionalLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a39abc97918a7952311bd944e6e1e7f" name="a6a39abc97918a7952311bd944e6e1e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a39abc97918a7952311bd944e6e1e7f">&#9670;&#160;</a></span>getNameStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> * Ogre::Hlms::getNameStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string name associated with its hashed name (this was passed as refName in <a class="el" href="class_ogre_1_1_hlms.html#a029b71d6801fc4acbb682d362cf4a1bd" title="Creates a unique datablock that can be shared by multiple renderables.">createDatablock()</a>). </p>
<p>Returns null ptr if not found. The reason this String doesn't live in <a class="el" href="class_ogre_1_1_hlms_datablock.html" title="An hlms datablock contains individual information about a specific material.">HlmsDatablock</a> is to prevent cache trashing (datablocks are hot iterated every frame, and the full name is rarely ever used) </p>

</div>
</div>
<a id="ac3c3c59d5048bcbdd3d7364710451b1f" name="ac3c3c59d5048bcbdd3d7364710451b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c3c59d5048bcbdd3d7364710451b1f">&#9670;&#160;</a></span>getParticleSystemConstSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::Hlms::getParticleSystemConstSlot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58e2d6842bad07409f827628be81570e" name="a58e2d6842bad07409f827628be81570e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e2d6842bad07409f827628be81570e">&#9670;&#160;</a></span>getParticleSystemSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::Hlms::getParticleSystemSlot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa09e06cb91f99f8e8fe0d0928ae64d22" name="aa09e06cb91f99f8e8fe0d0928ae64d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09e06cb91f99f8e8fe0d0928ae64d22">&#9670;&#160;</a></span>getPiecesLibrary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_hlms.html#a6515668f13ae08887b8104c7133e5c29">LibraryVec</a> &amp; Ogre::Hlms::getPiecesLibrary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14556592a9642bdea61b6a2298aaf53b" name="a14556592a9642bdea61b6a2298aaf53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14556592a9642bdea61b6a2298aaf53b">&#9670;&#160;</a></span>getPiecesLibraryAsArchiveVec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___resources.html#gac56fd5a93b0000f2487e2ca968784df3">ArchiveVec</a> Ogre::Hlms::getPiecesLibraryAsArchiveVec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31405ce224d30e5eff4900ba02f6fecd" name="a31405ce224d30e5eff4900ba02f6fecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31405ce224d30e5eff4900ba02f6fecd">&#9670;&#160;</a></span>getPrecisionMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954f">PrecisionMode</a> Ogre::Hlms::getPrecisionMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns requested precision mode (i.e., value passed to setPrecisionMode) See getSupportedPrecisionMode. </p>

</div>
</div>
<a id="ac3cbb0af420992ea18745ae2093ca78a" name="ac3cbb0af420992ea18745ae2093ca78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cbb0af420992ea18745ae2093ca78a">&#9670;&#160;</a></span>getProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> Ogre::Hlms::getProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>defaultVal</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility helper, mostly useful to <a class="el" href="class_ogre_1_1_hlms_listener.html" title="Listener that can be hooked to an Hlms implementation for extending it with custom code.">HlmsListener</a> implementations. </p>

</div>
</div>
<a id="a4551924c6b8aa1260e5d553c6b83e314" name="a4551924c6b8aa1260e5d553c6b83e314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4551924c6b8aa1260e5d553c6b83e314">&#9670;&#160;</a></span>getRenderSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> * Ogre::Hlms::getRenderSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a238f9c88f9122e99a617be7461e45c11" name="a238f9c88f9122e99a617be7461e45c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238f9c88f9122e99a617be7461e45c11">&#9670;&#160;</a></span>getShaderCodeCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ShaderCodeCacheVec &amp; Ogre::Hlms::getShaderCodeCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1beb8469205bfc6146705506ced9b8c" name="ab1beb8469205bfc6146705506ced9b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1beb8469205bfc6146705506ced9b8c">&#9670;&#160;</a></span>getShaderProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp; Ogre::Hlms::getShaderProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a905909d0752107d11db3fb6d27c2d615" name="a905909d0752107d11db3fb6d27c2d615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905909d0752107d11db3fb6d27c2d615">&#9670;&#160;</a></span>getShaderSyntax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::Hlms::getShaderSyntax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade989fe1d9b95aa73a7885211f764041" name="ade989fe1d9b95aa73a7885211f764041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade989fe1d9b95aa73a7885211f764041">&#9670;&#160;</a></span>getStaticBranchingLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Hlms::getStaticBranchingLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14d03f2b9bb51c0eb4d3583c20a2ec27" name="a14d03f2b9bb51c0eb4d3583c20a2ec27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d03f2b9bb51c0eb4d3583c20a2ec27">&#9670;&#160;</a></span>getSupportedPrecisionMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954f">PrecisionMode</a> Ogre::Hlms::getSupportedPrecisionMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some GPUs don't support all precision modes. </p>
<p>Therefore this will returns the actually used precision mode after checking HW support </p>

</div>
</div>
<a id="a7a0ec84d5e6078c5627f40e95d8d8ca3" name="a7a0ec84d5e6078c5627f40e95d8d8ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0ec84d5e6078c5627f40e95d8d8ca3">&#9670;&#160;</a></span>getTemplateChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::getTemplateChecksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af7c8391e4119084465186113a849f065">uint64</a>&#160;</td>
          <td class="paramname"><em>outHash</em>[2]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a508e017c803859196fc55860b7ddfc0f" name="a508e017c803859196fc55860b7ddfc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508e017c803859196fc55860b7ddfc0f">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___resources.html#ga11d7536f610632f563befe49447d8107">HlmsTypes</a> Ogre::Hlms::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10f828092b41b6224285937a71c69350" name="a10f828092b41b6224285937a71c69350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f828092b41b6224285937a71c69350">&#9670;&#160;</a></span>getTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::Hlms::getTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14ea98bcf58eda73fb8afb5a6de98edd" name="a14ea98bcf58eda73fb8afb5a6de98edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ea98bcf58eda73fb8afb5a6de98edd">&#9670;&#160;</a></span>getTypeNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp; Ogre::Hlms::getTypeNameStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ba9f48ab9315af6e69d98844ddabddb" name="a0ba9f48ab9315af6e69d98844ddabddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba9f48ab9315af6e69d98844ddabddb">&#9670;&#160;</a></span>hasParticleFX2Plugin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::Hlms::hasParticleFX2Plugin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a412a9493da6ff386a74c43aa7f53722f" name="a412a9493da6ff386a74c43aa7f53722f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412a9493da6ff386a74c43aa7f53722f">&#9670;&#160;</a></span>isDatablockCustomPieceFileCacheable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Hlms::isDatablockCustomPieceFileCacheable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>filenameHashId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87e7dcce06295d710b64917bb19e1f52" name="a87e7dcce06295d710b64917bb19e1f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e7dcce06295d710b64917bb19e1f52">&#9670;&#160;</a></span>isShaderCodeCacheDirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Hlms::isShaderCodeCacheDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Users can check this function to tell if <a class="el" href="class_ogre_1_1_hlms_disk_cache.html" title="This class allows saving the current state of an Hlms to disk: both its compiled shaders with source ...">HlmsDiskCache</a> needs saving. </p>
<p>If this value returns false, then <a class="el" href="class_ogre_1_1_hlms_disk_cache.html" title="This class allows saving the current state of an Hlms to disk: both its compiled shaders with source ...">HlmsDiskCache</a> doesn't need saving. </p>

</div>
</div>
<a id="ae4dbc640402f792b8d2da9889a4a9e19" name="ae4dbc640402f792b8d2da9889a4a9e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dbc640402f792b8d2da9889a4a9e19">&#9670;&#160;</a></span>parseOffline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Hlms::parseOffline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>inBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For standalone parsing. </p>

</div>
</div>
<a id="a666c0da0880cf52f84e31f03e4736cac" name="a666c0da0880cf52f84e31f03e4736cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666c0da0880cf52f84e31f03e4736cac">&#9670;&#160;</a></span>postCommandBufferExecution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::postCommandBufferExecution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets called after executing the command buffer. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_buffer_manager.html#a8884c9ce9db5b9e6090e4034e873cd63">Ogre::HlmsBufferManager</a>, and <a class="el" href="class_ogre_1_1_hlms_pbs.html#a5977a2c286fd961c231908dd57c407de">Ogre::HlmsPbs</a>.</p>

</div>
</div>
<a id="a365579c231d6fd0d32a567a3a1b6582a" name="a365579c231d6fd0d32a567a3a1b6582a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365579c231d6fd0d32a567a3a1b6582a">&#9670;&#160;</a></span>preCommandBufferExecution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::preCommandBufferExecution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets called right before executing the command buffer. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_buffer_manager.html#afeea1966ecc0c94015c232c841ec8716">Ogre::HlmsBufferManager</a>.</p>

</div>
</div>
<a id="ad3e82fb2e682366cc721e521ee41d64d" name="ad3e82fb2e682366cc721e521ee41d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e82fb2e682366cc721e521ee41d64d">&#9670;&#160;</a></span>preparePassHash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> Ogre::Hlms::preparePassHash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">Ogre::CompositorShadowNode</a> *&#160;</td>
          <td class="paramname"><em>shadowNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dualParaboloid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called every frame by the Render Queue to cache the properties needed by this pass. </p>
<p>i.e. Number of PSSM splits, number of shadow casting lights, etc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shadowNode</td><td>The shadow node currently in effect. Can be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A hash and cached property parameters. Unlike <a class="el" href="class_ogre_1_1_hlms.html#a5b71158453ed0a2411a92ecf767af130" title="Called by the renderable when either it changes the material, or its properties change (e....">calculateHashFor()</a>, the cache must be kept by the caller and not by us (because it may change every frame and is one for the whole pass, but <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Mesh</a>' properties usually stay consistent through its lifetime but may differ per mesh) </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_buffer_manager.html#a2d0a1980bba548053bc1752a31447b95">Ogre::HlmsBufferManager</a>, <a class="el" href="class_ogre_1_1_hlms_pbs.html#a85a58005d874ea0ff1e1d2dd6d6879d2">Ogre::HlmsPbs</a>, <a class="el" href="class_ogre_1_1_hlms_unlit.html#a05eb7eaf97a834862a19e43a2bd8f584">Ogre::HlmsUnlit</a>, and <a class="el" href="class_ogre_1_1_hlms_low_level.html#ac623534b088b737d1ffc5ecb9e219ba7">Ogre::HlmsLowLevel</a>.</p>

</div>
</div>
<a id="a2513b676def18667eb5579abfa50820a" name="a2513b676def18667eb5579abfa50820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2513b676def18667eb5579abfa50820a">&#9670;&#160;</a></span>reloadFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::reloadFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_archive.html">Archive</a> *&#160;</td>
          <td class="paramname"><em>newDataFolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___resources.html#gac56fd5a93b0000f2487e2ca968784df3">ArchiveVec</a> *&#160;</td>
          <td class="paramname"><em>libraryFolders</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys all the cached shaders and in the next opportunity will recreate them from the new location. </p>
<p>This is very useful for fast iteration and real-time editing of <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> shader templates. </p><dl class="section remark"><dt>Remarks</dt><dd>Calling with null pointer is possible and will only invalidate existing shaders but you should provide a valid pointer before we start generating the first shader (or else crash). </dd></dl>
<dl class="section user"><dt></dt><dd>Existing datablock materials won't be reloaded from files, so their properties won't change (i.e. changed from blue to red), but the shaders will. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libraryFolders</td><td>When null pointer, the library folders paths won't be changed at all (but still will be reloaded). When non-null pointer, the library folders will be overwriten. <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> an empty container if you want to stop using libraries. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_compute.html#a9dc3eb356c6a318389101c825483fb8b">Ogre::HlmsCompute</a>.</p>

</div>
</div>
<a id="a4f184b28b72445e50b59bcca8b16a3a6" name="a4f184b28b72445e50b59bcca8b16a3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f184b28b72445e50b59bcca8b16a3a6">&#9670;&#160;</a></span>saveAllTexturesFromDatablocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::saveAllTexturesFromDatablocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>folderPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>savedTextures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveOitd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_texture_export_listener.html">HlmsTextureExportListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebca7da0789967e8fde70d95fa74ac0c" name="aebca7da0789967e8fde70d95fa74ac0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebca7da0789967e8fde70d95fa74ac0c">&#9670;&#160;</a></span>setAreaLightForwardSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::setAreaLightForwardSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>areaLightsApproxLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>areaLightsLtcLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Area lights use regular Forward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">areaLightsApproxLimit</td><td><p class="starttd">Maximum number of area approx lights that will be considered by the shader. Default value is 1. Use 0 to disable area lights.</p>
<p class="intertd">Note: There is little to no performance impact for setting this value higher than you need. e.g. If you set areaLightsApproxLimit = 4, but you only have 2 area lights on scene, you'll pay the price of 2 area lights (but the RAM price of 4).</p>
<p class="endtd">Beware of setting this value too high (e.g. 65535) as the amount of memory space is limited (we cannot exceed 64kb, including unrelated data to lighting, but required to the pass) </p>
</td></tr>
    <tr><td class="paramname">areaLightsLtcLimit</td><td>Same as areaLightsApproxLimit, but for LTC lights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bd6a05326ef3082d1d88fa5c3ec8c61" name="a5bd6a05326ef3082d1d88fa5c3ec8c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd6a05326ef3082d1d88fa5c3ec8c61">&#9670;&#160;</a></span>setDebugOutputPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::setDebugOutputPath </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableDebugOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>outputProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call to output the automatically generated shaders (which are usually made from templates) on the given folder for inspection, analyzing, debugging, etc. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The shader will be dumped when it is generated, not when this function gets called. You should call this function at start up </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enableDebugOutput</td><td>Whether to enable or disable dumping the shaders into a folder </td></tr>
    <tr><td class="paramname">outputProperties</td><td>Whether to dump properties and pieces at the beginning of the shader file. This is very useful for determining what caused <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to compile a new variation. Note that this setting may not always produce valid shader code in the dumped files (but it we'll still produce valid shader code while at runtime) If you want to compile the dumped file and it is invalid, just strip this info. </td></tr>
    <tr><td class="paramname">path</td><td>Path location on where to dump it. Should end with slash for proper concatenation (i.e. C:/path/ instead of C:/path; or /home/user/ instead of /home/user) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a761bbbb8ac57759c2d2529a5d485c8c5" name="a761bbbb8ac57759c2d2529a5d485c8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761bbbb8ac57759c2d2529a5d485c8c5">&#9670;&#160;</a></span>setListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_listener.html">HlmsListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a listener to extend an existing <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> implementation's with custom code, without having to rewrite it or modify the source code directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Other alternatives for extending an existing implementation is to derive from the class and override particular virtual functions. For performance reasons, listeners are never called on a per-object basis. Consult the section "Customizing an existing implementation" from the manual in the Docs/2.0 folder. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>Listener pointer. Use null to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a144d4a10a6e3a7a1c580d72913ec1cd8" name="a144d4a10a6e3a7a1c580d72913ec1cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144d4a10a6e3a7a1c580d72913ec1cd8">&#9670;&#160;</a></span>setMaxNonCasterDirectionalLights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::setMaxNonCasterDirectionalLights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>maxLights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-caster directional lights are hardcoded into shaders. </p>
<p>This means that if you have 6 directional lights and then you add a 7th one, a whole new set of shaders will be created.</p>
<p>This setting allows you to tremendously reduce the amount of shader permutations by forcing <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to switching to static branching with an upper limit to the max number of non-shadow-casting directional lights.</p>
<p>There is no such switch for shadow-casting directional/point/spot lights because of technical limitations at the GPU level (cannot index shadow map textures in DX11, nor samplers in any known GPU).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms.html#aebca7da0789967e8fde70d95fa74ac0c" title="Area lights use regular Forward.">setAreaLightForwardSettings</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLights</td><td><p class="starttd">Maximum number of non-caster directional lights. 0 to allow unlimited number of lights, at the cost of shader recompilations when directional lights are added or removed.</p>
<p class="intertd">Default value is 0.</p>
<p class="intertd">Note: There is little to no performance impact for setting this value higher than you need. e.g. If you set maxLights = 4, but you only have 2 non-caster dir. lights on scene, you'll pay the price of 2 lights (but the RAM price of 4).</p>
<p class="endtd">Beware of setting this value too high (e.g. 65535) as the amount of memory space is limited (we cannot exceed 64kb, including unrelated data to lighting, but required to the pass) </p>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd7b3dc16d494d83e9608cdb68f4512d" name="afd7b3dc16d494d83e9608cdb68f4512d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7b3dc16d494d83e9608cdb68f4512d">&#9670;&#160;</a></span>setPrecisionMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Hlms::setPrecisionMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms.html#aa0365b8787bb8b348fb7b715c056954f">PrecisionMode</a>&#160;</td>
          <td class="paramname"><em>precisionMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the precision mode of <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a>. </p>
<p>See PrecisionMode Note: This call may invalidate the shader cache! Call as early as possible. </p>

</div>
</div>
<a id="a85c00acdba7c9a0bcab3c6a0a48d587f" name="a85c00acdba7c9a0bcab3c6a0a48d587f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c00acdba7c9a0bcab3c6a0a48d587f">&#9670;&#160;</a></span>setProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Hlms::setProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility helper, mostly useful to <a class="el" href="class_ogre_1_1_hlms_listener.html" title="Listener that can be hooked to an Hlms implementation for extending it with custom code.">HlmsListener</a> implementations. </p>

</div>
</div>
<a id="a46fdb3fe8b4889d911d41468dabf4400" name="a46fdb3fe8b4889d911d41468dabf4400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fdb3fe8b4889d911d41468dabf4400">&#9670;&#160;</a></span>setStaticBranchingLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Hlms::setStaticBranchingLights </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>staticBranchingLights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>By default shadow-caster spot and point lights are hardcoded into shaders. </p>
<p>This means that if you have 8 spot/point lights and then you add a 9th one, a whole new set of shaders will be created. Even more if you have a combination of 3 spot and 5 point lights and the combination has changed to 4 spot and 4 point lights then you'll get the next set of shaders</p>
<p>This setting allows you to tremendously reduce the amount of shader permutations by forcing <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to switching to static branching with an upper limit to the max number of shadow-casting spot or point lights.</p>
<p>See <a class="el" href="class_ogre_1_1_hlms.html#aebca7da0789967e8fde70d95fa74ac0c" title="Area lights use regular Forward.">Hlms::setAreaLightForwardSettings</a> </p><dl class="section remark"><dt>Remarks</dt><dd>All point and spot lights must share the same hlms_shadowmap atlas</dd></dl>
<p>This is mostly an D3D11 / HLSL SM 5.0 restriction (<a href="https://github.com/OGRECave/ogre-next/pull/255">https://github.com/OGRECave/ogre-next/pull/255</a>) but it may also help with performance in other APIs.</p>
<p>If multiple atlas support is needed, using Texture2DArrays may be a good solution, although it is currently untested and may need additional fixes to get it working</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">staticBranchingLights</td><td>True to evalute number of lights in the shader using static branching (less shader variants). False to recompile the shader more often (more variants, but better optimized shaders). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_hlms_pbs.html#a963eb65a741f018625e58db16852d2e9">Ogre::HlmsPbs</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3b41b85c9b51fe6794d25e95bd5ea31f" name="a3b41b85c9b51fe6794d25e95bd5ea31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b41b85c9b51fe6794d25e95bd5ea31f">&#9670;&#160;</a></span>kNoTid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Ogre::Hlms::kNoTid = 0u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For single-threaded operations. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_hlms_8h.html">OgreHlms.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
