<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::HlmsListener Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_hlms_listener.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_hlms_listener-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::HlmsListener Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Listener that can be hooked to an <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> implementation for extending it with custom code.  
 <a href="class_ogre_1_1_hlms_listener.html#details">More...</a></p>

<p><code>#include &lt;OgreHlmsListener.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a037010d6c19ab004d954b51b2bdc0154" id="r_a037010d6c19ab004d954b51b2bdc0154"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#a037010d6c19ab004d954b51b2bdc0154">applyStrongBlendblockRules</a> (<a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> &amp;blendblock, const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;properties) const</td></tr>
<tr class="memdesc:a037010d6c19ab004d954b51b2bdc0154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from Hlms::createShaderCacheEntry after an <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> is initialized.    <br /></td></tr>
<tr class="separator:a037010d6c19ab004d954b51b2bdc0154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b3e93ebf93e2ba65112d1296635aa5" id="r_a26b3e93ebf93e2ba65112d1296635aa5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#a26b3e93ebf93e2ba65112d1296635aa5">applyStrongMacroblockRules</a> (<a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> &amp;macroblock, const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;properties) const</td></tr>
<tr class="memdesc:a26b3e93ebf93e2ba65112d1296635aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from Hlms::createShaderCacheEntry after an <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> is initialized.  <br /></td></tr>
<tr class="separator:a26b3e93ebf93e2ba65112d1296635aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516750b25e741d5260ed81d98e0521b9" id="r_a516750b25e741d5260ed81d98e0521b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#a516750b25e741d5260ed81d98e0521b9">getNumExtraPassTextures</a> (const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;properties, bool casterPass) const</td></tr>
<tr class="memdesc:a516750b25e741d5260ed81d98e0521b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If hlmsTypeChanged is going to be binding extra textures, override this function to tell us how many textures you will use, so that we don't use those slots.  <br /></td></tr>
<tr class="separator:a516750b25e741d5260ed81d98e0521b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6908edd7c16efc1ef1638a6a1e08bd9" id="r_ad6908edd7c16efc1ef1638a6a1e08bd9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#ad6908edd7c16efc1ef1638a6a1e08bd9">getPassBufferSize</a> (const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *shadowNode, bool casterPass, bool dualParaboloid, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager) const</td></tr>
<tr class="memdesc:ad6908edd7c16efc1ef1638a6a1e08bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listeners should return the number of extra bytes they wish to allocate for storing additional data in the pass buffer.  <br /></td></tr>
<tr class="separator:ad6908edd7c16efc1ef1638a6a1e08bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10609ad741f2c3de7ce3715738cd0bea" id="r_a10609ad741f2c3de7ce3715738cd0bea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#a10609ad741f2c3de7ce3715738cd0bea">hlmsTypeChanged</a> (bool casterPass, <a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *commandBuffer, const <a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *datablock, size_t texUnit)</td></tr>
<tr class="memdesc:a10609ad741f2c3de7ce3715738cd0bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the last <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> processed was of a different <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> type, thus we need to rebind certain buffers (like the pass buffer).  <br /></td></tr>
<tr class="separator:a10609ad741f2c3de7ce3715738cd0bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857166e748d47c14a6ffbb67a6126468" id="r_a857166e748d47c14a6ffbb67a6126468"><td class="memItemLeft" align="right" valign="top">virtual float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#a857166e748d47c14a6ffbb67a6126468">preparePassBuffer</a> (const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *shadowNode, bool casterPass, bool dualParaboloid, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager, float *passBufferPtr)</td></tr>
<tr class="memdesc:a857166e748d47c14a6ffbb67a6126468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write additional data in the pass buffer.  <br /></td></tr>
<tr class="separator:a857166e748d47c14a6ffbb67a6126468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cc9cdfb4cc2eca0e06ba13a467c7e5" id="r_ab0cc9cdfb4cc2eca0e06ba13a467c7e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#ab0cc9cdfb4cc2eca0e06ba13a467c7e5">preparePassHash</a> (const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *shadowNode, bool casterPass, bool dualParaboloid, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager, <a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *hlms)</td></tr>
<tr class="memdesc:ab0cc9cdfb4cc2eca0e06ba13a467c7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called right before creating the pass cache, to allow the listener to add/remove properties.  <br /></td></tr>
<tr class="separator:ab0cc9cdfb4cc2eca0e06ba13a467c7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8ae5bc5f0c78db2e98b111bcdbed0d" id="r_a1b8ae5bc5f0c78db2e98b111bcdbed0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#a1b8ae5bc5f0c78db2e98b111bcdbed0d">propertiesMergedPreGenerationStep</a> (<a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *hlms, const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;passCache, const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;renderableCacheProperties, const <a class="el" href="group___resources.html#ga8d0386169199086cbe23f19967f934af">PiecesMap</a> renderableCachePieces[<a class="el" href="group___general.html#gga7049ce296bb4883feab25251d3865035a0bf893209b217d59e15abaf48092d132">NumShaderTypes</a>], const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;properties, const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;queuedRenderable, size_t tid)</td></tr>
<tr class="memdesc:a1b8ae5bc5f0c78db2e98b111bcdbed0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="class_ogre_1_1_hlms_listener.html#aaf83dfe4a43ac3c7c444c90d759a7744" title="Called after the shader was created/compiled, and right before bindGpuProgramParameters (relevant inf...">HlmsListener::shaderCacheEntryCreated</a>, but it gets called before creating any shader.  <br /></td></tr>
<tr class="separator:a1b8ae5bc5f0c78db2e98b111bcdbed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82f8eabfd65173e02a8e6901047eb62" id="r_aa82f8eabfd65173e02a8e6901047eb62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#aa82f8eabfd65173e02a8e6901047eb62">setupRootLayout</a> (<a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a> &amp;rootLayout, const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;properties, size_t tid) const</td></tr>
<tr class="memdesc:aa82f8eabfd65173e02a8e6901047eb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called right before compiling.  <br /></td></tr>
<tr class="separator:aa82f8eabfd65173e02a8e6901047eb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf83dfe4a43ac3c7c444c90d759a7744" id="r_aaf83dfe4a43ac3c7c444c90d759a7744"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_listener.html#aaf83dfe4a43ac3c7c444c90d759a7744">shaderCacheEntryCreated</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;shaderProfile, const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *hlmsCacheEntry, const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;passCache, const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;properties, const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;queuedRenderable, size_t tid)</td></tr>
<tr class="memdesc:aaf83dfe4a43ac3c7c444c90d759a7744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the shader was created/compiled, and right before bindGpuProgramParameters (relevant information for OpenGL programs).  <br /></td></tr>
<tr class="separator:aaf83dfe4a43ac3c7c444c90d759a7744"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Listener that can be hooked to an <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> implementation for extending it with custom code. </p>
<p>See "8.6.5 Customizing an existing implementation" of the 2.x manual on the different approaches to customizing <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> implementations. </p><dl class="section remark"><dt>Remarks</dt><dd>For performance reasons, the listener interface does not allow you to add customizations that work per <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a>, as that loop is performance sensitive. The only listener callback that works inside <a class="el" href="class_ogre_1_1_hlms.html#abd39fa103178d48aa78e8a1fd57e6e2b" title="Fills the constant buffers.">Hlms::fillBuffersFor</a> is hlmsTypeChanged which only gets evaluated when the previous <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> used a different <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> implementation; which is rare, and since we sort the <a class="el" href="class_ogre_1_1_render_queue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a>, it often branch predicts well. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a037010d6c19ab004d954b51b2bdc0154" name="a037010d6c19ab004d954b51b2bdc0154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037010d6c19ab004d954b51b2bdc0154">&#9670;&#160;</a></span>applyStrongBlendblockRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HlmsListener::applyStrongBlendblockRules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> &amp;&#160;</td>
          <td class="paramname"><em>blendblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called from Hlms::createShaderCacheEntry after an <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> is initialized.   </p>
<p>It allows to modify its currently assigned macroblock. This allows to override the macroblocks for all renderables within a pass. The listener can set a property or multiple properties in preparePassHash which can be accessed from this method to modify input macroblock. </p><dl class="section see"><dt>See also</dt><dd>Hlms::applyStrongMacroblockRules. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Given the same set of properties, the function must always return the same value. Otherwise caching (i.e. <a class="el" href="class_ogre_1_1_hlms_disk_cache.html" title="This class allows saving the current state of an Hlms to disk: both its compiled shaders with source ...">HlmsDiskCache</a>) won't work correctly. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">macroblock</td><td>[in/out] Current macroblock. You can modify it if needed. </td></tr>
    <tr><td class="paramname">properties</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26b3e93ebf93e2ba65112d1296635aa5" name="a26b3e93ebf93e2ba65112d1296635aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b3e93ebf93e2ba65112d1296635aa5">&#9670;&#160;</a></span>applyStrongMacroblockRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HlmsListener::applyStrongMacroblockRules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> &amp;&#160;</td>
          <td class="paramname"><em>macroblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called from Hlms::createShaderCacheEntry after an <a class="el" href="struct_ogre_1_1_hlms_pso.html" title="Defines a PipelineStateObject as required by Vulkan, Metal &amp; DX12.">HlmsPso</a> is initialized. </p>
<p>It allows to modify its currently assigned macroblock. This allows to override the macroblocks for all renderables within a pass. The listener can set a property or multiple properties in preparePassHash which can be accessed from this method to modify input macroblock. </p><dl class="section see"><dt>See also</dt><dd>Hlms::applyStrongMacroblockRules. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Given the same set of properties, the function must always return the same value. Otherwise caching (i.e. <a class="el" href="class_ogre_1_1_hlms_disk_cache.html" title="This class allows saving the current state of an Hlms to disk: both its compiled shaders with source ...">HlmsDiskCache</a>) won't work correctly. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">macroblock</td><td>[in/out] Current macroblock. You can modify it if needed. </td></tr>
    <tr><td class="paramname">properties</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a516750b25e741d5260ed81d98e0521b9" name="a516750b25e741d5260ed81d98e0521b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516750b25e741d5260ed81d98e0521b9">&#9670;&#160;</a></span>getNumExtraPassTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::HlmsListener::getNumExtraPassTextures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If hlmsTypeChanged is going to be binding extra textures, override this function to tell us how many textures you will use, so that we don't use those slots. </p>
<p>May be called from any thread. </p><dl class="section remark"><dt>Remarks</dt><dd>Given the same set of properties, the function must always return the same value. Otherwise caching (i.e. <a class="el" href="class_ogre_1_1_hlms_disk_cache.html" title="This class allows saving the current state of an Hlms to disk: both its compiled shaders with source ...">HlmsDiskCache</a>) won't work correctly </dd></dl>

</div>
</div>
<a id="ad6908edd7c16efc1ef1638a6a1e08bd9" name="ad6908edd7c16efc1ef1638a6a1e08bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6908edd7c16efc1ef1638a6a1e08bd9">&#9670;&#160;</a></span>getPassBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsListener::getPassBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *&#160;</td>
          <td class="paramname"><em>shadowNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dualParaboloid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Listeners should return the number of extra bytes they wish to allocate for storing additional data in the pass buffer. </p>
<p>The actual data will be provided by a <a class="el" href="class_ogre_1_1_hlms_listener.html#a857166e748d47c14a6ffbb67a6126468" title="Write additional data in the pass buffer.">preparePassBuffer()</a> override.</p>
<p>The Thread Idx is always <a class="el" href="class_ogre_1_1_hlms.html#a3b41b85c9b51fe6794d25e95bd5ea31f" title="For single-threaded operations.">Hlms::kNoTid</a> </p><dl class="section return"><dt>Returns</dt><dd>Number of bytes of additional pass buffer data to allocate. Must be a multiple of 16. </dd></dl>

</div>
</div>
<a id="a10609ad741f2c3de7ce3715738cd0bea" name="a10609ad741f2c3de7ce3715738cd0bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10609ad741f2c3de7ce3715738cd0bea">&#9670;&#160;</a></span>hlmsTypeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HlmsListener::hlmsTypeChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_command_buffer.html">CommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *&#160;</td>
          <td class="paramname"><em>datablock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the last <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> processed was of a different <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> type, thus we need to rebind certain buffers (like the pass buffer). </p>
<p>You can use this moment to bind your own buffers.</p>
<p>The Thread Idx is always <a class="el" href="class_ogre_1_1_hlms.html#a3b41b85c9b51fe6794d25e95bd5ea31f" title="For single-threaded operations.">Hlms::kNoTid</a> </p>

</div>
</div>
<a id="a857166e748d47c14a6ffbb67a6126468" name="a857166e748d47c14a6ffbb67a6126468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857166e748d47c14a6ffbb67a6126468">&#9670;&#160;</a></span>preparePassBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float * Ogre::HlmsListener::preparePassBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *&#160;</td>
          <td class="paramname"><em>shadowNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dualParaboloid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>passBufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write additional data in the pass buffer. </p>
<p>Users can write to passBufferPtr. Implementations must ensure they make the buffer big enough via <a class="el" href="class_ogre_1_1_hlms_listener.html#ad6908edd7c16efc1ef1638a6a1e08bd9" title="Listeners should return the number of extra bytes they wish to allocate for storing additional data i...">getPassBufferSize()</a>. The passBufferPtr is already aligned to 16 bytes.</p>
<p>The Thread Idx is always <a class="el" href="class_ogre_1_1_hlms.html#a3b41b85c9b51fe6794d25e95bd5ea31f" title="For single-threaded operations.">Hlms::kNoTid</a> </p><dl class="section return"><dt>Returns</dt><dd>Pointer past the end of added data, aligned to 16 bytes. The difference between the result pointer and the input passBufferPtr must equal the value that you returned from <a class="el" href="class_ogre_1_1_hlms_listener.html#ad6908edd7c16efc1ef1638a6a1e08bd9" title="Listeners should return the number of extra bytes they wish to allocate for storing additional data i...">getPassBufferSize()</a>. </dd></dl>

</div>
</div>
<a id="ab0cc9cdfb4cc2eca0e06ba13a467c7e5" name="ab0cc9cdfb4cc2eca0e06ba13a467c7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cc9cdfb4cc2eca0e06ba13a467c7e5">&#9670;&#160;</a></span>preparePassHash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HlmsListener::preparePassHash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a> *&#160;</td>
          <td class="paramname"><em>shadowNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dualParaboloid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *&#160;</td>
          <td class="paramname"><em>hlms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called right before creating the pass cache, to allow the listener to add/remove properties. </p>
<dl class="section remark"><dt>Remarks</dt><dd>For the rest of the parameters, </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms.html#ad3e82fb2e682366cc721e521ee41d64d" title="Called every frame by the Render Queue to cache the properties needed by this pass.">Hlms::preparePassHash</a></dd></dl>
<p>The Thread Idx is always <a class="el" href="class_ogre_1_1_hlms.html#a3b41b85c9b51fe6794d25e95bd5ea31f" title="For single-threaded operations.">Hlms::kNoTid</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hlms</td><td>Caller <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a>; from which you can alter the properties using Hlms::setProperty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b8ae5bc5f0c78db2e98b111bcdbed0d" name="a1b8ae5bc5f0c78db2e98b111bcdbed0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8ae5bc5f0c78db2e98b111bcdbed0d">&#9670;&#160;</a></span>propertiesMergedPreGenerationStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HlmsListener::propertiesMergedPreGenerationStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *&#160;</td>
          <td class="paramname"><em>hlms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;&#160;</td>
          <td class="paramname"><em>passCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>renderableCacheProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga8d0386169199086cbe23f19967f934af">PiecesMap</a>&#160;</td>
          <td class="paramname"><em>renderableCachePieces</em>[NumShaderTypes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;&#160;</td>
          <td class="paramname"><em>queuedRenderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="class_ogre_1_1_hlms_listener.html#aaf83dfe4a43ac3c7c444c90d759a7744" title="Called after the shader was created/compiled, and right before bindGpuProgramParameters (relevant inf...">HlmsListener::shaderCacheEntryCreated</a>, but it gets called before creating any shader. </p>
<p>The main difference is that there is no hlmsCacheEntry (because it hasn't been generated yet) and the properties are before they are transformed by the templates</p>
<p>propertiesMergedPreGenerationStep </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hlms</td><td><p class="starttd">Pointer to caller. WARNING: Note that any modified property WON'T BE CACHED. If you set a property based on external information, it will break caches.</p>
<p class="endtd">You can only set new properties that are derived from existing properties e.g. c = a + b, which means caching a and b will always result in c being the same value </p>
</td></tr>
    <tr><td class="paramname">passCache</td><td>Properties used by this pass </td></tr>
    <tr><td class="paramname">renderableCacheProperties</td><td>Properties assigned to the renderable </td></tr>
    <tr><td class="paramname">renderableCachePieces</td><td>Pieces that can be inserted, belonging to the renderable. The PiecesMap pointer cannot be null </td></tr>
    <tr><td class="paramname">properties</td><td>Combined properties of both renderableCacheProperties &amp; passCache.setProperties </td></tr>
    <tr><td class="paramname">queuedRenderable</td><td></td></tr>
    <tr><td class="paramname">tid</td><td>Thread Idx </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa82f8eabfd65173e02a8e6901047eb62" name="aa82f8eabfd65173e02a8e6901047eb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82f8eabfd65173e02a8e6901047eb62">&#9670;&#160;</a></span>setupRootLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HlmsListener::setupRootLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>rootLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called right before compiling. </p>
<p>If customizations require additional resources slots (e.g. more textures) then this function should modify the root layout accordingly</p>
<p>To allow caches to work, the rootLayout must only be generated from values in 'properties' (or via constant modifications) otherwise there is no guarantee a cached version can recreate the same state.</p>
<p>This is why the function is marked const. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootLayout</td><td>An already-filled rootLayout derived classes can modify </td></tr>
    <tr><td class="paramname">properties</td><td>The current contents of Hlms::mSetProperties </td></tr>
    <tr><td class="paramname">tid</td><td>Thread Idx </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf83dfe4a43ac3c7c444c90d759a7744" name="aaf83dfe4a43ac3c7c444c90d759a7744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf83dfe4a43ac3c7c444c90d759a7744">&#9670;&#160;</a></span>shaderCacheEntryCreated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HlmsListener::shaderCacheEntryCreated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> *&#160;</td>
          <td class="paramname"><em>hlmsCacheEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_cache.html">HlmsCache</a> &amp;&#160;</td>
          <td class="paramname"><em>passCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___resources.html#ga1d333e3b1280899cce855c563f200938">HlmsPropertyVec</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_queued_renderable.html">QueuedRenderable</a> &amp;&#160;</td>
          <td class="paramname"><em>queuedRenderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the shader was created/compiled, and right before bindGpuProgramParameters (relevant information for OpenGL programs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderProfile</td><td>See Hlms::mShaderProfile </td></tr>
    <tr><td class="paramname">hlmsCacheEntry</td><td>The created shader. </td></tr>
    <tr><td class="paramname">passCache</td><td>See Hlms::createShaderCacheEntry </td></tr>
    <tr><td class="paramname">properties</td><td>The current contents of Hlms::mSetProperties </td></tr>
    <tr><td class="paramname">queuedRenderable</td><td>See Hlms::createShaderCacheEntry </td></tr>
    <tr><td class="paramname">tid</td><td>Thread Idx </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_hlms_listener_8h.html">OgreHlmsListener.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_hlms_listener.html">HlmsListener</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
