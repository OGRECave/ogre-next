<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE-Next
   &#160;<span id="projectnumber">4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_ogre_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::Node Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___core.html">Core</a> &#124; <a class="el" href="group___component.html">Component</a> &raquo; <a class="el" href="group___scene.html">Scene</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing a general-purpose node an articulated scene graph.  
 <a href="class_ogre_1_1_node.html#details">More...</a></p>

<p><code>#include &lt;OgreNode.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::Node:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_node__inherit__graph.svg" width="286" height="262"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_node_1_1_listener.html" title="Listener which gets called back on Node events.">Listener</a> which gets called back on <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> events.  <a href="class_ogre_1_1_node_1_1_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a84efd2062a90048361e94e4db7bc79bc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_node.html#aa9b8a2daaf71dc3d4c816c14a7465875">NodeVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a84efd2062a90048361e94e4db7bc79bc">ConstNodeVecIterator</a></td></tr>
<tr class="separator:a84efd2062a90048361e94e4db7bc79bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b8a2daaf71dc3d4c816c14a7465875"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="class_ogre_1_1_node.html">Node</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa9b8a2daaf71dc3d4c816c14a7465875">NodeVec</a></td></tr>
<tr class="separator:aa9b8a2daaf71dc3d4c816c14a7465875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d127688e5dbfb0eeca46f34e2e1017"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_node.html#aa9b8a2daaf71dc3d4c816c14a7465875">NodeVec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a21d127688e5dbfb0eeca46f34e2e1017">NodeVecIterator</a></td></tr>
<tr class="separator:a21d127688e5dbfb0eeca46f34e2e1017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42e2063379286eb673eaffff6ca5e99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> { <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>
, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>
, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04">TS_WORLD</a>
 }</td></tr>
<tr class="memdesc:ac42e2063379286eb673eaffff6ca5e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration denoting the spaces which a transform can be relative to.  <a href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">More...</a><br /></td></tr>
<tr class="separator:ac42e2063379286eb673eaffff6ca5e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a07ce15da26399e2dcc9d0b0a8ab060e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a07ce15da26399e2dcc9d0b0a8ab060e7">Node</a> (const <a class="el" href="struct_ogre_1_1_transform.html">Transform</a> &amp;transformPtrs)</td></tr>
<tr class="memdesc:a07ce15da26399e2dcc9d0b0a8ab060e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't use this constructor unless you know what you're doing.  <a href="class_ogre_1_1_node.html#a07ce15da26399e2dcc9d0b0a8ab060e7">More...</a><br /></td></tr>
<tr class="separator:a07ce15da26399e2dcc9d0b0a8ab060e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d11f13ad85e092b2dab64c9555cf2cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1d11f13ad85e092b2dab64c9555cf2cb">Node</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id, <a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *nodeMemoryManager, <a class="el" href="class_ogre_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="memdesc:a1d11f13ad85e092b2dab64c9555cf2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, should only be called by parent, not directly.  <a href="class_ogre_1_1_node.html#a1d11f13ad85e092b2dab64c9555cf2cb">More...</a><br /></td></tr>
<tr class="separator:a1d11f13ad85e092b2dab64c9555cf2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f92f708c954f8bf6581eb2377656443"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4f92f708c954f8bf6581eb2377656443">~Node</a> ()</td></tr>
<tr class="separator:a4f92f708c954f8bf6581eb2377656443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5128a3043c814f21ae09c0e4fa6f121"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac5128a3043c814f21ae09c0e4fa6f121">_callMemoryChangeListeners</a> ()=0</td></tr>
<tr class="memdesc:ac5128a3043c814f21ae09c0e4fa6f121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use, notifies all attached objects that our memory pointers (i.e.  <a href="class_ogre_1_1_node.html#ac5128a3043c814f21ae09c0e4fa6f121">More...</a><br /></td></tr>
<tr class="separator:ac5128a3043c814f21ae09c0e4fa6f121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90c32702bc7d9ecf3045d084f9f4443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad90c32702bc7d9ecf3045d084f9f4443">_getDerivedOrientation</a> () const</td></tr>
<tr class="memdesc:ad90c32702bc7d9ecf3045d084f9f4443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the orientation of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#ad90c32702bc7d9ecf3045d084f9f4443">More...</a><br /></td></tr>
<tr class="separator:ad90c32702bc7d9ecf3045d084f9f4443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52966eed31d26431889bab047bc8cef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a52966eed31d26431889bab047bc8cef6">_getDerivedOrientationUpdated</a> ()</td></tr>
<tr class="memdesc:a52966eed31d26431889bab047bc8cef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the orientation of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#a52966eed31d26431889bab047bc8cef6">More...</a><br /></td></tr>
<tr class="separator:a52966eed31d26431889bab047bc8cef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8b93a13e3520fa0f1d67d796d2b18b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ada8b93a13e3520fa0f1d67d796d2b18b">_getDerivedPosition</a> () const</td></tr>
<tr class="memdesc:ada8b93a13e3520fa0f1d67d796d2b18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#ada8b93a13e3520fa0f1d67d796d2b18b">More...</a><br /></td></tr>
<tr class="separator:ada8b93a13e3520fa0f1d67d796d2b18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fb5e2347952b43bfb7b91139364e2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae7fb5e2347952b43bfb7b91139364e2b">_getDerivedPositionUpdated</a> ()</td></tr>
<tr class="memdesc:ae7fb5e2347952b43bfb7b91139364e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#ae7fb5e2347952b43bfb7b91139364e2b">More...</a><br /></td></tr>
<tr class="separator:ae7fb5e2347952b43bfb7b91139364e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67181c814f63f7f3fea54a2affd39e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad67181c814f63f7f3fea54a2affd39e2">_getDerivedScale</a> () const</td></tr>
<tr class="memdesc:ad67181c814f63f7f3fea54a2affd39e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scaling factor of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#ad67181c814f63f7f3fea54a2affd39e2">More...</a><br /></td></tr>
<tr class="separator:ad67181c814f63f7f3fea54a2affd39e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ff3f5276ed7358dce2e5681f3114c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ab74ff3f5276ed7358dce2e5681f3114c">_getDerivedScaleUpdated</a> ()</td></tr>
<tr class="memdesc:ab74ff3f5276ed7358dce2e5681f3114c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scalling factor of the node as derived from all parents.  <a href="class_ogre_1_1_node.html#ab74ff3f5276ed7358dce2e5681f3114c">More...</a><br /></td></tr>
<tr class="separator:ab74ff3f5276ed7358dce2e5681f3114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80127fa2d538c03441c563fbb82fdc69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a80127fa2d538c03441c563fbb82fdc69">_getFullTransform</a> () const</td></tr>
<tr class="memdesc:a80127fa2d538c03441c563fbb82fdc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the full transformation matrix for this node.  <a href="class_ogre_1_1_node.html#a80127fa2d538c03441c563fbb82fdc69">More...</a><br /></td></tr>
<tr class="separator:a80127fa2d538c03441c563fbb82fdc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861792d6e436ae23d3fcbb40b2c2c20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a861792d6e436ae23d3fcbb40b2c2c20c">_getFullTransformUpdated</a> ()</td></tr>
<tr class="memdesc:a861792d6e436ae23d3fcbb40b2c2c20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_node.html#ab74ff3f5276ed7358dce2e5681f3114c" title="Gets the scalling factor of the node as derived from all parents.">_getDerivedScaleUpdated()</a> remarks.  <a href="class_ogre_1_1_node.html#a861792d6e436ae23d3fcbb40b2c2c20c">More...</a><br /></td></tr>
<tr class="separator:a861792d6e436ae23d3fcbb40b2c2c20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c07f6e7386cd419a80855fa592c47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_transform.html">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8f3c07f6e7386cd419a80855fa592c47">_getTransform</a> ()</td></tr>
<tr class="memdesc:a8f3c07f6e7386cd419a80855fa592c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direct access to the <a class="el" href="struct_ogre_1_1_transform.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">Transform</a> state.  <a href="class_ogre_1_1_node.html#a8f3c07f6e7386cd419a80855fa592c47">More...</a><br /></td></tr>
<tr class="separator:a8f3c07f6e7386cd419a80855fa592c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd681ba32f8627cdd4c37ca766d60ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#afdd681ba32f8627cdd4c37ca766d60ea">_notifyStaticDirty</a> () const</td></tr>
<tr class="memdesc:afdd681ba32f8627cdd4c37ca766d60ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> when it is telling we're a static node being dirty Don't call this directly.  <a href="class_ogre_1_1_node.html#afdd681ba32f8627cdd4c37ca766d60ea">More...</a><br /></td></tr>
<tr class="separator:afdd681ba32f8627cdd4c37ca766d60ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383a4f0494151b534ac76ec0aecbb6a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a383a4f0494151b534ac76ec0aecbb6a1">_setDerivedOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="memdesc:a383a4f0494151b534ac76ec0aecbb6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the final world orientation of the node directly.  <a href="class_ogre_1_1_node.html#a383a4f0494151b534ac76ec0aecbb6a1">More...</a><br /></td></tr>
<tr class="separator:a383a4f0494151b534ac76ec0aecbb6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61f161b03f1a80bc5974b2804171062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa61f161b03f1a80bc5974b2804171062">_setDerivedPosition</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;pos)</td></tr>
<tr class="memdesc:aa61f161b03f1a80bc5974b2804171062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the final world position of the node directly.  <a href="class_ogre_1_1_node.html#aa61f161b03f1a80bc5974b2804171062">More...</a><br /></td></tr>
<tr class="separator:aa61f161b03f1a80bc5974b2804171062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b796c4810932765f140736f04f24ca4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a7b796c4810932765f140736f04f24ca4">_setNullNodeMemoryManager</a> ()</td></tr>
<tr class="memdesc:a7b796c4810932765f140736f04f24ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the mNodeMemoryManager to a null ptr.  <a href="class_ogre_1_1_node.html#a7b796c4810932765f140736f04f24ca4">More...</a><br /></td></tr>
<tr class="separator:a7b796c4810932765f140736f04f24ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625500757d216e51c48fbf09a52a36f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a625500757d216e51c48fbf09a52a36f7">_updateChildren</a> ()</td></tr>
<tr class="memdesc:a625500757d216e51c48fbf09a52a36f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to update the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> and all children.  <a href="class_ogre_1_1_node.html#a625500757d216e51c48fbf09a52a36f7">More...</a><br /></td></tr>
<tr class="separator:a625500757d216e51c48fbf09a52a36f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01698919040092766a3a4bfab8e7ceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af01698919040092766a3a4bfab8e7ceb">addChild</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child)</td></tr>
<tr class="memdesc:af01698919040092766a3a4bfab8e7ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a (precreated) child scene node to this node.  <a href="class_ogre_1_1_node.html#af01698919040092766a3a4bfab8e7ceb">More...</a><br /></td></tr>
<tr class="separator:af01698919040092766a3a4bfab8e7ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4764d25d695ab8bc5ad9bf378ae70786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4764d25d695ab8bc5ad9bf378ae70786">convertLocalToWorldDirection</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localDir, bool useScale)</td></tr>
<tr class="memdesc:a4764d25d695ab8bc5ad9bf378ae70786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world direction of a point in the node local space useful for simple transforms that don't require a child node.  <a href="class_ogre_1_1_node.html#a4764d25d695ab8bc5ad9bf378ae70786">More...</a><br /></td></tr>
<tr class="separator:a4764d25d695ab8bc5ad9bf378ae70786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac892e2e5a007c0f91112823d73ce5b38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac892e2e5a007c0f91112823d73ce5b38">convertLocalToWorldDirectionUpdated</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localDir, bool useScale)</td></tr>
<tr class="separator:ac892e2e5a007c0f91112823d73ce5b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4190c35585d53852c3ecb1d82813c287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4190c35585d53852c3ecb1d82813c287">convertLocalToWorldOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;localOrientation)</td></tr>
<tr class="memdesc:a4190c35585d53852c3ecb1d82813c287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node.  <a href="class_ogre_1_1_node.html#a4190c35585d53852c3ecb1d82813c287">More...</a><br /></td></tr>
<tr class="separator:a4190c35585d53852c3ecb1d82813c287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dced923268b7b145eb397d2bbf55520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a6dced923268b7b145eb397d2bbf55520">convertLocalToWorldOrientationUpdated</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;localOrientation)</td></tr>
<tr class="separator:a6dced923268b7b145eb397d2bbf55520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732f69dff26b677c6ab11da2a9474059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a732f69dff26b677c6ab11da2a9474059">convertLocalToWorldPosition</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localPos)</td></tr>
<tr class="memdesc:a732f69dff26b677c6ab11da2a9474059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world position of a point in the node local space useful for simple transforms that don't require a child node.  <a href="class_ogre_1_1_node.html#a732f69dff26b677c6ab11da2a9474059">More...</a><br /></td></tr>
<tr class="separator:a732f69dff26b677c6ab11da2a9474059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c0b966080de019c3b68c7f8db9eb4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa9c0b966080de019c3b68c7f8db9eb4d">convertLocalToWorldPositionUpdated</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;localPos)</td></tr>
<tr class="separator:aa9c0b966080de019c3b68c7f8db9eb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2c43ecc98d69ad63533ff4258a9349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a0f2c43ecc98d69ad63533ff4258a9349">convertWorldToLocalDirection</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;worldDir, bool useScale)</td></tr>
<tr class="memdesc:a0f2c43ecc98d69ad63533ff4258a9349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local direction, relative to this node, of the given world-space direction.  <a href="class_ogre_1_1_node.html#a0f2c43ecc98d69ad63533ff4258a9349">More...</a><br /></td></tr>
<tr class="separator:a0f2c43ecc98d69ad63533ff4258a9349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73c4989864f0066125b37bb7a93731f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af73c4989864f0066125b37bb7a93731f">convertWorldToLocalDirectionUpdated</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;worldDir, bool useScale)</td></tr>
<tr class="separator:af73c4989864f0066125b37bb7a93731f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a347f6c598d81c0d12d4c59e92acae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a51a347f6c598d81c0d12d4c59e92acae">convertWorldToLocalOrientation</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;worldOrientation)</td></tr>
<tr class="memdesc:a51a347f6c598d81c0d12d4c59e92acae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local orientation, relative to this node, of the given world-space orientation.  <a href="class_ogre_1_1_node.html#a51a347f6c598d81c0d12d4c59e92acae">More...</a><br /></td></tr>
<tr class="separator:a51a347f6c598d81c0d12d4c59e92acae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a39cee77eb770833f90a2085b16afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a73a39cee77eb770833f90a2085b16afd">convertWorldToLocalOrientationUpdated</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;worldOrientation)</td></tr>
<tr class="separator:a73a39cee77eb770833f90a2085b16afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70989f6375d53ee7e91e06ae8341023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac70989f6375d53ee7e91e06ae8341023">convertWorldToLocalPosition</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;worldPos)</td></tr>
<tr class="memdesc:ac70989f6375d53ee7e91e06ae8341023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local position, relative to this node, of the given world-space position.  <a href="class_ogre_1_1_node.html#ac70989f6375d53ee7e91e06ae8341023">More...</a><br /></td></tr>
<tr class="separator:ac70989f6375d53ee7e91e06ae8341023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c19ff3089bb7353f28cdd7e4181d065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1c19ff3089bb7353f28cdd7e4181d065">convertWorldToLocalPositionUpdated</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;worldPos)</td></tr>
<tr class="separator:a1c19ff3089bb7353f28cdd7e4181d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6976feeb8705b7899cfc4219c3408a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac6976feeb8705b7899cfc4219c3408a3">createChild</a> (<a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType=<a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a>, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#ac97975ed6d907bc0674dc9f26b154a8f">translate</a>=<a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a4ae0264db9d227d20390ebfd01cee64e">rotate</a>=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr class="memdesc:ac6976feeb8705b7899cfc4219c3408a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unnamed new <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node.  <a href="class_ogre_1_1_node.html#ac6976feeb8705b7899cfc4219c3408a3">More...</a><br /></td></tr>
<tr class="separator:ac6976feeb8705b7899cfc4219c3408a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a7872671761814b72ace4e89b869dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac7a7872671761814b72ace4e89b869dc">getChild</a> (size_t index)</td></tr>
<tr class="memdesc:ac7a7872671761814b72ace4e89b869dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to a child node.  <a href="class_ogre_1_1_node.html#ac7a7872671761814b72ace4e89b869dc">More...</a><br /></td></tr>
<tr class="separator:ac7a7872671761814b72ace4e89b869dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95614dd446dfbfe6d88db22f654683ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a95614dd446dfbfe6d88db22f654683ea">getChild</a> (size_t index) const</td></tr>
<tr class="separator:a95614dd446dfbfe6d88db22f654683ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49482dee5a9d1eebd1851c5f3464fbf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html#a21d127688e5dbfb0eeca46f34e2e1017">NodeVecIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a49482dee5a9d1eebd1851c5f3464fbf7">getChildIterator</a> ()</td></tr>
<tr class="memdesc:a49482dee5a9d1eebd1851c5f3464fbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for efficiently looping through all children of this node.  <a href="class_ogre_1_1_node.html#a49482dee5a9d1eebd1851c5f3464fbf7">More...</a><br /></td></tr>
<tr class="separator:a49482dee5a9d1eebd1851c5f3464fbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dcbdb546c8efcf780ed27f01e9d714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html#a84efd2062a90048361e94e4db7bc79bc">ConstNodeVecIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa6dcbdb546c8efcf780ed27f01e9d714">getChildIterator</a> () const</td></tr>
<tr class="memdesc:aa6dcbdb546c8efcf780ed27f01e9d714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an iterator for efficiently looping through all children of this node.  <a href="class_ogre_1_1_node.html#aa6dcbdb546c8efcf780ed27f01e9d714">More...</a><br /></td></tr>
<tr class="separator:aa6dcbdb546c8efcf780ed27f01e9d714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae910eab0d400594e70133831cb1621fe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae910eab0d400594e70133831cb1621fe">getDefaultNodeMemoryManager</a> (<a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a> sceneType)=0</td></tr>
<tr class="separator:ae910eab0d400594e70133831cb1621fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478f180848cc1f39caa8f17f86e8a5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a478f180848cc1f39caa8f17f86e8a5dd">getDepthLevel</a> () const</td></tr>
<tr class="memdesc:a478f180848cc1f39caa8f17f86e8a5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how deep in the hierarchy we are (eg. 0 -&gt; root node, 1 -&gt; child of root)  <a href="class_ogre_1_1_node.html#a478f180848cc1f39caa8f17f86e8a5dd">More...</a><br /></td></tr>
<tr class="separator:a478f180848cc1f39caa8f17f86e8a5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eeca6c33a61c00b3fb2abd2c1289ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a67eeca6c33a61c00b3fb2abd2c1289ba">getIndestructibleByClearScene</a> () const</td></tr>
<tr class="separator:a67eeca6c33a61c00b3fb2abd2c1289ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98ec089fda531aa72b7200d4bc98f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae98ec089fda531aa72b7200d4bc98f03">getInheritOrientation</a> () const</td></tr>
<tr class="memdesc:ae98ec089fda531aa72b7200d4bc98f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is affected by orientation applied to the parent node.  <a href="class_ogre_1_1_node.html#ae98ec089fda531aa72b7200d4bc98f03">More...</a><br /></td></tr>
<tr class="separator:ae98ec089fda531aa72b7200d4bc98f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add630c76ba07eb3435947b4545276534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#add630c76ba07eb3435947b4545276534">getInheritScale</a> () const</td></tr>
<tr class="memdesc:add630c76ba07eb3435947b4545276534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is affected by scaling factors applied to the parent node.  <a href="class_ogre_1_1_node.html#add630c76ba07eb3435947b4545276534">More...</a><br /></td></tr>
<tr class="separator:add630c76ba07eb3435947b4545276534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ccad036a830972b4cfb2cf0820c58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ad6ccad036a830972b4cfb2cf0820c58f">getListener</a> () const</td></tr>
<tr class="memdesc:ad6ccad036a830972b4cfb2cf0820c58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="class_ogre_1_1_node.html#ad6ccad036a830972b4cfb2cf0820c58f">More...</a><br /></td></tr>
<tr class="separator:ad6ccad036a830972b4cfb2cf0820c58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd2eef2b05e313c25f23a488f70a934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a2dd2eef2b05e313c25f23a488f70a934">getLocalAxes</a> () const</td></tr>
<tr class="memdesc:a2dd2eef2b05e313c25f23a488f70a934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent.  <a href="class_ogre_1_1_node.html#a2dd2eef2b05e313c25f23a488f70a934">More...</a><br /></td></tr>
<tr class="separator:a2dd2eef2b05e313c25f23a488f70a934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a46c60d76c45674902645d8991eebe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a48a46c60d76c45674902645d8991eebe">getName</a> () const</td></tr>
<tr class="memdesc:a48a46c60d76c45674902645d8991eebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the node.  <a href="class_ogre_1_1_node.html#a48a46c60d76c45674902645d8991eebe">More...</a><br /></td></tr>
<tr class="separator:a48a46c60d76c45674902645d8991eebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ff235b93b63af33f3b7f7164e3c643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a70ff235b93b63af33f3b7f7164e3c643">getOrientation</a> () const</td></tr>
<tr class="memdesc:a70ff235b93b63af33f3b7f7164e3c643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a quaternion representing the nodes orientation.  <a href="class_ogre_1_1_node.html#a70ff235b93b63af33f3b7f7164e3c643">More...</a><br /></td></tr>
<tr class="separator:a70ff235b93b63af33f3b7f7164e3c643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7832bef084fac469f35b927fae335395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a7832bef084fac469f35b927fae335395">getParent</a> () const</td></tr>
<tr class="memdesc:a7832bef084fac469f35b927fae335395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets this node's parent (NULL if this is the root).  <a href="class_ogre_1_1_node.html#a7832bef084fac469f35b927fae335395">More...</a><br /></td></tr>
<tr class="separator:a7832bef084fac469f35b927fae335395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bb47ce140c3a1d5eba04df7b342ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a32bb47ce140c3a1d5eba04df7b342ca8">getPosition</a> () const</td></tr>
<tr class="memdesc:a32bb47ce140c3a1d5eba04df7b342ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the node relative to it's parent.  <a href="class_ogre_1_1_node.html#a32bb47ce140c3a1d5eba04df7b342ca8">More...</a><br /></td></tr>
<tr class="separator:a32bb47ce140c3a1d5eba04df7b342ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662fa5e94c54f76ff078c52492062865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a662fa5e94c54f76ff078c52492062865">getScale</a> () const</td></tr>
<tr class="memdesc:a662fa5e94c54f76ff078c52492062865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scaling factor of this node.  <a href="class_ogre_1_1_node.html#a662fa5e94c54f76ff078c52492062865">More...</a><br /></td></tr>
<tr class="separator:a662fa5e94c54f76ff078c52492062865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39354baf38396f9c86de5e1822364c15"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a39354baf38396f9c86de5e1822364c15">getSquaredViewDepth</a> (const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *cam) const</td></tr>
<tr class="memdesc:a39354baf38396f9c86de5e1822364c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, get the squared view depth.  <a href="class_ogre_1_1_node.html#a39354baf38396f9c86de5e1822364c15">More...</a><br /></td></tr>
<tr class="separator:a39354baf38396f9c86de5e1822364c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52d2653967a5cc778ea5ceae0537043"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_ogre_platform_8h.html#af2652ba9f4945789c869d74d7e67cbcb">OGRE_DEPRECATED</a> const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ab52d2653967a5cc778ea5ceae0537043">getUserAny</a> () const</td></tr>
<tr class="separator:ab52d2653967a5cc778ea5ceae0537043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fcf16e43b07e046816125cbb8dc8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3">getUserObjectBindings</a> ()</td></tr>
<tr class="memdesc:af3fcf16e43b07e046816125cbb8dc8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3">More...</a><br /></td></tr>
<tr class="separator:af3fcf16e43b07e046816125cbb8dc8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa154e07b616313f4c345ec6c0da635cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#aa154e07b616313f4c345ec6c0da635cd">getUserObjectBindings</a> () const</td></tr>
<tr class="memdesc:aa154e07b616313f4c345ec6c0da635cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="class_ogre_1_1_node.html#aa154e07b616313f4c345ec6c0da635cd">More...</a><br /></td></tr>
<tr class="separator:aa154e07b616313f4c345ec6c0da635cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2045217c742576f9a82e4070da277e89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a2045217c742576f9a82e4070da277e89">isStatic</a> () const</td></tr>
<tr class="memdesc:a2045217c742576f9a82e4070da277e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this node is static.  <a href="class_ogre_1_1_node.html#a2045217c742576f9a82e4070da277e89">More...</a><br /></td></tr>
<tr class="separator:a2045217c742576f9a82e4070da277e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5fc23a04991fc7a524763b0bdf829c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a6f5fc23a04991fc7a524763b0bdf829c">migrateTo</a> (<a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *nodeMemoryManager)</td></tr>
<tr class="memdesc:a6f5fc23a04991fc7a524763b0bdf829c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrates the node and all of its children to the new memory manager, at the same depth level.  <a href="class_ogre_1_1_node.html#a6f5fc23a04991fc7a524763b0bdf829c">More...</a><br /></td></tr>
<tr class="separator:a6f5fc23a04991fc7a524763b0bdf829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789e0dfefecefbd30b449fc47a4372de"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a789e0dfefecefbd30b449fc47a4372de">numChildren</a> () const</td></tr>
<tr class="memdesc:a789e0dfefecefbd30b449fc47a4372de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of child nodes under this one.  <a href="class_ogre_1_1_node.html#a789e0dfefecefbd30b449fc47a4372de">More...</a><br /></td></tr>
<tr class="separator:a789e0dfefecefbd30b449fc47a4372de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4a8283f41882f4b6c70acbe9f27c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ade4a8283f41882f4b6c70acbe9f27c61">pitch</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:ade4a8283f41882f4b6c70acbe9f27c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the X-axis.  <a href="class_ogre_1_1_node.html#ade4a8283f41882f4b6c70acbe9f27c61">More...</a><br /></td></tr>
<tr class="separator:ade4a8283f41882f4b6c70acbe9f27c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ac98a5c316736e60d3a92f798a6e82"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af4ac98a5c316736e60d3a92f798a6e82">removeAllChildren</a> ()</td></tr>
<tr class="memdesc:af4ac98a5c316736e60d3a92f798a6e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all child Nodes attached to this node.  <a href="class_ogre_1_1_node.html#af4ac98a5c316736e60d3a92f798a6e82">More...</a><br /></td></tr>
<tr class="separator:af4ac98a5c316736e60d3a92f798a6e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527d3766bb672f8bccc8535666511cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a8527d3766bb672f8bccc8535666511cb">removeChild</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *child)</td></tr>
<tr class="memdesc:a8527d3766bb672f8bccc8535666511cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the specified child from this node.  <a href="class_ogre_1_1_node.html#a8527d3766bb672f8bccc8535666511cb">More...</a><br /></td></tr>
<tr class="separator:a8527d3766bb672f8bccc8535666511cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba27b1ade1c9e80d77f8acd2413d3b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a0ba27b1ade1c9e80d77f8acd2413d3b4">resetOrientation</a> ()</td></tr>
<tr class="memdesc:a0ba27b1ade1c9e80d77f8acd2413d3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the nodes orientation (local axes as world axes, no rotation).  <a href="class_ogre_1_1_node.html#a0ba27b1ade1c9e80d77f8acd2413d3b4">More...</a><br /></td></tr>
<tr class="separator:a0ba27b1ade1c9e80d77f8acd2413d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17b2a4b91e5213ca68c106a3b6f79a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae17b2a4b91e5213ca68c106a3b6f79a4">roll</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:ae17b2a4b91e5213ca68c106a3b6f79a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the Z-axis.  <a href="class_ogre_1_1_node.html#ae17b2a4b91e5213ca68c106a3b6f79a4">More...</a><br /></td></tr>
<tr class="separator:ae17b2a4b91e5213ca68c106a3b6f79a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6755a5f452cd93b08d2a3261cf0a3ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a6755a5f452cd93b08d2a3261cf0a3ae3">rotate</a> (const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;q, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:a6755a5f452cd93b08d2a3261cf0a3ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around an arbitrary axis using a Quarternion.  <a href="class_ogre_1_1_node.html#a6755a5f452cd93b08d2a3261cf0a3ae3">More...</a><br /></td></tr>
<tr class="separator:a6755a5f452cd93b08d2a3261cf0a3ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae0264db9d227d20390ebfd01cee64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4ae0264db9d227d20390ebfd01cee64e">rotate</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;axis, const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:a4ae0264db9d227d20390ebfd01cee64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around an arbitrary axis.  <a href="class_ogre_1_1_node.html#a4ae0264db9d227d20390ebfd01cee64e">More...</a><br /></td></tr>
<tr class="separator:a4ae0264db9d227d20390ebfd01cee64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590240d3ac5eb4ccdfc2ac98bc360390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a590240d3ac5eb4ccdfc2ac98bc360390">scale</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;scale)</td></tr>
<tr class="memdesc:a590240d3ac5eb4ccdfc2ac98bc360390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the node, combining it's current scale with the passed in scaling factor.  <a href="class_ogre_1_1_node.html#a590240d3ac5eb4ccdfc2ac98bc360390">More...</a><br /></td></tr>
<tr class="separator:a590240d3ac5eb4ccdfc2ac98bc360390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe1f0d7aace82d233c326ad31dd097c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#abfe1f0d7aace82d233c326ad31dd097c">scale</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="memdesc:abfe1f0d7aace82d233c326ad31dd097c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the node, combining it's current scale with the passed in scaling factor.  <a href="class_ogre_1_1_node.html#abfe1f0d7aace82d233c326ad31dd097c">More...</a><br /></td></tr>
<tr class="separator:abfe1f0d7aace82d233c326ad31dd097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5c13c4251135f4d03ef75dbb03afe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#afc5c13c4251135f4d03ef75dbb03afe5">setIndestructibleByClearScene</a> (bool indestructible)</td></tr>
<tr class="memdesc:afc5c13c4251135f4d03ef75dbb03afe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling <a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc.">SceneManager::clearScene</a> won't destroy this node nor detach its objects (but may still destroy parent and children nodes if they're not indestructible) when this is true.  <a href="class_ogre_1_1_node.html#afc5c13c4251135f4d03ef75dbb03afe5">More...</a><br /></td></tr>
<tr class="separator:afc5c13c4251135f4d03ef75dbb03afe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c305942b550d110b85c5da64a0a5f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a60c305942b550d110b85c5da64a0a5f6">setInheritOrientation</a> (bool inherit)</td></tr>
<tr class="memdesc:a60c305942b550d110b85c5da64a0a5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the node whether it should inherit orientation from it's parent node.  <a href="class_ogre_1_1_node.html#a60c305942b550d110b85c5da64a0a5f6">More...</a><br /></td></tr>
<tr class="separator:a60c305942b550d110b85c5da64a0a5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a994b31f757ba9d3059a133712ffe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af0a994b31f757ba9d3059a133712ffe7">setInheritScale</a> (bool inherit)</td></tr>
<tr class="memdesc:af0a994b31f757ba9d3059a133712ffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the node whether it should inherit scaling factors from it's parent node.  <a href="class_ogre_1_1_node.html#af0a994b31f757ba9d3059a133712ffe7">More...</a><br /></td></tr>
<tr class="separator:af0a994b31f757ba9d3059a133712ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac958f0d4fad0970aa65bdd0f86de6781"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac958f0d4fad0970aa65bdd0f86de6781">setListener</a> (<a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *listener)</td></tr>
<tr class="memdesc:ac958f0d4fad0970aa65bdd0f86de6781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="class_ogre_1_1_node.html#ac958f0d4fad0970aa65bdd0f86de6781">More...</a><br /></td></tr>
<tr class="separator:ac958f0d4fad0970aa65bdd0f86de6781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bfe1d06442abf69042794c75d783fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ae4bfe1d06442abf69042794c75d783fe">setName</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:ae4bfe1d06442abf69042794c75d783fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a custom name for this node.  <a href="class_ogre_1_1_node.html#ae4bfe1d06442abf69042794c75d783fe">More...</a><br /></td></tr>
<tr class="separator:ae4bfe1d06442abf69042794c75d783fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5432efc903b990958e5befc260591c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ada5432efc903b990958e5befc260591c">setOrientation</a> (<a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> q)</td></tr>
<tr class="memdesc:ada5432efc903b990958e5befc260591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the orientation of this node via a quaternion.  <a href="class_ogre_1_1_node.html#ada5432efc903b990958e5befc260591c">More...</a><br /></td></tr>
<tr class="separator:ada5432efc903b990958e5befc260591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf639f3cc469fec01702cd647c4ba3a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#acf639f3cc469fec01702cd647c4ba3a6">setOrientation</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> w, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="memdesc:acf639f3cc469fec01702cd647c4ba3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the orientation of this node via quaternion parameters.  <a href="class_ogre_1_1_node.html#acf639f3cc469fec01702cd647c4ba3a6">More...</a><br /></td></tr>
<tr class="separator:acf639f3cc469fec01702cd647c4ba3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea731e0b03a84dec688dd05739ca108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a9ea731e0b03a84dec688dd05739ca108">setPosition</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;pos)</td></tr>
<tr class="memdesc:a9ea731e0b03a84dec688dd05739ca108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the node relative to it's parent.  <a href="class_ogre_1_1_node.html#a9ea731e0b03a84dec688dd05739ca108">More...</a><br /></td></tr>
<tr class="separator:a9ea731e0b03a84dec688dd05739ca108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b19d272c8b485831fb8987fa3b936b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4b19d272c8b485831fb8987fa3b936b1">setPosition</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="memdesc:a4b19d272c8b485831fb8987fa3b936b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the node relative to it's parent.  <a href="class_ogre_1_1_node.html#a4b19d272c8b485831fb8987fa3b936b1">More...</a><br /></td></tr>
<tr class="separator:a4b19d272c8b485831fb8987fa3b936b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62a3dc794cf46ef1c023353e1eccbfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af62a3dc794cf46ef1c023353e1eccbfc">setScale</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;<a class="el" href="class_ogre_1_1_node.html#a590240d3ac5eb4ccdfc2ac98bc360390">scale</a>)</td></tr>
<tr class="memdesc:af62a3dc794cf46ef1c023353e1eccbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scaling factor applied to this node.  <a href="class_ogre_1_1_node.html#af62a3dc794cf46ef1c023353e1eccbfc">More...</a><br /></td></tr>
<tr class="separator:af62a3dc794cf46ef1c023353e1eccbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dc062290e30d1cdb51d629cb952cc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a16dc062290e30d1cdb51d629cb952cc7">setScale</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="memdesc:a16dc062290e30d1cdb51d629cb952cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scaling factor applied to this node.  <a href="class_ogre_1_1_node.html#a16dc062290e30d1cdb51d629cb952cc7">More...</a><br /></td></tr>
<tr class="separator:a16dc062290e30d1cdb51d629cb952cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f18bc6093c94defdaf64b504df81259"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a1f18bc6093c94defdaf64b504df81259">setStatic</a> (bool bStatic)</td></tr>
<tr class="memdesc:a1f18bc6093c94defdaf64b504df81259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> into static or dynamic.  <a href="class_ogre_1_1_node.html#a1f18bc6093c94defdaf64b504df81259">More...</a><br /></td></tr>
<tr class="separator:a1f18bc6093c94defdaf64b504df81259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f495289a449621359d2b23eaa31786c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_ogre_platform_8h.html#af2652ba9f4945789c869d74d7e67cbcb">OGRE_DEPRECATED</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a2f495289a449621359d2b23eaa31786c">setUserAny</a> (const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;anything)</td></tr>
<tr class="separator:a2f495289a449621359d2b23eaa31786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dce11eb77f674b03594a9d70217660d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a0dce11eb77f674b03594a9d70217660d">translate</a> (const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;axes, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;move, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:a0dce11eb77f674b03594a9d70217660d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the node along arbitrary axes.  <a href="class_ogre_1_1_node.html#a0dce11eb77f674b03594a9d70217660d">More...</a><br /></td></tr>
<tr class="separator:a0dce11eb77f674b03594a9d70217660d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4569105087414a50c40b19800eb9faae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a4569105087414a50c40b19800eb9faae">translate</a> (const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;axes, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:a4569105087414a50c40b19800eb9faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the node along arbitrary axes.  <a href="class_ogre_1_1_node.html#a4569105087414a50c40b19800eb9faae">More...</a><br /></td></tr>
<tr class="separator:a4569105087414a50c40b19800eb9faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97975ed6d907bc0674dc9f26b154a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ac97975ed6d907bc0674dc9f26b154a8f">translate</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;d, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:ac97975ed6d907bc0674dc9f26b154a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the node along the Cartesian axes.  <a href="class_ogre_1_1_node.html#ac97975ed6d907bc0674dc9f26b154a8f">More...</a><br /></td></tr>
<tr class="separator:ac97975ed6d907bc0674dc9f26b154a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f546194a1dcf79703ef2ffd6cead4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a6e4f546194a1dcf79703ef2ffd6cead4">translate</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>)</td></tr>
<tr class="memdesc:a6e4f546194a1dcf79703ef2ffd6cead4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the node along the Cartesian axes.  <a href="class_ogre_1_1_node.html#a6e4f546194a1dcf79703ef2ffd6cead4">More...</a><br /></td></tr>
<tr class="separator:a6e4f546194a1dcf79703ef2ffd6cead4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cb21c7d7270547ae33b5eab8c8b02d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#ab4cb21c7d7270547ae33b5eab8c8b02d">yaw</a> (const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;angle, <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=<a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>)</td></tr>
<tr class="memdesc:ab4cb21c7d7270547ae33b5eab8c8b02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the node around the Y-axis.  <a href="class_ogre_1_1_node.html#ab4cb21c7d7270547ae33b5eab8c8b02d">More...</a><br /></td></tr>
<tr class="separator:ab4cb21c7d7270547ae33b5eab8c8b02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_ogre_1_1_id_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_ogre_1_1_id_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_ogre_1_1_id_object.html">Ogre::IdObject</a></td></tr>
<tr class="memitem:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a7884ec3abf1ed8c1b1514d3bda918370">IdObject</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id)</td></tr>
<tr class="memdesc:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">We don't call generateNewId() here, to prevent objects in the stack (i.e.  <a href="class_ogre_1_1_id_object.html#a7884ec3abf1ed8c1b1514d3bda918370">More...</a><br /></td></tr>
<tr class="separator:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#ab152c8f646a835c2f88585ad4fe0413a">getId</a> () const</td></tr>
<tr class="memdesc:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique id of this object.  <a href="class_ogre_1_1_id_object.html#ab152c8f646a835c2f88585ad4fe0413a">More...</a><br /></td></tr>
<tr class="separator:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0523432c6e5133ff4fc251111a60e inherit pub_methods_class_ogre_1_1_id_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a57e0523432c6e5133ff4fc251111a60e">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;right)</td></tr>
<tr class="separator:a57e0523432c6e5133ff4fc251111a60e inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae22596b5bd2a3faf2958ab3d109d1f inherit pub_methods_class_ogre_1_1_id_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a0ae22596b5bd2a3faf2958ab3d109d1f">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *right)</td></tr>
<tr class="separator:a0ae22596b5bd2a3faf2958ab3d109d1f inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0d44ecad702257bcf68140063ee4bc42"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#a0d44ecad702257bcf68140063ee4bc42">updateAllTransforms</a> (const size_t numNodes, <a class="el" href="struct_ogre_1_1_transform.html">Transform</a> t)</td></tr>
<tr class="separator:a0d44ecad702257bcf68140063ee4bc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afa0a0288b4e3cd278984c1d3c05d8f3e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#afa0a0288b4e3cd278984c1d3c05d8f3e">mGlobalIndex</a></td></tr>
<tr class="memdesc:afa0a0288b4e3cd278984c1d3c05d8f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index in the vector holding this node reference (could be our parent node, or a global array tracking all created nodes to avoid memory leaks).  <a href="class_ogre_1_1_node.html#afa0a0288b4e3cd278984c1d3c05d8f3e">More...</a><br /></td></tr>
<tr class="separator:afa0a0288b4e3cd278984c1d3c05d8f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af133224a62eb73055298c3e2a889f6f5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html#af133224a62eb73055298c3e2a889f6f5">mParentIndex</a></td></tr>
<tr class="memdesc:af133224a62eb73055298c3e2a889f6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index in the vector holding this node reference (could be our parent node, or a global array tracking all created nodes to avoid memory leaks).  <a href="class_ogre_1_1_node.html#af133224a62eb73055298c3e2a889f6f5">More...</a><br /></td></tr>
<tr class="separator:af133224a62eb73055298c3e2a889f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a general-purpose node an articulated scene graph. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A node in the scene graph is a node in a structured tree. A node contains information about the transformation which will apply to it and all of it's children. Child nodes can have transforms of their own, which are combined with their parent's transformations. </dd></dl>
<dl class="section user"><dt></dt><dd>This is an abstract class - concrete classes are based on this for specific purposes, e.g. <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">SceneNode</a>, <a class="el" href="class_ogre_1_1_bone.html" title="Class representing a Bone in the join hierarchy of a skeleton.">Bone</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a84efd2062a90048361e94e4db7bc79bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84efd2062a90048361e94e4db7bc79bc">&#9670;&nbsp;</a></span>ConstNodeVecIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_node.html#aa9b8a2daaf71dc3d4c816c14a7465875">NodeVec</a>&gt; <a class="el" href="class_ogre_1_1_node.html#a84efd2062a90048361e94e4db7bc79bc">Ogre::Node::ConstNodeVecIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9b8a2daaf71dc3d4c816c14a7465875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b8a2daaf71dc3d4c816c14a7465875">&#9670;&nbsp;</a></span>NodeVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="class_ogre_1_1_node.html">Node</a> *&gt;::type <a class="el" href="class_ogre_1_1_node.html#aa9b8a2daaf71dc3d4c816c14a7465875">Ogre::Node::NodeVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21d127688e5dbfb0eeca46f34e2e1017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d127688e5dbfb0eeca46f34e2e1017">&#9670;&nbsp;</a></span>NodeVecIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_node.html#aa9b8a2daaf71dc3d4c816c14a7465875">NodeVec</a>&gt; <a class="el" href="class_ogre_1_1_node.html#a21d127688e5dbfb0eeca46f34e2e1017">Ogre::Node::NodeVecIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac42e2063379286eb673eaffff6ca5e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42e2063379286eb673eaffff6ca5e99">&#9670;&nbsp;</a></span>TransformSpace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">Ogre::Node::TransformSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration denoting the spaces which a transform can be relative to. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2"></a>TS_LOCAL&#160;</td><td class="fielddoc"><p><a class="el" href="struct_ogre_1_1_transform.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">Transform</a> is relative to the local space. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce"></a>TS_PARENT&#160;</td><td class="fielddoc"><p><a class="el" href="struct_ogre_1_1_transform.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">Transform</a> is relative to the space of the parent node. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04"></a>TS_WORLD&#160;</td><td class="fielddoc"><p><a class="el" href="struct_ogre_1_1_transform.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">Transform</a> is relative to world space. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d11f13ad85e092b2dab64c9555cf2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d11f13ad85e092b2dab64c9555cf2cb">&#9670;&nbsp;</a></span>Node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>nodeMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, should only be called by parent, not directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Parent pointer can be null. </dd></dl>

</div>
</div>
<a id="a07ce15da26399e2dcc9d0b0a8ab060e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce15da26399e2dcc9d0b0a8ab060e7">&#9670;&nbsp;</a></span>Node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_transform.html">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transformPtrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Don't use this constructor unless you know what you're doing. </p>
<dl class="section see"><dt>See also</dt><dd>NodeMemoryManager::mDummyNode </dd></dl>

</div>
</div>
<a id="a4f92f708c954f8bf6581eb2377656443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f92f708c954f8bf6581eb2377656443">&#9670;&nbsp;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac5128a3043c814f21ae09c0e4fa6f121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5128a3043c814f21ae09c0e4fa6f121">&#9670;&nbsp;</a></span>_callMemoryChangeListeners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::_callMemoryChangeListeners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use, notifies all attached objects that our memory pointers (i.e. </p>
<p><a class="el" href="struct_ogre_1_1_transform.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">Transform</a>) may have changed (e.g. during cleanups, change of parent, etc) </p>

<p>Implemented in <a class="el" href="class_ogre_1_1_scene_node.html#a7275725950b2282af107dd005bd6269a">Ogre::SceneNode</a>.</p>

</div>
</div>
<a id="ad90c32702bc7d9ecf3045d084f9f4443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90c32702bc7d9ecf3045d084f9f4443">&#9670;&nbsp;</a></span>_getDerivedOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::_getDerivedOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the orientation of the node as derived from all parents. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Assumes the caches are already updated. Will trigger an assert otherwise. See <a class="el" href="class_ogre_1_1_node.html#a52966eed31d26431889bab047bc8cef6" title="Gets the orientation of the node as derived from all parents.">_getDerivedOrientationUpdated()</a> if you need the update process to be guaranteed </dd></dl>

</div>
</div>
<a id="a52966eed31d26431889bab047bc8cef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52966eed31d26431889bab047bc8cef6">&#9670;&nbsp;</a></span>_getDerivedOrientationUpdated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::_getDerivedOrientationUpdated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the orientation of the node as derived from all parents. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike _getDerivedOrientation, this function guarantees the cache stays up to date. It is strongly advised against calling this function for a large number of nodes. Refactor your queries so that they happen after SceneManager::UpdateAllTransforms() has been called </dd></dl>

</div>
</div>
<a id="ada8b93a13e3520fa0f1d67d796d2b18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8b93a13e3520fa0f1d67d796d2b18b">&#9670;&nbsp;</a></span>_getDerivedPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::_getDerivedPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of the node as derived from all parents. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Assumes the caches are already updated. Will trigger an assert otherwise. See <a class="el" href="class_ogre_1_1_node.html#ae7fb5e2347952b43bfb7b91139364e2b" title="Gets the position of the node as derived from all parents.">_getDerivedPositionUpdated()</a> if you need the update process to be guaranteed </dd></dl>

</div>
</div>
<a id="ae7fb5e2347952b43bfb7b91139364e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fb5e2347952b43bfb7b91139364e2b">&#9670;&nbsp;</a></span>_getDerivedPositionUpdated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::_getDerivedPositionUpdated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of the node as derived from all parents. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike _getDerivedPosition, this function guarantees the cache stays up to date. It is strongly advised against calling this function for a large number of nodes. Refactor your queries so that they happen after SceneManager::UpdateAllTransforms() has been called </dd></dl>

</div>
</div>
<a id="ad67181c814f63f7f3fea54a2affd39e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67181c814f63f7f3fea54a2affd39e2">&#9670;&nbsp;</a></span>_getDerivedScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::_getDerivedScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the scaling factor of the node as derived from all parents. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Assumes the caches are already updated. Will trigger an assert otherwise. See <a class="el" href="class_ogre_1_1_node.html#ab74ff3f5276ed7358dce2e5681f3114c" title="Gets the scalling factor of the node as derived from all parents.">_getDerivedScaleUpdated()</a> if you need the update process to be guaranteed </dd></dl>

</div>
</div>
<a id="ab74ff3f5276ed7358dce2e5681f3114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74ff3f5276ed7358dce2e5681f3114c">&#9670;&nbsp;</a></span>_getDerivedScaleUpdated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::_getDerivedScaleUpdated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the scalling factor of the node as derived from all parents. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike _getDerivedScale, this function guarantees the cache stays up to date. It is STRONGLY advised against calling this function for a large number of nodes. Refactor your queries so that they happen after SceneManager::UpdateAllTransforms() has been called </dd></dl>

</div>
</div>
<a id="a80127fa2d538c03441c563fbb82fdc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80127fa2d538c03441c563fbb82fdc69">&#9670;&nbsp;</a></span>_getFullTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&amp; Ogre::Node::_getFullTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the full transformation matrix for this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method returns the full transformation matrix for this node, including the effect of any parent node transformations, provided they have been updated using the Node::_update method. This should only be called by a <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> which knows the derived transforms have been updated before calling this method. Applications using <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> should just use the relative transforms. Assumes the caches are already updated </dd></dl>

<p class="reference">References <a class="el" href="struct_ogre_1_1_transform.html#ab130604cfbbebb88805dd147aa7a3e11">Ogre::Transform::mDerivedTransform</a>, <a class="el" href="struct_ogre_1_1_transform.html#a14e0f44727da02c219d40449c6e95ded">Ogre::Transform::mIndex</a>, and <a class="el" href="_ogre_platform_8h.html#a1a71b761de4da71ff1db4be2232e06e7">OGRE_ASSERT_MEDIUM</a>.</p>

</div>
</div>
<a id="a861792d6e436ae23d3fcbb40b2c2c20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861792d6e436ae23d3fcbb40b2c2c20c">&#9670;&nbsp;</a></span>_getFullTransformUpdated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&amp; Ogre::Node::_getFullTransformUpdated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_node.html#ab74ff3f5276ed7358dce2e5681f3114c" title="Gets the scalling factor of the node as derived from all parents.">_getDerivedScaleUpdated()</a> remarks. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_node.html#a80127fa2d538c03441c563fbb82fdc69" title="Gets the full transformation matrix for this node.">_getFullTransform</a> </dd></dl>

</div>
</div>
<a id="a8f3c07f6e7386cd419a80855fa592c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3c07f6e7386cd419a80855fa592c47">&#9670;&nbsp;</a></span>_getTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_transform.html">Transform</a>&amp; Ogre::Node::_getTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a direct access to the <a class="el" href="struct_ogre_1_1_transform.html" title="Represents the transform of a single object, arranged in SoA (Structure of Arrays)">Transform</a> state. </p>

</div>
</div>
<a id="afdd681ba32f8627cdd4c37ca766d60ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd681ba32f8627cdd4c37ca766d60ea">&#9670;&nbsp;</a></span>_notifyStaticDirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::_notifyStaticDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> when it is telling we're a static node being dirty Don't call this directly. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a464c4d6f1f2761d8d3b715df0591b96a" title="Notifies that the given Node is dirty (i.e.">SceneManager::notifyStaticDirty</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_scene_node.html#a7ca83fa0cc29674d7a43c32a2f24f885">Ogre::SceneNode</a>.</p>

</div>
</div>
<a id="a383a4f0494151b534ac76ec0aecbb6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383a4f0494151b534ac76ec0aecbb6a1">&#9670;&nbsp;</a></span>_setDerivedOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::_setDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the final world orientation of the node directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It's advisable to use the local setOrientation if possible, this simply does the conversion for you. </dd></dl>

</div>
</div>
<a id="aa61f161b03f1a80bc5974b2804171062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61f161b03f1a80bc5974b2804171062">&#9670;&nbsp;</a></span>_setDerivedPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::_setDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the final world position of the node directly. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It's advisable to use the local setPosition if possible </dd></dl>

</div>
</div>
<a id="a7b796c4810932765f140736f04f24ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b796c4810932765f140736f04f24ca4">&#9670;&nbsp;</a></span>_setNullNodeMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::_setNullNodeMemoryManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually set the mNodeMemoryManager to a null ptr. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> doesn't follow the rule of three. This function is useful when you make multiple hard copies but only the destructor must release the mTransform only slots once. </dd></dl>

</div>
</div>
<a id="a625500757d216e51c48fbf09a52a36f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625500757d216e51c48fbf09a52a36f7">&#9670;&nbsp;</a></span>_updateChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::_updateChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to update the <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> and all children. </p>
<dl class="section note"><dt>Note</dt><dd>Updates this node and all children to incorporate transforms etc. <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> never call it, preferring full update of all transforms, but there could be situations when scene modifications are known and so small that full update is inefficient. </dd></dl>

</div>
</div>
<a id="af01698919040092766a3a4bfab8e7ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01698919040092766a3a4bfab8e7ceb">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a (precreated) child scene node to this node. </p>
<p>If it is attached to another node, it must be detached first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> which is to become a child node of this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4764d25d695ab8bc5ad9bf378ae70786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4764d25d695ab8bc5ad9bf378ae70786">&#9670;&nbsp;</a></span>convertLocalToWorldDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertLocalToWorldDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the world direction of a point in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="ac892e2e5a007c0f91112823d73ce5b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac892e2e5a007c0f91112823d73ce5b38">&#9670;&nbsp;</a></span>convertLocalToWorldDirectionUpdated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertLocalToWorldDirectionUpdated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4190c35585d53852c3ecb1d82813c287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4190c35585d53852c3ecb1d82813c287">&#9670;&nbsp;</a></span>convertLocalToWorldOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::convertLocalToWorldOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>localOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="a6dced923268b7b145eb397d2bbf55520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dced923268b7b145eb397d2bbf55520">&#9670;&nbsp;</a></span>convertLocalToWorldOrientationUpdated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::convertLocalToWorldOrientationUpdated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>localOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a732f69dff26b677c6ab11da2a9474059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732f69dff26b677c6ab11da2a9474059">&#9670;&nbsp;</a></span>convertLocalToWorldPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertLocalToWorldPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the world position of a point in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a id="aa9c0b966080de019c3b68c7f8db9eb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c0b966080de019c3b68c7f8db9eb4d">&#9670;&nbsp;</a></span>convertLocalToWorldPositionUpdated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertLocalToWorldPositionUpdated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>localPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f2c43ecc98d69ad63533ff4258a9349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2c43ecc98d69ad63533ff4258a9349">&#9670;&nbsp;</a></span>convertWorldToLocalDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertWorldToLocalDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the local direction, relative to this node, of the given world-space direction. </p>

</div>
</div>
<a id="af73c4989864f0066125b37bb7a93731f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73c4989864f0066125b37bb7a93731f">&#9670;&nbsp;</a></span>convertWorldToLocalDirectionUpdated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertWorldToLocalDirectionUpdated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51a347f6c598d81c0d12d4c59e92acae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a347f6c598d81c0d12d4c59e92acae">&#9670;&nbsp;</a></span>convertWorldToLocalOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::convertWorldToLocalOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>worldOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the local orientation, relative to this node, of the given world-space orientation. </p>

</div>
</div>
<a id="a73a39cee77eb770833f90a2085b16afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a39cee77eb770833f90a2085b16afd">&#9670;&nbsp;</a></span>convertWorldToLocalOrientationUpdated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::convertWorldToLocalOrientationUpdated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>worldOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac70989f6375d53ee7e91e06ae8341023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70989f6375d53ee7e91e06ae8341023">&#9670;&nbsp;</a></span>convertWorldToLocalPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertWorldToLocalPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the local position, relative to this node, of the given world-space position. </p>

</div>
</div>
<a id="a1c19ff3089bb7353f28cdd7e4181d065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c19ff3089bb7353f28cdd7e4181d065">&#9670;&nbsp;</a></span>convertWorldToLocalPositionUpdated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::convertWorldToLocalPositionUpdated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6976feeb8705b7899cfc4219c3408a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6976feeb8705b7899cfc4219c3408a3">&#9670;&nbsp;</a></span>createChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::createChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>translate</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotate</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unnamed new <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td class="paramname">rotate</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a7872671761814b72ace4e89b869dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a7872671761814b72ace4e89b869dc">&#9670;&nbsp;</a></span>getChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to a child node. </p>

</div>
</div>
<a id="a95614dd446dfbfe6d88db22f654683ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95614dd446dfbfe6d88db22f654683ea">&#9670;&nbsp;</a></span>getChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49482dee5a9d1eebd1851c5f3464fbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49482dee5a9d1eebd1851c5f3464fbf7">&#9670;&nbsp;</a></span>getChildIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html#a21d127688e5dbfb0eeca46f34e2e1017">NodeVecIterator</a> Ogre::Node::getChildIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an iterator for efficiently looping through all children of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Using this is faster than repeatedly calling getChild if you want to go through all (or most of) the children of this node. Note that the returned iterator is only valid whilst no children are added or removed from this node. Thus you should not store this returned iterator for later use, nor should you add / remove children whilst iterating through it; store up changes for later. Note that calling methods on returned items in the iterator IS allowed and does not invalidate the iterator. </dd></dl>

</div>
</div>
<a id="aa6dcbdb546c8efcf780ed27f01e9d714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dcbdb546c8efcf780ed27f01e9d714">&#9670;&nbsp;</a></span>getChildIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html#a84efd2062a90048361e94e4db7bc79bc">ConstNodeVecIterator</a> Ogre::Node::getChildIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an iterator for efficiently looping through all children of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Using this is faster than repeatedly calling getChild if you want to go through all (or most of) the children of this node. Note that the returned iterator is only valid whilst no children are added or removed from this node. Thus you should not store this returned iterator for later use, nor should you add / remove children whilst iterating through it; store up changes for later. Note that calling methods on returned items in the iterator IS allowed and does not invalidate the iterator. </dd></dl>

</div>
</div>
<a id="ae910eab0d400594e70133831cb1621fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae910eab0d400594e70133831cb1621fe">&#9670;&nbsp;</a></span>getDefaultNodeMemoryManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a>* Ogre::Node::getDefaultNodeMemoryManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_ogre_1_1_scene_node.html#ab8be5bd671d9eff3fc87ff38f568850e">Ogre::SceneNode</a>.</p>

</div>
</div>
<a id="a478f180848cc1f39caa8f17f86e8a5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478f180848cc1f39caa8f17f86e8a5dd">&#9670;&nbsp;</a></span>getDepthLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a> Ogre::Node::getDepthLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how deep in the hierarchy we are (eg. 0 -&gt; root node, 1 -&gt; child of root) </p>

</div>
</div>
<a id="a67eeca6c33a61c00b3fb2abd2c1289ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67eeca6c33a61c00b3fb2abd2c1289ba">&#9670;&nbsp;</a></span>getIndestructibleByClearScene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Node::getIndestructibleByClearScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae98ec089fda531aa72b7200d4bc98f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98ec089fda531aa72b7200d4bc98f03">&#9670;&nbsp;</a></span>getInheritOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> bool Ogre::Node::getInheritOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this node is affected by orientation applied to the parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd>
<dd>
See setInheritOrientation for more info. </dd></dl>

</div>
</div>
<a id="add630c76ba07eb3435947b4545276534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add630c76ba07eb3435947b4545276534">&#9670;&nbsp;</a></span>getInheritScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> bool Ogre::Node::getInheritScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this node is affected by scaling factors applied to the parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>See setInheritScale for more info. </dd></dl>

</div>
</div>
<a id="ad6ccad036a830972b4cfb2cf0820c58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ccad036a830972b4cfb2cf0820c58f">&#9670;&nbsp;</a></span>getListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a>* Ogre::Node::getListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

</div>
</div>
<a id="a2dd2eef2b05e313c25f23a488f70a934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd2eef2b05e313c25f23a488f70a934">&#9670;&nbsp;</a></span>getLocalAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> Ogre::Node::getLocalAxes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent. </p>

</div>
</div>
<a id="a48a46c60d76c45674902645d8991eebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a46c60d76c45674902645d8991eebe">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Node::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the node. </p>

</div>
</div>
<a id="a70ff235b93b63af33f3b7f7164e3c643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ff235b93b63af33f3b7f7164e3c643">&#9670;&nbsp;</a></span>getOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> Ogre::Node::getOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a quaternion representing the nodes orientation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Don't call this function too often, as we need to convert from SoA </dd></dl>

</div>
</div>
<a id="a7832bef084fac469f35b927fae335395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7832bef084fac469f35b927fae335395">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::Node::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets this node's parent (NULL if this is the root). </p>

</div>
</div>
<a id="a32bb47ce140c3a1d5eba04df7b342ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bb47ce140c3a1d5eba04df7b342ca8">&#9670;&nbsp;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::getPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of the node relative to it's parent. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Don't call this function too often, as we need to convert from SoA </dd></dl>

</div>
</div>
<a id="a662fa5e94c54f76ff078c52492062865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662fa5e94c54f76ff078c52492062865">&#9670;&nbsp;</a></span>getScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::Node::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the scaling factor of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Don't call this function too often, as we need to convert from SoA </dd></dl>

</div>
</div>
<a id="a39354baf38396f9c86de5e1822364c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39354baf38396f9c86de5e1822364c15">&#9670;&nbsp;</a></span>getSquaredViewDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Node::getSquaredViewDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function, get the squared view depth. </p>
<p><br  />
 </p>

</div>
</div>
<a id="ab52d2653967a5cc778ea5ceae0537043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52d2653967a5cc778ea5ceae0537043">&#9670;&nbsp;</a></span>getUserAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="_ogre_platform_8h.html#af2652ba9f4945789c869d74d7e67cbcb">OGRE_DEPRECATED</a> const <a class="el" href="class_ogre_1_1_any.html">Any</a>&amp; Ogre::Node::getUserAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_user_object_bindings.html#adec1cf29d6134cbb881fc7c79b900bcf" title="Retrieves the custom key less user object associated with this class.">UserObjectBindings::getUserAny</a> via <a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3" title="Return an instance of user objects binding associated with this class.">getUserObjectBindings()</a> instead.</dd></dl>
<p>Retrieves the custom user value associated with this object. </p>

</div>
</div>
<a id="af3fcf16e43b07e046816125cbb8dc8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fcf16e43b07e046816125cbb8dc8f3">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Node::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<a id="aa154e07b616313f4c345ec6c0da635cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa154e07b616313f4c345ec6c0da635cd">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Node::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<a id="a2045217c742576f9a82e4070da277e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2045217c742576f9a82e4070da277e89">&#9670;&nbsp;</a></span>isStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Node::isStatic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether this node is static. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_node.html#a1f18bc6093c94defdaf64b504df81259" title="Turns this Node into static or dynamic.">setStatic</a> </dd></dl>

</div>
</div>
<a id="a6f5fc23a04991fc7a524763b0bdf829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5fc23a04991fc7a524763b0bdf829c">&#9670;&nbsp;</a></span>migrateTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::migrateTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node_memory_manager.html">NodeMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>nodeMemoryManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrates the node and all of its children to the new memory manager, at the same depth level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeMemoryManager</td><td>New memory manager to migrate to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a789e0dfefecefbd30b449fc47a4372de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789e0dfefecefbd30b449fc47a4372de">&#9670;&nbsp;</a></span>numChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Node::numChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the number of child nodes under this one. </p>

</div>
</div>
<a id="ade4a8283f41882f4b6c70acbe9f27c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4a8283f41882f4b6c70acbe9f27c61">&#9670;&nbsp;</a></span>pitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::pitch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the node around the X-axis. </p>

</div>
</div>
<a id="af4ac98a5c316736e60d3a92f798a6e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ac98a5c316736e60d3a92f798a6e82">&#9670;&nbsp;</a></span>removeAllChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all child Nodes attached to this node. </p>
<p>Does not delete the nodes, just detaches them from this parent, potentially to be reattached elsewhere. </p>

</div>
</div>
<a id="a8527d3766bb672f8bccc8535666511cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8527d3766bb672f8bccc8535666511cb">&#9670;&nbsp;</a></span>removeChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the specified child from this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. </dd></dl>
<dl class="section user"><dt></dt><dd>Asserts if child is not one of our children. </dd></dl>

</div>
</div>
<a id="a0ba27b1ade1c9e80d77f8acd2413d3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba27b1ade1c9e80d77f8acd2413d3b4">&#9670;&nbsp;</a></span>resetOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void Ogre::Node::resetOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the nodes orientation (local axes as world axes, no rotation). </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="ae17b2a4b91e5213ca68c106a3b6f79a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17b2a4b91e5213ca68c106a3b6f79a4">&#9670;&nbsp;</a></span>roll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::roll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the node around the Z-axis. </p>

</div>
</div>
<a id="a6755a5f452cd93b08d2a3261cf0a3ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6755a5f452cd93b08d2a3261cf0a3ae3">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the node around an arbitrary axis using a Quarternion. </p>

</div>
</div>
<a id="a4ae0264db9d227d20390ebfd01cee64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae0264db9d227d20390ebfd01cee64e">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the node around an arbitrary axis. </p>

</div>
</div>
<a id="a590240d3ac5eb4ccdfc2ac98bc360390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590240d3ac5eb4ccdfc2ac98bc360390">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the node, combining it's current scale with the passed in scaling factor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if the existing scale was 1. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="abfe1f0d7aace82d233c326ad31dd097c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe1f0d7aace82d233c326ad31dd097c">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the node, combining it's current scale with the passed in scaling factor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if the existing scale was 1. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="afc5c13c4251135f4d03ef75dbb03afe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5c13c4251135f4d03ef75dbb03afe5">&#9670;&nbsp;</a></span>setIndestructibleByClearScene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setIndestructibleByClearScene </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>indestructible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling <a class="el" href="class_ogre_1_1_scene_manager.html#a01ba0aad5090ed0a8ff5e9c3d24fa924" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc.">SceneManager::clearScene</a> won't destroy this node nor detach its objects (but may still destroy parent and children nodes if they're not indestructible) when this is true. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function provides trivial setter/getters rather than making mIndestructibleByClearScene public for two reasons:<ol type="1">
<li>It's rare called</li>
<li>There's a lot of value in debugging when a node is set to indestructible, which could happen by accident; and would thus leak. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a60c305942b550d110b85c5da64a0a5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c305942b550d110b85c5da64a0a5f6">&#9670;&nbsp;</a></span>setInheritOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::setInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the node whether it should inherit orientation from it's parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inherit</td><td>If true, this node's orientation will be affected by its parent's orientation. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0a994b31f757ba9d3059a133712ffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a994b31f757ba9d3059a133712ffe7">&#9670;&nbsp;</a></span>setInheritScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::setInheritScale </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the node whether it should inherit scaling factors from it's parent node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inherit</td><td>If true, this node's scale will be affected by its parent's scale. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac958f0d4fad0970aa65bdd0f86de6781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac958f0d4fad0970aa65bdd0f86de6781">&#9670;&nbsp;</a></span>setListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node_1_1_listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a listener for this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note for size and performance reasons only one listener per node is allowed. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_scene_node.html#abc0069789efaa4cc6d9cacb57d6218a4">Ogre::SceneNode</a>.</p>

</div>
</div>
<a id="ae4bfe1d06442abf69042794c75d783fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bfe1d06442abf69042794c75d783fe">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Node::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a custom name for this node. </p>
<p>Doesn't have to be unique </p>

</div>
</div>
<a id="ada5432efc903b990958e5befc260591c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5432efc903b990958e5befc260591c">&#9670;&nbsp;</a></span>setOrientation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void Ogre::Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a>&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the orientation of this node via a quaternion. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. Don't call this function too often, as we need to convert to SoA </dd></dl>
<dl class="section user"><dt></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="acf639f3cc469fec01702cd647c4ba3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf639f3cc469fec01702cd647c4ba3a6">&#9670;&nbsp;</a></span>setOrientation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void Ogre::Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the orientation of this node via quaternion parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. Don't call this function too often, as we need to convert to SoA </dd></dl>
<dl class="section user"><dt></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="a9ea731e0b03a84dec688dd05739ca108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea731e0b03a84dec688dd05739ca108">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void Ogre::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position of the node relative to it's parent. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Don't call this function too often, as we need to convert to SoA </dd></dl>

</div>
</div>
<a id="a4b19d272c8b485831fb8987fa3b936b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b19d272c8b485831fb8987fa3b936b1">&#9670;&nbsp;</a></span>setPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void Ogre::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position of the node relative to it's parent. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Don't call this function too often, as we need to convert to SoA </dd></dl>

</div>
</div>
<a id="af62a3dc794cf46ef1c023353e1eccbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62a3dc794cf46ef1c023353e1eccbfc">&#9670;&nbsp;</a></span>setScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void Ogre::Node::setScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the scaling factor applied to this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. Don't call this function too often, as we need to convert to SoA </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="a16dc062290e30d1cdb51d629cb952cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dc062290e30d1cdb51d629cb952cc7">&#9670;&nbsp;</a></span>setScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#ad8a102b20f8a115e9787f68fc1045cdf">virtual_l1</a> void Ogre::Node::setScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the scaling factor applied to this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. Don't call this function too often, as we need to convert to SoA </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a id="a1f18bc6093c94defdaf64b504df81259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18bc6093c94defdaf64b504df81259">&#9670;&nbsp;</a></span>setStatic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::Node::setStatic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStatic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> into static or dynamic. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Switching between dynamic and static has some overhead and forces to update all static scene when converted to static. So don't do it frequently. Static objects are not updated every frame, only when requested explicitly. Use this feature if you plan to have this object unaltered for a very long times </dd></dl>
<dl class="section user"><dt></dt><dd>Changing this attribute to a node will cause to switch the attribute to all attached entities (but not children or parent nodes; it's perfectly valid and useful to have dynamic children of a static parent; although the opposite (static children, dynamic parent) is probably a bug. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if setStatic made an actual change. False otherwise. Can fail because the object was already static/dynamic, or because switching is not supported </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_scene_node.html#a25a25c3d3d15e808a9955d65a13c160b">Ogre::SceneNode</a>.</p>

</div>
</div>
<a id="a2f495289a449621359d2b23eaa31786c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f495289a449621359d2b23eaa31786c">&#9670;&nbsp;</a></span>setUserAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="_ogre_platform_8h.html#af2652ba9f4945789c869d74d7e67cbcb">OGRE_DEPRECATED</a> void Ogre::Node::setUserAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"><em>anything</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a> via <a class="el" href="class_ogre_1_1_node.html#af3fcf16e43b07e046816125cbb8dc8f3" title="Return an instance of user objects binding associated with this class.">getUserObjectBindings()</a> instead.</dd></dl>
<p>Sets any kind of user value on this object. </p><dl class="section remark"><dt>Remarks</dt><dd>This method allows you to associate any user value you like with this <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. This can be a pointer back to one of your own classes for instance. </dd></dl>

</div>
</div>
<a id="a0dce11eb77f674b03594a9d70217660d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dce11eb77f674b03594a9d70217660d">&#9670;&nbsp;</a></span>translate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the node along arbitrary axes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method translates the node by a vector which is relative to a custom set of axes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>A 3x3 Matrix containing 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as: <pre>
    1 0 0
    0 1 0
    0 0 1
    </pre> i.e. the identity matrix. </td></tr>
    <tr><td class="paramname">move</td><td>Vector relative to the axes above. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4569105087414a50c40b19800eb9faae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4569105087414a50c40b19800eb9faae">&#9670;&nbsp;</a></span>translate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the node along arbitrary axes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method translates the node by a vector which is relative to a custom set of axes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>A 3x3 Matrix containing 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as <pre>
    1 0 0
    0 1 0
    0 0 1
    </pre> i.e. the identity matrix. </td></tr>
    <tr><td class="paramname">x</td><td>The <code>x</code> translation component relative to the axes above. </td></tr>
    <tr><td class="paramname">y</td><td>The <code>y</code> translation component relative to the axes above. </td></tr>
    <tr><td class="paramname">z</td><td>The <code>z</code> translation component relative to the axes above. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac97975ed6d907bc0674dc9f26b154a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97975ed6d907bc0674dc9f26b154a8f">&#9670;&nbsp;</a></span>translate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the node along the Cartesian axes. </p>
<dl class="section user"><dt></dt><dd>This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Vector with x,y,z values representing the translation. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e4f546194a1dcf79703ef2ffd6cead4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f546194a1dcf79703ef2ffd6cead4">&#9670;&nbsp;</a></span>translate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the node along the Cartesian axes. </p>
<dl class="section user"><dt></dt><dd>This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Real <code>x</code> value representing the translation. </td></tr>
    <tr><td class="paramname">y</td><td>Real <code>y</code> value representing the translation. </td></tr>
    <tr><td class="paramname">z</td><td>Real <code>z</code> value representing the translation. </td></tr>
    <tr><td class="paramname">relativeTo</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d44ecad702257bcf68140063ee4bc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d44ecad702257bcf68140063ee4bc42">&#9670;&nbsp;</a></span>updateAllTransforms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Node::updateAllTransforms </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_transform.html">Transform</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a1f59ebdfaadbe33f713d754737041654" title="Updates the derived transforms of all nodes in the scene.">SceneManager::updateAllTransforms()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>We don't pass by reference on purpose (avoid implicit aliasing) </dd></dl>

</div>
</div>
<a id="ab4cb21c7d7270547ae33b5eab8c8b02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cb21c7d7270547ae33b5eab8c8b02d">&#9670;&nbsp;</a></span>yaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a2c52accfdfe1971a9c62bac16d2bbdc8">virtual_l2</a> void Ogre::Node::yaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_radian.html">Radian</a> &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&#160;</td>
          <td class="paramname"><em>relativeTo</em> = <code><a class="el" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the node around the Y-axis. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afa0a0288b4e3cd278984c1d3c05d8f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0a0288b4e3cd278984c1d3c05d8f3e">&#9670;&nbsp;</a></span>mGlobalIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Node::mGlobalIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index in the vector holding this node reference (could be our parent node, or a global array tracking all created nodes to avoid memory leaks). </p>
<p>Used for O(1) removals. </p><dl class="section remark"><dt>Remarks</dt><dd>It is the parent (or our creator) the one that sets this value, not ourselves. Do NOT modify it manually. </dd></dl>

</div>
</div>
<a id="af133224a62eb73055298c3e2a889f6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af133224a62eb73055298c3e2a889f6f5">&#9670;&nbsp;</a></span>mParentIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Node::mParentIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index in the vector holding this node reference (could be our parent node, or a global array tracking all created nodes to avoid memory leaks). </p>
<p>Used for O(1) removals. </p><dl class="section remark"><dt>Remarks</dt><dd>It is the parent (or our creator) the one that sets this value, not ourselves. Do NOT modify it manually. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_node_8h.html">OgreNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_node.html">Node</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
