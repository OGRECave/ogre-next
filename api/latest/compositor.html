<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Compositor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE-Next
   &#160;<span id="projectnumber">4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('compositor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Compositor </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#CompositorNodes">Nodes</a><ul><li class="level2"><a href="#CompositorNodesChannelsAndRTTs">Input &amp; output channels and RTTs</a><ul><li class="level3"><a href="#CompositorNodesChannelsAndRTTsLocalTextures">Locally declared textures</a></li>
<li class="level3"><a href="#CompositorNodesChannelsAndRTTsFromInputChannel">Textures coming from input channels</a></li>
<li class="level3"><a href="#CompositorNodesChannelsAndRTTsGlobal">Global Textures</a></li>
<li class="level3"><a href="#autotoc_md110">compositor_node parameters</a><ul><li class="level4"><a href="#CompositorNode_in">in</a></li>
<li class="level4"><a href="#CompositorNode_out">out</a></li>
<li class="level4"><a href="#CompositorNode_in_buffer">in_buffer</a></li>
<li class="level4"><a href="#CompositorNode_out_buffer">out_buffer</a></li>
<li class="level4"><a href="#CompositorNode_custom_id">custom_id</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesChannelsAndRTTsMainRenderTarget">Main RenderTarget</a></li>
</ul>
</li>
<li class="level2"><a href="#CompositorNodesTarget">Target</a><ul><li class="level3"><a href="#autotoc_md111">target parameters</a><ul><li class="level4"><a href="#CompositorTarget_target_level_barrier">target_level_barrier</a></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><a href="#CompositorNodesPasses">Passes</a><ul><li class="level3"><a href="#autotoc_md112">pass parameters</a><ul><li class="level4"><a href="#CompositorPass_pass">pass</a></li>
<li class="level4"><a href="#CompositorPass_num_initial">num_initial</a></li>
<li class="level4"><a href="#CompositorPass_flush_command_buffers">flush_command_buffers</a></li>
<li class="level4"><a href="#CompositorPass_identifier">identifier</a></li>
<li class="level4"><a href="#CompositorPass_execution_mask">execution_mask</a></li>
<li class="level4"><a href="#CompositorPass_viewport_modifier_mask">viewport_modifier_mask</a></li>
<li class="level4"><a href="#CompositorPass_colour_write">colour_write</a></li>
<li class="level4"><a href="#CompositorPass_profiling_id">profiling_id</a></li>
<li class="level4"><a href="#CompositorPass_viewport">viewport</a></li>
<li class="level4"><a href="#CompositorPass_expose">expose</a></li>
<li class="level4"><a href="#CompositorPass_skip_load_store_semantics">skip_load_store_semantics</a></li>
<li class="level4"><a href="#CompositorPass_load">load</a></li>
<li class="level4"><a href="#CompositorPass_load_all">all (load)</a></li>
<li class="level4"><a href="#CompositorPass_load_colour">colour (load)</a></li>
<li class="level4"><a href="#CompositorPass_load_depth">depth (load)</a></li>
<li class="level4"><a href="#CompositorPass_load_stencil">stencil (load)</a></li>
<li class="level4"><a href="#CompositorPass_load_clear_colour">clear_colour / colour_value (load)</a></li>
<li class="level4"><a href="#CompositorPass_load_clear_colour_reverse_depth_aware">clear_colour_reverse_depth_aware (load)</a></li>
<li class="level4"><a href="#CompositorPass_load_clear_depth">clear_depth (load)</a></li>
<li class="level4"><a href="#CompositorPass_load_clear_stencil">clear_stencil (load)</a></li>
<li class="level4"><a href="#CompositorPass_load_warn_if_rtv_was_flushed">warn_if_rtv_was_flushed (load)</a></li>
<li class="level4"><a href="#CompositorPass_store">store</a></li>
<li class="level4"><a href="#CompositorPass_store_all">all (store)</a></li>
<li class="level4"><a href="#CompositorPass_store_colour">colour (store)</a></li>
<li class="level4"><a href="#CompositorPass_store_depth">depth (store)</a></li>
<li class="level4"><a href="#CompositorPass_store_stencil">stencil (store)</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesPassesClear">clear</a><ul><li class="level4"><a href="#CompositorPass_clear_non_tilers_only">non_tilers_only</a></li>
<li class="level4"><a href="#CompositorPass_clear_buffers">buffers</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesPassesGenerateMipmaps">generate_mipmaps</a><ul><li class="level4"><a href="#CompositorNodesPassesGenerateMipmaps_mipmap_method">mipmap_method</a></li>
<li class="level4"><a href="#CompositorNodesPassesGenerateMipmaps_kernel_radius">kernel_radius</a></li>
<li class="level4"><a href="#CompositorNodesPassesGenerateMipmaps_gauss_deviation">gauss_deviation</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesPassesQuad">render_quad</a><ul><li class="level4"><a href="#CompositorNodesPassesQuad_use_quad">use_quad</a></li>
<li class="level4"><a href="#CompositorNodesPassesQuad_material">material</a></li>
<li class="level4"><a href="#CompositorNodesPassesQuad_hlms">hlms</a></li>
<li class="level4"><a href="#CompositorNodesPassesQuad_input">input</a></li>
<li class="level4"><a href="#CompositorNodesPassesQuad_quad_normals">quad_normals</a></li>
<li class="level4"><a href="#CompositorNodesPassesQuad_camera">camera</a></li>
<li class="level4"><a href="#CompositorNodesPassesQuad_camera_cubemap_reorient">camera_cubemap_reorient</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesPassesRenderScene">render_scene</a><ul><li class="level4"><a href="#CompositorNodesPassesRenderScene_rq_first">rq_first</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_rq_last">rq_last</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_lod_bias">lod_bias</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_lod_update_list">lod_update_list</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_cull_reuse_data">cull_reuse_data</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_visibility_mask">visibility_mask</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_light_visibility_mask">light_visibility_mask</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_shadows">shadows</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_overlays">overlays</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_camera">camera</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_lod_camera">lod_camera</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_cull_camera">cull_camera</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_camera_cubemap_reorient">camera_cubemap_reorient</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_enable_forwardplus">enable_forwardplus</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_flush_command_buffers_after_shadow_node">flush_command_buffers_after_shadow_node</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_is_prepass">is_prepass</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_use_prepass">use_prepass</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_gen_normals_gbuffer">gen_normals_gbuffer</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesPassesRenderScene_use_refractions">use_refractions</a><ul><li class="level4"><a href="#CompositorNodesPassesRenderScene_uv_baking">uv_baking</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_uv_baking_offset">uv_baking_offset</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_bake_lighting_only">bake_lighting_only</a></li>
<li class="level4"><a href="#CompositorNodesPassesRenderScene_instanced_stereo">instanced_stereo</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesPassesShadows">shadows</a></li>
<li class="level3"><a href="#CompositorNodesPassesStencil">stencil</a></li>
<li class="level3"><a href="#CompositorNodesPassesUavQueue">uav_queue</a><ul><li class="level4"><a href="#CompositorNodesPassesUavQueue_starting_slot">starting_slot</a></li>
<li class="level4"><a href="#CompositorNodesPassesUavQueue_uav">uav</a></li>
<li class="level4"><a href="#CompositorNodesPassesUavQueue_uav_external">uav_external</a></li>
<li class="level4"><a href="#CompositorNodesPassesUavQueue_uav_buffer">uav_buffer</a></li>
<li class="level4"><a href="#CompositorNodesPassesUavQueue_keep_previous_uavs">keep_previous_uavs</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesPassesCompute">compute</a><ul><li class="level4"><a href="#CompositorPassCompute_job">job</a></li>
<li class="level4"><a href="#CompositorPassCompute_uav">uav</a></li>
<li class="level4"><a href="#CompositorPassCompute_uav_buffer">uav_buffer</a></li>
<li class="level4"><a href="#CompositorPassCompute_input">input</a></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><a href="#CompositorNodesTextures">texture</a><ul><li class="level3"><a href="#CompositorNodesTexturesMsaa">MSAA: Explicit vs Implicit resolves</a><ul><li class="level4"><a href="#CompositorNodesTexturesMsaaImplicit">Implicit resolves</a></li>
<li class="level4"><a href="#CompositorNodesTexturesMsaaExplicit">Explicit resolves</a></li>
</ul>
</li>
<li class="level3"><a href="#CompositorNodesTexturesDepth">Depth Textures</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#CompositorShadowNodes">Shadow Nodes</a><ul><li class="level2"><a href="#CompositorShadowNodesSetup">Setting up shadow nodes</a><ul><ul><li class="level4"><a href="#CompositorShadowNodesSetup_technique">technique</a></li>
<li class="level4"><a href="#CompositorShadowNodesSetup_num_splits">num_splits</a></li>
<li class="level4"><a href="#CompositorShadowNodesSetup_num_stable_splits">num_stable_splits</a></li>
<li class="level4"><a href="#CompositorShadowNodesSetup_normal_offset_bias">normal_offset_bias</a></li>
<li class="level4"><a href="#CompositorShadowNodesSetup_constant_bias_scale">constant_bias_scale</a></li>
<li class="level4"><a href="#CompositorShadowNodesSetup_pssm_lambda">pssm_lambda</a></li>
<li class="level4"><a href="#CompositorShadowNodesSetup_pssm_split_blend">pssm_split_blend</a></li>
<li class="level4"><a href="#CompositorShadowNodesSetup_pssm_split_fade">pssm_split_fade</a></li>
<li class="level4"><a href="#CompositorShadowNodesSetup_shadow_map">shadow_map</a></li>
</ul>
</ul>
</li>
<li class="level2"><a href="#CompositorShadowNodesExample">Example</a></li>
<li class="level2"><a href="#CompositorShadowNodesAtlasAndPointLights">Shadow map atlas &amp; Point Lights</a></li>
<li class="level2"><a href="#CompositorShadowNodesReuseEtc">Reuse, recalculate and first</a></li>
<li class="level2"><a href="#CompositorShadowNodesTypes">Shadow mapping setup types</a><ul><li class="level3"><a href="#CompositorShadowNodesTypesUniform">Uniform shadow mapping</a></li>
<li class="level3"><a href="#CompositorShadowNodesTypesFocused">Focused</a></li>
<li class="level3"><a href="#CompositorShadowNodesTypesPssm">PSSM / CSM</a></li>
<li class="level3"><a href="#CompositorShadowNodesTypesPlaneOptimal">Plane Optimal</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#CompositorWorkspaces">Workspaces</a><ul><ul><ul><li class="level4"><a href="#CompositorWorkspaces_connect">connect</a></li>
<li class="level4"><a href="#CompositorWorkspaces_connect_external">connect_external</a></li>
<li class="level4"><a href="#CompositorWorkspaces_alias">alias</a></li>
<li class="level4"><a href="#CompositorWorkspaces_buffer">buffer</a></li>
<li class="level4"><a href="#CompositorWorkspaces_connect_buffer">connect_buffer</a></li>
<li class="level4"><a href="#CompositorWorkspaces_connect_buffer_external">connect_buffer_external</a></li>
</ul>
</ul>
<li class="level2"><a href="#CompositorWorkspacesDataDependencies">Data dependencies between nodes and circular dependencies</a></li>
</ul>
</li>
<li class="level1"><a href="#CompositorSetupCode">Setting up code</a><ul><li class="level2"><a href="#CompositorWorkspacesSetupInitialize">Initializing the workspace</a></li>
<li class="level2"><a href="#CompositorWorkspacesSetupSimple">Simple bootstrap for beginners</a></li>
<li class="level2"><a href="#CompositorWorkspacesSetupAdvanced">Advanced C++ users</a></li>
</ul>
</li>
<li class="level1"><a href="#StereoAndSplitScreenRendering">Stereo and Split-Screen Rendering</a><ul><li class="level2"><a href="#CompositorWorkspacesStereoPerWorkspace">Per-Workspace offset and scale</a></li>
<li class="level2"><a href="#CompositorWorkspacesStereoViewportMask">Viewport modifier mask</a></li>
<li class="level2"><a href="#CompositorWorkspacesStereoExecutionMask">Execution mask</a></li>
<li class="level2"><a href="#CompositorWorkspacesStereoDefaultValues">Default values</a></li>
</ul>
</li>
<li class="level1"><a href="#AdvancedMSAA">Advanced MSAA</a><ul><li class="level2"><a href="#autotoc_md113">What is MSAA?</a><ul><li class="level3"><a href="#autotoc_md114">Supersampling Antialiasing (SSAA) vs MSAA</a></li>
<li class="level3"><a href="#autotoc_md115">MSAA approach to the problem</a><ul><li class="level4"><a href="#CompositorNodesTexturesMsaaResources">Resources</a></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md116">Ogre + MSAA with Implicit Resolves</a></li>
<li class="level2"><a href="#MSAAExplicitResolves">Ogre + MSAA with Explicit Resolves</a></li>
</ul>
</li>
<li class="level1"><a href="#CompositorRTV">RTV (RenderTargetView)</a><ul><li class="level2"><a href="#CompositorWhatisAnRtv">What is an RTV</a></li>
<li class="level2"><a href="#CompositorRtvSettings">RTV settings</a><ul><ul><li class="level4"><a href="#CompositorRtv_colour">colour</a></li>
<li class="level4"><a href="#CompositorRtv_depth">depth</a></li>
<li class="level4"><a href="#CompositorRtv_stencil">stencil</a></li>
<li class="level4"><a href="#CompositorRtv_depth_stencil">depth_stencil</a></li>
<li class="level4"><a href="#CompositorRtv_depth_pool">depth_pool</a></li>
<li class="level4"><a href="#CompositorRtv_depth_texture">depth_texture</a></li>
<li class="level4"><a href="#CompositorRtv_depth_format">depth_format</a></li>
<li class="level4"><a href="#CompositorRtv_depth_read_only">depth_read_only</a></li>
<li class="level4"><a href="#CompositorRtv_stencil_read_only">stencil_read_only</a></li>
</ul>
</ul>
</li>
<li class="level2"><a href="#CompositorRtv_Examples">RTV Examples</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_manual_Scripts_compositor"></a></p>
<p>The Compositor is a Core and key component in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0. In 1.x, it was just used for fancy post-processing effects. In 2.0, it's the way to tell <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> how you want to render the scene. Without setting it up, <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> won't render to screen.</p>
<p>With the Compositor, the user stops having to deal with setting Viewports, RenderTargets, updating these RenderTargets every frame, etc.</p>
<p>Instead the user has now to setup Nodes and a Workspace. The workspace is the top level system where the user indicates which Nodes he wants to use, how they will be connected, which global render textures will be declared (which can be seen by all nodes from the same workspace), where to render the final output (i.e. RenderWindow, an offscreen RenderTexture) and which SceneManager to use. The user can have multiple workspaces active at the same time.</p>
<p>The new Compositor system was heavily inspired by Blender's Compositor system. Picture from Blender:</p>
<p><img src="workspace.png" alt="" class="inline"/></p>
<p><img src="node.png" alt="" class="inline"/></p>
<p>Compositor script syntax hasn't changed much, which should make porting them quite easy. Internally though, the new system was written from scratch (while reusing &amp; reviewing some of the existing code); as the previous Compositor was stack-based, while the new one is node-based.</p>
<p>So, if you used to manipulate the Compositor directly from C++; porting efforts could be considerably bigger.</p>
<h1><a class="anchor" id="CompositorNodes"></a>
Nodes</h1>
<p>A compositor node most likely resembles what used to be "a compositor" in 1.x</p>
<p>The following node clears the RT and draws everything that is in the render queue #50</p>
<div class="fragment"><div class="line">compositor_node MyNode</div>
<div class="line">{</div>
<div class="line">    in 0 Input_as_MyLocaName <span class="comment">// Take input texture #0 and use the local name &quot;Input_as_MyLocaName&quot; for reference</span></div>
<div class="line">    </div>
<div class="line">    target Input_as_MyLocaName</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Clear to violet</span></div>
<div class="line">        pass clear</div>
<div class="line">        {</div>
<div class="line">            colour_value 1 0 1 1</div>
<div class="line">        }</div>
<div class="line">        pass render_scene</div>
<div class="line">        {</div>
<div class="line">            visibility_mask 0xffffffff   <span class="comment">//Viewport&#39;s visibility mask</span></div>
<div class="line"> </div>
<div class="line">            rq_first        50      <span class="comment">//Inclusive</span></div>
<div class="line">            rq_last     51      <span class="comment">//Not inclusive</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    out 0 Input_as_MyLocaName</div>
<div class="line">}</div>
</div><!-- fragment --><p>Where is <code>Input_as_MyLocaName</code> defined? What is its resolution? Its bit depth? The RT comes from the input channel, so the answer is that it depends on how the Workspace will connect this node. The Workspace may pass a local RTT declared in a previous node or it could pass RenderWindow.</p>
<h2><a class="anchor" id="CompositorNodesChannelsAndRTTs"></a>
Input &amp; output channels and RTTs</h2>
<p>A node's texture may come from three different sources:</p>
<ol type="1">
<li>It was <a class="el" href="compositor.html#CompositorNodesChannelsAndRTTsLocalTextures">locally declared</a>.</li>
<li>It comes from an <a class="el" href="compositor.html#CompositorNodesChannelsAndRTTsFromInputChannel">input channel</a>.</li>
<li>It is a <a class="el" href="compositor.html#CompositorNodesChannelsAndRTTsGlobal">global texture</a> declared in the Workspace. Global textures must use the <em><b>global_</b></em> prefix</li>
</ol>
<h3><a class="anchor" id="CompositorNodesChannelsAndRTTsLocalTextures"></a>
Locally declared textures</h3>
<p>The following script declares a local texture of resolution 800x600, clears it to violet, and puts it in the output channel #0 (so other compositor nodes can use it as input):</p>
<div class="fragment"><div class="line">compositor_node MyNode</div>
<div class="line">{</div>
<div class="line">    texture rt0 800 600 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">PFG_RGBA8_UNORM_SRGB</a></div>
<div class="line">    </div>
<div class="line">    target Input_as_MyLocaName</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Clear to violet</span></div>
<div class="line">        pass clear</div>
<div class="line">        {</div>
<div class="line">            colour_value 1 0 1 1</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    out 0 rt0</div>
<div class="line">}</div>
<div class="ttc" id="agroup___image_html_gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31"><div class="ttname"><a href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">Ogre::PFG_RGBA8_UNORM_SRGB</a></div><div class="ttdeci">@ PFG_RGBA8_UNORM_SRGB</div><div class="ttdef"><b>Definition:</b> OgrePixelFormatGpu.h:78</div></div>
</div><!-- fragment --><p>You may have noticed the syntax for declaring the RTT is similar as it was in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x</p>
<p>For more information on the syntax see <a class="el" href="compositor.html#CompositorNodesTextures">texture</a>.</p>
<h3><a class="anchor" id="CompositorNodesChannelsAndRTTsFromInputChannel"></a>
Textures coming from input channels</h3>
<p>Input channels are numbered. An input channel must be given a name so that they can be referenced locally at node scope by all target passes. There can't be any gaps (i.e. you can't use channels 0 &amp; 2 but not 1).</p>
<p>Output channels are also numbered and must be assigned an RTT. This number will be later used by the Workspace to perform the connections.</p>
<p>The workspace will be responsible for connecting node A's output channels with node B's input channels. In <b>other words, channels are a way to send, receive and share RTTs between nodes.</b></p>
<p>The only restriction is that global textures can't be used neither as input or output (global textures are referenced directly). There can be more input channels than output channels, viceversa, and there may be no input nor output channels (i.e. when working with global textures alone).</p>
<p>The following node definition (which does no rendering):</p><ol type="1">
<li>Takes input channel #0 and sends it to output channel #1</li>
<li>Takes input channel #1 and sends it through output channel #0 (in other words it flips the channels #0 &amp; #1).</li>
<li>Takes an uninitialized texture created locally to channel #2</li>
</ol>
<div class="fragment"><div class="line">compositor_node MyNode</div>
<div class="line">{</div>
<div class="line">    in 0 myFirstInput</div>
<div class="line">    in 1 mySecondInput</div>
<div class="line">    </div>
<div class="line">    texture rt0 target_width_scaled 0.25 target_height_scaled 0.25 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">PFG_RGBA8_UNORM_SRGB</a></div>
<div class="line"> </div>
<div class="line">    out 0 mySecondInput</div>
<div class="line">    out 1 myFirstInput</div>
<div class="line">    out 2 rt0</div>
<div class="line">}</div>
</div><!-- fragment --><p>Drawing inspiration from Blender's compositor system, the little dots on the left would be the input channels, while the dots on right would be the output texture channels:</p>
<p><img src="channels.png" alt="" class="inline"/></p>
<h3><a class="anchor" id="CompositorNodesChannelsAndRTTsGlobal"></a>
Global Textures</h3>
<p>Global textures are declared <b>at workspace scope</b> and have the same syntax as local textures. There are a few restrictions:</p>
<ol type="1">
<li>Global texture names must contain the <em><b>global_</b></em> prefix. Inversely, any local texture or input channel trying to use a name that starts with <code>global_</code> is illegal.</li>
<li>They can't be used in input or output channels.</li>
<li>Global textures can be seen by any node belonging to the same workspace, but they can't see a global texture that belongs to a different workspace.</li>
<li>If a Node uses a global texture that the Workspace didn't declare, execution of the workspace will fail.</li>
</ol>
<p>Global textures are as powerful/dangerous as global variables are in C++. The main reason of their existence is that many nodes may use temporary rtts to perform their work, and it's <em>very</em> wasteful to declare these intermediate rtts on every node when they can be shared and reused.</p>
<p>Sharing and reusage can also be achieved through input &amp; output channels, however for temporary rtts (or rtts that are accessed very frequently, i.e. a deferred shader's G Buffer) it would lead to connection hell; and hence global textures are a much better fit.</p>
<h3><a class="anchor" id="autotoc_md110"></a>
compositor_node parameters</h3>
<ul>
<li><a class="el" href="compositor.html#CompositorNode_in">in</a></li>
<li><a class="el" href="compositor.html#CompositorNode_out">out</a></li>
<li><a class="el" href="compositor.html#CompositorNode_in_buffer">in_buffer</a></li>
<li><a class="el" href="compositor.html#CompositorNode_out_buffer">out_buffer</a></li>
<li><a class="el" href="compositor.html#CompositorNode_custom_id">custom_id</a></li>
</ul>
<h4><a class="anchor" id="CompositorNode_in"></a>
in</h4>
<p>The input(s) to this node. This clause may be repeated. A node definition may have no inputs.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">in &lt;channel_id&gt; &lt;local_texture_name&gt;</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>channel_id is a number in range [0; inf) but must be consecutive and continuous (no gaps, i.e. define channel 0, 2, but not 1).</td></tr>
    <tr><td class="paramname">local_texture_name</td><td>An arbitrary &amp; unique name, cannot start with <code>global_</code>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorNode_out"></a>
out</h4>
<p>The input(s) from this node. This clause may be repeated. A node definition may have no outputs.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">out &lt;channel_id&gt; &lt;local_texture_name&gt;</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>channel_id is a number in range [0; inf) but must be consecutive and continuous (no gaps, i.e. define channel 0, 2, but not 1).</td></tr>
    <tr><td class="paramname">local_texture_name</td><td>An arbitrary &amp; unique name, cannot start with <code>global_</code>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorNode_in_buffer"></a>
in_buffer</h4>
<p>For UAV buffers. Same as with regular input textures, except you can reference global buffers, and global buffers don't have to start with <code>global_</code>.</p>
<p>If a local buffer and a global buffer have the same name, the local buffer takes precedence.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">in_buffer &lt;channel_id&gt; &lt;buffer_name&gt;</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>channel_id is a number in range [0; inf) but must be consecutive and continuous (no gaps, i.e. define channel 0, 2, but not 1).</td></tr>
    <tr><td class="paramname">local_texture_name</td><td>An arbitrary &amp; unique name.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorNode_out_buffer"></a>
out_buffer</h4>
<p>For UAV buffers. Same as with regular output textures, except you can reference global buffers, and global buffers don't have to start with <code>global_</code>.</p>
<p>If a local buffer and a global buffer have the same name, the local buffer takes precedence.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">out_buffer &lt;channel_id&gt; &lt;buffer_name&gt;</div>
</div><!-- fragment --></dd></dl>
<p>For parameters, see <a class="el" href="compositor.html#CompositorNode_in_buffer">in_buffer</a></p>
<h4><a class="anchor" id="CompositorNode_custom_id"></a>
custom_id</h4>
<p>Custom string that will be hashed to identify this Node definition. Useful for classifying nodes into categories.</p>
<p>Multiple nodes can have the same custom_id.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">custom_id &lt;string&gt;</div>
</div><!-- fragment --></dd></dl>
<p>From C++ you can use:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyListener : <a class="code" href="class_ogre_1_1_compositor_workspace_listener.html">Ogre::CompositorWorkspaceListener</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="class_ogre_1_1_compositor_workspace_listener.html#a30e82f9915494734c77e2be6386045bd">passPreExecute</a>( <a class="code" href="class_ogre_1_1_compositor_pass.html">Ogre::CompositorPass</a> *pass )<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">if</span>( pass-&gt;<a class="code" href="class_ogre_1_1_compositor_pass.html#a1fcf0351919f3f8fa422dae558bbf64b">getParentNode</a>()-&gt;<a class="code" href="class_ogre_1_1_compositor_node.html#a761eb7b05dbc96b29b4fac5110e6fe40">getDefinition</a>()-&gt;<a class="code" href="class_ogre_1_1_compositor_node_def.html#a36e47a50b2435b56a804cef26f8e86fe">mCustomIdentifier</a> == <span class="stringliteral">&quot;CustomString&quot;</span> )</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// This is our node</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_ogre_1_1_compositor_node_def_html_a36e47a50b2435b56a804cef26f8e86fe"><div class="ttname"><a href="class_ogre_1_1_compositor_node_def.html#a36e47a50b2435b56a804cef26f8e86fe">Ogre::CompositorNodeDef::mCustomIdentifier</a></div><div class="ttdeci">IdString mCustomIdentifier</div><div class="ttdef"><b>Definition:</b> OgreCompositorNodeDef.h:103</div></div>
<div class="ttc" id="aclass_ogre_1_1_compositor_node_html_a761eb7b05dbc96b29b4fac5110e6fe40"><div class="ttname"><a href="class_ogre_1_1_compositor_node.html#a761eb7b05dbc96b29b4fac5110e6fe40">Ogre::CompositorNode::getDefinition</a></div><div class="ttdeci">const CompositorNodeDef * getDefinition() const</div><div class="ttdef"><b>Definition:</b> OgreCompositorNode.h:162</div></div>
<div class="ttc" id="aclass_ogre_1_1_compositor_pass_html"><div class="ttname"><a href="class_ogre_1_1_compositor_pass.html">Ogre::CompositorPass</a></div><div class="ttdoc">Abstract class for compositor passes.</div><div class="ttdef"><b>Definition:</b> OgreCompositorPass.h:77</div></div>
<div class="ttc" id="aclass_ogre_1_1_compositor_pass_html_a1fcf0351919f3f8fa422dae558bbf64b"><div class="ttname"><a href="class_ogre_1_1_compositor_pass.html#a1fcf0351919f3f8fa422dae558bbf64b">Ogre::CompositorPass::getParentNode</a></div><div class="ttdeci">const CompositorNode * getParentNode() const</div><div class="ttdef"><b>Definition:</b> OgreCompositorPass.h:187</div></div>
<div class="ttc" id="aclass_ogre_1_1_compositor_workspace_listener_html"><div class="ttname"><a href="class_ogre_1_1_compositor_workspace_listener.html">Ogre::CompositorWorkspaceListener</a></div><div class="ttdef"><b>Definition:</b> OgreCompositorWorkspaceListener.h:47</div></div>
<div class="ttc" id="aclass_ogre_1_1_compositor_workspace_listener_html_a30e82f9915494734c77e2be6386045bd"><div class="ttname"><a href="class_ogre_1_1_compositor_workspace_listener.html#a30e82f9915494734c77e2be6386045bd">Ogre::CompositorWorkspaceListener::passPreExecute</a></div><div class="ttdeci">virtual void passPreExecute(CompositorPass *pass)</div><div class="ttdoc">Called when each pass is about to be executed.</div><div class="ttdef"><b>Definition:</b> OgreCompositorWorkspaceListener.h:65</div></div>
</div><!-- fragment --><h3><a class="anchor" id="CompositorNodesChannelsAndRTTsMainRenderTarget"></a>
Main RenderTarget</h3>
<p>When creating the Workspace instance, the C++ code will ask for the RT which should be the ultimate target (i.e. the RenderWindow). This RT is very important as keywords like <code>target_width_scaled</code> and settings like default msaa &amp; pixel format will be based on the attributes from this main RT. This feature will be seen in more detail in the Workspace section.</p>
<dl class="section note"><dt>Note</dt><dd>By default you cannot use the main RenderTarget as a texture (because it's usually the RenderWindow and D3D and OpenGL don't allow it), and doing it may result in a crash.<br  />
<br  />
 It is possible to manually call <code>node-&gt;connectFinalRT</code> and supply a texture pointer (i.e. if the final RenderTarget is a RenderTexture) that can be bound. An automated way of doing this is not yet implemented.</dd></dl>
<h2><a class="anchor" id="CompositorNodesTarget"></a>
Target</h2>
<p>Targets include multiple passes. Their main purpose is define to which RenderTarget the passes will render to.</p>
<p>What's worth noting is that targets accept an optional parameter '<em>slice</em>'.</p>
<p>The slice parameter is optional and refers to which slice or face from a 3D texture (or cubemap or 2D array) to use from the given texture. Valid values can be numeric or the hint '+X'. '-X', '+Y', '-Y', '+Z', and '-Z'.</p>
<dl class="section note"><dt>Note</dt><dd>The word 'slice' must not be written. Just write 'target myTexture +X' to work.</dd>
<dd>
When the target is a 3D/Cubemap/array texture, if the slice goes out of bounds, an exception will be raised. If the target is a 2D or 1D texture, this value is silently ignored. Default: slice = 0</dd></dl>
<h3><a class="anchor" id="autotoc_md111"></a>
target parameters</h3>
<ul>
<li><a class="el" href="compositor.html#CompositorTarget_target_level_barrier">target_level_barrier</a></li>
</ul>
<h4><a class="anchor" id="CompositorTarget_target_level_barrier"></a>
target_level_barrier</h4>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">target_level_barrier [yes|no]</div>
</div><!-- fragment --></dd></dl>
<p>Default value is no.</p>
<p>When yes, this setting is meant to be used with <code>skip_load_store_semantics</code> for optimization on mobile/TBDR targets, but should be used with care.</p>
<p><code>skip_load_store_semantics</code> allows OgreNext to execute multiple consecutive passes as if they were only one.</p>
<p>An obstacle for this is that barriers from all theses passes must be issued <em>before</em> the first pass executes; otherwise the passes need to be internally broken up and OgreNext will complain if <code>skip_load_store_semantics on</code> but we can't merge the passes.</p>
<p><code>target_level_barrier yes</code> means that an extra hidden pass will be inserted at the beginning of the target and issue all necessary barriers from subsequent passes:</p>
<div class="fragment"><div class="line">target rt_renderwindow</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// By having this set to true or yes, a barrier will be issued</span></div>
<div class="line">    <span class="comment">// to cover all 4 passes in this target, which happens</span></div>
<div class="line">    <span class="comment">// before the first render_quad</span></div>
<div class="line">    target_level_barrier <span class="keyword">true</span></div>
<div class="line"> </div>
<div class="line">    pass render_quad</div>
<div class="line">    {</div>
<div class="line">        load</div>
<div class="line">        {</div>
<div class="line">            all     dont_care</div>
<div class="line">        }</div>
<div class="line">        store</div>
<div class="line">        {</div>
<div class="line">            all     dont_care</div>
<div class="line">            colour  store</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        material MyMaterial</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pass render_scene</div>
<div class="line">    {</div>
<div class="line">        skip_load_store_semantics <span class="keyword">true</span></div>
<div class="line"> </div>
<div class="line">        rq_first    0</div>
<div class="line">        rq_last     5</div>
<div class="line"> </div>
<div class="line">        shadows     MainCharacter reuse</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pass render_quad</div>
<div class="line">    {</div>
<div class="line">        skip_load_store_semantics <span class="keyword">true</span></div>
<div class="line">        material <a class="code" href="namespace_ogre_1_1_texture_source_type.html#a487889f4cfc926c4eaaf01e2f4e68c5aa602ee38ea2347d313beab4dabced99fb">Compositor</a>/UpsampleDepth</div>
<div class="line">        input 0 worldRt_depth</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pass render_scene</div>
<div class="line">    {</div>
<div class="line">        skip_load_store_semantics <span class="keyword">true</span></div>
<div class="line"> </div>
<div class="line">        rq_first    14</div>
<div class="line">        rq_last     249</div>
<div class="line"> </div>
<div class="line">        shadows     NormalShadows reuse</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_ogre_1_1_texture_source_type_html_a487889f4cfc926c4eaaf01e2f4e68c5aa602ee38ea2347d313beab4dabced99fb"><div class="ttname"><a href="namespace_ogre_1_1_texture_source_type.html#a487889f4cfc926c4eaaf01e2f4e68c5aa602ee38ea2347d313beab4dabced99fb">Ogre::TextureSourceType::Compositor</a></div><div class="ttdeci">@ Compositor</div><div class="ttdoc">Created by compositor.</div><div class="ttdef"><b>Definition:</b> OgreTextureGpu.h:181</div></div>
</div><!-- fragment --><p><b>Note that not always <code>target_level_barrier yes</code> can be successful.</b></p>
<p>For example if pass <code>A</code> needs texture <code>X</code> to be in state <code>Texture</code> for sampling but pass <code>C</code> needs that same texture in state <code>Uav</code> then we have a contradiction as we can't transition to two states at the same time.</p>
<p>The only solution is to break up the passes and issue two barriers. Note that you can however issue break ups manually:</p>
<div class="fragment"><div class="line">target rt_renderwindow</div>
<div class="line">{</div>
<div class="line">    target_level_barrier <span class="keyword">true</span></div>
<div class="line">    <span class="comment">// Pass A</span></div>
<div class="line">    pass render_quad {}</div>
<div class="line">    <span class="comment">// Pass B</span></div>
<div class="line">    pass render_quad {skip_load_store_semantics <span class="keyword">true</span>}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">target rt_renderwindow</div>
<div class="line">{</div>
<div class="line">    target_level_barrier <span class="keyword">true</span></div>
<div class="line">    <span class="comment">// Pass C</span></div>
<div class="line">    pass render_quad {}</div>
<div class="line">    <span class="comment">// Pass D</span></div>
<div class="line">    pass render_quad {skip_load_store_semantics <span class="keyword">true</span>}</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="CompositorNodesPasses"></a>
Passes</h2>
<p>Types of passes:</p>
<ul>
<li><a class="el" href="compositor.html#CompositorNodesPassesClear">clear</a> (PASS_CLEAR)</li>
<li><a class="el" href="compositor.html#CompositorNodesPassesGenerateMipmaps">generate_mipmaps</a> (PASS_MIPMAP)</li>
<li><a class="el" href="compositor.html#CompositorNodesPassesQuad">render_quad</a> (PASS_QUAD)</li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene">render_scene</a> (PASS_SCENE)</li>
<li>shadows (PASS_SHADOWS)</li>
<li>stencil (PASS_STENCIL)</li>
<li><a class="el" href="compositor.html#CompositorNodesPassesUavQueue">uav_queue</a> (PASS_UAV)</li>
<li><a class="el" href="compositor.html#CompositorNodesPassesCompute">compute</a> (PASS_COMPUTE)</li>
<li>custom (PASS_CUSTOM)</li>
</ul>
<h3><a class="anchor" id="autotoc_md112"></a>
pass parameters</h3>
<p>All passes share the following script parameters:</p>
<ul>
<li><a class="el" href="compositor.html#CompositorPass_pass">pass</a></li>
<li><a class="el" href="compositor.html#CompositorPass_num_initial">num_initial</a></li>
<li><a class="el" href="compositor.html#CompositorPass_flush_command_buffers">flush_command_buffers</a></li>
<li><a class="el" href="compositor.html#CompositorPass_identifier">identifier</a></li>
<li><a class="el" href="compositor.html#CompositorPass_execution_mask">execution_mask</a></li>
<li><a class="el" href="compositor.html#CompositorPass_viewport_modifier_mask">viewport_modifier_mask</a></li>
<li><a class="el" href="compositor.html#CompositorPass_colour_write">colour_write</a></li>
<li><a class="el" href="compositor.html#CompositorPass_profiling_id">profiling_id</a></li>
<li><a class="el" href="compositor.html#CompositorPass_expose">expose</a></li>
<li><a class="el" href="compositor.html#CompositorPass_skip_load_store_semantics">skip_load_store_semantics</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load">load</a></li>
<li><a class="el" href="compositor.html#CompositorPass_store">store</a></li>
</ul>
<h4><a class="anchor" id="CompositorPass_pass"></a>
pass</h4>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">pass &lt;type&gt; [customId]</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>must be one of the <a class="el" href="compositor.html#CompositorNodesPasses">supported types</a>: clear, quad, resolve, render_scene, stencil, custom, etc.</td></tr>
    <tr><td class="paramname">customId</td><td>Optional. It is used by custom passes to give the registered custom pass provider the means to identify multiple types, in case there are more than one type of custom passes.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_num_initial"></a>
num_initial</h4>
<p>Number of times this pass will be executed. Default is -1, which means always execute.</p>
<p>When the execution count hits that value, it won't executed again until a d3d device reset, resize or workspace recreation (the execution count is reset and executed N times again)</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">num_initial &lt;number&gt;</div>
</div><!-- fragment --></dd></dl>
<p>This parameter replaces the <code>only_initial</code> parameter in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x.</p>
<h4><a class="anchor" id="CompositorPass_flush_command_buffers"></a>
flush_command_buffers</h4>
<p>Whether to flush the command buffer at the end of the pass.</p>
<p>This can incur in a performance overhead (see OpenGL's glFlush and D3D11' ID3D11DeviceContext::Flush) for info.</p>
<p>Usually you want to leave this off. However for VR applications that must meet VSync, profiling may show your workload benefits from submitting earlier so the GPU can start right away executing rendering commands.</p>
<p>The main reason to use this is in CPU-bound scenarios where the GPU starts too late after sitting idle.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">flush_command_buffers &lt;off|on&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorPass_identifier"></a>
identifier</h4>
<p>An arbitrary user-defined numeric ID used for identifying individual passes in the C++ code.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">identifier &lt;number&gt;</div>
</div><!-- fragment --></dd></dl>
<p>From C++ you can access it via:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyListener : <a class="code" href="class_ogre_1_1_compositor_workspace_listener.html">Ogre::CompositorWorkspaceListener</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="class_ogre_1_1_compositor_workspace_listener.html#a30e82f9915494734c77e2be6386045bd">passPreExecute</a>( <a class="code" href="class_ogre_1_1_compositor_pass.html">Ogre::CompositorPass</a> *pass )<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">if</span>( pass-&gt;<a class="code" href="class_ogre_1_1_compositor_pass.html#a123ad972ffeab36c66f31c26a2b639e4">getDefinition</a>()-&gt;<a class="code" href="class_ogre_1_1_compositor_pass_def.html#ab32b226a745dfd996d7b94a7197044eb">mIdentifier</a> == 1234u )</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// This is our pass</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_ogre_1_1_compositor_pass_def_html_ab32b226a745dfd996d7b94a7197044eb"><div class="ttname"><a href="class_ogre_1_1_compositor_pass_def.html#ab32b226a745dfd996d7b94a7197044eb">Ogre::CompositorPassDef::mIdentifier</a></div><div class="ttdeci">uint32 mIdentifier</div><div class="ttdoc">Custom value in case there's a listener attached (to identify the pass)</div><div class="ttdef"><b>Definition:</b> OgreCompositorPassDef.h:138</div></div>
<div class="ttc" id="aclass_ogre_1_1_compositor_pass_html_a123ad972ffeab36c66f31c26a2b639e4"><div class="ttname"><a href="class_ogre_1_1_compositor_pass.html#a123ad972ffeab36c66f31c26a2b639e4">Ogre::CompositorPass::getDefinition</a></div><div class="ttdeci">const CompositorPassDef * getDefinition() const</div><div class="ttdef"><b>Definition:</b> OgreCompositorPass.h:185</div></div>
</div><!-- fragment --><h4><a class="anchor" id="CompositorPass_execution_mask"></a>
execution_mask</h4>
<p>8-bit hex value. Specifies the execution mask. For more information see <a class="el" href="compositor.html#StereoAndSplitScreenRendering">Stereo and Split-Screen Rendering for more information</a>. Default is 0xFF except for clear passes, which default to 0x01.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">execution_mask &lt;hex number&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorPass_viewport_modifier_mask"></a>
viewport_modifier_mask</h4>
<p>8-bit hex value. Specifies the viewport modifier mask. For more information see [Stereo and Split-Screen Rendering for more <a class="el" href="compositor.html#StereoAndSplitScreenRendering">Stereo and Split-Screen Rendering for more information</a>. Default is 0xFF except for clear passes, which default to 0x00.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">viewport_modifier_mask &lt;hex number&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorPass_colour_write"></a>
colour_write</h4>
<p>Disables colour writes. Useful for Z prepass passes; or pixel shaders that output to an UAV instead of a regular RenderTarget (like a Render Texture).</p>
<p>Default: on.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">colour_write &lt;off|on&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorPass_profiling_id"></a>
profiling_id</h4>
<p>User defined text for identifying this pass by name in profilers and GPU debuggers such as <a href="https://renderdoc.org/">RenderDoc</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">profiling_id <span class="stringliteral">&quot;name&quot;</span></div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorPass_viewport"></a>
viewport</h4>
<p>Specifies the viewport. Supported by many other passes (e.g. render_quad, render_scene). The default is <code>0 0 1 1</code> which covers the entire screen. Values should be between 0 and 1.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">viewport [idx] &lt;left&gt; &lt;top&gt; &lt;width&gt; &lt;height&gt;</div>
<div class="line">    [&lt;scissor_left&gt; &lt;scissor_top&gt; &lt;scissor_width&gt; &lt;scissor_height&gt;]</div>
</div><!-- fragment --></dd></dl>
<p>When 4 parameters are suplied, the scissor box will match the viewport's. All 8 parameters allow to set a custom scissor box.</p>
<dl class="section note"><dt>Note</dt><dd>Scissor testing must be enabled by <a class="el" href="struct_ogre_1_1_hlms_macroblock.html#a6992c372553d3cf1045f403bdd1a488c">Ogre::HlmsMacroblock::mScissorTestEnabled</a> for it to work, we just set the size here.</dd></dl>
<p>When the optional 'idx' parameter is supplied at the beginning there will be either 5 or 9 parameters instead of 4 or 8 respectively.</p>
<p>This index allows you to set multiple viewports for e.g. <a class="el" href="compositor.html#CompositorNodesPassesRenderScene_instanced_stereo">instanced_stereo</a> or for shaders that make use of gl_ViewportIndex/SV_ViewportArrayIndex. When not provided, this value defaults to 0. The value is in range [0; 16)</p>
<p>The Compositor will automatically share Viewport pointers between different passes to the same RenderTarget (even for different nodes) as long as they share the exact same parameters.</p>
<h4><a class="anchor" id="CompositorPass_expose"></a>
expose</h4>
<p>Tells OgreNext that you plan on using <code>texture_name</code> for sampling during this pass.</p>
<p>Usually this can be inferred (e.g. render_quad's input parameter).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">expose &lt;texture_name&gt;</div>
</div><!-- fragment --></dd></dl>
<p>Reasons for using <code>expose</code>:</p>
<ol type="1">
<li>You plan on using an exposed texture from C++, e.g. via <a class="el" href="class_ogre_1_1_scene_manager.html#a705ea2e352334d130af77391bc3605a0">Ogre::SceneManager::getCompositorTextures</a>.</li>
<li>You set a low level material texture directly to that texture (either via name or pointer) and the Compositor isn't aware of it.</li>
</ol>
<p>OgreNext must know which textures may or will be used during the pass so resource transitions and barriers can be issued in explicit APIs like DX12 and Vulkan (also OpenGL has rudimentary memory barriers that are needed if Compute Shaders are involved).</p>
<p>Without it, you may get exceptions when using the Vulkan RenderSystem, or Vulkan Validation Errors (when debug validation layers are active).</p>
<h4><a class="anchor" id="CompositorPass_skip_load_store_semantics"></a>
skip_load_store_semantics</h4>
<p>When yes, the load and store semantics will be ignored. Use with care as improper usage may lead to rendering bugs or crashes.</p>
<p>Normally OgreNext tries to merge passes when possible but certain advanced uses are impossible or difficult to get automatically merged, thus this flag indicates we want.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">skip_load_store_semantics [yes|no]</div>
</div><!-- fragment --></dd></dl>
<p>e.g.</p>
<div class="fragment"><div class="line">compositor_node MyNode</div>
<div class="line">{</div>
<div class="line">    in 0 rtt</div>
<div class="line"> </div>
<div class="line">    target rtt</div>
<div class="line">    {</div>
<div class="line">        pass render_quad</div>
<div class="line">        {</div>
<div class="line">            load</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Do not load or clear anything to colour, this pass will overwrite everything</span></div>
<div class="line">                all     clear</div>
<div class="line">                colour  dont_care</div>
<div class="line">            }</div>
<div class="line">            store</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Only save colour, don&#39;t care about depth/stencil</span></div>
<div class="line">                all     dont_care</div>
<div class="line">                colour  store</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            material MaterialThatWritesToEveryColourPixel</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        pass render_scene</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Inherit the same semantics of the previous pass</span></div>
<div class="line">            skip_load_store_semantics <span class="keyword">true</span></div>
<div class="line"> </div>
<div class="line">            rq_first 0</div>
<div class="line">            rq_last max</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// We can NOT use recalculate or first, because</span></div>
<div class="line">            <span class="comment">// doing so will end the pass, and we&#39;re explicitly</span></div>
<div class="line">            <span class="comment">// asking Ogre to not close the pass.</span></div>
<div class="line">            shadows     MyShadowNode reuse</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The reason you should be careful is that we assume you know where you're drawing. Consider the following example:</p>
<div class="fragment"><div class="line">target TargetA</div>
<div class="line">{</div>
<div class="line">    pass render_quad {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">target UnrelatedTargetB</div>
<div class="line">{</div>
<div class="line">    pass render_quad { skip_load_store_semantics <span class="keyword">true</span> }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This script will <em>not</em> behave as expected because <b>both render_quad passes will draw to TargetA!</b></p>
<p>This is because with <code>skip_load_store_semantics</code> you're telling <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> not to set <code>UnrelatedTargetB</code> as the current target <em>because OgreNext should assume it already is</em> the current target.</p>
<p>Likewise there should be no barriers to execute because barriers force the pass to 'close' which means store semantics must be executed; and to open another pass we must execute load semantics again (see <a class="el" href="compositor.html#CompositorTarget_target_level_barrier">target_level_barrier</a> to solve this problem).</p>
<p>We try to perform validation checks in Debug mode to avoid these type of errors, but we can't cover them all.</p>
<p>This setting is an optimization specifically aimed at mobile and you should pay attention to errors, the Ogre.log, Vulkan Validation Layers, and tools like <a href="https://renderdoc.org/">RenderDoc</a> to be sure rendering is happening as intended.</p>
<h4><a class="anchor" id="CompositorPass_load"></a>
load</h4>
<p>This is often referred as "Load Actions". To understand their relevancy please read <a href="{#Ogre22LoadStoreSemantics}">Load Store semantics</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    all             clear</div>
<div class="line">    clear_colour    0.2 0.4 0.6 1</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<ul>
<li><a class="el" href="compositor.html#CompositorPass_load_all">all</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_colour">colour</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_depth">depth</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_stencil">stencil</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_colour">clear_colour</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_colour">colour_value</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_colour_reverse_depth_aware">clear_colour_reverse_depth_aware</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_depth">clear_depth</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_stencil">clear_stencil</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_warn_if_rtv_was_flushed">warn_if_rtv_was_flushed</a></li>
</ul>
<h4><a class="anchor" id="CompositorPass_load_all"></a>
all (load)</h4>
<p>Sets all RTV parameters (all colour targets in MRT + depth + stencil) to the same load action.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    all [dont_care|clear|clear_on_tilers|load]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dont_care</td><td>Assume uninitialized values are present and will be completely overwritten. This is discouraged on depth &amp; stencil buffers because it precludes optimizations (e.g. Hi-Z, Early Z, Depth Compression, etc.). See <a class="el" href="namespace_ogre_1_1_load_action.html#a5660308b2075405f9623301506fc922e">LoadAction::DontCare</a>. </td></tr>
    <tr><td class="paramname">clear</td><td>Clear the whole texture to the set clear_colour/clear_depth/clear_stencil values. See <a class="el" href="namespace_ogre_1_1_load_action.html#a5660308b2075405f9623301506fc922e">LoadAction::Clear</a>. </td></tr>
    <tr><td class="paramname">clear_on_tilers</td><td>See <a class="el" href="namespace_ogre_1_1_load_action.html#a5660308b2075405f9623301506fc922e">LoadAction::ClearOnTilers</a>. </td></tr>
    <tr><td class="paramname">load</td><td>Load the contents that were stored in the texture. See <a class="el" href="namespace_ogre_1_1_load_action.html#a5660308b2075405f9623301506fc922e">LoadAction::Load</a>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_load_colour"></a>
colour (load)</h4>
<p>Sets the load action for each and/or all the colour textures. Does nothing if there are no colour textures.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    colour [dont_care|clear|clear_on_tilers|load]</div>
<div class="line">    colour [N] [dont_care|clear|clear_on_tilers|load]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Value in range [0; num_mrt) to reference the colour target in an MRT. For non-MRT RTVs, use 0 or skip this parameter.</td></tr>
    <tr><td class="paramname">dont_care|clear|clear_on_tilers|load</td><td>See Load Actions in <a class="el" href="compositor.html#CompositorPass_load_all">all</a>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_load_depth"></a>
depth (load)</h4>
<p>Sets the load action for the Depth Buffer. Does nothing if there is no depth buffer.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    depth [dont_care|clear|clear_on_tilers|load]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dont_care|etc</td><td>See Load Actions in <a class="el" href="compositor.html#CompositorPass_load_all">all</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For performance reasons, the load action of the depth buffer should be the same as the stencil one.</dd></dl>
<h4><a class="anchor" id="CompositorPass_load_stencil"></a>
stencil (load)</h4>
<p>Sets the load action for the Stencil Buffer. Does nothing if there is no stencil buffer.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    stencil [dont_care|clear|clear_on_tilers|load]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dont_care|etc</td><td>See Load Actions in <a class="el" href="compositor.html#CompositorPass_load_all">all</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For performance reasons, the load action of the depth buffer should be the same as the stencil one.</dd></dl>
<h4><a class="anchor" id="CompositorPass_load_clear_colour"></a>
clear_colour / colour_value (load)</h4>
<p>Sets the colour to set the texture to. The kayword colour_value is the same, and retained due to old naming conventions.</p>
<dl class="section note"><dt>Note</dt><dd><b>IMPORTANT:</b> The load action for this colour target <b>must</b> be set to clear or clear_on_tilers. Otherwise this value is ignored.</dd></dl>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    clear_colour [N] &lt;r g b a&gt;</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Value in range [0; num_mrt) to reference the colour target in an MRT. When absent, it sets all colour targets in the MRT to the same value.</td></tr>
    <tr><td class="paramname">rgba</td><td>Four float values to set the colour target to. e.g. <code>clear_colour 0.2 0.4 0.5 1.0</code>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_load_clear_colour_reverse_depth_aware"></a>
clear_colour_reverse_depth_aware (load)</h4>
<p>Sets the colour texture to either the <code>clear_colour</code> or <code>White - clear_colour</code> depending on whether OgreNext is configured to use reverse depth. See <a class="el" href="class_ogre_1_1_render_system.html#a0f6d872e0df3b080da903d9e0f4af6ba">Ogre::RenderSystem::isReverseDepth</a>.</p>
<p>This setting is useful when storing depth data into colour textures such as <code>PFG_R32_FLOAT</code>.</p>
<dl class="section note"><dt>Note</dt><dd><b>IMPORTANT:</b> The load action for this colour target <b>must</b> be set to clear or clear_on_tilers. Otherwise this value is ignored.</dd></dl>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    clear_colour_reverse_depth_aware [N] &lt;r g b a&gt;</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Value in range [0; num_mrt) to reference the colour target in an MRT. When absent, it sets all colour targets in the MRT to the same value.</td></tr>
    <tr><td class="paramname">rgba</td><td>Four float values to set the colour target to. e.g. <code>0.2 0.4 0.5 1.0</code>. When using reverse Z, the final colour value will be <code>0.8 0.6 0.5 0.0</code>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_load_clear_depth"></a>
clear_depth (load)</h4>
<p>Sets the value to set the depth buffer to.</p>
<dl class="section note"><dt>Note</dt><dd><b>IMPORTANT:</b> The load action for depth <b>must</b> be set to clear or clear_on_tilers. Otherwise this value is ignored.</dd></dl>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    clear_depth &lt;value&gt;</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Floating point value to set the depth to. Usually in range [0; 1], but not necessarily (depends on API support). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If OgreNext is using reverse depth, the depth value will be set to 1.0 - value.</dd></dl>
<h4><a class="anchor" id="CompositorPass_load_clear_stencil"></a>
clear_stencil (load)</h4>
<p>Sets the value to set the stencil buffer to.</p>
<dl class="section note"><dt>Note</dt><dd><b>IMPORTANT:</b> The load action for stencil <b>must</b> be set to clear or clear_on_tilers. Otherwise this value is ignored.</dd></dl>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    clear_stencil &lt;value&gt;</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Integer value to set the depth to. Usually in range [0; 255] since to date all known stencil formats are 8-bit.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_load_warn_if_rtv_was_flushed"></a>
warn_if_rtv_was_flushed (load)</h4>
<p>See <a class="el" href="class_ogre_1_1_compositor_pass_def.html#a03f4a196d4bc9d62b967019c5bf7c5ac" title="Will issue a warning (by raising an exception) if Ogre is forced to flush the RenderTarget,...">Ogre::CompositorPassDef::mWarnIfRtvWasFlushed</a></p>
<p>Default: False.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">load</div>
<div class="line">{</div>
<div class="line">    warn_if_rtv_was_flushed [on|off]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorPass_store"></a>
store</h4>
<p>This is often referred as "Store Actions". To understand their relevancy please read <a href="{#Ogre22LoadStoreSemantics}">Load Store semantics</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">store</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// These are the optimum settings unless you need to reuse more data</span></div>
<div class="line">    <span class="comment">// (e.g. you need the depth buffer, or you want access to MSAA data before resolving).</span></div>
<div class="line">    colour  store_or_resolve</div>
<div class="line">    depth   dont_care</div>
<div class="line">    stencil dont_care</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<ul>
<li><a class="el" href="compositor.html#CompositorPass_store_all">all</a></li>
<li><a class="el" href="compositor.html#CompositorPass_store_colour">colour</a></li>
<li><a class="el" href="compositor.html#CompositorPass_store_depth">depth</a></li>
<li><a class="el" href="compositor.html#CompositorPass_store_stencil">stencil</a></li>
</ul>
<h4><a class="anchor" id="CompositorPass_store_all"></a>
all (store)</h4>
<p>Sets all RTV parameters (all colour targets in MRT + depth + stencil) to the same store action.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">store</div>
<div class="line">{</div>
<div class="line">    all [dont_care|store|resolve|store_and_resolve|store_or_resolve]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dont_care</td><td>Discard, leaving the texture contents in an undefined state. You should not attempt to read from it after this. See <a class="el" href="namespace_ogre_1_1_store_action.html#a1605e763b81f293b404de4a521f541ca">StoreAction::DontCare</a>. </td></tr>
    <tr><td class="paramname">store</td><td>Do not resolve. Useful if you have to interrupt rendering to a RenderTarget, switch to another RenderTarget, and come back to continue rendering; asuming you didn't need to sample from this texture (to fetch what has been rendered so far). <br  />
 See <a class="el" href="namespace_ogre_1_1_store_action.html#a1605e763b81f293b404de4a521f541ca">StoreAction::Store</a>. </td></tr>
    <tr><td class="paramname">resolve</td><td>Always resolve the texture once we're done rendering, and we do not care about the contents of the MSAA surface. This flag won't work on non-MSAA textures and will raise an exception. You should not continue rendering to this texture after this, unless you clear it. <br  />
 See <a class="el" href="namespace_ogre_1_1_store_action.html#a1605e763b81f293b404de4a521f541caa29fa644125a73b0ab4d4e9598b76eb74">StoreAction::MultisampleResolve</a>. </td></tr>
    <tr><td class="paramname">store_and_resolve</td><td>Always resolve the texture once we're done rendering, and we do care about the contents of the MSAA surface. It is valid to use this flag without an MSAA texture. This flag is mostly meant for explicit-resolve textures as <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> users have no way of accessing MSAA contents. However it may be useful if you need to interrupt rendering to a RenderTarget, switch to another RenderTarget while also sampling what has been rendered so far, and then come back to continue rendering to MSAA. <br  />
 See <a class="el" href="namespace_ogre_1_1_store_action.html#a1605e763b81f293b404de4a521f541caa1db7140816d8021d0f8f5fc47a6efb42">StoreAction::StoreAndMultisampleResolve</a>. </td></tr>
    <tr><td class="paramname">store_or_resolve</td><td>This is the compositor's default. It behaves like 'Store' if the texture is not MSAA. It behaves like 'MultisampleResolve' if the texture is MSAA. <br  />
 See <a class="el" href="namespace_ogre_1_1_store_action.html#a1605e763b81f293b404de4a521f541caae44608ad53aaf0bfa08df78448168e42">StoreAction::StoreOrResolve</a>. This is the default value.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_store_colour"></a>
colour (store)</h4>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">store</div>
<div class="line">{</div>
<div class="line">    colour [dont_care|store|resolve|store_and_resolve|store_or_resolve]</div>
<div class="line">    colour [N] [dont_care|store|resolve|store_and_resolve|store_or_resolve]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Value in range [0; num_mrt) to reference the colour target in an MRT. For non-MRT RTVs, use 0 or skip this parameter.</td></tr>
    <tr><td class="paramname">dont_care|etc</td><td>See Store Actions in <a class="el" href="compositor.html#CompositorPass_store_all">all</a>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_store_depth"></a>
depth (store)</h4>
<p>Sets the store action for the Depth Buffer.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">store</div>
<div class="line">{</div>
<div class="line">    depth [dont_care|store|resolve|store_and_resolve|store_or_resolve]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dont_care|etc</td><td>See Store Actions in <a class="el" href="compositor.html#CompositorPass_store_all">all</a>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorPass_store_stencil"></a>
stencil (store)</h4>
<p>Sets the store action for the Stencil Buffer.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">store</div>
<div class="line">{</div>
<div class="line">    stencil [dont_care|store|resolve|store_and_resolve|store_or_resolve]</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dont_care|etc</td><td>See store Actions in <a class="el" href="compositor.html#CompositorPass_store_all">all</a>.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="CompositorNodesPassesClear"></a>
clear</h3>
<ul>
<li><a class="el" href="compositor.html#CompositorPass_clear_non_tilers_only">non_tilers_only</a></li>
<li><a class="el" href="compositor.html#CompositorPass_clear_buffers">buffers</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_colour">colour_value</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_colour_reverse_depth_aware">clear_colour_reverse_depth_aware</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_depth">depth_value</a></li>
<li><a class="el" href="compositor.html#CompositorPass_load_clear_stencil">stencil_value</a></li>
</ul>
<h4><a class="anchor" id="CompositorPass_clear_non_tilers_only"></a>
non_tilers_only</h4>
<p>When true, this pass must only execute if the current GPU is not a TBDR GPU. When false, this pass always executes. Default: false.</p>
<p>This setting is tightly related to <a class="el" href="compositor.html#CompositorPass_load_all">Load Action clear_on_tilers</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">non_tilers_only [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorPass_clear_buffers"></a>
buffers</h4>
<p>Tells the pass which buffers to clear.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">buffers [colour] [depth] [stencil]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colour</td><td>Tells the pass to clear all colour target Does nothing if there is no colour buffer(s). </td></tr>
    <tr><td class="paramname">depth</td><td>Tells the pass to clear the depth buffer. Does nothing if there is no depth buffer. </td></tr>
    <tr><td class="paramname">stencil</td><td>Tells the pass to clear the stencil buffer. Does nothing if there is no stencil buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For performance reasons, if you clear the depth buffer you should also clear the stencil buffer.</dd></dl>
<h3><a class="anchor" id="CompositorNodesPassesGenerateMipmaps"></a>
generate_mipmaps</h3>
<p>generate_mipmaps doesn't have special parameters other than the shared ones that are still relevant (i.e. identifier). They're useful for explicitly populating the lower mip levels after you've done rendering.</p>
<ul>
<li><a class="el" href="compositor.html#CompositorNodesPassesGenerateMipmaps_mipmap_method">mipmap_method</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesGenerateMipmaps_kernel_radius">kernel_radius</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesGenerateMipmaps_gauss_deviation">gauss_deviation</a></li>
</ul>
<h4><a class="anchor" id="CompositorNodesPassesGenerateMipmaps_mipmap_method"></a>
mipmap_method</h4>
<p>Default is <code>api_default</code> which will ask the API or driver to generate them for you. If the API does not support it (e.g. DX12) then Compute will be used.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">mipmap_method [api_default|compute|compute_hq]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api_default</td><td>Uses whatever the API provides. Which is usually a bilinear downscale.</td></tr>
    <tr><td class="paramname">compute</td><td>At the moment, it is the same as compute_hq.</td></tr>
    <tr><td class="paramname">compute_hq</td><td>Uses a high quality gaussian filter. Useful for fast &amp; high quality mipmap generation. Uses a compute shader.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>generate_mipmaps works at texture level. If you pass a Cubemap, it will generate mipmaps for all the faces. If you pass a 3D or a 2D array texture, it will generate mipmaps for all slices. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>In order for compute-based mipmap generation to work, OgreNext must be compiled with JSON support, and the user must include the resources included in OgreNext's repository at Samples/Media/2.0/scripts/materials/Common</dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesGenerateMipmaps_kernel_radius"></a>
kernel_radius</h4>
<p>Integer value. Default is 8. Must be positive, even number. Defines the kernel radius of the <code>compute_hq</code> gaussian filter.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">kernel_radius &lt;8&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesGenerateMipmaps_gauss_deviation"></a>
gauss_deviation</h4>
<p>The standard deviation of the <code>compute_hq</code> gaussian filter. The default is 0.5.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">gauss_deviation &lt;0.5&gt;</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="CompositorNodesPassesQuad"></a>
render_quad</h3>
<p>Quad passes have the same syntax as 1.x; plus the following keywords have been added:</p>
<ul>
<li><a class="el" href="compositor.html#CompositorNodesPassesQuad_use_quad">use_quad</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesQuad_material">material</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesQuad_hlms">hlms</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesQuad_input">input</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesQuad_quad_normals">quad_normals</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesQuad_camera">camera</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesQuad_camera_cubemap_reorient">camera_cubemap_reorient</a></li>
</ul>
<h4><a class="anchor" id="CompositorNodesPassesQuad_use_quad"></a>
use_quad</h4>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">use_quad [yes|no]</div>
</div><!-- fragment --></dd></dl>
<p>Default is <em>no</em>. When <em>no</em>; the compositor will draw a fullscreen <em>triangle</em>. Due to how modern GPUs work, using two rectangles wastes GPU processing power in the diagonal borders because pixels are processed <em>at least</em> in 2x2 blocks; and the results from the pixels out of the triangle have to be discarded. A single triangle is more efficient as all blocks are fill the viewport area, and when the rectangle goes out of the viewport, the gpu efficiently clips it.</p>
<p>When the viewport is not <code>0 0 1 1</code>; this value is forced to <em>yes</em>. The following picture illustrates a fullscreen triangle:</p>
<p><img src="use_quad.png" alt="" class="inline"/></p>
<p>Interpolation will cause that the effective UV coordinates will be in the [0; 1] range while inside the viewport area.</p>
<p>Using <code>camera_far_corners_world_space</code> will also force to use a quad instead of a tri (but <code>camera_far_corners_view_space</code> works with tris)</p>
<p>For an explanation of why this is a performance optimization, refer to <a href="http://fgiesen.wordpress.com/2013/02/10/optimizing-the-basic-rasterizer/">Optimizing the basic rasterizer</a> by Fabien Giesen.</p>
<h4><a class="anchor" id="CompositorNodesPassesQuad_material"></a>
material</h4>
<p>Name of the low level material to use.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">material &lt;material_name&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesQuad_hlms"></a>
hlms</h4>
<p>Name of the Hlms datablock to use.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">hlms &lt;datablock_name&gt;</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The datablock must be visible to the HlmsManager. See <a class="el" href="class_ogre_1_1_hlms_manager.html#ae017c067728c1de583db541cf5fdbb2f" title="Retrieves an exisiting datablock (i.e.">Ogre::HlmsManager::getDatablock</a>.</dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesQuad_input"></a>
input</h4>
<p>Texture to bind to the material or datablock.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">input &lt;N&gt; &lt;texture_name&gt;</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Material's Texture Unit to set. </td></tr>
    <tr><td class="paramname">texture_name</td><td>Name of the texture. <b>Must</b> be a local, input or global texture.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorNodesPassesQuad_quad_normals"></a>
quad_normals</h4>
<p>Sends to the vertex shaderthe camera's frustum corners in either world space or view space through the <code>NORMALS</code> semantic.</p>
<p>This is particularly useful for efficiently reconstructing position using only the depth and the corners (see Samples/2.0/Tutorials/Tutorial_ReconstructPosFromDepth).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">quad_normals</div>
<div class="line">    [camera_far_corners_view_space|camera_far_corners_view_space_normalized|camera_far_corners_view_space_normalized_lh|camera_far_corners_world_space|camera_far_corners_world_space_centered|camera_direction]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera_far_corners_view_space</td><td>Sends camera frustum corners in view space. </td></tr>
    <tr><td class="paramname">camera_far_corners_view_space_normalized</td><td>Sends camera frustum corners in view space. See <a class="el" href="class_ogre_1_1_compositor_pass_quad_def.html#ad8aef1ad03925bb5348dd6b0c008c0d9a00f58cc6fbcb836a80e7c16f8710b353" title="When normalized, then the corner is divided by the far plane.">Ogre::CompositorPassQuadDef::VIEW_SPACE_CORNERS_NORMALIZED</a>. Note: It divides the whole vector by the far plane; causing dir.z to be always -1 (but the vector itself isn't unit-length). </td></tr>
    <tr><td class="paramname">camera_far_corners_view_space_normalized_lh</td><td>Same as camera_far_corners_view_space_normalized but left-handed. Note: dir.z is always 1. </td></tr>
    <tr><td class="paramname">camera_far_corners_world_space</td><td>Sends camera frustum corners in world space. </td></tr>
    <tr><td class="paramname">camera_far_corners_world_space_centered</td><td>Sends camera frustum corners direction, but it is centered around origin (0, 0, 0). </td></tr>
    <tr><td class="paramname">camera_direction</td><td>Same as camera_far_corners_world_space_centered but normalized (values are in range [0;1]) which is useful for sky rendering &amp; atmospheric scattering. See <code>TutorialSky_Postprocess</code> sample.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Interesting read:</b> Reconstructing Position From Depth <a href="http://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/">Part I</a>, <a href="http://mynameismjp.wordpress.com/2009/05/05/reconstructing-position-from-depth-continued/">Part II</a>, <a href="http://mynameismjp.wordpress.com/2010/09/05/position-from-depth-3/">Part III</a></p>
<dl class="section note"><dt>Note</dt><dd>In OgreNext you need to apply the <b>world-view-proj matrix</b> so that the pass being drawn compensates for texel-to-pixel aligning reads in Direct3D9. Failing to do so will not only cause the aforementioned alignment issue, but also will cause glitches when the viewport is not 0 0 1 1<br  />
<br  />
 In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x, only the proj matrix was necessary to fix texture flipping issues when rendering to FBOs in OpenGL.</dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesQuad_camera"></a>
camera</h4>
<p>Sets the current camera to use if you want to use a different one from the default one.</p>
<div class="fragment"><div class="line">camera &lt;camera_name&gt;</div>
</div><!-- fragment --><h4><a class="anchor" id="CompositorNodesPassesQuad_camera_cubemap_reorient"></a>
camera_cubemap_reorient</h4>
<p>Rotates the camera 90, -90 or 180 depending on the value of the slice index. See <a class="el" href="class_ogre_1_1_compositor_pass_quad_def.html#aa115367c85e90c5f16d7d8941ef1ce78" title="When true, the camera will be rotated 90, -90 or 180 depending on the value of mRtIndex and then r...">Ogre::CompositorPassQuadDef::mCameraCubemapReorient</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">camera_cubemap_reorient [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="CompositorNodesPassesRenderScene"></a>
render_scene</h3>
<p>This is the main pass to render most of the scene.</p>
<ul>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_rq_first">rq_first</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_rq_last">rq_last</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_lod_bias">lod_bias</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_lod_update_list">lod_update_list</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_cull_reuse_data">cull_reuse_data</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_visibility_mask">visibility_mask</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_light_visibility_mask">light_visibility_mask</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_shadows">shadows</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_overlays">overlays</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_camera">camera</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_lod_camera">lod_camera</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_cull_camera">cull_camera</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_camera_cubemap_reorient">camera_cubemap_reorient</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_enable_forwardplus">enable_forwardplus</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_flush_command_buffers_after_shadow_node">flush_command_buffers_after_shadow_node</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_is_prepass">is_prepass</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_use_prepass">use_prepass</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_gen_normals_gbuffer">gen_normals_gbuffer</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_use_refractions">use_refractions</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_uv_baking">uv_baking</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_uv_baking_offset">uv_baking_offset</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_bake_lighting_only">bake_lighting_only</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesRenderScene_instanced_stereo">instanced_stereo</a></li>
</ul>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_rq_first"></a>
rq_first</h4>
<p>Sets the first render queue ID to start rendering from. The default is 0. Must be a value in range [0 and 255].</p>
<p>The value is inclusive (Objects in ID = rq_first get rendered).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">rq_first &lt;id&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_rq_last"></a>
rq_last</h4>
<p>The default is <code>max</code> which is a special parameter that implies the last active render queue ID. If numeric, value must be between 0 and 255.</p>
<p>The value is <b>not</b> inclusive (Objects in ID = rq_last do not get rendered).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">rq_last &lt;id&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_lod_bias"></a>
lod_bias</h4>
<p>Applies a bias multiplier to the lod. Valid values are in range [0; Inf).</p>
<p>A higher lod bias causes LODs to pop up sooner and should be preferred on slower devices.</p>
<p>Default: 1.0</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">lod_bias &lt;bias&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_lod_update_list"></a>
lod_update_list</h4>
<p>When <code>no</code>, the LOD list won't be updated, and will use the LOD lists of calculated by a previous pass. This saves valuable CPU time.</p>
<p>Useful for multiple passes using the same lod_camera (without a pass in the middle with a different lod_camera that would override the cached LOD lists).</p>
<p>If your application is extremely CPU bound, and hence you don't need LOD, turning this setting to false in all passes will effectively turn lodding off (and alleviate the CPU).</p>
<p>Default: yes; except for passes belonging to shadow nodes, which is forced to false unless lod_camera is a non-empty string.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">lod_update_list [yes|no]</div>
</div><!-- fragment --></dd></dl>
<p>See <a class="el" href="class_ogre_1_1_compositor_pass_scene_def.html#ac2ebb8b97a0e78189b21c95170338825" title="When true, which Lod index is current will be updated.">Ogre::CompositorPassSceneDef::mUpdateLodLists</a>.</p>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_cull_reuse_data"></a>
cull_reuse_data</h4>
<p>When true, the frustum culling is skipped in this pass. Data from the previous frustum culling execution is used instead.</p>
<p>This is useful if you execute two render_scene passes in a row that are almost identical (e.g. early depth pre-pass followed by a normal render); thus saving lots of valuable CPU time.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">cull_reuse_data [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_visibility_mask"></a>
visibility_mask</h4>
<p>Visibility mask to be used by the pass' viewport. Those entities that fail the test '<em>entityMask &amp; visibility_mask</em>' will not be rendered.</p>
<p>There are no significant changes to <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x, except that the script compiler now accepts hexadecimal values with the 0x prefix instead of decimal values.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">visibility_mask &lt;hex number&gt; <span class="comment">// e.g. visibility_mask 0xffff0000</span></div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_light_visibility_mask"></a>
light_visibility_mask</h4>
<p>Visibility mask to be used by the pass for culling lights in Forward+.</p>
<p>Those entities that fail the test '<em>entityMask &amp; light_visibility_mask</em>' will not be used as non-shadow-casting lights during this pass.</p>
<p>This will give you a relatively efficient way to control with <b>coarse</b> granularity which lights affect which objects.</p>
<p>Note that this uses the mask set via light-&gt;setVisibilityMask, not the one set via light-&gt;setLightMask.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">light_visibility_mask &lt;hex number&gt; <span class="comment">// e.g. light_visibility_mask 0xffff0000</span></div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_shadows"></a>
shadows</h4>
<p>Specifies the shadow node to use for rendering with shadow maps. See section about <a class="el" href="compositor.html#CompositorShadowNodesReuseEtc">*Shadow Nodes*</a> for more information. When a shadow node's name is provided, the second parameter defaults to <em>first</em>.</p>
<p>Off by default.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">shadows &lt;off|shadow_node_name&gt; [first|reuse|recalculate]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>Set to <code>off</code> if it should not use shadows. </td></tr>
    <tr><td class="paramname">shadow_node_name</td><td>The name of the shadow node to use. Mutually exclusive with <code>off</code>. </td></tr>
    <tr><td class="paramname">first</td><td>Optional. Default. Automatically calculates whether we should reuse or recalculate, based on whether this is the first node. Mutually exclusive with reuse &amp; recalculate. </td></tr>
    <tr><td class="paramname">reuse</td><td>Optional. Reuses existing rendered shadow map data, regardless of whether it's valid or if OgreNext believes it should be redrawn. Mutually exclusive with first &amp; recalculate. </td></tr>
    <tr><td class="paramname">recalculate</td><td>Optional. Forces to redraw the shadow map, even if OgreNext believes it should not. This is useful if you've modified the scene via listeners or rendering in a complex way that OgreNext has no way to know the shadow node should be redrawn. Mutually exclusive with first &amp; reuse.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_overlays"></a>
overlays</h4>
<p>Whether to render Overlays from the OverlaySystem component. On by default for regular nodes, Off by default on shadow nodes. The goal is that eventually Overlays obey RenderQueue IDs like everything else, but it was too hard to port (Overlay system is tad bit complex...) so this hack/flag was created. It will be eventually removed.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">overlays &lt;off|on&gt;</div>
</div><!-- fragment --></dd></dl>
<p>See <a class="el" href="v1__overlays.html">Overlays</a> for more info.</p>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_camera"></a>
camera</h4>
<p>When not specified, the default camera is used for rendering the pass (this default camera is specified when instantiating the workspace from C++).</p>
<p>When a name is given, the Compositor will look for this camera and use it. Very useful for reflection passes (mirrors, water) where the user wants to be in control of the camera, while the Compositor is associated with it. The Camera <b>must</b> be created by the user before the workspace is instantiated and remain valid until the workspace is destroyed.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">camera &lt;camera_name&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_lod_camera"></a>
lod_camera</h4>
<p>The camera point of view from which the LOD calculations will be based from (i.e. useful for shadow mapping, which needs the LOD to match that of the user camera). When an empty string is provided, OgreNext will assume the lod camera is the same as the current camera, except for shadow nodes in which it will assume it's the lod_camera from the normal pass the shadow node is attached to. Default: Empty string.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">lod_camera &lt;camera_name&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_cull_camera"></a>
cull_camera</h4>
<p>In VR we want to reuse the same cull list for both eyes. Additionally we'd like to calculate shadows for both eyes once, rather than once per eye. This setting allows setting a cull camera different from the rendering camera that should be placed in such a way that the cull camera's frustum encompases both left and right eye. When this string is empty, the regular camera is used. Default: Empty string.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">cull_camera &lt;camera_name&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_camera_cubemap_reorient"></a>
camera_cubemap_reorient</h4>
<p>When Yes, the camera will be reoriented for rendering cubemaps, depending on which slice of the render target we're rendering to (3D, Cubemaps and 2D-array textures only). Its original orientation is restored after the pass finishes. The rotations are relative to its original orientation, which can produce counter-intuitive results if the Camera wasn't set to identity (unless that's the desired effect). See <a href="#CompositorNodesTarget">Target</a> section on how to indicate which slice should we render to. Default: No.</p>
<p><b>Note:</b> if the target is not a cubemap, <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will still try to rotate the camera, often to unintended angles.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">camera_cubemap_reorient [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_enable_forwardplus"></a>
enable_forwardplus</h4>
<p>When yes, this pass will use Forward3D/ForwardClustered (must be enabled first by the developer via C++, see Forward3D sample). When No, Forward3D will not be used for this pass, which can improve performance both CPU and GPU side (but many lights are likely not going to be drawn or used).</p>
<p>Default: Yes.</p>
<p><b>Details:</b> CPU side, lights won't be culled against the camera (only a saving if F3D didn't already have a cache from a previous pass during the same frame, with the exact same camera and angle). GPU side, the pixel shaders will be lighter.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">enable_forwardplus [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_flush_command_buffers_after_shadow_node"></a>
flush_command_buffers_after_shadow_node</h4>
<p>Very similar to <a class="el" href="compositor.html#CompositorPass_flush_command_buffers">flush_command_buffers</a>. Does not do anything if 'shadows' is set to 'reuse' (or was set to 'first' and this node is not the first).</p>
<p>See <a class="el" href="class_ogre_1_1_compositor_pass_scene_def.html#a125a142085fcc39304d15944c24282bf" title="Same as CompositorPassDef::mFlushCommandBuffers, but executed after the shadow node Note you may end ...">Ogre::CompositorPassSceneDef::mFlushCommandBuffersAfterShadowNode</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">flush_command_buffers_after_shadow_node [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_is_prepass"></a>
is_prepass</h4>
<p>Indicates this is a prepass render. HlmsPbs implementation will render a GBuffer with normals and shadow mapping information. See ScreenSpaceReflections sample for an example on how to use it.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">is_prepass [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_use_prepass"></a>
use_prepass</h4>
<p>Indicates this pass will take advantage of the data generated during the prepass, which means depth buffer writes may be forced to off; normals will be sourced for the GBuffer. And if present, a reflection texture will be used for calculating SSR (Screen Space Reflections).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">use_prepass &lt;GBuffer&gt; [reflectionBuffer]</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_gen_normals_gbuffer"></a>
gen_normals_gbuffer</h4>
<p>See <a class="el" href="class_ogre_1_1_compositor_pass_scene_def.html#a21c75caa6f66a3571ccb437ac3d4755e" title="Generate Normals for a GBuffer in RTV output 1, This flag is ignored mPrePassMode if mPrePassMode !...">Ogre::CompositorPassSceneDef::mGenNormalsGBuf</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">gen_normals_gbuffer [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="CompositorNodesPassesRenderScene_use_refractions"></a>
use_refractions</h3>
<p>Tells the HlmsPbs implementation the necessary data to perform refractions.</p>
<p>See sample Samples/2.0/ApiUsage/Refractions on how to set it up.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">use_refractions &lt;depth_texture&gt; &lt;refractions_texture&gt;</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth_texture</td><td>Name of the depth texture used for rendering the scene without refractive objects. </td></tr>
    <tr><td class="paramname">refractions_texture</td><td>Name of the colour texture used for rendering the scene without refractive objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the depth_texture is the same as the depth buffer being rendered to, then the current RTV in the target pass <b>must</b> have the depth buffer to <code>read_only</code>.<br  />
<br  />
 By default use_refractions will always force-enable <code>read_only</code>, which means the current <code>render_scene</code> cannot write to the depth or the stencil buffers.<br  />
<br  />
 Due to this, trying to use skip_load_store_semantics for this pass (or the next one) may cause problems unless read-only depth buffers are desired.</dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_uv_baking"></a>
uv_baking</h4>
<p>Value in range [0; 254]. When set to 255, it is disabled.</p>
<p>See Samples/2.0/Tutorials/Tutorial_TextureBaking See <a class="el" href="class_ogre_1_1_compositor_pass_scene_def.html#a7b6757dc80fabdbbd8d3a0808037453f" title="Used for baking lightmaps and similar stuff.">Ogre::CompositorPassSceneDef::mUvBakingSet</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">uv_baking &lt;value&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_uv_baking_offset"></a>
uv_baking_offset</h4>
<p>Float value in for offsetting U &amp; V values, in pixels.</p>
<p>See Samples/2.0/Tutorials/Tutorial_TextureBaking See <a class="el" href="class_ogre_1_1_compositor_pass_scene_def.html#a02648d48cf90fe76925818c30741809a" title="When mUvBakingSet is enabled, this defines the UV offset (in pixels).">Ogre::CompositorPassSceneDef::mUvBakingOffset</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">uv_baking_offset &lt;offset_x&gt; &lt;offset_y&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_bake_lighting_only"></a>
bake_lighting_only</h4>
<p>See Samples/2.0/Tutorials/Tutorial_TextureBaking See <a class="el" href="class_ogre_1_1_compositor_pass_scene_def.html#afb98de697dcbffbb54c4f6262d36ba4d" title="When mUvBakingSet is set, tells whether we should bake the whole render result or just the lighting i...">Ogre::CompositorPassSceneDef::mBakeLightingOnly</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">bake_lighting_only [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesRenderScene_instanced_stereo"></a>
instanced_stereo</h4>
<p>Whether to use instanced stereo, for VR rendering. See InstancedStereo and OpenVR samples. You will probably want to also set multiple viewports, at the very least viewports 0 and 1</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">instanced_stereo [yes|no]</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="CompositorNodesPassesShadows"></a>
shadows</h3>
<p>This pass enables force-updating multiple shadow nodes in batch in its own pass</p>
<p>This is useful because shadow nodes may "break" a render pass in 3:</p>
<ul>
<li>Normal rendering to RT</li>
<li>Shadow node update</li>
<li>Continue Normal rendering to the same RT</li>
</ul>
<p>This is an unnecessary performance hit on mobile (TBDR) thus executing them earlier allows for a smooth:</p>
<ul>
<li>Shadow node update (all of them? Up to you)</li>
<li>Normal rendering to RT</li>
</ul>
<p>Don't forget to set shadow nodes to reuse in the pass scene passes or else you may overwrite them unnecessarily</p>
<p>Usage is simple:</p>
<div class="fragment"><div class="line"><span class="comment">// This pass supports being part of a nameless target</span></div>
<div class="line">target</div>
<div class="line">{</div>
<div class="line">    pass shadows</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We can update multiple shadow nodes</span></div>
<div class="line">        shadows MyShadowNode_0</div>
<div class="line">        shadows MyShadowNode_1</div>
<div class="line">        shadows MyShadowNode_2</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// These 4 parameters are the same as in pass_scene</span></div>
<div class="line">        camera      CameraName</div>
<div class="line">        lod_camera  CameraName</div>
<div class="line">        cull_camera CameraName</div>
<div class="line">        visibility_mask 0xffffffff</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="CompositorNodesPassesStencil"></a>
stencil</h3>
<p>Stencil passes are little more flexible than in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x; always remember to restore the stencil passes before leaving the node otherwise next nodes that will be executed may use unexpected stencil settings.</p>
<p>Most relevant changes are that two sided stencil can now be definted with more flexibility (it's not a boolean anymore), and that syntax has slightly changed to accomodate for this change:</p>
<div class="fragment"><div class="line">pass stencil</div>
<div class="line">{</div>
<div class="line">    check       <span class="keyword">true</span></div>
<div class="line">    mask        0xff</div>
<div class="line">    read_mask   0xff</div>
<div class="line">    </div>
<div class="line">    both</div>
<div class="line">    {</div>
<div class="line">        fail_op     keep</div>
<div class="line">        depth_fail_op   increment</div>
<div class="line">        pass_op     decrement_wrap</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>read mask</code> is new, and now the <code>fail_op</code>, <code>depth_fail_op</code> &amp; <code>pass_op</code> must be enclosed between brackets.</p>
<p>Valid values are 'both' 'front' and 'back'. 'both' is just a shortcut for defining front and back at the same time with less typing.</p>
<h3><a class="anchor" id="CompositorNodesPassesUavQueue"></a>
uav_queue</h3>
<p>This is a new feature introduced in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.1. s stands for <b>U</b>nordered <b>A</b>ccess <b>V</b>iews, in D3D's jargon. OpenGL users know UAVs as the feature combination of <em>image</em> textures (imageLoad, imageStore) and SSBOs (Shader Storage Buffer Object). UAVs are powerful beasts because they allow random read and write access from a shader, and even support atomic operations. Proper use of them can achieve incredible results that couldn't be done without UAVs, but improper use can severely hurt performance.</p>
<p>There's quite a discrepancy between D3D11 &amp; OpenGL in how they treat UAVs from API interface perspective. D3D11 equals UAVs to RenderTargets; while OpenGL equals them more like textures.</p>
<p>In fact, the D3D11 API call to bind UAVs must set RenderTargets at the same time. There is no API call to only set UAVs. To make things harder, D3D11 forces UAVs to share slots with RenderTargets; and there are up to 8 slots in total (64 when using D3D11.1 on Windows 8.1). Which means if you're using an MRT with 3 targets, you only have 5 slots left for UAVs.</p>
<p>We can guess for performance improvements: this way D3D11 can check for hazards when setting RTs and UAVs (i.e. make sure you don't bind the same resource as both RT and UAV) while they still use the same hazard checking they do for textures to check that you're not binding a texture at the same time it is bound as an RT/UAV.</p>
<p>If the UAV equals a texture, as in OpenGL; they would have to check textures against textures every time a texture changes, which is O( N! ) complexity; and also a very common operation. Considering past experiences, we're guessing OpenGL just simply skips the check and lets the hazard happen (which is cool when there are hardware extensions that allow you to read/write from these resources at the same time as long as you abide to certain rules).</p>
<p>Because D3D11 is more restrictive than OpenGL, our interface resemble's D3D11.</p>
<ul>
<li><a class="el" href="compositor.html#CompositorNodesPassesUavQueue_starting_slot">starting_slot</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesUavQueue_uav">uav</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesUavQueue_uav_external">uav_external</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesUavQueue_uav_buffer">uav_buffer</a></li>
<li><a class="el" href="compositor.html#CompositorNodesPassesUavQueue_keep_previous_uavs">keep_previous_uavs</a></li>
</ul>
<h4><a class="anchor" id="CompositorNodesPassesUavQueue_starting_slot"></a>
starting_slot</h4>
<p>Offset for all UAV slots. For example if you bind an uav to slot 3 and the starting slot is 2; the uav will actually be bound to uav slot 5. When set to 255, the slot offset is ignore and leaves the last setting made.</p>
<p>Default: 255 (by default <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> sets it to 1).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">starting_slot &lt;number&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorNodesPassesUavQueue_uav"></a>
uav</h4>
<p>Sets a texture visible in the current compositor scope (i.e. global textures, input textures, local textures).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">uav &lt;slot&gt; &lt;texture_name&gt; &lt;read&gt; &lt;write&gt; [pixel_format] [mipmap #]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>0-based index to bind to. </td></tr>
    <tr><td class="paramname">texture_name</td><td>Name of the texture. Must be global, input or local texture. </td></tr>
    <tr><td class="paramname">read</td><td>If present, it states you want to read from this UAV in the next vertex/pixel shaders. If absent, you don't intend to read. </td></tr>
    <tr><td class="paramname">write</td><td>If present, it states you want to write into this UAV in the next vertex/pixel shaders. If absent, you don't intend to write. </td></tr>
    <tr><td class="paramname">pixel_format</td><td>Optional. The pixel format to bind as. If absent, it uses the original pixel format. Note: the texture must have been declared with <code>reinterpretable</code> if reinterpreting as a different pixel format. </td></tr>
    <tr><td class="paramname">mipmap</td><td>The mipmap value must be following by a number (0-based). If not present, default value is 0.</td></tr>
  </table>
  </dd>
</dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flag Combination   </th><th class="markdownTableHeadNone">Status    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">read   </td><td class="markdownTableBodyNone">valid    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Read + write   </td><td class="markdownTableBodyNone">valid    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">write   </td><td class="markdownTableBodyNone">valid    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&lt;nothing&gt;   </td><td class="markdownTableBodyNone">invalid   </td></tr>
</table>
<p>Example:</p>
<div class="fragment"><div class="line">starting_slot 1</div>
<div class="line">uav 2 global_myTexture read write mipmap 5</div>
</div><!-- fragment --><p>Will bind the global texture 'global_myTexture' to slot 3, will have both read &amp; write access, and use mipmap level 5.</p>
<dl class="section note"><dt>Note</dt><dd>starting_slot + slot = 1 + 2 = 3</dd></dl>
<p>If only the slot is specified, the slot will be cleared.</p>
<h4><a class="anchor" id="CompositorNodesPassesUavQueue_uav_external"></a>
uav_external</h4>
<p>Exactly the same as <a class="el" href="compositor.html#CompositorNodesPassesUavQueue_uav">uav</a>. But instead of sourcing the texture by name from the Compositor scope, the name is referencing a texture that can be accessed via <code>TextureGpuManager::findTextureNoThrow</code>.</p>
<h4><a class="anchor" id="CompositorNodesPassesUavQueue_uav_buffer"></a>
uav_buffer</h4>
<p>Sets an UAV buffer visible in the current compositor scope (i.e. global buffers, input buffers, local buffers).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">uav__buffer &lt;slot&gt; &lt;buffer_name&gt; &lt;read&gt; &lt;write&gt; [offset_bytes] [size_bytes]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>Same as <a class="el" href="compositor.html#CompositorNodesPassesUavQueue_uav">uav</a> </td></tr>
    <tr><td class="paramname">read</td><td>Same as <a class="el" href="compositor.html#CompositorNodesPassesUavQueue_uav">uav</a> </td></tr>
    <tr><td class="paramname">write</td><td>Same as <a class="el" href="compositor.html#CompositorNodesPassesUavQueue_uav">uav</a> </td></tr>
    <tr><td class="paramname">offset_bytes</td><td>Default: 0. Optional. Offset in bytes to bind. </td></tr>
    <tr><td class="paramname">size_bytes</td><td>Default: 0. Optional. Size in bytes to bind. When size_bytes = 0, we assume you want to bind from the offset until the end of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">starting_slot 1</div>
<div class="line">uav_buffer 3 myUavBuffer read write 256 512</div>
</div><!-- fragment --><p>Note there may be HW alignment restriction on which offset you specify. Multiples of 256 bytes are a safe bet.</p>
<p>Note that uav_buffer slots are shared with uav texture's. Binding both to the same slot index will only result in one of them being available.</p>
<p>If only the slot is specified, the slot will be cleared.</p>
<h4><a class="anchor" id="CompositorNodesPassesUavQueue_keep_previous_uavs"></a>
keep_previous_uavs</h4>
<p>When false, all previous UAVs in all slot will be cleared. When true, only the UAV slots modified by this pass will be affected. Default: true.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">keep_previous_uavs [<span class="keyword">true</span>|<span class="keyword">false</span>]</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="CompositorNodesPassesCompute"></a>
compute</h3>
<p>Compute passes let you run a compute job. It can read textures, read/write to UAV textures, and read/write to UAV buffers.</p>
<ul>
<li><a href="#CompositorPassCompute_job">job</a></li>
<li><a href="#CompositorPassCompute_uav">uav</a></li>
<li><a href="#CompositorPassCompute_uav_buffer">uav_buffer</a></li>
<li><a href="#CompositorPassCompute_input">input</a></li>
</ul>
<h4><a class="anchor" id="CompositorPassCompute_job"></a>
job</h4>
<p>Sets the name of the compute job to run (an HlmsComputeJob).</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">job &lt;job_name&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorPassCompute_uav"></a>
uav</h4>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">uav &lt;slot&gt; &lt;texture_name&gt; [mrt #] &lt;read&gt; &lt;write&gt; [pixel_format] [&lt;mipmap&gt; #] [allow_write_after_write]</div>
</div><!-- fragment --></dd></dl>
<p>See <a href="#CompositorNodesPassesUavQueue">uav_queue</a> description. The presence of <code>allow_write_after_write</code> means the compositor will not insert a barrier between to consecutive passes that writes to the UAV without reading.</p>
<h4><a class="anchor" id="CompositorPassCompute_uav_buffer"></a>
uav_buffer</h4>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">uav_buffer &lt;slot&gt; &lt;bufferName&gt; &lt;read&gt; &lt;write&gt; [offsetBytes] [sizeBytes] [allow_write_after_write]</div>
</div><!-- fragment --></dd></dl>
<p>See <a href="#CompositorNodesPassesUavQueue">uav_queue</a> description. The presence of <code>allow_write_after_write</code> means the compositor will not insert a barrier between to consecutive passes that writes to the UAV without reading.</p>
<h4><a class="anchor" id="CompositorPassCompute_input"></a>
input</h4>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">input &lt;slot&gt; &lt;texture_name&gt;</div>
</div><!-- fragment --></dd></dl>
<p>Binds a texture to the texture unit. Syntax is the same as render_quad's <a class="el" href="compositor.html#CompositorNodesPassesQuad_input">input</a>. The slot is not shared with the uav's.</p>
<p>Compute passes don't really belong to a render target. However due to the Compositor's design, they must be specified within a render target. You may do so within a valid render target:</p>
<div class="fragment"><div class="line">compositor_node MyNode</div>
<div class="line">{</div>
<div class="line">    in 0 rt_renderwindow</div>
<div class="line">    texture myUavTexture target_width target_height <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a812348e195a0efa7681c307e9c39b39f">PFG_RGBA8_UNORM</a> depth_pool 0 uav</div>
<div class="line">    buffer myUavBuffer 1024 4</div>
<div class="line">    </div>
<div class="line">    target rt_renderwindow</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Run compute job with myUavTexture &amp; myUavBuffer bound.</span></div>
<div class="line">        pass compute</div>
<div class="line">        {</div>
<div class="line">            job myComputeJobName</div>
<div class="line">            uav 0 myUavTexture read write</div>
<div class="line">            uav_buffer 1 myUavBuffer read write</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">//Clear  rt_renderwindow to violet</span></div>
<div class="line">        pass clear</div>
<div class="line">        {</div>
<div class="line">            colour_value 1 0 1 1</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    out 0 myUavTexture</div>
<div class="line">    out_buffer 0 myUavBuffer</div>
<div class="line">}</div>
<div class="ttc" id="agroup___image_html_gga71f09fe41a1db41186262f1aa5814a18a812348e195a0efa7681c307e9c39b39f"><div class="ttname"><a href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a812348e195a0efa7681c307e9c39b39f">Ogre::PFG_RGBA8_UNORM</a></div><div class="ttdeci">@ PFG_RGBA8_UNORM</div><div class="ttdef"><b>Definition:</b> OgrePixelFormatGpu.h:77</div></div>
</div><!-- fragment --><p>Or to a null dummy render target, which occupies almost no memory:</p>
<div class="fragment"><div class="line">compositor_node MyNode</div>
<div class="line">{</div>
<div class="line">    texture nullDummy target_width target_height <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a0b36a2df52b5dec901790a1e997e0b30">PFG_NULL</a></div>
<div class="line">    texture myUavTexture target_width target_height <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a812348e195a0efa7681c307e9c39b39f">PFG_RGBA8_UNORM</a> depth_pool 0 uav</div>
<div class="line">    buffer myUavBuffer 1024 4</div>
<div class="line">    </div>
<div class="line">    target  nullDummy</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Run compute job with myUavTexture bound.</span></div>
<div class="line">        pass compute</div>
<div class="line">        {</div>
<div class="line">            job myComputeJobName</div>
<div class="line">            uav 0 myUavTexture read write</div>
<div class="line">            uav_buffer 1 myUavBuffer read write</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    out 0 myUavTexture</div>
<div class="line">    out_buffer 0 myUavBuffer</div>
<div class="line">}</div>
<div class="ttc" id="agroup___image_html_gga71f09fe41a1db41186262f1aa5814a18a0b36a2df52b5dec901790a1e997e0b30"><div class="ttname"><a href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a0b36a2df52b5dec901790a1e997e0b30">Ogre::PFG_NULL</a></div><div class="ttdeci">@ PFG_NULL</div><div class="ttdef"><b>Definition:</b> OgrePixelFormatGpu.h:49</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Do NOT set UAV buffers to the compute job directly via C++ (the class <a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a>) bypassing the Compositor. The Compositor needs to evaluate memory barriers and resource transitions. Leaving inconsistent memory barriers can result in hazards/race conditions in some APIs. If in doubt, change the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> instead. <br  />
 Also setting Textures that are RenderTargets is dangerous. For RenderTargets, change the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> instead. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Don't interleave compute and graphics passes. For optimum performance, try to batch everything of the same type together.</dd></dl>
<h2><a class="anchor" id="CompositorNodesTextures"></a>
texture</h2>
<div class="fragment"><div class="line">texture &lt;name&gt; &lt;width&gt; &lt;height&gt; [depth] &lt;pixel_format&gt; [msaa &lt;N&gt;] [msaa_auto]</div>
<div class="line">[depth_texture] [depth_pool &lt;poolId&gt;] [uav] [2d_array|3d|cubemap] [mipmaps &lt;numMips&gt;] [no_automipmaps] [reinterpretable]</div>
<div class="line">[explicit_resolve] [not_texture]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A locally unique name must be assigned (and cannot start with <em>global_</em> prefix).</td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td>The dimensions of the render texture. You can either specify a fixed width and height, or you can request that the texture is based on the physical dimensions of the viewport to which the compositor is attached. The options for the latter are either of <ul>
<li>
<code>target_width</code> and <code>target_height</code> </li>
<li>
<code>target_width_scaled</code> &lt;factor&gt; and <code>target_height_scaled</code> &lt;factor&gt; </li>
</ul>
where &lt;factor&gt; is the amount by which you wish to multiply the size of the main target to derive the dimensions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Used by 2d_array and 3d textures. Specifies their depth / number of slices. It's automatically forced to 1 for 2d textures and 6 for cubemaps.</td></tr>
    <tr><td class="paramname">pixel_format</td><td>The pixel format of the render texture. This affects how much memory it will take, what colour channels will be available, and what precision you will have within those channels. Most common options are <code>PFG_RGBA8_UNORM_SRGB</code>, <code>PFG_RGBA8_UNORM</code>, <code>PFG_RGBA16_FLOAT</code>, <code>PFG_R16_FLOAT</code>, <code>PFG_RGBA16_FLOAT</code>, <code>PFG_R32_FLOAT</code>. See <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18" title="The pixel format used for images, textures, and render surfaces.">Ogre::PixelFormatGpu</a> for all options.</td></tr>
    <tr><td class="paramname">msaa</td><td>Explicitly specifies the MSAA count. Valid values are: <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>.<br  />
 Note that this is subject to GPU support (e.g. some mobile GPUs don't support MSAA 2x and most consumer desktop GPUs don't support values &gt; 8).</td></tr>
    <tr><td class="paramname">msaa_auto</td><td>Uses the same MSAA setting as the global setting for the workspace.</td></tr>
    <tr><td class="paramname">depth_pool</td><td>When present, this directive has to be followed by an integer. This one sets from which Depth buffer pool the depth buffer will be chosen from. All RTs from all compositors with the same pool ID share the same depth buffers as long as it's possible (must have the same resolution, must have the same depth_texture setting). RenderWindows can**not** share their depth buffers due to API limitations on some RenderSystems. When the pool ID is 0, no depth buffer is used. This can be helpful for passes that dont require a Depth buffer at all, potentially saving performance and memory. Default value is 1.</td></tr>
    <tr><td class="paramname">depth_texture</td><td>When present, the RTT indicates you want to later access the depth buffer's contents as a texture in a shader. This feature is discouraged starting OgreNext &gt;= 2.2 because using RTVs gives you better control.</td></tr>
    <tr><td class="paramname">uav</td><td>When present, the texture can be used as an UAV (also called "STORAGE" in Vulkan lingo).</td></tr>
    <tr><td class="paramname">2d_array|3d|cubemap</td><td>When present, the texture will be created as a 2d_array, 3d or cubemap. Mostly relevant for UAVs but is also useful for rendering. See <a href="#4.1.2.Target|outline">Target</a> slice parameter.</td></tr>
    <tr><td class="paramname">mipmaps</td><td>Default: 1; Indicates how many mipmaps to use. 1 for none. Use 0 to fill all mipmaps until 1x1</td></tr>
    <tr><td class="paramname">no_automipmaps</td><td>When absent (default) and mipmaps are != 1, OgreNext will assume you may eventually use <a href="#CompositorNodesPassesGenerateMipmaps">generate_mipmaps</a> (not the Compute version) on this texture or call <a class="el" href="class_ogre_1_1_texture_gpu.html#a9591cec393bcb06deda9b5f94a040fc5" title="Tells the API to let the HW autogenerate mipmaps.">Ogre::TextureGpu::_autogenerateMipmaps</a> from C++.<br  />
 When present, it is not valid to use generate_mipmaps on this texture (except for the Compute version).</td></tr>
    <tr><td class="paramname">reinterpretable</td><td>When present, it indicates the texture may be reinterpreted to a different pixel format. e.g. PFG_RGBA8_UNORM as PFG_RGBA8_UNORM_SRGB, PFG_RGBA8_UNORM as PFG_R32_UINT, etc.</td></tr>
  </table>
  </dd>
</dl>
<p>Not all formats can be reinterpreted into any format. The bpp must be the same. Compressed blocks (e.g. BCn) <a href="https://learn.microsoft.com/en-us/windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-block-compression#format-conversion-using-direct3d-101">have specific rules</a>. The reinterpretation must be supported by the GPU and API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">explicit_resolve</td><td>When absent (default), MSAA textures will have an extra non-MSAA copy where the contents are always resolved (unless store actions are not set to resolve).<br  />
 When present, there is no extra copy; and you must setup the RTV manually with a different non-MSAA texture where to resolve to. See <a class="el" href="compositor.html#MSAAExplicitResolves">MSAA with Explicit Resolves</a>.</td></tr>
    <tr><td class="paramname">not_texture</td><td>When absent (default), the texture can be bound as a regular texture for sampling (e.g. with point/bilinear filtering). When present, you can't sample from this texture. This flag is useful if you intend to use it together with uav or explicit_resolve.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="CompositorNodesTexturesMsaa"></a>
MSAA: Explicit vs Implicit resolves</h3>
<p>Not long ago, MSAA support was automatic, and worked flawlessly with forward renderers and no postprocessing. Direct3D 9 and OpenGL were not able to access the individual MSAA subsamples from shaders at all.</p>
<p>Fast forward to the present, MSAA resolving should be performed after HDR to avoid halos around edges, and deferred shading can't resolve the G-Buffer otherwise aliasing only gets worse.</p>
<p>Direct3D10 and GL 3.2 introduced the ability of access the MSAA subsamples from within a shader, also giving the ability to write custom resolves.</p>
<p>For those unaware what "resolving MSAA" means; a very brief explanation is that when rendering using 4xMSAA, we're actually rendering to a RT that is twice the resolution.</p>
<p>"Resolving" is the act of scaling down the resolution into the real RT (i.e. think of Photoshop or Gimp's downscale filter modes). See the Resources section at the end for links to detailed explanations of how MSAA works.</p>
<p>To cleanly deal with this new feature without breaking compatibility with D3D9 &amp; older GL render systems while at the same time being able to effortlessly switch MSAA on and off; the notion of "Explicit" and "Implicit" resolves were added.</p>
<h4><a class="anchor" id="CompositorNodesTexturesMsaaImplicit"></a>
Implicit resolves</h4>
<p>By default all RTTs are implicitly resolved. The behavior of implicitly resolved textures mimics <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x (except for implementation and design issues in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x that could cause an RTT to resolve multiple times per frame unnecessarily).</p>
<p>When you render and store actions are set to <code>store_or_resolve</code>, we will automatically resolve to the internal texture.</p>
<dl class="section note"><dt>Note</dt><dd>Cubemaps can't be implicitly resolved. They must use explicit resolves. See <a class="el" href="compositor.html#CompositorRtv_Examples">RTV Examples</a>.</dd></dl>
<h4><a class="anchor" id="CompositorNodesTexturesMsaaExplicit"></a>
Explicit resolves</h4>
<p>To perform explicit resolves you need to setup an RTV, see <a class="el" href="compositor.html#AdvancedMSAA">Advanced MSAA</a></p>
<h3><a class="anchor" id="CompositorNodesTexturesDepth"></a>
Depth Textures</h3>
<p>Since <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.1; depth textures are supported. It has been a feature missing from <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> since a long time by now.</p>
<p>Depth textures are a bit particular because they may not "own" the depth buffer. They're just a null render target with a "view" on an already existing depth buffer. But... what does this mean?</p>
<p>Depth Buffers can be tricky. Suppose the following example:</p>
<div class="fragment"><div class="line">compositor_node Example</div>
<div class="line">{</div>
<div class="line">        texture myDepthTexture 512 512 PF_D32_FLOAT</div>
<div class="line">        texture finalSSAO 512 512 PF_R8G8B8</div>
<div class="line">        <span class="comment">//Draw the depth</span></div>
<div class="line">        target myDepthTexture</div>
<div class="line">        {</div>
<div class="line">                pass clear {}</div>
<div class="line">                pass render_scene</div>
<div class="line">                {</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        target finalSSAO</div>
<div class="line">        {</div>
<div class="line">                pass clear {}</div>
<div class="line">                pass render_quad</div>
<div class="line">                {</div>
<div class="line">                        material DepthAnalysis</div>
<div class="line">                        input 0 myDepthTexture</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        out 0 finalSSAO</div>
<div class="line">}</div>
</div><!-- fragment --><p>Which simply does "Render a depth only pass to myDepthTexture; and read the depth buffer contents with a render quad, and store the results in a coloured RTT called 'finalSSAO' ".</p>
<p>That one was easy. But what about this one?</p>
<div class="fragment"><div class="line">compositor_node Example2</div>
<div class="line">{</div>
<div class="line">        texture firstPass 512 512 PF_R8G8B8</div>
<div class="line">        texture finalColour 512 512 PF_R8G8B8</div>
<div class="line">        <span class="comment">//Draw everything, colour and depth</span></div>
<div class="line">        target firstPass</div>
<div class="line">        {</div>
<div class="line">                pass clear {}</div>
<div class="line">                pass render_scene</div>
<div class="line">                {</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        target finalColour</div>
<div class="line">        {</div>
<div class="line">                pass clear {}</div>
<div class="line">                pass render_quad</div>
<div class="line">                {</div>
<div class="line">                        material SSAO</div>
<div class="line">                        input 0 ??? <span class="comment">// Depth, firstPass&#39; depth texture?</span></div>
<div class="line">                        input 1 firstPass</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        out 0 finalColour</div>
<div class="line">}</div>
</div><!-- fragment --><p>The first pass is a pass that includes both colour and depth. The second one, we want to just take the depth and colour buffers separately as input textures to the SSAO material pass.</p>
<p>But how do we take the depth buffer? For that, we need to do two steps:</p>
<ol type="1">
<li>Request the original RTT that it wants to use a depth texture.</li>
<li>Create a depth texture that will be a "view" to the depth buffer. Depth buffer sharing system should assign the same depth buffer to the RTT and the depth texture "view".</li>
</ol>
<p>The solution is the following:</p>
<div class="fragment"><div class="line">compositor_node Example2_fixed</div>
<div class="line">{</div>
<div class="line">        <span class="comment">//Instruct we want to use a depth texture (32-bit float). The &quot;depth_texture&quot; keyword is necessary.</span></div>
<div class="line">        <span class="comment">//Specifying The depth format is optional and so is the depth pool. However recommended to specify</span></div>
<div class="line">        <span class="comment">//them to avoid surprises.</span></div>
<div class="line">        texture firstPass 512 512 PF_R8G8B8 depth_format PF_D32_FLOAT depth_texture depth_pool 1</div>
<div class="line">        <span class="comment">//Declare the depth texture view (which becomes so by using PF_D32_FLOAT as format).</span></div>
<div class="line">        <span class="comment">//Settings MUST match (depth format, pools, resolution). Specifying the depth pool is necessary,</span></div>
<div class="line">        <span class="comment">//otherwise the depth texture will get its own depth buffer, instead of becoming a view.</span></div>
<div class="line">        texture firstPassDepthTexture 512 512 PF_D32_FLOAT depth_pool 1</div>
<div class="line">        texture finalColour 512 512 PF_R8G8B8</div>
<div class="line">        <span class="comment">//Draw everything, colour and depth</span></div>
<div class="line">        target firstPass</div>
<div class="line">        {</div>
<div class="line">                pass clear {}</div>
<div class="line">                pass render_scene</div>
<div class="line">                {</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        target finalColour</div>
<div class="line">        {</div>
<div class="line">                pass clear {}</div>
<div class="line">                pass render_quad</div>
<div class="line">                {</div>
<div class="line">                        material SSAO</div>
<div class="line">                        input 0 firstPassDepthTexture</div>
<div class="line">                        input 1 firstPass</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        out 0 finalColour</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>On a lot of Hardware, depth buffers are compressed (see <a href="https://archive.org/details/depth-in-depth">Depth In Depth</a> and <a href="https://archive.org/details/ati-radeon-hd-2000-programming-guide">ATI Radeon HD 2000 Programming Guide</a>). Before AMD's GCN Taihiti hardware (AMD Radeon R9 280), <b>depth buffers need to be decompressed when bound for sampling as a depth texture.</b> Trying to use the depth texture as a depth buffer again without clearing it will degrade due to the lack of compression. <br  />
 <br  />
 It is suggested to copy the depth texture to another depth texture if you desire to use one for sampling and another to keep rendering, in order to maximize performance. <br  />
 <br  />
 The specifics of depth (de)compression for NVIDIA and Intel aren't known but it's probable they're bound to similar issues. <br  />
 <br  />
 TODO: Compositor interface to copy depth texture to another depth texture automatically.</dd></dl>
<h1><a class="anchor" id="CompositorShadowNodes"></a>
Shadow Nodes</h1>
<p>The only way to have shadows in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> is through shadow nodes.</p>
<p>Stencil shadows and "textured shadows" have been removed from <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0; only depth shadow maps are supported.</p>
<p>A shadow node is a special type of Node (in fact, the class inherits from CompositorNode) that is executed inside a regular node (normally, a render_scene pass) instead of being connected to other nodes.</p>
<p>It is possible however, to connect the output from a Shadow Node to a regular Node for further postprocessing (i.e. reflective shadow maps for real time Global Illumination), but Shadow Nodes cannot have input. <em>This particular feature (output to regular nodes) is still a work in progress at the time of writing since ensuring the regular node is executed after the shadow node has been executed can be a bit tricky</em>.</p>
<h2><a class="anchor" id="CompositorShadowNodesSetup"></a>
Setting up shadow nodes</h2>
<p>Shadow nodes work very similar to regular nodes. Perhaps their most noticeable difference is how are RTTs defined. The following keywords are supposed at shadow node scope:</p>
<ul>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_technique">technique</a></li>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_num_splits">num_splits</a></li>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_num_stable_splits">num_stable_splits</a></li>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_normal_offset_bias">normal_offset_bias</a></li>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_constant_bias_scale">constant_bias_scale</a></li>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_pssm_lambda">pssm_lambda</a></li>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_pssm_split_blend">pssm_split_blend</a></li>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_pssm_split_fade">pssm_split_fade</a></li>
<li><a class="el" href="compositor.html#CompositorShadowNodesSetup_shadow_map">shadow_map</a></li>
</ul>
<h4><a class="anchor" id="CompositorShadowNodesSetup_technique"></a>
technique</h4>
<p>Specifies which shadow technique to use for the subsequent shadow map declarations. The default is uniform.</p>
<dl class="section note"><dt>Note</dt><dd>planeoptimal has also not been implemented yet.</dd></dl>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">technique &lt;uniform|planeoptimal|focused|pssm&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorShadowNodesSetup_num_splits"></a>
num_splits</h4>
<p>Only used by PSSM techniques. Specifies the number of splits per light. Can vary per shadow map. The number of splits must be greater than 2. Default is 3.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">num_splits &lt;num_splits&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorShadowNodesSetup_num_stable_splits"></a>
num_stable_splits</h4>
<p>PSSM tends to be very unstable to camera rotation changes. Just rotate the camera around without changing its position and the shadow mapping artifacts keep flickering.</p>
<p><a class="el" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#ae856178ef392e5f8b082cea81b15c141" title="PSSM tends to be very unstable to camera rotation changes.">Ogre::PSSMShadowCameraSetup::setNumStableSplits</a> allows you to fix that problem by switching to <a class="el" href="class_ogre_1_1_concentric_shadow_camera.html">ConcentricShadowCamera</a> for the first N splits you specify while the remaining splits will use FocusedShadowCameraSetup.</p>
<p><b>We achieve rotation stability by sacrificing overall quality.</b> Using ConcentricShadowCamera on higher splits means exponentially sacrificing a lot more quality (and even performance); thus the recommended values are num_stable_splits = 1 or num_stable_splits = 2.</p>
<p>The default is num_stable_splits = 0 which disables the feature.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">num_stable_splits &lt;num_stable_splits&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorShadowNodesSetup_normal_offset_bias"></a>
normal_offset_bias</h4>
<p>Normal-offset bias is per cascade / shadow map to fight shadow acne and self shadowing artifacts. Very large values can cause misalignments between the objects and their shadows (if they're touching).</p>
<p>Default is 168.0.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">normal_offset_bias &lt;value&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorShadowNodesSetup_constant_bias_scale"></a>
constant_bias_scale</h4>
<p>Constant bias is normally per material (tweak <a class="el" href="class_ogre_1_1_hlms_datablock.html#ae0ab6a48ea79da805bc7ba0e4908190c">HlmsDatablock::mShadowConstantBias</a>). This value lets you multiply it 'mShadowConstantBias * constantBiasScale' per cascade / shadow map</p>
<p>Large values cause peter-panning.</p>
<p>Default is 1.0.</p>
<div class="fragment"><div class="line">constant_bias_scale &lt;value&gt;</div>
</div><!-- fragment --><h4><a class="anchor" id="CompositorShadowNodesSetup_pssm_lambda"></a>
pssm_lambda</h4>
<p>Used only by PSSM techniques. Value should be in range [0; 1]. The default is 0.95. PSSM's lambda is a weight value for a linear interpolation between exponential and linear separation between each split. A higher lambda will use exponential distribution, thus closer shadows will improve quality. A lower lambda will use a linear distribution, pushing the splits further, improving the quality of shadows in the distance.</p>
<div class="fragment"><div class="line">pssm_lambda &lt;value&gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Lambda   </th><th class="markdownTableHeadNone">Close Shadows   </th><th class="markdownTableHeadNone">Far Shadows    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.0   </td><td class="markdownTableBodyNone">Low Quality   </td><td class="markdownTableBodyNone">High Quality    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">High Quality   </td><td class="markdownTableBodyNone">Low Quality   </td></tr>
</table>
<h4><a class="anchor" id="CompositorShadowNodesSetup_pssm_split_blend"></a>
pssm_split_blend</h4>
<p>Used only by PSSM techniques. Value in range [0; 1]. The default is 0.125; use 0 to disable it. PSSM's blend defines, in the closest N-1 splits, the blend band size. E.g., a value of 0.1 means that the farthest 10% of the first split is blended with the second split (and so on for the other splits). A higher blend reduces visible seams between splits at a cost of a slightly less defined shadow. See <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416307(v=vs.85).aspx">Blend between Cascades</a> for additional info.</p>
<div class="fragment"><div class="line">pssm_split_blend &lt;value&gt;</div>
</div><!-- fragment --><h4><a class="anchor" id="CompositorShadowNodesSetup_pssm_split_fade"></a>
pssm_split_fade</h4>
<ul>
<li>pssm_split_fade &lt;fade&gt;</li>
</ul>
<p>Used only by PSSM techniques. Value in range [0; 1]. The default is 0.313; use 0 to disable it. PSSM's fade defines how much of the last split will fade out. E.g., a value of 0.1 means that the farthest 10% of the last split will fade out. A higher fade makes the transition from shadowed to non shadowed areas (and viceversa) smoother at a cost of a less visible distant shadow.</p>
<div class="fragment"><div class="line">pssm_split_fade &lt;value&gt;</div>
</div><!-- fragment --><h4><a class="anchor" id="CompositorShadowNodesSetup_shadow_map"></a>
shadow_map</h4>
<div class="fragment"><div class="line">shadow_map &lt;number&gt; &lt;texture_name&gt; [uv &lt;left&gt; &lt;top&gt; &lt;width&gt; &lt;height&gt;] light &lt;light_index&gt; [split &lt;index&gt;]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>The number of the shadow map being defined.</td></tr>
    <tr><td class="paramname">texture_name</td><td>What texture to use which must have already been declared, where the shadow map contents will be stored.</td></tr>
    <tr><td class="paramname">uv</td><td>Optional. After this keyword, 4 more numbers must follow (left, top, width, height). <br  />
 An atlas allows you to use a region of a texture. Instead of using the whole atlas content, you can use a region of it. This allows you to have multiple shadow maps in the same texture.</td></tr>
    <tr><td class="paramname">left</td><td></td></tr>
    <tr><td class="paramname">top</td><td>Specifies the left &amp; top origin of the shadow map inside the atlas. In UV space. in range [0; 1].</td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td>Specifies the width &amp; height of the shadow map inside the atlas. In UV space. in range [0; 1].</td></tr>
    <tr><td class="paramname">light</td><td>After <code>light</code> must follow the number for the light. Indicates which light index will be associated with this shadow map. This is useful for PSSM because multiple shadow maps may refer to the same light.</td></tr>
    <tr><td class="paramname">split</td><td>Optional. After <code>split</code> must follow the split index. Used by PSSM, indicates which split does this shadow map handle.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="CompositorShadowNodesExample"></a>
Example</h2>
<p>Declaring a shadow map is not enough. You need to tell OgreNext what do you want to render to it and how. And for that you need <a class="el" href="compositor.html#CompositorNodesPassesRenderScene">render_scene</a> passes.</p>
<p>Shadow nodes can be written with the regular <code>target { pass render_scene {} }</code> syntax. However when you have 6 shadow maps with the same exact pass settings, it's cumbersome to write the pass six times. Instead the <code>shadow_map</code> keyword repeats the passes for you.</p>
<p>The following is a basic script that will set a single shadow map with a focused setup:</p>
<div class="fragment"><div class="line">compositor_node_shadow myShadowNode</div>
<div class="line">{</div>
<div class="line">    technique focused</div>
<div class="line">    texture focusedTex 2048 2048 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line">    shadow_map 0 focusedTex light 0</div>
<div class="line">    <span class="comment">// Render shadow map &quot;0&quot;</span></div>
<div class="line">    shadow_map_target_type directional spot</div>
<div class="line">    {</div>
<div class="line">        shadow_map 0</div>
<div class="line">        {</div>
<div class="line">            pass render_scene</div>
<div class="line">            {</div>
<div class="line">                load</div>
<div class="line">                {</div>
<div class="line">                    all clear</div>
<div class="line">                }</div>
<div class="line">                rq_first 0</div>
<div class="line">                rq_last max</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup___image_html_gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058"><div class="ttname"><a href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">Ogre::PFG_D32_FLOAT</a></div><div class="ttdeci">@ PFG_D32_FLOAT</div><div class="ttdef"><b>Definition:</b> OgrePixelFormatGpu.h:89</div></div>
</div><!-- fragment --><p>The typical setup is to have one directional light for the sun. And then multiple point or spot lights.</p>
<p>This means directional light should use a PSSM setting for best quality while point &amp; spot lights shadow maps could use focused or uniform.</p>
<p>The following script creates 3 shadow maps for 3 PSSM splits, and 3 additional ones for the remaining lights (which can be either directional or spot):</p>
<div class="fragment"><div class="line">compositor_node_shadow myShadowNode</div>
<div class="line">{</div>
<div class="line">    technique pssm</div>
<div class="line"> </div>
<div class="line">    texture tex_for_pssm0 2048 2048 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line">    texture tex_for_pssm1 1024 1024 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line">    texture tex_for_pssm2 1024 1024 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line"> </div>
<div class="line">    texture tex_for_spot0 2048 2048 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line">    texture tex_for_spot1 2048 2048 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line"> </div>
<div class="line">    num_splits      3</div>
<div class="line">    pssm_lambda     0.95</div>
<div class="line">    <span class="comment">// Store 1st closest light, splits 0 1 &amp; 2</span></div>
<div class="line">    shadow_map 0 tex_for_pssm0 light 0 split 0</div>
<div class="line">    shadow_map 1 tex_for_pssm1 light 0 split 1</div>
<div class="line">    shadow_map 2 tex_for_pssm2 light 0 split 2</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Change to focused from now on</span></div>
<div class="line">    technique focused</div>
<div class="line">    shadow_map 3 tex_for_spot0 light 1</div>
<div class="line">    shadow_map 4 tex_for_spot1 light 2</div>
<div class="line"> </div>
<div class="line">    shadow_map_target_type directional</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Render shadow maps 0, 1 and 2.</span></div>
<div class="line">        <span class="comment">// Can only be used by directional lights.</span></div>
<div class="line">        shadow_map 0 1 2</div>
<div class="line">        {</div>
<div class="line">            pass render_scene</div>
<div class="line">            {</div>
<div class="line">                load</div>
<div class="line">                {</div>
<div class="line">                    all clear</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    shadow_map_target_type directional spot</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Render shadow maps 3 and 4</span></div>
<div class="line">        <span class="comment">// Can only be used by either directional lights or spot lights.</span></div>
<div class="line">        shadow_map 3 4</div>
<div class="line">        {</div>
<div class="line">            pass render_scene</div>
<div class="line">            {</div>
<div class="line">                load</div>
<div class="line">                {</div>
<div class="line">                    all clear</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="CompositorShadowNodesAtlasAndPointLights"></a>
Shadow map atlas &amp; Point Lights</h2>
<p>Instead of rendering each PSSM split into a different texture, you can use an atlas:</p>
<div class="fragment"><div class="line">compositor_node_shadow PssmWithAtlas</div>
<div class="line">{</div>
<div class="line">    technique pssm</div>
<div class="line"> </div>
<div class="line">    texture atlas 3072 2048 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//The splits are distributed in the atlas like this:</span></div>
<div class="line">    <span class="comment">//  -------------</span></div>
<div class="line">    <span class="comment">//  |     |  2  |</span></div>
<div class="line">    <span class="comment">//  |  1  |-----|</span></div>
<div class="line">    <span class="comment">//  |     |  3  |</span></div>
<div class="line">    <span class="comment">//  -------------</span></div>
<div class="line">    num_splits      3</div>
<div class="line">    pssm_lambda     0.95</div>
<div class="line">    shadow_map 0 atlas uv 0.000000000000000 0.0 0.666666666666667 1.0 light 0 split 0</div>
<div class="line">    shadow_map 1 atlas uv 0.666666666666667 0.0 0.333333333333333 0.5 light 0 split 1</div>
<div class="line">    shadow_map 2 atlas uv 0.666666666666667 0.5 0.333333333333333 0.5 light 0 split 2</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Before doing anything, clear the whole atlas in one go. This is not</span></div>
<div class="line">    <span class="comment">// ideal on iOS &amp; Android though; but recommended on Desktop.</span></div>
<div class="line">    target atlas</div>
<div class="line">    {</div>
<div class="line">        pass clear</div>
<div class="line">        {</div>
<div class="line">            colour_value 1 1 1 1</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    shadow_map_target_type directional</div>
<div class="line">    {</div>
<div class="line">        shadow_map 0 1 2</div>
<div class="line">        {</div>
<div class="line">            pass render_scene</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// The viewport settings will be automatically</span></div>
<div class="line">                <span class="comment">// adjusted to constrain to the atlas regions.</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Point light shadow mapping must exploit the powerful compositor scripting capabilities: OgreNext uses DPSM (Dual Paraboloid Shadow Maps).</p>
<p>Please note we will be rendering to cubemaps, then converting to DPSM.</p>
<p>We won't be rendering directly as DPSM because testing shows it deforms too much when tessellation is low. We could support it, but it's not a priority. Thus OgreNext first needs to render to a cubemap, which can be shared by all shadow maps, and then a converter transforms it to DPSM.</p>
<p>The reason to use scene -&gt; Cubemap -&gt; DPSM is so that we keep a reasonable memory footprint and be atlas-friendly. If we use cubemaps directly and want to support 8 point lights at 1024x1024, then we would need 1024x1024x6x8 = 192MB.</p>
<p>However with DPSM it would be 8 DPSM and 1 cubemap: 1024x1024x4x8 + 1024x1024x4x6 = 56MB.</p>
<p>The following example setups a script to support two point lights (and <b>only</b> two point lights):</p>
<div class="fragment"><div class="line"><span class="keyword">abstract</span> target cubemap_target_shadow</div>
<div class="line">{</div>
<div class="line">    pass render_scene</div>
<div class="line">    {</div>
<div class="line">        load</div>
<div class="line">        {</div>
<div class="line">            all                                 clear</div>
<div class="line">            clear_colour_reverse_depth_aware    1 1 1 1</div>
<div class="line">        }</div>
<div class="line">        store</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//We only care about the contents of the colour target with point shadows</span></div>
<div class="line">            depth           dont_care</div>
<div class="line">            stencil         dont_care</div>
<div class="line">        }</div>
<div class="line">        camera_cubemap_reorient <span class="keyword">true</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">compositor_node_shadow PointLight</div>
<div class="line">{</div>
<div class="line">    technique pssm</div>
<div class="line"> </div>
<div class="line">    texture pointLightTex0 2048 2048 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line">    texture pointLightTex1 2048 2048 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line">    texture tmpCubemap 1024 1024 <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a96e16f1358f65eaf3717b5994c59aa12">PFG_R32_FLOAT</a> cubemap depth_format <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a></div>
<div class="line"> </div>
<div class="line">    technique focused</div>
<div class="line">    shadow_map 0 pointLightTex0 light 0</div>
<div class="line">    shadow_map 1 pointLightTex1 light 1</div>
<div class="line"> </div>
<div class="line">    shadow_map_target_type point</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//shadow_map_repeat tells to repeat what&#39;s inside its body for shadow map 0 &amp; 1</span></div>
<div class="line">        shadow_map_repeat 0 1</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Render to the cubemap with the camera settings of</span></div>
<div class="line">            <span class="comment">// the currently iterated point light shadow map</span></div>
<div class="line">            target tmpCubemap +X : cubemap_target_shadow {}</div>
<div class="line">            target tmpCubemap -X : cubemap_target_shadow {}</div>
<div class="line">            target tmpCubemap +Y : cubemap_target_shadow {}</div>
<div class="line">            target tmpCubemap -Y : cubemap_target_shadow {}</div>
<div class="line">            target tmpCubemap +Z : cubemap_target_shadow {}</div>
<div class="line">            target tmpCubemap -Z : cubemap_target_shadow {}</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Render to the current shadow map being iterated.</span></div>
<div class="line">            shadow_map</div>
<div class="line">            {</div>
<div class="line">                pass render_quad</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// This material can be found in Samples/Media/2.0/materials/Common</span></div>
<div class="line">                    material <a class="code" href="namespace_ogre.html">Ogre</a>/DPSM/CubeToDpsm</div>
<div class="line">                    input 0 tmpCubemap</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup___image_html_gga71f09fe41a1db41186262f1aa5814a18a96e16f1358f65eaf3717b5994c59aa12"><div class="ttname"><a href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a96e16f1358f65eaf3717b5994c59aa12">Ogre::PFG_R32_FLOAT</a></div><div class="ttdeci">@ PFG_R32_FLOAT</div><div class="ttdef"><b>Definition:</b> OgrePixelFormatGpu.h:90</div></div>
<div class="ttc" id="anamespace_ogre_html"><div class="ttname"><a href="namespace_ogre.html">Ogre</a></div><div class="ttdoc">bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;</div><div class="ttdef"><b>Definition:</b> OgreAndroidLogListener.h:35</div></div>
</div><!-- fragment --><p>See Samples/Media/2.0/scripts/Compositors/ShadowMapDebugging.compositor for an example of a full script that can support directional, spot &amp; point lights all in one, in a single atlas.</p>
<h2><a class="anchor" id="CompositorShadowNodesReuseEtc"></a>
Reuse, recalculate and first</h2>
<p>Each <code>PASS_SCENE</code> from regular nodes have three settings:</p>
<ol type="1">
<li><code>SHADOW_NODE_REUSE</code></li>
<li><code>SHADOW_NODE_RECALCULATE</code></li>
<li><code>SHADOW_NODE_FIRST_ONLY</code></li>
</ol>
<p>This affect when shadow nodes are executed and how they cache their results. The default value is <code>SHADOW_NODE_FIRST_ONLY</code>; in which means <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> should manage this automatically; however there are times when <code>SHADOW_NODE_REUSE</code> could be useful.</p>
<p>It's easier to explain what they do with examples.</p>
<p>Suppose the user has two <code>render_scene</code> passes, both have the same shadow node associated:</p>
<ol type="1">
<li>One for opaque geometry.</li>
<li>Another for transparent geometry,</li>
</ol>
<p>If using <code>SHADOW_NODE_FIRST_ONLY</code>, when the first pass is executed (opaque geometry), <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will first execute the shadow nodes, updating the shadow maps; then render the opaque geometry.</p>
<p>When the second pass is executed (transparent geometry), the shadow node won't be executed as the shadow maps are supposed to be up to date; hence the transparent geometry will reuse the results.</p>
<p>Another example: Suppose the user has three passes:</p>
<ol type="1">
<li>One for opaque geometry.</li>
<li>Another for reflections, seen from a different camera.</li>
<li>The last pass for transparent geometry, rendered using the same camera as opaque geometry.</li>
</ol>
<p>If using <code>SHADOW_NODE_FIRST_ONLY</code>; the shadow node will be executed before the opaque geometry pass.</p>
<p>Then the reflections' pass comes. It uses a different camera, which means there could be a different set of lights that will be used for shadow casting (since some techniques set shadow cameras relative to the rendering camera for optimum quality, pssm splits become obsolete, some lights are closer to this camera than they were to the player's camera, etc). <em><b><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> has no choice but to recalculate and execute the shadow node again, updating the shadow maps</b></em>.</p>
<p>When the third pass kicks in, the camera has changed again; thus we need to execute the shadow node... again!</p>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will log a warning when it detects a suboptimal compositor setup such as this one. To be more specific, <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> detects that the 3rd pass uses the same results as the 1st pass, but the shadow node is being forced to recalculate in the third one, instead of reusing.</p>
<p>There are several ways to solve this problem:</p>
<ol type="1">
<li>Render reflections first: This is perhaps the most obvious one. If there are no data dependencies; first perform the reflection pass, and then the opaque &amp; transparent passes; so the shadow node is executed twice instead of three times.</li>
<li>Use two shadow nodes: When the first option isn't viable (i.e. there's a data dependency) using two shadow nodes will guarantee the results don't get overwritten. This option needs more VRAM though.</li>
<li><b>Use SHADOW_NODE_REUSE in the reflection render_scene pass:</b> This will force <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> not to execute the shadow node. This assumes you know what you're doing or else you may experience glitches (i.e. pssm splits aren't fully usable from a camera with a different position). This is useful though, if you wish to maintain consistency in the light list being used (since recalculation may cause a different set of lights to be used for shadow maps, since it depends on proximity to the active camera). Another reason to force reusage could be performance: The shadow node is only being executed once.</li>
</ol>
<p>The setting <code>SHADOW_NODE_RECALCULATE</code> forces <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to always recalculate. <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will not issue a warning if it detects your node setup is suboptimal because of passes using <code>SHADOW_NODE_RECALCULATE</code>.</p>
<p>Forcing recalculation only makes sense when the application makes relevant changes to the camera between passes that <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> cannot detect (i.e. change the position or the orientation through listeners)</p>
<h2><a class="anchor" id="CompositorShadowNodesTypes"></a>
Shadow mapping setup types</h2>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> supports 5 depth shadow mapping techniques. Although they're as old as <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.4 or older, they've never been mentioned in the manual, and the doxygen documentation is quite cryptic, assuming the reader is quite familiar with the original papers. Here each is technique explained.</p>
<h3><a class="anchor" id="CompositorShadowNodesTypesUniform"></a>
Uniform shadow mapping</h3>
<p>The oldest form of shadow mapping, and the most simple one. It's very basic and thus probably glitch-free. However it's quality is very bad, even on high resolutions.</p>
<p>The user needs to call <code>SceneManager::setShadowDirectionalLightExtrusionDistance</code> &amp; <code>SceneManager::getShadowFarDistance</code> let <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> know how far directional lights should be from camera (since theoretically they're infinitely distant). If the value is too low, some casters won't be included and thus won't cast a shadow. Too high and the quality will quickly degrade.</p>
<p>Most likely only useful for testing that shaders are working correctly, and shadows not showing up correctly is not an <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> bug or the scene (i.e. casters with infinite aabbs can cause trouble for Focused techniques).</p>
<h3><a class="anchor" id="CompositorShadowNodesTypesFocused"></a>
Focused</h3>
<p>An improved form over uniform shadow mapping. The technique uses the AABB enclosing all casters, an AABB enclosing all receivers visible by the current camera and the camera's frustum to build a hull (which is the intersection of all three, also known as the "intersection body B"). With this hull's information, Focused shadow mapping is able to deduce the optimal extrusion distance (no need to set it like in uniform shadow mapping), and create a much tighter near and far plane, resulting in much superior quality.</p>
<p><code>SceneManager::getShadowFarDistance</code> is still used, and it can cause major quality improvements, because the camera's frustum used to build the hull is first clipped at the shadow far distance (instead of using the camera's far plane)</p>
<p>Most of the time, this is one of the best choices for general shadow mapping.</p>
<h3><a class="anchor" id="CompositorShadowNodesTypesPssm"></a>
PSSM / CSM</h3>
<p>PSSM stands for Parallel Split Shadow Mapping aka. Cascaded Shadow Maps.</p>
<p>Shadow maps are divided into "cascades" or "splits"; in order to improve quality. So instead of getting one RTT per light, the user gets multiple RTTs per light. Usually the depth in camera space is determining factor to know which cascade/split to use.</p>
<p>There's a lot of resources on internet regarding PSSM / CSM:</p>
<ul>
<li><a href="http://mynameismjp.wordpress.com/2013/09/10/shadow-maps/">A Sampling of Shadow Techniques</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee416307(v=vs.85).aspx">Cascaded Shadow Maps</a></li>
<li><a href="http://visual-computing.intel-research.net/art/publications/sdsm/">Sample Distribution Shadow Maps</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch10.html">Parallel-Split Shadow Maps on Programmable GPUs</a></li>
</ul>
<p>The original technique was introduced by Fan Zhang, Hanqiu Sun, Leilei Xu &amp; Lee Kit Lun</p>
<h3><a class="anchor" id="CompositorShadowNodesTypesPlaneOptimal"></a>
Plane Optimal</h3>
<p>TBD</p>
<h1><a class="anchor" id="CompositorWorkspaces"></a>
Workspaces</h1>
<p>Nodes are useless without setting up a workspace.</p>
<p>A workspace defines what nodes are going to be used and how they're going to be connected. They also need to declare global textures. <b>Declaration order is very important</b>.</p>
<p>Nodes are automatically in use when their connection is specified.</p>
<ul>
<li><a class="el" href="compositor.html#CompositorWorkspaces_connect">connect</a></li>
<li><a class="el" href="compositor.html#CompositorWorkspaces_connect_external">connect_external</a></li>
<li><a class="el" href="compositor.html#CompositorWorkspaces_alias">alias</a></li>
<li><a class="el" href="compositor.html#CompositorWorkspaces_buffer">buffer</a></li>
<li><a class="el" href="compositor.html#CompositorWorkspaces_connect_buffer">connect_buffer</a></li>
<li><a class="el" href="compositor.html#CompositorWorkspaces_connect_buffer_external">connect_buffer_external</a></li>
</ul>
<h4><a class="anchor" id="CompositorWorkspaces_connect"></a>
connect</h4>
<div class="fragment"><div class="line">connect &lt;node_name_1&gt; [&lt;output_ch #&gt;] [&lt;output_ch #&gt;]  &lt;node_name_2&gt; [&lt;input_ch #&gt;] [&lt;input_ch #&gt;]</div>
</div><!-- fragment --><p>Connects the Node "node_name_1" output channels to "node_name_2" input channels. This implicitly means "node_name_1" &amp; "node_name_2" will be used and executed by the workspace (even if they're isolated and never reach the screen)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_name_1</td><td>The name of the Node that will be executed before "node_name_2"</td></tr>
    <tr><td class="paramname">output_ch</td><td>Channel numbers from node_name_1's output channels that will be connected to node_name_2.</td></tr>
    <tr><td class="paramname">node_name_2</td><td>The name of the Node that will be executed after "node_name_1"</td></tr>
    <tr><td class="paramname">input_ch</td><td>Channel numbers from node_name_2's inputs channels that will be connected from node_name_2 bindings.</td></tr>
  </table>
  </dd>
</dl>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">//Connect nodeA to nodeB</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 0 ==&gt; B&#39;s input channel 1</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 1 ==&gt; B&#39;s input channel 2</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 2 ==&gt; B&#39;s input channel 0</span></div>
<div class="line">connect nodeA 0 1 2 nodeB 1 2 0</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Connect nodeA to nodeB</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 0 ==&gt; B&#39;s input channel 0</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 2 ==&gt; B&#39;s input channel 1</span></div>
<div class="line">connect nodeA 0 2 nodeB  0 1</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Connect nodeC to nodeB</span></div>
<div class="line"><span class="comment">//C&#39;s output channel 3 ==&gt; B&#39;s input channel 1</span></div>
<div class="line">connect nodeC 3 nodeB 1</div>
</div><!-- fragment --><p>Not all output channels must be used. Take in mind that if an output is not used at all, it will still take CPU &amp; GPU processing time.</p>
<dl class="section note"><dt>Note</dt><dd>All nodes must have their input channels connected. If a node has a disconnected input channel, the workspace will fail to initialize and throw a warning. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Nodes that have no input channels will be the first to be executed, regardless of declaration order (but nodes without input channels declared first should run before nodes declared later with no input channels). Take this in mind if you plan to use global textures as a means of passing information (usually a very bad idea).</dd></dl>
<h4><a class="anchor" id="CompositorWorkspaces_connect_external"></a>
connect_external</h4>
<div class="fragment"><div class="line">connect_external &lt;external_channel #&gt; &lt;node_name&gt; &lt;input_channel #&gt;</div>
</div><!-- fragment --><p>Connects the final render target (i.e. the RenderWindow) to the specified input channel from the node. Implicitly the node will be used and executed. The render target in external channel #0 is always used as the reference for target_width, target_width_scaled and all other parameters that are based on an external RTT. You can use connect_external as many times as you want. The external render targets are passed in C++ code when initializing the Workspace.</p>
<p>It is possible for a Workspace to not use this variable (though rather pointless)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">external_channel</td><td>The index to the external texture or UAV buffer passed to addWorkspace.</td></tr>
    <tr><td class="paramname">node_name</td><td>The name of the Node that will receive the external texture.</td></tr>
    <tr><td class="paramname">input_channel</td><td>The number of the input channel from node_name.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">//Pass the external texture to nodeA through channel #0</span></div>
<div class="line">connect_external 0 nodeA 0</div>
<div class="line"><span class="comment">//Pass the external texture to nodeB through channel #0</span></div>
<div class="line">connect_external 0 nodeB 0</div>
<div class="line"><span class="comment">//Pass a second external texture to nodeB through channel #1</span></div>
<div class="line">connect_external 1 nodeB 1</div>
</div><!-- fragment --><div class="fragment"><div class="line">connect_output &lt;node_name&gt; &lt;input_channel #&gt;</div>
</div><!-- fragment --><p>It's the same as <code>connect_external 0 &lt;node_name&gt; &lt;input_channel&gt;</code>.</p>
<p>Provided for compatibility reasons and convenience. Originally only one connect_output was allowed, but now you can use it as many as you need.</p>
<h4><a class="anchor" id="CompositorWorkspaces_alias"></a>
alias</h4>
<div class="fragment"><div class="line">alias &lt;node_name&gt; &lt;aliased_name&gt;</div>
</div><!-- fragment --><p>Normally, a Node is always reused. So, if node A connects to B and C; and D connects to A; it's always the same node A the one we're talking about. The definition is only instantiated once.</p>
<p>However there may be cases where you want to have multiple instances of the same node definition (i.e. because you want unique local textures, or because you want to repeat a process on a different set of nodes), and hence that's what node aliasing does. Once an alias is declared, the node will be instantiated with a different name (its aliased name), and will be possible to make connections with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_name</td><td>The name of the original instance </td></tr>
    <tr><td class="paramname">aliased_name</td><td>The alias name to give to this separate instance. The alias must be unique across the workspace, and must also be unique across the names of original node definitions.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><div class="line">workspace MyWorkspace</div>
<div class="line">{</div>
<div class="line">    alias nodeA UniqueNode1     <span class="comment">//Instantiate nodeA, calling it UniqueNode1</span></div>
<div class="line"> </div>
<div class="line">    connect nodeA       0 UniqueNode1 0</div>
<div class="line">    connect nodeA       0 nodeB 0</div>
<div class="line">    connect UniqueNode1 0 nodeB 1</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="CompositorWorkspaces_buffer"></a>
buffer</h4>
<div class="fragment"><div class="line">buffer &lt;buffer_name&gt; &lt;num_elements&gt; &lt;bytes_per_element&gt; [target_width] [target_width_scaled] [target_height] [target_height_scaled]</div>
</div><!-- fragment --><p>Creates an UAV buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_name</td><td>The name of the buffer. Unlike textures, there are no naming restrictions (i.e. no <code>global_</code> prefix). If a buffer local to the node and a global buffer have the same name, the local one takes precedence and a warning is logged.</td></tr>
    <tr><td class="paramname">num_elements</td><td>The number of elements in the UAV. Must be a number higher than 0.</td></tr>
    <tr><td class="paramname">bytes_per_element</td><td>Bytes per element. Must be a number higher than 0.</td></tr>
    <tr><td class="paramname">target_width</td><td></td></tr>
    <tr><td class="paramname">target_height</td><td></td></tr>
    <tr><td class="paramname">target_width_scaled</td><td></td></tr>
    <tr><td class="paramname">target_height_scaled</td><td>See <a class="el" href="compositor.html#CompositorNodesTextures">texture</a> they work like their texture counterparts, and when present, will be multiplied against the number of elements.</td></tr>
  </table>
  </dd>
</dl>
<p>The size of the UAV buffer is calculated as follows:</p>
<div class="fragment"><div class="line">finalNumElements = numElements * bytesPerElement;</div>
<div class="line"><span class="keywordflow">if</span>( widthFactor &gt; 0 )</div>
<div class="line">    finalNumElements *= (widthFactor * width);</div>
<div class="line"><span class="keywordflow">if</span>( heightFactor &gt; 0 )</div>
<div class="line">    finalNumElements *= (heightFactor * height);</div>
</div><!-- fragment --><p>For example if you want to do 512 x height; just set numElements to 512 and target_height or target_height_scaled 1.</p>
<p>Since there are no pixel formats, the bytesPerElement controls such such thing (eg. 4 bytes for RGBA8_UNORM).</p>
<p>UAV Buffers are not just for storing contiguous texture data. For example if you run a compute shader that gathers all lights, you would store the following in an UAV buffer:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="namespace_ogre_1_1_scene_flags.html#af3190017d83d94455e645c506aa1681ba9116754b875c4e6c60a159495035eaff">Lights</a></div>
<div class="line">{</div>
<div class="line">    float3 position;</div>
<div class="line">    float3 direction;</div>
<div class="line">    float3 diffuse;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">RWStructuredBuffer&lt;Lights&gt; myLights;</div>
<div class="ttc" id="anamespace_ogre_1_1_scene_flags_html_af3190017d83d94455e645c506aa1681ba9116754b875c4e6c60a159495035eaff"><div class="ttname"><a href="namespace_ogre_1_1_scene_flags.html#af3190017d83d94455e645c506aa1681ba9116754b875c4e6c60a159495035eaff">Ogre::SceneFlags::Lights</a></div><div class="ttdeci">@ Lights</div><div class="ttdef"><b>Definition:</b> OgreSceneFormatBase.h:60</div></div>
</div><!-- fragment --><p>In this case, numElements = 16 means we can address up to myLights[15]; and bytesPerElement = 36.</p>
<p>bytesPerElement must account padding according to the HLSL rules (4 x 4 x 3 =&gt;; 4 floats x sizeof(float) x 3).</p>
<p>Because calculation of bytesPerElement can get really tricky by hand (or may change dynamically at runtime), complex cases are best if the UAV is created in C++, and passed to the Workspace via connect_buffer_external.</p>
<p>Why consider UAV buffers for texture operations?</p>
<p>Regular textures have an optimized layout for adapting to most rasterization cases (filtering, stretching). Often these layout is swizzled or tiled (i.e. storing data as RRRR GGGG BBBB AAAA, or storing pixels in <a href="https://en.wikipedia.org/wiki/Z-order_curve">morton order</a>). Sometimes they may even be losslessly compressed by the GPU.</p>
<p>When you're working with compute shaders (e.g. for postprocessing) and don't need filtering, your access patterns will likely be flat, linear and contiguous, and thus get higher performance by using an UAV Buffer.</p>
<p>This is not a rule of thumb. You'll need to experiment with both UAV textures and UAV buffers in your compute shaders to see what gives you the best performance.</p>
<h4><a class="anchor" id="CompositorWorkspaces_connect_buffer"></a>
connect_buffer</h4>
<div class="fragment"><div class="line">connect_buffer &lt;node_name_1&gt; [&lt;output_ch #&gt;] [&lt;output_ch #&gt;]  &lt;node_name_2&gt; [&lt;input_ch #&gt;] [&lt;input_ch #&gt;]</div>
</div><!-- fragment --><p>Exactly the same as connect, but it connects UAV buffers instead of textures.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">//Connect nodeA to nodeB</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 0 ==&gt; B&#39;s input channel 1</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 1 ==&gt; B&#39;s input channel 2</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 2 ==&gt; B&#39;s input channel 0</span></div>
<div class="line">connect_buffer nodeA 0 1 2 nodeB 1 2 0</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Connect nodeA to nodeB</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 0 ==&gt; B&#39;s input channel 0</span></div>
<div class="line"><span class="comment">//A&#39;s output channel 2 ==&gt; B&#39;s input channel 1</span></div>
<div class="line">connect_buffer nodeA 0 2 nodeB  0 1</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Connect nodeC to nodeB</span></div>
<div class="line"><span class="comment">//C&#39;s output channel 3 ==&gt; B&#39;s input channel 1</span></div>
<div class="line">connect_buffer nodeC 3 nodeB 1</div>
</div><!-- fragment --><h4><a class="anchor" id="CompositorWorkspaces_connect_buffer_external"></a>
connect_buffer_external</h4>
<div class="fragment"><div class="line">connect_buffer_external &lt;external_channel #&gt; &lt;node_name&gt; &lt;input_channel #&gt;</div>
</div><!-- fragment --><p>Connects multiple external UAV buffer. External UAV buffers are provided when instantiating the Workspace via addWorkspace in C++.</p>
<p>It is possible for a Workspace to not use this variable (though rather pointless)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">external_channel</td><td>The index to the external UAV buffer passed to addWorkspace. </td></tr>
    <tr><td class="paramname">node_name</td><td>The name of the Node that will receive the external UAV </td></tr>
    <tr><td class="paramname">input_channel</td><td>The number of the input channel from node_name.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">//Pass the external UAV to nodeA through channel #0</span></div>
<div class="line">connect_buffer_external 0 nodeA 0</div>
<div class="line"><span class="comment">//Pass the external UAV to nodeB through channel #0</span></div>
<div class="line">connect_buffer_external 0 nodeB 0</div>
<div class="line"><span class="comment">//Pass a second external UAV to nodeB through channel #1</span></div>
<div class="line">connect_buffer_external 1 nodeB 1</div>
</div><!-- fragment --><h2><a class="anchor" id="CompositorWorkspacesDataDependencies"></a>
Data dependencies between nodes and circular dependencies</h2>
<p>The Compostor will solve data dependencies and reorder node execution as necessary. It will also detect some circular dependencies (i.e. node A connecting to A; A connecting to B and B connecting to A) report the error and refuse to initialize the workspace, but it may not detect more complex cases (i.e. node A connecting to B, B to C, C to D, D to B) and attempting execution could result in crashes or graphical glitches.</p>
<p>If you happen to encounter a circular dependency that is not reported by <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>, we would be intereste in knowing more about it. You can <a href="https://ogre3d.atlassian.net/browse/OGRE">submit your bug report to JIRA</a></p>
<h1><a class="anchor" id="CompositorSetupCode"></a>
Setting up code</h1>
<h2><a class="anchor" id="CompositorWorkspacesSetupInitialize"></a>
Initializing the workspace</h2>
<p>To create the workspace, just call the following function with the name of the workspace:</p>
<div class="fragment"><div class="line">CompositorManager2 *compositorManager = mRoot-&gt;getCompositorManager2();</div>
<div class="line">compositorManager-&gt;addWorkspace( mSceneMgr, mWindow, mCamera, <span class="stringliteral">&quot;MyOwnWorkspace&quot;</span>, <span class="keyword">true</span> );</div>
</div><!-- fragment --><p>You can have more than one Workspace instance of the same Workspace definition. This is mostly useful if you're trying to render to two or more different RTs (i.e. two Render Windows, a RenderWindow and an offscreen RTT, etc) or if you want to use completely different SceneManagers.</p>
<h2><a class="anchor" id="CompositorWorkspacesSetupSimple"></a>
Simple bootstrap for beginners</h2>
<p>If you're a user that doesn't want to deal with compositor nodes, you're a beginner, or you're in a rush, there is an utility function that will help you set up a basic workspace and a compositor node to render the whole scene:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> IdString workspaceName( <span class="stringliteral">&quot;MyOwnWorkspace&quot;</span> );</div>
<div class="line">CompositorManager2 *compositorManager = mRoot-&gt;getCompositorManager2();</div>
<div class="line"><span class="keywordflow">if</span>( !compositorManager-&gt;hasWorkspaceDefinition( workspaceName ) )</div>
<div class="line">    compositorManager-&gt;createBasicWorkspaceDef( workspaceName, ColourValue( 0.6f, 0.0f, 0.6f ) );</div>
<div class="line">compositorManager-&gt;addWorkspace( mSceneMgr, mWindow, mCamera, workspaceName, <span class="keyword">true</span> );</div>
</div><!-- fragment --><p>The workspace created by the utility function is equivalent to the following compositor script:</p>
<div class="fragment"><div class="line">compositor_node MyOwnWorkspace_Node</div>
<div class="line">{</div>
<div class="line">    in 0 renderwindow</div>
<div class="line"> </div>
<div class="line">    target renderwindow</div>
<div class="line">    {</div>
<div class="line">        pass render_scene</div>
<div class="line">        {</div>
<div class="line">            load</div>
<div class="line">            {</div>
<div class="line">                all clear</div>
<div class="line">                clear_colour 0.6 0 0.6 1</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            rq_first    0</div>
<div class="line">            rq_last     max</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">workspace MyOwnWorkspace</div>
<div class="line">{</div>
<div class="line">    connect_output MyOwnWorkspace_Node 0</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="CompositorWorkspacesSetupAdvanced"></a>
Advanced C++ users</h2>
<p>Advanced C++ users who want to deal with the <code>CompositorManager2</code> directly, may find the information in this section useful.</p>
<p>The <code>CompositorManager2</code> uses a C++ pattern where there is an object Definition and an instance. For example; there is a class called <code>CompositorPassSceneDef</code> and a class called <code>CompositorPassScene</code>. The former is the definition, while the latter is the instance.</p>
<p>All instances share the same definition and have only read-access to them. Modifying the shared definition while there are instances active is undefined and could happen anything ranging from what the user expected, to glitches, crashes, or memory leaks. Only by analyzing the code it is possible to determine which changes are likely to be "safe" (like changing the visibility mask) and which ones require the instance to be destroyed and recreated.</p>
<p>The syntax of the compositor scripts translate almost 1:1 to definitions, rather than instances. Probably the most notable difference is that <code>NodeDef</code>s contain <code>CompositorTargetDef</code>, and these contain <code>CompositorPassDef</code>; while the instances, Targets and Passes are joined together, thus Nodes contain <code>CompositorPasses</code> directly.</p>
<p>Because the <code>CompositorManager2</code> is still very new, we admit real time changes to nodes (especially channel connections) can be a bit troublesome to deal with unless destroying everything and recreating it, which could be suboptimal for live editing nodes.</p>
<p>We would love to hear your developer feedback on the <a href="http://ogre3d.org/forums/">forums</a> regarding live editing the nodes and further improve the Compositor.</p>
<h1><a class="anchor" id="StereoAndSplitScreenRendering"></a>
Stereo and Split-Screen Rendering</h1>
<p>Rendering in Stereo ala Occulus Rift (or splitting the screen in multiple sections for multiplayer) has been made easier with the introduction of execution and viewport masks.</p>
<p>Normally, to render to the left side of the screen and then to the right side; you would need to create a clear pass to clear the whole render target, and two passes <code>render_scene</code> passes with different viewport settings, one for each eye.</p>
<p>With execution and viewport modifier masks, you no longer need to duplicate the number of passes per region of screen you want to draw to. You will have to create a workspace for each region though (i.e. one workspace per eye).</p>
<h2><a class="anchor" id="CompositorWorkspacesStereoPerWorkspace"></a>
Per-Workspace offset and scale</h2>
<p>Each workspace contains an offset and scale to be applied to each pass; passed as a <code>Vector4</code> to <code>CompositorManager2::addWorkspace</code>. The XY components contain the offset, the ZW contain the scale.</p>
<p>On each pass, its final viewport is calculated this way:</p>
<div class="fragment"><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> left   = mDefinition-&gt;mVpLeft      + vpModifier.x;</div>
<div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> top    = mDefinition-&gt;mVpTop       + vpModifier.y;</div>
<div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> width  = mDefinition-&gt;mVpWidth     * vpModifier.z;</div>
<div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> height = mDefinition-&gt;mVpHeight    * vpModifier.w;</div>
<div class="ttc" id="anamespace_ogre_html_aa3a7b6dfb905e6572d62f0dfa3d4274d"><div class="ttname"><a href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Ogre::Real</a></div><div class="ttdeci">float Real</div><div class="ttdoc">Software floating point type.</div><div class="ttdef"><b>Definition:</b> OgrePrerequisites.h:109</div></div>
</div><!-- fragment --><p>This means that to render to the left eye, you would need to specify <code>Vector4( 0.0f, 0.0f, 0.5f, 1.0f )</code> and to render to the right eye you would specify <code>Vector4( 0.5f, 0.0f, 0.5f, 1.0f )</code>.</p>
<h2><a class="anchor" id="CompositorWorkspacesStereoViewportMask"></a>
Viewport modifier mask</h2>
<p>You don't want the modifier to affect <em>all</em> passes. The viewport modifer mask is a per-pass 8-bit value that is AND'ed with the workspace's mask. If the result is non-zero, the offset and scale is applied.</p>
<p>For example, you can apply postprocessing passes to entire screen instead of just a single eye.</p>
<p>The most common use for this mask is clearing: The GPU prefers that you clear the entire buffer in one go, rather than two partial clears. Therefore you can use the mask to prevent the clear's viewport from being affected, and end up affecting the whole screen.</p>
<p>There's still a problem though: You have two workspaces (one per eye). The first workspace will work as intended. However the workspace will execute the clear again, and remove the contents drawn to the left eye. The Execution Mask solves this problem.</p>
<h2><a class="anchor" id="CompositorWorkspacesStereoExecutionMask"></a>
Execution mask</h2>
<p>The execution mask is per-pass 8-bit value that is AND'ed with the workspace's execution mask. When zero, the pass is skipped, when non-zero, the pass is executed.</p>
<p>Continuing the example from the previous section, you can use an execution mask to cause the clear to only be executed when rendering the first left eye; and the clear pass will not be performed when rendering the right eye.</p>
<p>As another example, you could use two <code>render_pass</code> to perform Anaglyph 3D, i.e. red tint on the left eye, cyan tint on the right eye. You would set the viewport modifier mask to 0 so that it's not be affected by the workspace's offset and scale; but set the execution masks so that the red tint pass only gets executed for the left eye's workspace, and the cyan pass only gets executed for the right eye's workspace.</p>
<h2><a class="anchor" id="CompositorWorkspacesStereoDefaultValues"></a>
Default values</h2>
<p>By default execution and viewport masks default to <code>0xFF</code> except for Clear passes where the defaults are:</p>
<div class="fragment"><div class="line"><span class="comment">//Override so that it only gets executed on the first execution on the</span></div>
<div class="line"><span class="comment">//whole screen (i.e. clear the whole viewport during the left eye pass)</span></div>
<div class="line">mExecutionMask          = 0x01;</div>
<div class="line">mViewportModifierMask   = 0x00;</div>
</div><!-- fragment --><p>This assumes that your first workspace (i.e. the left eye / first player in split screen) sets the execution mask to 1; and the other workspaces have the first bit unset for that mask.</p>
<p>Using the defaults, the following example splits the screen in 4 for multiplayer (i.e. Mario Kart games and similar) or also useful for editing in 4-POV modelling application; and the clear passes will apply to the whole screen with the first workspace:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt;4; ++i )</div>
<div class="line">{</div>
<div class="line">    Vector4 vpModifier( (i % 2) * 0.5f, (i &gt;&gt; 1) * 0.5f, 0.25f, 0.25f );</div>
<div class="line">    m_workspace[i] = mgr-&gt;addWorkspace( sceneManager, renderTarget,</div>
<div class="line">                                        playerCam[i], <span class="stringliteral">&quot;MainWorkspace&quot;</span>, <span class="keyword">true</span>,</div>
<div class="line">                                        -1, vpModifier,</div>
<div class="line">                                        (1 &lt;&lt; i), (1 &lt;&lt; i) );</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="AdvancedMSAA"></a>
Advanced MSAA</h1>
<h2><a class="anchor" id="autotoc_md113"></a>
What is MSAA?</h2>
<p>MSAA (Multisample Antialiasing) is a very common antialiasing technique.</p>
<p>It is quite common to treat MSAA like black magic: it works automatically and makes those staircase effect aka jagged edges aka aliasing disappear.</p>
<p>However there are times where we need to understand how it works, what's going on and how to control it explicitly via <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>.</p>
<h3><a class="anchor" id="autotoc_md114"></a>
Supersampling Antialiasing (SSAA) vs MSAA</h3>
<p>It is best to explain what MSAA is by first explaining Supersampling Antialiasing (SSAA).</p>
<p>If we have to render 1920x1080 4xSSAA, then we would just render at 3840x2160 and downscale back to 1920x1080 (either with a basic bilinear filter or something more advanced e.g. bicubic, gaussian, etc).</p>
<p>Huh? What's next, you ask? That's it!</p>
<dl class="section note"><dt>Note</dt><dd>1920x2 = 3840 and 1080x2 = 2160, twice the width and twice the height is 4x the area. Hence 4xSSAA.</dd></dl>
<p>Thus SSAA is not a complex algorithm: it's just rendering at higher resolution and then scaling down to blur each of the 4 pixels into 1, producing soft edges.</p>
<p><b>This operation of scaling down is known as <em>Resolve</em></b></p>
<p>The problem with SSAA: it consumes a lot of bandwidth and processing power. 4x of everything to be exact (for 4xSSAA).</p>
<p><b>That's where MSAA comes in.</b> MSAA in is basic form looks like SSAA: the GPU needs to allocate a 3840x2160 colour target and a 3840x2160 depth buffer. Thus it stll consumes 4x more memory.</p>
<h3><a class="anchor" id="autotoc_md115"></a>
MSAA approach to the problem</h3>
<p>MSAA exploits a simple fact: only the triangle borders need antialiasing.</p>
<p>Thus for all pixels except the ones touching the border of a triangle, the GPU will only run the pixel shader <em>once</em> and broadcast the colour to all 4 pixels <em>just as if it were rendering at 1920x1080</em>. This saves 4x of colour bandwidth and 4x processing power, making it very efficient.</p>
<dl class="section note"><dt>Note</dt><dd>Internally the GPU may have a hidden 2-bit mask. Thus if a triangle covers all 4 subpixels, it runs the pixel shader once and and sets the mask to 0x3 to indicate all 4 subpixels share the same value. <br  />
 The specifics of how these hidden bit masks work depend on vendor and GPU model and are implementation details.</dd></dl>
<p>The depth however is still populated at 3840x2160.</p>
<p>Ideally it is only at the polygon edges that the pixel shader may run <em>up to</em> 4 times.</p>
<p>The major drawbacks from MSAA are two:</p>
<ul>
<li>Performance is highly dependent on the geometry involved. A scene with lots of sharp &amp; spiky triangles will force the GPU to run the pixel shader up to 4 times very often (grass blades often trigger this worst case scenario). Thus MSAA effectively becomes SSAA. While a scene with smoothly-connected triangles (i.e. barely any edges) will run very fast.</li>
<li>Only geometric aliasing (e.g. polygon edges) is fixed. There are other sources of aliasing (texture, shading) which are not considered. Texture aliasing is often fixed with mipmapping though. While fixing shading aliasing is still a hot topic.</li>
</ul>
<p>The specific of how the GPU keeps the MSAA contents in memory are vendor and device-specific. However they're often not sampling-friendly (poor cache behavior, no bilinear filtering available) therefore we often resolve the contents before working on its data.</p>
<p>But there are exceptions where we need access to the MSAA subsamples before resolve:</p>
<ol type="1">
<li>HDR tonemapping <a href="https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/">should happen before resolving</a>, otherwise aliasing effects won't go away. That means an HDR tonemap needs direct access to the MSAA contents. See our HDR sample which deals with this issue.</li>
<li>Resolving a depth buffer makes no sense. Averaging depth is meaningless. Depth is often required by postprocessing effects such as Screen Space Reflections, Depth of Field, SSAO. In order to do this, either the 1920x1080 4xMSAA depth buffer gets copied to a regular 3840x2160 texture (to make it cache- and sampling-friendly) or we pretend MSAA did not happen and just take of the values, or the minimum or maximum of each. There is no right answer and it is a very similar problem <a href="https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-23-high-speed-screen-particles">mixed resolution particle rendering has</a>.</li>
</ol>
<h4><a class="anchor" id="CompositorNodesTexturesMsaaResources"></a>
Resources</h4>
<ul>
<li><a href="http://mynameismjp.wordpress.com/2012/10/24/msaa-overview/">A Quick Overview of MSAA</a></li>
<li><a href="http://mynameismjp.wordpress.com/2012/10/28/msaa-resolve-filters/">Experimenting with Reconstruction Filters for MSAA Resolve</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md116"></a>
Ogre + MSAA with Implicit Resolves</h2>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> by default uses implicit resolves. When you call:</p>
<div class="fragment"><div class="line">texture = textureGpuManager-&gt;createTexture(</div>
<div class="line">                   <span class="stringliteral">&quot;MyRtt&quot;</span>,</div>
<div class="line">                   <a class="code" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65a28135d9485a60bfa1a598cba471d6891">GpuPageOutStrategy::Discard</a>,</div>
<div class="line">                   <a class="code" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434a3ff7a5394c299b94950eb7cff468ad1b">TextureFlags::RenderToTexture</a>,</div>
<div class="line">                   <a class="code" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82aaccb80fce163e32091af35b9de1c1001">TextureTypes::Type2D</a> );</div>
<div class="line">texture-&gt;setResolution( 1920, 1080 );</div>
<div class="line">texture-&gt;setPixelFormat( <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">PFG_RGBA8_UNORM_SRGB</a> );</div>
<div class="line">texture-&gt;setNumMipmaps( 1u );</div>
<div class="line">texture-&gt;setSampleDescription( SampleDescription( 4u ) ); <span class="comment">// 4x MSAA</span></div>
<div class="line">texture-&gt;scheduleTransitionTo( <a class="code" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">GpuResidency::Resident</a> );</div>
<div class="ttc" id="anamespace_ogre_1_1_gpu_page_out_strategy_html_a4d2162c156be30917f38f15e2327ce65a28135d9485a60bfa1a598cba471d6891"><div class="ttname"><a href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65a28135d9485a60bfa1a598cba471d6891">Ogre::GpuPageOutStrategy::Discard</a></div><div class="ttdeci">@ Discard</div><div class="ttdoc">When the resource is no longer resident, we just throw the GPU data.</div><div class="ttdef"><b>Definition:</b> OgreGpuResource.h:89</div></div>
<div class="ttc" id="anamespace_ogre_1_1_gpu_residency_html_a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2"><div class="ttname"><a href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">Ogre::GpuResidency::Resident</a></div><div class="ttdeci">@ Resident</div><div class="ttdoc">VRAM and other GPU resources have been allocated for this resource.</div><div class="ttdef"><b>Definition:</b> OgreGpuResource.h:66</div></div>
<div class="ttc" id="anamespace_ogre_1_1_texture_flags_html_a59b71e36a14465bd82595d6d467e1434a3ff7a5394c299b94950eb7cff468ad1b"><div class="ttname"><a href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434a3ff7a5394c299b94950eb7cff468ad1b">Ogre::TextureFlags::RenderToTexture</a></div><div class="ttdeci">@ RenderToTexture</div><div class="ttdoc">Texture can be used as an RTT (FBO in GL terms)</div><div class="ttdef"><b>Definition:</b> OgreTextureGpu.h:88</div></div>
<div class="ttc" id="anamespace_ogre_1_1_texture_types_html_aa364e348564060700791c9940d5ced82aaccb80fce163e32091af35b9de1c1001"><div class="ttname"><a href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82aaccb80fce163e32091af35b9de1c1001">Ogre::TextureTypes::Type2D</a></div><div class="ttdeci">@ Type2D</div><div class="ttdef"><b>Definition:</b> OgreTextureGpu.h:57</div></div>
</div><!-- fragment --><p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> creates two textures:</p><ol type="1">
<li>The MSAA surface. Generally you don't have direct access to it. This one occupies 1920x1080x4x4 = 31.64MB</li>
<li>The implicitly resolved texture which can be used for sampling. This one occupies 1920x1080x4 = 7.91MB</li>
</ol>
<p><a class="el" href="compositor.html#CompositorPass_store_all">StoreActions</a> control when the texture is resolved.</p>
<p>Implicitly resolved textures is how <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> traditionally worked before <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2 <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.1 tried to implement this but it was very basic and often broken.</p>
<h2><a class="anchor" id="MSAAExplicitResolves"></a>
Ogre + MSAA with Explicit Resolves</h2>
<p>You need to explicitly ask for explicit resolves. When you call:</p>
<div class="fragment"><div class="line">texture = textureGpuManager-&gt;createTexture(</div>
<div class="line">                   <span class="stringliteral">&quot;MyRtt&quot;</span>,</div>
<div class="line">                   <a class="code" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65a28135d9485a60bfa1a598cba471d6891">GpuPageOutStrategy::Discard</a>,</div>
<div class="line">                   <a class="code" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434a3ff7a5394c299b94950eb7cff468ad1b">TextureFlags::RenderToTexture</a> | <a class="code" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434ad873b427a39b3c3aabac9ae445f192f4">TextureFlags::MsaaExplicitResolve</a>,</div>
<div class="line">                   <a class="code" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82aaccb80fce163e32091af35b9de1c1001">TextureTypes::Type2D</a> );</div>
<div class="line">texture-&gt;setResolution( 1920, 1080 );</div>
<div class="line">texture-&gt;setPixelFormat( <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">PFG_RGBA8_UNORM_SRGB</a> );</div>
<div class="line">texture-&gt;setNumMipmaps( 1u );</div>
<div class="line">texture-&gt;setSampleDescription( SampleDescription( 4u ) ); <span class="comment">// 4x MSAA</span></div>
<div class="line">texture-&gt;scheduleTransitionTo( <a class="code" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">GpuResidency::Resident</a> );</div>
<div class="ttc" id="anamespace_ogre_1_1_texture_flags_html_a59b71e36a14465bd82595d6d467e1434ad873b427a39b3c3aabac9ae445f192f4"><div class="ttname"><a href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434ad873b427a39b3c3aabac9ae445f192f4">Ogre::TextureFlags::MsaaExplicitResolve</a></div><div class="ttdeci">@ MsaaExplicitResolve</div><div class="ttdoc">MSAA rendering is an antialiasing technique.</div><div class="ttdef"><b>Definition:</b> OgreTextureGpu.h:113</div></div>
</div><!-- fragment --><p>OgreNext creates only one texture:</p><ol type="1">
<li>The MSAA surface. This one occupies 1920x1080x4x4 = 31.64MB</li>
</ol>
<p>Therefore:</p>
<ol type="1">
<li>Binding this texture to a shader means the shader must access it via Texture2DMS (HLSL), sampler2DMS (GLSL), and texture2d_ms (Metal).</li>
<li>Resolving must be done manually (assuming you want to resolve at all). This means setting up the RTV on the compositor manually.</li>
</ol>
<p>In compositor scripts one would have to set the rtv like this:</p>
<div class="fragment"><div class="line">compositor_node MyExplicitMsaaNode</div>
<div class="line">{</div>
<div class="line">    // This is the explicit MSAA surface</div>
<div class="line">    texture myMsaaTex   target_width target_height PFG_RGBA8_UNORM_SRGB msaa_auto explicit_resolve</div>
<div class="line">    // This is where myMsaaTex will be resolved to. It&#39;s just a regular texture</div>
<div class="line">    texture myResolvedResult    target_width target_height PFG_RGBA8_UNORM_SRGB</div>
<div class="line"> </div>
<div class="line">    // Create a custom RenderTargetView.</div>
<div class="line">    // Normally Ogre automatically generates one with the same name as the texture</div>
<div class="line">    // (We could also modify that auto-generated one by specifying &#39;rtv myMsaaTex&#39;)</div>
<div class="line">    // but we create another one to emphasize it&#39;s custom-made</div>
<div class="line">    rtv myCustomRtv</div>
<div class="line">    {</div>
<div class="line">        // Specify we want to render to myMsaaTex at slot[0] but we want to resolve to myResolvedResult</div>
<div class="line">        colour  0 myMsaaTex resolve myResolvedResult</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    target myCustomRtv</div>
<div class="line">    {</div>
<div class="line">        // Render...</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Now you just rendered to myMsaaTex, resolved into myResolvedResult and can have direct access to MSAA samples (by binding myMsaaTex to a material).</p>
<p>See Samples/Media/2.0/scripts/Compositors/ScreenSpaceReflections.compositor for a specific example</p>
<h1><a class="anchor" id="CompositorRTV"></a>
RTV (RenderTargetView)</h1>
<p>So far all examples tried to ignore RTVs.</p>
<p>The Compositor creates an rtv automatically with the same name for locally created textures and input textures.</p>
<p>However there are cases when you need to know them.</p>
<h2><a class="anchor" id="CompositorWhatisAnRtv"></a>
What is an RTV</h2>
<p>When you render to a Texture, the GPU actually needs to setup a lot of things:</p>
<ul>
<li>If it has multiple mipmaps, which mipmap.</li>
<li>If it is a Cubemap, a 3D or a 2D Array texture, which slice.</li>
<li>If it's MSAA, where to resolve the MSAA contents into (unless we don't want to resolve).<ul>
<li>What MSAA mipmap to resolve into.</li>
<li>What MSAA slice to resolve into.</li>
</ul>
</li>
<li>What depth buffer to use.</li>
<li>What stencil buffer to use.</li>
<li>If using MRT (Multiple Render Targets), you want to setup more than one colour texture at the same time.</li>
</ul>
<p>An RTV contains the definition of all that.</p>
<h2><a class="anchor" id="CompositorRtvSettings"></a>
RTV settings</h2>
<ul>
<li><a class="el" href="compositor.html#CompositorRtv_colour">colour</a></li>
<li><a class="el" href="compositor.html#CompositorRtv_depth">depth</a></li>
<li><a class="el" href="compositor.html#CompositorRtv_stencil">stencil</a></li>
<li><a class="el" href="compositor.html#CompositorRtv_depth_stencil">depth_stencil</a></li>
<li><a class="el" href="compositor.html#CompositorRtv_depth_texture">depth_texture</a></li>
<li><a class="el" href="compositor.html#CompositorRtv_depth_pool">depth_pool</a></li>
<li><a class="el" href="compositor.html#CompositorRtv_depth_format">depth_format</a></li>
<li><a class="el" href="compositor.html#CompositorRtv_depth_read_only">depth_read_only</a></li>
<li><a class="el" href="compositor.html#CompositorRtv_stencil_read_only">stencil_read_only</a></li>
</ul>
<h4><a class="anchor" id="CompositorRtv_colour"></a>
colour</h4>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">colour &lt;texture_name&gt;</div>
<div class="line">colour &lt;mrt_idx&gt; &lt;texture_name&gt; [resolve &lt;resolve_dst_texture_name&gt;] [mip &lt;#&gt;] [resolve_mip &lt;#&gt;] [slice &lt;#&gt;] [resolve_slice &lt;#&gt;] [all_layers [<span class="keyword">true</span>|<span class="keyword">false</span>]]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mrt_index</td><td>0-based slot of the MRT (Multiple Render Target). Must be in range [0; <a class="el" href="class_ogre_1_1_render_system_capabilities.html#ad8f321e5894e0b64b3c52b9626c3f115" title="The number of simultaneous render targets supported.">Ogre::RenderSystemCapabilities::getNumMultiRenderTargets</a>). </td></tr>
    <tr><td class="paramname">texture_name</td><td>Name of the colour texture to bind at this slot. </td></tr>
    <tr><td class="paramname">mip</td><td></td></tr>
    <tr><td class="paramname">resolve_mip</td><td>Optional. Mip level to render or resolve to. This keyword must be followed by a number. </td></tr>
    <tr><td class="paramname">slice</td><td></td></tr>
    <tr><td class="paramname">resolve_slice</td><td>Optional. Slice index to render or resolve to. This keyword must be followed by a number. </td></tr>
    <tr><td class="paramname">all_layers</td><td>Optional. This keyword must be followed by a boolean. When true <code>slice</code> will be ignored and all slices will be attached instead. The shaders are expected to use gl_ViewportIndex or equivalent to dispatch geometry to the right slice. <br  />
 See <a class="el" href="struct_ogre_1_1_render_pass_colour_target.html#af0a022b05b422db667ffcd64af73203e" title="When true, slice will be ignored, and all slices will be attached instead.">Ogre::RenderPassColourTarget::allLayers</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>As a shortcut, if the user only types:</p>
<div class="fragment"><div class="line">colour texture_name</div>
</div><!-- fragment --><p>it is the same as:</p>
<div class="fragment"><div class="line">colour 0 texture_name resolve texture_name mip 0 resolve_mip 0 slice 0 resolve_slice 0 all_layers <span class="keyword">false</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>texture_name MUST have a pixel format that is colour.</dd></dl>
<h4><a class="anchor" id="CompositorRtv_depth"></a>
depth</h4>
<p>Explicitly assigns a depth buffer to this RTV.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">depth &lt;texture_name&gt; [mip &lt;#&gt;] [slice &lt;#&gt;]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture_name</td><td>Name of the depth texture to bind at this slot. </td></tr>
    <tr><td class="paramname">mip</td><td>Optional. Mip level to render to. This keyword must be followed by a number. </td></tr>
    <tr><td class="paramname">slice</td><td>Optional. Slice index to render to. This keyword must be followed by a number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Most APIs do not allow to create a 2D Array depth buffer, thus the slice parameter is always 0. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>texture_name MUST have a pixel format that is depth.</dd></dl>
<h4><a class="anchor" id="CompositorRtv_stencil"></a>
stencil</h4>
<p>Explicitly assigns a stencil buffer to this RTV.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">stencil &lt;texture_name&gt; [mip &lt;#&gt;] [slice &lt;#&gt;]</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture_name</td><td>Name of the stencil texture to bind at this slot. </td></tr>
    <tr><td class="paramname">mip</td><td>Optional. Mip level to render to. This keyword must be followed by a number. </td></tr>
    <tr><td class="paramname">slice</td><td>Optional. Slice index to render to. This keyword must be followed by a number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Most APIs do not allow to create a 2D Array stencil buffer, thus the slice parameter is always 0. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>texture_name MUST have a pixel format that is stencil or depth_stencil. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only iOS supports setting a stencil texture different from a depth texture. For maximum compatibility always use depth and depth_stencil.</dd></dl>
<h4><a class="anchor" id="CompositorRtv_depth_stencil"></a>
depth_stencil</h4>
<p>This is the same as calling <a class="el" href="compositor.html#CompositorRtv_depth">depth</a> &amp; <a class="el" href="compositor.html#CompositorRtv_stencil">stencil</a> with the same parameters. e.g.</p>
<div class="fragment"><div class="line">depth myDepthStencilTexture</div>
<div class="line">stencil myDepthStencilTexture</div>
<div class="line"> </div>
<div class="line"><span class="comment">// is equivalent to:</span></div>
<div class="line">depth_stencil myDepthStencilTexture</div>
</div><!-- fragment --><h4><a class="anchor" id="CompositorRtv_depth_pool"></a>
depth_pool</h4>
<p>If <a class="el" href="compositor.html#CompositorRtv_depth">depth</a> &amp; <a class="el" href="compositor.html#CompositorRtv_stencil">stencil</a> are left blank, this setting uses pool ID so that a generic depth buffer from the same pool ID that matches the colour resolution is generated or reused instead.</p>
<p>Set to 0 to disable.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">depth_pool &lt;pool_id&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorRtv_depth_texture"></a>
depth_texture</h4>
<p>If <a class="el" href="compositor.html#CompositorRtv_depth">depth</a> &amp; <a class="el" href="compositor.html#CompositorRtv_stencil">stencil</a> are left blank and <a class="el" href="compositor.html#CompositorRtv_depth_pool">depth_pool</a> isn't 0, this setting uses indicates the texture from the pool must allow sampling.</p>
<p>This setting is discouraged and deprecated.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">depth_pool &lt;true|false&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorRtv_depth_format"></a>
depth_format</h4>
<p>If <a class="el" href="compositor.html#CompositorRtv_depth">depth</a> &amp; <a class="el" href="compositor.html#CompositorRtv_stencil">stencil</a> are left blank and <a class="el" href="compositor.html#CompositorRtv_depth_pool">depth_pool</a> isn't 0, this setting uses indicates the pixel format to prefer.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">depth_format &lt;pixel_format&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorRtv_depth_read_only"></a>
depth_read_only</h4>
<p>It is invalid to bind a depth buffer as RTV and sample from it at the same time. Doing so is called <em>Framebuffer Feeback</em> and results in Undefined Behavior.</p>
<p>However there are exceptions. If the depth buffer is bound as read_only (which means depth writes are ignored even if <a class="el" href="struct_ogre_1_1_hlms_macroblock.html#a38d3242e6c29312f16a8293b9f70efae">Ogre::HlmsMacroblock::mDepthWrite</a> is true) it is possible to use it for both rendering and sampling at the same time.</p>
<p>This can be useful for certain effects such as refractions.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">depth_read_only &lt;true|false&gt;</div>
</div><!-- fragment --></dd></dl>
<h4><a class="anchor" id="CompositorRtv_stencil_read_only"></a>
stencil_read_only</h4>
<p>See <a class="el" href="compositor.html#CompositorRtv_depth_read_only">depth_read_only</a>.</p>
<dl class="section user"><dt></dt><dd>Format: <div class="fragment"><div class="line">stencil_read_only &lt;true|false&gt;</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="CompositorRtv_Examples"></a>
RTV Examples</h2>
<p>You can create new RTVs or modify autogenerated ones. The only exception is that you can't modify autogenerated ones from input channels, because input channels are evaluted too late during execution.</p>
<p>The following modifies an autogenerated RTV to use a specific depth buffer:</p>
<div class="fragment"><div class="line">compositor_node RefractionsRenderingNode</div>
<div class="line">{</div>
<div class="line">    texture depthBuffer target_width target_height <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a> msaa_auto</div>
<div class="line">    texture rtt01       target_width target_height target_format msaa_auto</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// An RTV named &quot;rtt01&quot; was autogenerated that uses the texture &quot;rtt01&quot;</span></div>
<div class="line">    <span class="comment">// and a depth buffer from its default pool_id.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// However we will now modify it so it uses a depth buffer of our choosing.</span></div>
<div class="line">    rtv rtt01</div>
<div class="line">    {</div>
<div class="line">        depth_stencil   depthBuffer</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    target rtt01</div>
<div class="line">    {</div>
<div class="line">        pass render_scene</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We can also generate a new RTV with a new name. For example here's an MRT example:</p>
<div class="fragment"><div class="line">compositor_node ScreenSpaceReflectionsRenderingNode</div>
<div class="line">{</div>
<div class="line">    texture gBufferNormals          target_width target_height <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a74af65ce150702461f3e43d28ea26aa0">PFG_R10G10B10A2_UNORM</a>    msaa_auto explicit_resolve</div>
<div class="line">    texture gBufferShadowRoughness  target_width target_height <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18ac89e5e52580e64c927d90f8e12728447">PFG_RG16_UNORM</a>           msaa_auto explicit_resolve</div>
<div class="line">    texture gBufferDepthBuffer      target_width target_height <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a458e94093eee7ccec11069e3105d1058">PFG_D32_FLOAT</a>            msaa_auto</div>
<div class="line"> </div>
<div class="line">    rtv mrtGBuffer</div>
<div class="line">    {</div>
<div class="line">        colour  gBufferNormals gBufferShadowRoughness</div>
<div class="line">        depth   gBufferDepthBuffer</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    target mrtGBuffer</div>
<div class="line">    {</div>
<div class="line">        pass render_scene</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup___image_html_gga71f09fe41a1db41186262f1aa5814a18a74af65ce150702461f3e43d28ea26aa0"><div class="ttname"><a href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a74af65ce150702461f3e43d28ea26aa0">Ogre::PFG_R10G10B10A2_UNORM</a></div><div class="ttdeci">@ PFG_R10G10B10A2_UNORM</div><div class="ttdef"><b>Definition:</b> OgrePixelFormatGpu.h:73</div></div>
<div class="ttc" id="agroup___image_html_gga71f09fe41a1db41186262f1aa5814a18ac89e5e52580e64c927d90f8e12728447"><div class="ttname"><a href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18ac89e5e52580e64c927d90f8e12728447">Ogre::PFG_RG16_UNORM</a></div><div class="ttdeci">@ PFG_RG16_UNORM</div><div class="ttdef"><b>Definition:</b> OgrePixelFormatGpu.h:84</div></div>
</div><!-- fragment --><p>Cubemaps can't be implicitly resolved. In fact cubemap MSAA textures don't exist. The API will refuse.</p>
<p>Here's an example where we create a single 2D MSAA surface to render MSAA, and a cubemap where we resolve to:</p>
<div class="fragment"><div class="line">abstract target cubemap_target</div>
<div class="line">{</div>
<div class="line">    pass render_scene</div>
<div class="line">    {</div>
<div class="line">        store</div>
<div class="line">        {</div>
<div class="line">            // This is the default. But change it to store_and_resolve if you wish</div>
<div class="line">            // to preserve the MSAA contents of all 6 faces.</div>
<div class="line">            colour store_or_resolve</div>
<div class="line">        }</div>
<div class="line">        // ...</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">compositor_node CubemapRendererNodeMsaa</div>
<div class="line">{</div>
<div class="line">    in 0 cubemap</div>
<div class="line"> </div>
<div class="line">    // Note: IF you wish to preserve the MSAA contents of all 6 faces, then use</div>
<div class="line">    //  &#39;texture tmpMsaa target_width target_height 6 target_format 2d_array msaa 4 explicit_resolve&#39;</div>
<div class="line">    // instead. Don&#39;t forget to use store_and_resolve (the default is store_or_resolve)</div>
<div class="line">    texture tmpMsaa     target_width target_height target_format msaa 4 explicit_resolve</div>
<div class="line">    texture myCubemap   target_width target_height target_format cubemap mipmaps 0</div>
<div class="line"> </div>
<div class="line">    rtv mixedCubemapRtv</div>
<div class="line">    {</div>
<div class="line">        // Specify we want to render to tmpMsaa at slot[0] but we want to resolve to tmpCubemap</div>
<div class="line">        colour  0 tmpMsaa resolve myCubemap</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    target mixedCubemapRtv +X : cubemap_target {}</div>
<div class="line">    target mixedCubemapRtv -X : cubemap_target {}</div>
<div class="line">    target mixedCubemapRtv +Y : cubemap_target {}</div>
<div class="line">    target mixedCubemapRtv -Y : cubemap_target {}</div>
<div class="line">    target mixedCubemapRtv +Z : cubemap_target {}</div>
<div class="line">    target mixedCubemapRtv -Z : cubemap_target {}</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_scripts.html">Scripts</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
