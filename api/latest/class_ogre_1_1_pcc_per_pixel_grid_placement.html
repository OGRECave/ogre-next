<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::PccPerPixelGridPlacement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_pcc_per_pixel_grid_placement.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_pcc_per_pixel_grid_placement-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::PccPerPixelGridPlacement Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Placing multiple PCC probes by hand can be difficult and even error prone.  
 <a href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#details">More...</a></p>

<p><code>#include &lt;OgrePccPerPixelGridPlacement.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::PccPerPixelGridPlacement:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_pcc_per_pixel_grid_placement__inherit__graph.svg" width="250" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa40eaf124caabf407529cdb14bfb0d2a" id="r_aa40eaf124caabf407529cdb14bfb0d2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#aa40eaf124caabf407529cdb14bfb0d2a">PccPerPixelGridPlacement</a> ()</td></tr>
<tr class="separator:aa40eaf124caabf407529cdb14bfb0d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874d75aad2ec1422d1f27891791a82ce" id="r_a874d75aad2ec1422d1f27891791a82ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a874d75aad2ec1422d1f27891791a82ce">~PccPerPixelGridPlacement</a> () override</td></tr>
<tr class="separator:a874d75aad2ec1422d1f27891791a82ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab2193334326547db2eb8e982c1cd13" id="r_a5ab2193334326547db2eb8e982c1cd13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a5ab2193334326547db2eb8e982c1cd13">buildEnd</a> ()</td></tr>
<tr class="memdesc:a5ab2193334326547db2eb8e982c1cd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes placing all probes and renders to them again, this time with the modified auto-generated shape sizes.  <br /></td></tr>
<tr class="separator:a5ab2193334326547db2eb8e982c1cd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb883732dccbbe6fdea7aa28a51537f" id="r_a1bb883732dccbbe6fdea7aa28a51537f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a1bb883732dccbbe6fdea7aa28a51537f">buildStart</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> resolution, <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *camera, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat=<a class="el" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">PFG_RGBA8_UNORM_SRGB</a>, float camNear=0.5f, float camFar=500.0f)</td></tr>
<tr class="memdesc:a1bb883732dccbbe6fdea7aa28a51537f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GPU commands to render into all probes and obtain depth from it.  <br /></td></tr>
<tr class="separator:a1bb883732dccbbe6fdea7aa28a51537f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0244672aeb84ce3bd933ed3577d6b508" id="r_a0244672aeb84ce3bd933ed3577d6b508"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_aabb.html">Aabb</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a0244672aeb84ce3bd933ed3577d6b508">getFullRegion</a> () const</td></tr>
<tr class="separator:a0244672aeb84ce3bd933ed3577d6b508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdcddbb7d2a7878ff1a0aee56d8beed" id="r_a4fdcddbb7d2a7878ff1a0aee56d8beed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a4fdcddbb7d2a7878ff1a0aee56d8beed">getMaxNumProbes</a> () const</td></tr>
<tr class="memdesc:a4fdcddbb7d2a7878ff1a0aee56d8beed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns numProbes[0] * numProbes[1] * numProbes[2].  <br /></td></tr>
<tr class="separator:a4fdcddbb7d2a7878ff1a0aee56d8beed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd65f3e20fd66d76ce2deacb09691e6" id="r_a2fd65f3e20fd66d76ce2deacb09691e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a2fd65f3e20fd66d76ce2deacb09691e6">getNumProbes</a> () const</td></tr>
<tr class="separator:a2fd65f3e20fd66d76ce2deacb09691e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86c528885247b347de3fa537a79eb37" id="r_af86c528885247b347de3fa537a79eb37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#af86c528885247b347de3fa537a79eb37">getOverlap</a> () const</td></tr>
<tr class="separator:af86c528885247b347de3fa537a79eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6feb92ffd56d1b821e7c7381ff3eb0" id="r_aed6feb92ffd56d1b821e7c7381ff3eb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html">ParallaxCorrectedCubemapAuto</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#aed6feb92ffd56d1b821e7c7381ff3eb0">getParallaxCorrectedCubemap</a> ()</td></tr>
<tr class="separator:aed6feb92ffd56d1b821e7c7381ff3eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a82e14e83ac22f6d2c4266beb2fed04" id="r_a9a82e14e83ac22f6d2c4266beb2fed04"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a9a82e14e83ac22f6d2c4266beb2fed04">getSnapDeviationError</a> () const</td></tr>
<tr class="separator:a9a82e14e83ac22f6d2c4266beb2fed04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f417e20a1c115bd860f640e28435a74" id="r_a4f417e20a1c115bd860f640e28435a74"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a4f417e20a1c115bd860f640e28435a74">getSnapSidesDeviationErrorMax</a> () const</td></tr>
<tr class="separator:a4f417e20a1c115bd860f640e28435a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3017cc26d334e18a2664f4a2055809e" id="r_af3017cc26d334e18a2664f4a2055809e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#af3017cc26d334e18a2664f4a2055809e">getSnapSidesDeviationErrorMin</a> () const</td></tr>
<tr class="separator:af3017cc26d334e18a2664f4a2055809e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a34da70c23bf1259095a3c38471c16" id="r_a38a34da70c23bf1259095a3c38471c16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a38a34da70c23bf1259095a3c38471c16">preCopyRenderTargetToCubemap</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *renderTarget, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> cubemapArrayIdx) override</td></tr>
<tr class="memdesc:a38a34da70c23bf1259095a3c38471c16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html">ParallaxCorrectedCubemapAutoListener</a> overloads.  <br /></td></tr>
<tr class="separator:a38a34da70c23bf1259095a3c38471c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc55cee31ecef33fb8ca31f97ac0548a" id="r_acc55cee31ecef33fb8ca31f97ac0548a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#acc55cee31ecef33fb8ca31f97ac0548a">setFullRegion</a> (const <a class="el" href="struct_ogre_1_1_aabb.html">Aabb</a> &amp;fullRegion)</td></tr>
<tr class="memdesc:acc55cee31ecef33fb8ca31f97ac0548a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html" title="Placing multiple PCC probes by hand can be difficult and even error prone.">PccPerPixelGridPlacement</a> needs, as guidance, the maximum region it will be occupying.  <br /></td></tr>
<tr class="separator:acc55cee31ecef33fb8ca31f97ac0548a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93392f3dbbd10f324dbeed2806b55135" id="r_a93392f3dbbd10f324dbeed2806b55135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a93392f3dbbd10f324dbeed2806b55135">setNumProbes</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numProbes[3])</td></tr>
<tr class="memdesc:a93392f3dbbd10f324dbeed2806b55135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of probes in each axis.  <br /></td></tr>
<tr class="separator:a93392f3dbbd10f324dbeed2806b55135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec8c3b5990717a1afac302b67356fc6" id="r_a5ec8c3b5990717a1afac302b67356fc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a5ec8c3b5990717a1afac302b67356fc6">setOverlap</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;overlap)</td></tr>
<tr class="memdesc:a5ec8c3b5990717a1afac302b67356fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html" title="Placing multiple PCC probes by hand can be difficult and even error prone.">PccPerPixelGridPlacement</a> will subdivide in mNumProbes[i] probes along each axis, creating a 3D grid.  <br /></td></tr>
<tr class="separator:a5ec8c3b5990717a1afac302b67356fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6f80f8122a3a86b9d4a711ee6ba310" id="r_ace6f80f8122a3a86b9d4a711ee6ba310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#ace6f80f8122a3a86b9d4a711ee6ba310">setParallaxCorrectedCubemapAuto</a> (<a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html">ParallaxCorrectedCubemapAuto</a> *pcc)</td></tr>
<tr class="separator:ace6f80f8122a3a86b9d4a711ee6ba310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada834debc302bdbd001e042a96b21a14" id="r_ada834debc302bdbd001e042a96b21a14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#ada834debc302bdbd001e042a96b21a14">setSnapDeviationError</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;relativeError)</td></tr>
<tr class="memdesc:ada834debc302bdbd001e042a96b21a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the probes have a different size than what they should have, but they're almost the same as mFullRegion (they can be different due to precision issues, small objects being on camera); it may be desirable to make them "snap" back to mFullRegion; particularly to avoid artifacts (missing reflections).  <br /></td></tr>
<tr class="separator:ada834debc302bdbd001e042a96b21a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8f0c9bb113456db6c36741d73e4daa" id="r_a3a8f0c9bb113456db6c36741d73e4daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a3a8f0c9bb113456db6c36741d73e4daa">setSnapSides</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;snapSidesDeviationErrorMin, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;snapSidesDeviationErrorMax)</td></tr>
<tr class="memdesc:a3a8f0c9bb113456db6c36741d73e4daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very similar to <a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#ada834debc302bdbd001e042a96b21a14" title="When the probes have a different size than what they should have, but they&#39;re almost the same as mFul...">PccPerPixelGridPlacement::setSnapDeviationError</a> but more specific; thus allowing for much bigger error margins to fix glitches without causing major distortions.  <br /></td></tr>
<tr class="separator:a3a8f0c9bb113456db6c36741d73e4daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_ogre_1_1_parallax_corrected_cubemap_auto_listener"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_ogre_1_1_parallax_corrected_cubemap_auto_listener')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html">Ogre::ParallaxCorrectedCubemapAutoListener</a></td></tr>
<tr class="memitem:ae123dc080710e7016fc569e38445ad2d inherit pub_methods_class_ogre_1_1_parallax_corrected_cubemap_auto_listener" id="r_ae123dc080710e7016fc569e38445ad2d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html#ae123dc080710e7016fc569e38445ad2d">~ParallaxCorrectedCubemapAutoListener</a> ()</td></tr>
<tr class="separator:ae123dc080710e7016fc569e38445ad2d inherit pub_methods_class_ogre_1_1_parallax_corrected_cubemap_auto_listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Placing multiple PCC probes by hand can be difficult and even error prone. </p>
<p>This class aims at helping developers and artists by automatically finding ideal probe shape sizes that adjust to underlying geometry in the scene by only providing the overall enclosing AABB of the scene that needs to be covered by PCC.</p>
<p>Note that once probes have been rendered and their shapes set, you can safely destroy this <a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html" title="Placing multiple PCC probes by hand can be difficult and even error prone.">PccPerPixelGridPlacement</a> instance; and even modify or remove probes you don't like or that feel excessive.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html" title="Per-Pixel reflection probes.">ParallaxCorrectedCubemapAuto</a> pointer is externally owned and must be provided via <a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#ace6f80f8122a3a86b9d4a711ee6ba310">PccPerPixelGridPlacement::setParallaxCorrectedCubemapAuto</a>, before calling build.</dd></dl>
<p>The compositor from which <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html" title="Per-Pixel reflection probes.">ParallaxCorrectedCubemapAuto</a> is based on MUST have the depth compressed in the alpha channel.</p>
<p>See samples on how they use PccDepthCompressor and see Media/2.0/scripts/Compositors/LocalCubemaps.compositor</p>
<p>See Samples/2.0/ApiUsage/PccPerPixelGridPlacement for usage </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa40eaf124caabf407529cdb14bfb0d2a" name="aa40eaf124caabf407529cdb14bfb0d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40eaf124caabf407529cdb14bfb0d2a">&#9670;&#160;</a></span>PccPerPixelGridPlacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::PccPerPixelGridPlacement::PccPerPixelGridPlacement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a874d75aad2ec1422d1f27891791a82ce" name="a874d75aad2ec1422d1f27891791a82ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874d75aad2ec1422d1f27891791a82ce">&#9670;&#160;</a></span>~PccPerPixelGridPlacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::PccPerPixelGridPlacement::~PccPerPixelGridPlacement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5ab2193334326547db2eb8e982c1cd13" name="a5ab2193334326547db2eb8e982c1cd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab2193334326547db2eb8e982c1cd13">&#9670;&#160;</a></span>buildEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::buildEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes placing all probes and renders to them again, this time with the modified auto-generated shape sizes. </p>
<p>Must be called after buildStart. This function reads from GPU memory, thus we must wait for our GPU commands issued in buildStart to finish. If you have something else to do, you may want to insert your code between those buildStart and buildEnd calls in order to maximize CPU/GPU parallelism.</p>
<p>See <a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a1bb883732dccbbe6fdea7aa28a51537f" title="Issues GPU commands to render into all probes and obtain depth from it.">PccPerPixelGridPlacement::buildStart</a> </p>

</div>
</div>
<a id="a1bb883732dccbbe6fdea7aa28a51537f" name="a1bb883732dccbbe6fdea7aa28a51537f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb883732dccbbe6fdea7aa28a51537f">&#9670;&#160;</a></span>buildStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::buildStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em> = <code><a class="el" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">PFG_RGBA8_UNORM_SRGB</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>camNear</em> = <code>0.5f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>camFar</em> = <code>500.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues GPU commands to render into all probes and obtain depth from it. </p>
<p>See <a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#a5ab2193334326547db2eb8e982c1cd13" title="Finishes placing all probes and renders to them again, this time with the modified auto-generated sha...">PccPerPixelGridPlacement::buildEnd</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>Cubemap resolution. Beware you can easily run out of memory! </td></tr>
    <tr><td class="paramname">camera</td><td></td></tr>
    <tr><td class="paramname">pixelFormat</td><td></td></tr>
    <tr><td class="paramname">camNear</td><td></td></tr>
    <tr><td class="paramname">camFar</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0244672aeb84ce3bd933ed3577d6b508" name="a0244672aeb84ce3bd933ed3577d6b508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0244672aeb84ce3bd933ed3577d6b508">&#9670;&#160;</a></span>getFullRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_aabb.html">Aabb</a> &amp; Ogre::PccPerPixelGridPlacement::getFullRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fdcddbb7d2a7878ff1a0aee56d8beed" name="a4fdcddbb7d2a7878ff1a0aee56d8beed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdcddbb7d2a7878ff1a0aee56d8beed">&#9670;&#160;</a></span>getMaxNumProbes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::PccPerPixelGridPlacement::getMaxNumProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns numProbes[0] * numProbes[1] * numProbes[2]. </p>

</div>
</div>
<a id="a2fd65f3e20fd66d76ce2deacb09691e6" name="a2fd65f3e20fd66d76ce2deacb09691e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd65f3e20fd66d76ce2deacb09691e6">&#9670;&#160;</a></span>getNumProbes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> * Ogre::PccPerPixelGridPlacement::getNumProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af86c528885247b347de3fa537a79eb37" name="af86c528885247b347de3fa537a79eb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86c528885247b347de3fa537a79eb37">&#9670;&#160;</a></span>getOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp; Ogre::PccPerPixelGridPlacement::getOverlap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed6feb92ffd56d1b821e7c7381ff3eb0" name="aed6feb92ffd56d1b821e7c7381ff3eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6feb92ffd56d1b821e7c7381ff3eb0">&#9670;&#160;</a></span>getParallaxCorrectedCubemap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html">ParallaxCorrectedCubemapAuto</a> * Ogre::PccPerPixelGridPlacement::getParallaxCorrectedCubemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a82e14e83ac22f6d2c4266beb2fed04" name="a9a82e14e83ac22f6d2c4266beb2fed04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a82e14e83ac22f6d2c4266beb2fed04">&#9670;&#160;</a></span>getSnapDeviationError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp; Ogre::PccPerPixelGridPlacement::getSnapDeviationError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f417e20a1c115bd860f640e28435a74" name="a4f417e20a1c115bd860f640e28435a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f417e20a1c115bd860f640e28435a74">&#9670;&#160;</a></span>getSnapSidesDeviationErrorMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp; Ogre::PccPerPixelGridPlacement::getSnapSidesDeviationErrorMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3017cc26d334e18a2664f4a2055809e" name="af3017cc26d334e18a2664f4a2055809e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3017cc26d334e18a2664f4a2055809e">&#9670;&#160;</a></span>getSnapSidesDeviationErrorMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp; Ogre::PccPerPixelGridPlacement::getSnapSidesDeviationErrorMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38a34da70c23bf1259095a3c38471c16" name="a38a34da70c23bf1259095a3c38471c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a34da70c23bf1259095a3c38471c16">&#9670;&#160;</a></span>preCopyRenderTargetToCubemap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::preCopyRenderTargetToCubemap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>renderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>cubemapArrayIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html">ParallaxCorrectedCubemapAutoListener</a> overloads. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html#a1a953bb915a4b866f71f41229238a7b4">Ogre::ParallaxCorrectedCubemapAutoListener</a>.</p>

</div>
</div>
<a id="acc55cee31ecef33fb8ca31f97ac0548a" name="acc55cee31ecef33fb8ca31f97ac0548a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc55cee31ecef33fb8ca31f97ac0548a">&#9670;&#160;</a></span>setFullRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::setFullRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_aabb.html">Aabb</a> &amp;&#160;</td>
          <td class="paramname"><em>fullRegion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html" title="Placing multiple PCC probes by hand can be difficult and even error prone.">PccPerPixelGridPlacement</a> needs, as guidance, the maximum region it will be occupying. </p>
<p>It could be a room, a house. We will then distribute the probes homegeneously then analyze average depth, and try to match the shape of the probes to match the visible geometry from the probe's perspective. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullRegion</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93392f3dbbd10f324dbeed2806b55135" name="a93392f3dbbd10f324dbeed2806b55135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93392f3dbbd10f324dbeed2806b55135">&#9670;&#160;</a></span>setNumProbes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::setNumProbes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numProbes</em>[3]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of probes in each axis. </p>
<p>Thus the total number of probes will be numProbes[0] * numProbes[1] * numProbes[2] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numProbes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec8c3b5990717a1afac302b67356fc6" name="a5ec8c3b5990717a1afac302b67356fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec8c3b5990717a1afac302b67356fc6">&#9670;&#160;</a></span>setOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::setOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>overlap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html" title="Placing multiple PCC probes by hand can be difficult and even error prone.">PccPerPixelGridPlacement</a> will subdivide in mNumProbes[i] probes along each axis, creating a 3D grid. </p>
<p>Overlap is disabled with a value of 1.0</p>
<p>Without overlap, there will be harsh outlines at the borders between the probes. Adding some overlap allows a smooth blending between them.</p>
<p>Higher overlap results in smoother blending, but also makes each probe's area coverage bigger, which reduces runtime performance.</p>
<p>Vaules lower than 1.0 make the areas smaller, leaving gaps between each probe. This often is undesired unless it's a building with clearly separated rooms at homogeneous distances (which is often unnatural). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlap</td><td>Valid range: (0; inf) Default: 1.5 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace6f80f8122a3a86b9d4a711ee6ba310" name="ace6f80f8122a3a86b9d4a711ee6ba310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6f80f8122a3a86b9d4a711ee6ba310">&#9670;&#160;</a></span>setParallaxCorrectedCubemapAuto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::setParallaxCorrectedCubemapAuto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html">ParallaxCorrectedCubemapAuto</a> *&#160;</td>
          <td class="paramname"><em>pcc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada834debc302bdbd001e042a96b21a14" name="ada834debc302bdbd001e042a96b21a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada834debc302bdbd001e042a96b21a14">&#9670;&#160;</a></span>setSnapDeviationError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::setSnapDeviationError </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>relativeError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When the probes have a different size than what they should have, but they're almost the same as mFullRegion (they can be different due to precision issues, small objects being on camera); it may be desirable to make them "snap" back to mFullRegion; particularly to avoid artifacts (missing reflections). </p>
<p>If the distance between the new shape and the mFullRegion is smaller than relativeError (in %) then we snap the shape's bound back to mFullRegion. For more info, see snapToFullRegion.</p>
<dl class="section see"><dt>See also</dt><dd>PccPerPixelGridPlacement::snapToFullRegion </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativeError</td><td>Valid range: [0; inf) Use a very large value to always snap 0 to disable snapping in this axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a8f0c9bb113456db6c36741d73e4daa" name="a3a8f0c9bb113456db6c36741d73e4daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8f0c9bb113456db6c36741d73e4daa">&#9670;&#160;</a></span>setSnapSides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::PccPerPixelGridPlacement::setSnapSides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>snapSidesDeviationErrorMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>snapSidesDeviationErrorMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Very similar to <a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#ada834debc302bdbd001e042a96b21a14" title="When the probes have a different size than what they should have, but they&#39;re almost the same as mFul...">PccPerPixelGridPlacement::setSnapDeviationError</a> but more specific; thus allowing for much bigger error margins to fix glitches without causing major distortions. </p>
<p>If a wall is outside the probe's shape, it won't have reflections. It may be quite common that if <a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html#acc55cee31ecef33fb8ca31f97ac0548a" title="PccPerPixelGridPlacement needs, as guidance, the maximum region it will be occupying.">setFullRegion()</a> defines a rectangular room, then the produced shapes may end up smaller than the room; thus the walls, ceiling and floor won't have reflections.</p>
<p>Thus this setting allows to defining relative errors for probes that are in the corners.</p>
<p>In a 2D version, if the layout is like the following:</p>
<div class="fragment"><div class="line">               max</div>
<div class="line">   -----------</div>
<div class="line">  | A | B | C |</div>
<div class="line">  | D | E | F |</div>
<div class="line">  | G | H | I |</div>
<div class="line">   -----------</div>
<div class="line">min</div>
</div><!-- fragment --><p>Then G will be snapped against the left corner if the distance to this corner is &lt;= snapSidesDeviationErrorMin.x (in percentage) and A will also snapped against the bottom corner using snapSidesDeviationErrorMin.y</p>
<p>While C will snapped against the right corner using snapSidesDeviationErrorMax.x and against the top corner using snapSidesDeviationErrorMax.y</p>
<p>B will only be snapped against the top corner using snapSidesDeviationErrorMax.y</p>
<p>Likewise, E won't be snapped because it's not in any corner or edge. </p><dl class="section remark"><dt>Remarks</dt><dd>Why shouldn't always snap? Consider a room with a hallway, or a non-rectangular room with column:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Room with a hallway:</span></div>
<div class="line">     -----------------------</div>
<div class="line">    | A | B | C  ___________|</div>
<div class="line">    | D | E | F |</div>
<div class="line">    | G | H | I |</div>
<div class="line">     -----------</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Non-rectangular with a column:</span></div>
<div class="line">     -------</div>
<div class="line">    | A | B |___</div>
<div class="line">    | D | E | F |</div>
<div class="line">    | G | H | I |</div>
<div class="line">     -----------</div>
</div><!-- fragment --><p>In these cases, we don't want C to snap, because the reflections when using C's probe will look unnecessarily distorted. Thus we only want to snap if the error is small enough, else it should be safe to assume there is no wall at that location.</p>
<p>It's not always easy. If the probe is too big and the hallway/column is halfway through the probe, then we could only fix this by hand by an artist, or by adding more probes (which can consume significantly more resources)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snapSidesDeviationErrorMin</td><td>Valid range: [0; inf) Use a very large value to always snap 0 to disable snapping against this corner </td></tr>
    <tr><td class="paramname">snapSidesDeviationErrorMax</td><td>Valid range: [0; inf) Use a very large value to always snap 0 to disable snapping against this corner </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_pcc_per_pixel_grid_placement_8h.html">OgrePccPerPixelGridPlacement.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_pcc_per_pixel_grid_placement.html">PccPerPixelGridPlacement</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
