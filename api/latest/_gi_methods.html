<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Global Illumination Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE-Next
   &#160;<span id="projectnumber">4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_gi_methods.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Global Illumination Methods </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#GiAmbientLighting">Ambient Lighting</a><ul><li class="level2"><a href="#GiAmbientLightingFlat">Flat</a></li>
<li class="level2"><a href="#GiAmbientLightingHemisphere">Hemisphere</a></li>
<li class="level2"><a href="#GiAmbientLightingSH">Spherical Harmonics</a></li>
</ul>
</li>
<li class="level1"><a href="#GiPCC">Parallax Corrected Cubemaps (PCC)</a><ul><li class="level2"><a href="#GiPCCAuto">Auto PCC</a></li>
<li class="level2"><a href="#GiPCCManual">Manual PCC</a></li>
</ul>
</li>
<li class="level1"><a href="#GiPPPCC">Per Pixel PCC</a><ul><li class="level2"><a href="#GiPPGridPlacement">PCC Per Pixel Grid Placement</a></li>
</ul>
</li>
<li class="level1"><a href="#GiInstantRadiosity">Instant Radiosity</a><ul><ul><li class="level3"><a href="#autotoc_md85">Pros</a></li>
<li class="level3"><a href="#autotoc_md86">Cons</a></li>
</ul>
</ul>
</li>
<li class="level1"><a href="#GiIrradianceVolume">Irradiance Volume</a><ul><ul><li class="level3"><a href="#autotoc_md87">Pros</a></li>
<li class="level3"><a href="#autotoc_md88">Cons</a></li>
</ul>
</ul>
</li>
<li class="level1"><a href="#GiVCT">Voxel Cone Tracing (aka VCT)</a><ul><ul><li class="level3"><a href="#autotoc_md89">Pros</a></li>
<li class="level3"><a href="#autotoc_md90">Cons</a></li>
</ul>
<li class="level2"><a href="#GiVCTPlusPPPCC">VCT + Per Pixel PCC Hybrid</a></li>
</ul>
</li>
<li class="level1"><a href="#GiIFD">Irradiance Field with Depth (IFD)</a><ul><ul><li class="level3"><a href="#autotoc_md91">Pros</a></li>
<li class="level3"><a href="#autotoc_md92">Cons</a></li>
</ul>
</ul>
</li>
<li class="level1"><a href="#GiCIVCT">Cascaded Image Voxel Cone Tracing (CIVCT)</a></li>
<li class="level1"><a href="#GiWhatTechniqueChoose">What technique should I choose?</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_manual_Rendering_GiMethods"></a> <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> offers various GI techniques and it can be overwhelming which one to choose.</p>
<h1><a class="anchor" id="GiAmbientLighting"></a>
Ambient Lighting</h1>
<p>The simplest and fastest solution there is.</p>
<p>It can be:</p>
<h2><a class="anchor" id="GiAmbientLightingFlat"></a>
Flat</h2>
<p>Use <code>SceneManager::setAmbientLight</code> and set <code>upperHemisphere</code> and <code>lowerHemisphere</code> to the same value or set <code>HlmsPbs::setAmbientLightMode</code> to <code>AmbientFixed</code>.</p>
<p>This is just a solid colour applied uniformly to the entire scene. Very basic</p>
<h2><a class="anchor" id="GiAmbientLightingHemisphere"></a>
Hemisphere</h2>
<p>Use <code>SceneManager::setAmbientLight</code> and set <code>upperHemisphere</code> and <code>lowerHemisphere</code> to the different values and set <code>HlmsPbs::setAmbientLightMode</code> to either <code>AmbientAuto</code> or <code>AmbientHemisphere</code>.</p>
<p>Hemisphere lighting is supposed to be set to the colour of the sky or sun in upperHemisphere, and the colour of the ground in lower hemisphere to mimic a single bounce coming from the ground.</p>
<p>Good enough for simple outdoor scenes.</p>
<h2><a class="anchor" id="GiAmbientLightingSH"></a>
Spherical Harmonics</h2>
<p>If Spherical Harmonics have been calculated elsewhere, 3rd-order SH coefficients can be provided to <code>SceneManager::setSphericalHarmonics</code> and set <code>HlmsPbs::setAmbientLightMode</code> to either <code>AmbientSh</code> or <code>AmbientShMonochrome</code>.</p>
<p>If <code>AmbientShMonochrome</code>, the red channel of the SH components will be used.</p>
<blockquote class="doxtable">
<p><b>Note:</b> <a href="https://github.com/google/filament/releases/tag/v1.10.1">Filament's cmgen</a> tool can generate SH coefficients out of cubemaps</p>
<p><b>Note:</b> SH lighting is best understood if seen like a single 16x16 cubemap lossy-compressed into 27 floats (if coloured, 9 floats if monochrome) </p>
</blockquote>
<h1><a class="anchor" id="GiPCC"></a>
Parallax Corrected Cubemaps (PCC)</h1>
<p>The oldest technique we have. PCC is mostly for getting good-looking (but often incorrect) specular reflections, but we also use it as a poor-man replacement of diffuse GI by sampling the highest mip.</p>
<p>It consists in generating a cubemap and using simple math to assume the room is reflecting a rectangular room, therefore distortions happen when this assumption is broken e.g. room is round or has a trapezoidal shape, large furniture is placed in the middle of the room, furniture is not thin and glued to the walls, ceiling or floor.</p>
<p>Notice non-rectangular rooms will have incorrect reflections <img src="PCC01.jpg" alt="" class="inline"/></p>
<p>The reflection of the red wall on the white wall appears to be much bigger and higher than it should <img src="PCC02.jpg" alt="" class="inline"/></p>
<p>For reference the red wall when viewed directly: <img src="PCC03.jpg" alt="" class="inline"/></p>
<blockquote class="doxtable">
<p><b>Note:</b> Faking Diffuse GI from PCC can be disabled via <code>envFeatures</code> param in <code>SceneManager::setAmbientLight</code></p>
<p><b>Note:</b> To improve diffuse GI lighting quality, you can either use <code>ibl_specular</code> pass to generate mipmaps (see <code>Samples/Media/2.0/scripts/Compositors/Tutorial_DynamicCubemap.compositor</code> or <code>LocalCubemaps.compositor</code>) or you can use <a href="https://github.com/google/filament/releases/tag/v1.10.1">Filament's cmgen</a> in combination with our OgreCmgenToCubemap tool </p>
</blockquote>
<blockquote class="doxtable">
<p>How to use cmgen + OgreCmgenToCubemap:</p>
<div class="fragment"><div class="line"># Step 1: Launch cmgen</div>
<div class="line">cmgen -f png -x out --no-mirror panorama_map.hdr</div>
<div class="line"> </div>
<div class="line"># Output data is stored in output/panorama_map/m0*.png to m8*.png</div>
<div class="line"> </div>
<div class="line"># Step 2: Convert the filtered cubemaps to OITD (Ogre internal format):</div>
<div class="line">OgreCmgenToCubemap d:\hdri\out\panorama_map png 8 panorama_map.oitd</div>
</div><!-- fragment --><p>Then load the oitd in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> at runtime (You need to explicitly use the prefer-loading-as-sRGB flag) and set it to PBSM_REFLECTION of the datablock. </p>
</blockquote>
<h2><a class="anchor" id="GiPCCAuto"></a>
Auto PCC</h2>
<p>Cubemaps are blended automatically based on close probes and camera location. Results are usually poor.</p>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/ApiUsage/LocalCubemaps</code> </p>
</blockquote>
<h2><a class="anchor" id="GiPCCManual"></a>
Manual PCC</h2>
<p>Each cubemap probe must be set to each HlmsPbsDatablock by hand. This achieves much better results but requires a lot of manual setting.</p>
<p>It is also problematic if two probes should be applied to the same mesh with the same material because that is impossible. The mesh must be split into two with different materials.</p>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/ApiUsage/LocalCubemapsManualProbes</code> </p>
</blockquote>
<h1><a class="anchor" id="GiPPPCC"></a>
Per Pixel PCC</h1>
<p>Can run on old Hardware (if using lower quality dual-paraboloid maps) or on modern hardware (if using higher quality cubemap arrays).</p>
<p>Per Pixel PCC is always automatic and combines the results of multiple probes at per pixel granularity. This is extremely convenient because 'it just works' with no further intervention required. It looks as good or better than manual and it's automatic.</p>
<p>But it has a higher performance cost, which is often not a problem for Desktop systems but may be a problem on Mobile.</p>
<p>Requires Forward+ to be enabled.</p>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/ApiUsage/LocalCubemaps</code></p><ul>
<li>See <code>Samples/2.0/ApiUsage/LocalCubemapsManualProbes</code> </li>
</ul>
</blockquote>
<h2><a class="anchor" id="GiPPGridPlacement"></a>
PCC Per Pixel Grid Placement</h2>
<p>Strictly speaking this is not a GI technique.</p>
<p>It's merely an automated process to decide the placement of a grid of per pixel PCC probes. Once the probes are set artists can further tweak it.</p>
<p><b>The main use case is procedurally generated scenes</b>, but can also be useful for artists as a starting point.</p>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/ApiUsage/PccPerPixelGridPlacement</code> </p>
</blockquote>
<h1><a class="anchor" id="GiInstantRadiosity"></a>
Instant Radiosity</h1>
<p>For starters, this technique is a fake. It's not meant to achieve hyper realistic GI, but rather give "good enough" results.</p>
<p>It is based on an old <a href="https://www.gamedev.net/blogs/entry/1925299-deferred-lighting-and-instant-radiosity/">gamedev.net article</a>.</p>
<p>The technique consist in doing raytracing from the light points of view into all directions. And whenever there is a hit place a 'virtual point light' which is literally a basic point that emits light, mimicking a light bounce</p>
<p>Another way to see this technique is that it's just placing an arbitrary amount of point lights until the scene is lit enough from many locations. But instead of the lights being placed by artists, it's done automatically.</p>
<h3><a class="anchor" id="autotoc_md85"></a>
Pros</h3>
<ol type="1">
<li>Lots of parameter to tune. The more VPLs you have, the more accurate the solution will be but higher the performance cost</li>
<li>After some tuning can get decent performance even in old cards</li>
<li>VPLs can later be tweaked manually for artistic control</li>
<li>Bounces affect dynamic and static objects</li>
<li>Camera independent</li>
<li>Can be enabled at the same time as PCC, and PCC can provide information about specular reflections and sky</li>
</ol>
<h3><a class="anchor" id="autotoc_md86"></a>
Cons</h3>
<ol type="1">
<li>Requires Forward+ to be active</li>
<li>Light leaking</li>
<li>Not very accurate unless VPL count is insanely high, tanking performance</li>
<li>Only static objects participate in bounce evaluation</li>
<li>Changing lighting position/direction requires rebuilding</li>
<li>Changing static objects requires rebuilding</li>
</ol>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/ApiUsage/InstantRadiosity</code> </p>
</blockquote>
<p>Instant Radiosity's virtual light points visualized for 0 and 1 bounce (intensity exaggerated)</p>
<p><img src="InstantRad01.jpg" alt="" class="inline"/></p>
<p><img src="InstantRad02.jpg" alt="" class="inline"/></p>
<h1><a class="anchor" id="GiIrradianceVolume"></a>
Irradiance Volume</h1>
<p>Irradiance Volume uses a 3D volume to store lighting information. Currently this IV is generated from Instant Radiosity data. But once generated the 3D texture can be saved to disk as is and be loaded directly which should be very fast (only limitation is IO bandwidth)</p>
<p>Each voxel contains lighting information from all 6 directions.</p>
<p>Another way to look at this solution is like a 3D grid of lots of 1x1 cubemaps.</p>
<h3><a class="anchor" id="autotoc_md87"></a>
Pros</h3>
<ol type="1">
<li>Extremely fast</li>
<li>Runs on old HW</li>
<li>Bounces affect dynamic and static objects</li>
<li>Camera independent</li>
<li>Can be enabled at the same time as PCC, and PCC can provide information about specular reflections and sky</li>
</ol>
<h3><a class="anchor" id="autotoc_md88"></a>
Cons</h3>
<ol type="1">
<li>Quality/accuracy depends on how dense the grid is. Big scenes may need very large resolution. 3D volume textures quickly grow in VRAM usage. e.g. a 16x16x16 needs only 16kb of VRAM, whereas a 128x128x128 volume needs 8MB and 256x256x256 needs 64MB</li>
<li>Light leaks</li>
<li>Changing lighting position/direction requires rebuilding</li>
<li>Changing static objects requires rebuilding</li>
<li>Not much artistic control</li>
<li>Accuracy depends on the input data, and currently it's based on Instant Radiosity so it is not very accurate</li>
</ol>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/ApiUsage/InstantRadiosity</code> </p>
</blockquote>
<h1><a class="anchor" id="GiVCT"></a>
Voxel Cone Tracing (aka VCT)</h1>
<p>VCT is ray marching but instead of rays, cones are used. Hence <b>cone</b> tracing or cone marching.</p>
<p>As of 2021 this technique is state of the art and is <em>very</em> accurate and can even generate specular glossy reflections, although low roughness reflections will not look as good as high roughness reflections.</p>
<p>This technique works by voxelizing the entire scene (i.e. turning the whole scene into a Minecraft-like world representation) and then at runtime cone tracing against this voxel world to gather bounce data.</p>
<p><img src="VCT.jpg" alt="" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md89"></a>
Pros</h3>
<ol type="1">
<li>Extremely accurate</li>
<li>Decent performance on modern hardware</li>
<li>Supports emissive textured materials being light sources</li>
<li>Bounces affect dynamic and static objects</li>
<li>Quality can be lowered for much higher performance<ol type="a">
<li>Via <code>HlmsPbs::setVctFullConeCount</code></li>
<li>Via <code>VctLighting::setAnisotropic</code></li>
<li>Via <code>VctLighting::mSpecularSdfQuality</code></li>
<li>Lower resolution</li>
</ol>
</li>
<li>Light leaking is still a problem, but less so than other techniques<ol type="a">
<li>Use <code>thinWallCounter</code> in <code>VctLighting::update</code> to tweak this</li>
</ol>
</li>
<li>Supports changing lighting position/direction with a small performance cost<ol type="a">
<li>This ability can be sacrificed by destroying VctVoxelizer to free up VRAM</li>
</ol>
</li>
<li>Camera independent</li>
<li>Specular rough reflections supported</li>
</ol>
<h3><a class="anchor" id="autotoc_md90"></a>
Cons</h3>
<ol type="1">
<li>Massive amounts of VRAM required</li>
<li>Like any volumetric solution (e.g. Irradiance Volume), bigger scenes requires larger resolution to keep quality. And this technique uses up to 4 3D volumetric textures. It eats a lot of VRAM.</li>
<li>Requires DX11/GL4 level hardware</li>
<li>Performance can vary wildly depending on what you're currently looking at</li>
<li>Low roughness (i.e. mirror-like) reflections, voxelization becomes noticeable (e.g. reflection looks minecraft-like)</li>
<li>Only static objects participate in bounce evaluation</li>
<li>Voxelization process is currently very slow. Although results could be saved to disk (not implemented, shouldn't be hard).</li>
<li>Voxelization process can cause a temporary spike of VRAM usage.</li>
<li>In its current implementation, sky does not participate as a GI source and <code>VctLighting::setAmbient</code> can be used to fake sky lighting information</li>
</ol>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/Tests/Voxelizer</code> </p>
</blockquote>
<h2><a class="anchor" id="GiVCTPlusPPPCC"></a>
VCT + Per Pixel PCC Hybrid</h2>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> supports combining Per-Pixel Parallax Corrected Cubemaps (PCC) with VCT when both techniques are enabled at the same time.</p>
<p>The idea is to use PCC to support much better low roughness (e.g. mirror-like) reflections and when PCC data is not available fallback to VCT.</p>
<p>Details are in our <a href="https://www.ogre3d.org/2019/08/14/pcc-vct-hybrid-progress">News Announcement</a>.</p>
<p>Parameters <code>pccVctMinDistance</code> and <code>pccVctMaxDistance</code> from <code>HlmsPbs::setParallaxCorrectedCubemap</code> control how PCC and VCT data is combined.</p>
<p><img src="VctPccHybrid.jpg" alt="" class="inline"/></p>
<h1><a class="anchor" id="GiIFD"></a>
Irradiance Field with Depth (IFD)</h1>
<p>This is a more generic term for what NVIDIA calls <a href="https://developer.nvidia.com/blog/an-engineers-guide-to-integrating-ddgi/">Dynamic Diffuse Global Illumination</a>, but instead of generating it out of Raytracing, we generated it from any source of data available (in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>'s case, from VCT's Voxel data or via Rasterization).</p>
<p>IFD only supports diffuse GI.</p>
<p>As of 2021 this technique is also state of the art and can be very accurate.</p>
<p>This technique is extremely similar to <code>Irradiance Volume</code> before (e.g. can be thought of a 3D grid of 1x1 cubemaps), but it is combined with depth information to fight leaking.</p>
<p>Additionally, instead of 3D textures, a 2D texture is used and octahedral maps are used to store information. The use of 2D textures instead of 3D opens up unexplored possibilities such as streaming 2D data using MPEG video compression, or GPU-friendly compression formats such as BC7 or ASTC.</p>
<h3><a class="anchor" id="autotoc_md91"></a>
Pros</h3>
<ol type="1">
<li>Very accurate</li>
<li>Very good performance</li>
<li>Very decent VRAM usage</li>
<li>Performance does not vary depending on what you're looking at</li>
<li>Can be combined with VCT so that IFD handles diffuse and VCT specular. The overall VRAM consumption is higher than VCT alone, but performance is better.</li>
<li>Supports emissive textured materials being light sources</li>
<li>Bounces affect dynamic and static objects</li>
<li>Multiple bounces look very good<ol type="a">
<li>More bounces take small performance impact when lights are changed (if lights don't change there is no cost)</li>
<li>Disabling light bounces entirely allows saving VRAM (via <code>VctLighting::setAllowMultipleBounces</code>)</li>
</ol>
</li>
<li>Light leaking is still a problem, but less so than other techniques</li>
<li>Supports changing lighting position/direction with a small performance cost.<ol type="a">
<li>User must kept voxelized world in VRAM for this to happen (unless rasterization is being used as source)</li>
<li>Update is distributed over time to avoid a large performance cost and is barely noticeable unless light changes too abruptly.</li>
<li>Slower systems can distribute the update over a larger time than fast system to keep a minimum target framerate (via <code>probesPerFrame</code> argument in <code>IrradianceField::update</code>)</li>
</ol>
</li>
<li>Camera independent</li>
<li>Data could be saved to disk (not implemented, shouldn't be hard) if the scene and lighting are not meant to change</li>
<li>Can be enabled at the same time as per pixel PCC, and PCC can provide information about specular reflections and sky. If VCT is also enabled, See VCT + PCC hybrid section.</li>
<li>When generated off rasterization, sky information is included.</li>
</ol>
<h3><a class="anchor" id="autotoc_md92"></a>
Cons</h3>
<ol type="1">
<li>Some artifacts may appear<ol type="a">
<li>This is often solved by slightly padding <code>fieldSize</code> and <code>fieldOrigin</code></li>
<li>Changing params in IrradianceFieldSettings may also fix it</li>
</ol>
</li>
<li>Like any volumetric solution, bigger scenes require bigger <code>IrradianceFieldSettings::mNumProbes</code> which consumes more VRAM and makes lighting updates to take longer</li>
<li>Requires DX11/GL4 level hardware, although it could be retrofit to support older GPUs if the IFD result is baked to disk</li>
<li>Updating IFD requires either Voxelization or Rasterization as source<ol type="a">
<li>Voxelization consumes considerable amount of VRAM</li>
<li>Rasterization is very slow, but very accurate</li>
</ol>
</li>
<li>When generated off Voxelization, sky information is currently not included.</li>
</ol>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/Tests/Voxelizer</code> </p>
</blockquote>
<h1><a class="anchor" id="GiCIVCT"></a>
Cascaded Image Voxel Cone Tracing (CIVCT)</h1>
<p>Image Voxel Cone Tracing is like regular VCT except it bakes every mesh into voxels, and then copies those voxels into the scene.</p>
<p>This makes rebuilding the scene <em>much</em> faster at the cost of higher VRAM usage and slightly lower quality.</p>
<p>By being able to revoxelize scenes very fast we can:</p>
<ul>
<li>Support arbitrary scenes (indoor, outdoors)</li>
<li>Support static objects</li>
<li>Optionally support dynamic objects (e.g. revoxelize every frame)</li>
</ul>
<p>This would make it the best overall GI implementation.</p>
<p>The details are described in <a class="el" href="_image_voxel_cone_tracing.html">Image Voxel Cone Tracing</a></p>
<p>Cascaded IVCT extends the concept with cascades of varying quality to cover large distances around the camera but at lower resolutions.</p>
<p>Currently CIVCT is in alpha state which means:</p>
<ul>
<li>Vulkan works great, but on low VRAM GPUs you may run out of VRAM and things will become super slow. Specially with e.g. 4 cascades</li>
<li>OpenGL works, same issues as Vulkan. But needs a few workarounds and may run into issues due to the 32 texture unit limit. Also the way OGL calculates mipmaps makes the GI darker and that needs fixing.</li>
<li>D3D11 works with low cascade count (e.g. 2), but breaks at 4 cascades. That's because D3D11 runs out of the 16 samplers because Hlms implementations are currently wasting a lot instead of reusing</li>
<li>Metal does not work because it runs out of UAV texture units (this is an <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> limitation, not Metal)</li>
</ul>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.4 will fix most of these issues</p>
<blockquote class="doxtable">
<p>- See <code>Samples/2.0/ApiUsage/ImageVoxelizer</code> </p>
</blockquote>
<h1><a class="anchor" id="GiWhatTechniqueChoose"></a>
What technique should I choose?</h1>
<p>PCC is what most games use because it's fast, easy to understand, and has predictable results. If the scene is mostly composed of rectangular rooms with little furniture, PCC will also be extremely accurate.</p>
<p>If all you want is a solution that pretends to have GI regardless of accuracy, <code>Instant Radiosity</code> can be an interesting choice, specially if you already needed to enable Forward+.</p>
<p><code>Irradiance Volume</code> is also even faster and for small indoor scenes it can get very reasonable results, specially if supporting old HW is needed.</p>
<p>If you want something accurate, pretty and runs reasonably fast with reasonably memory consumption then go for <code>IFD</code>. This one has the best balance of quality, usability and performance.</p>
<p>If you need the best possible quality or require to change lighting at runtime, then VCT (or IFD + VCT) is the best solution.</p>
<p>Please note that many of these techniques can be combined together (e.g. PCC and per-pixel PCC usually can be paired with anything) but they won't necessarily end up in pleasant-looking results, and certain combinations may cause shaders to compile (it could be an <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> bug so if you find it please report it <a href="https://forums.ogre3d.org/viewforum.php?f=25">in the forums</a> or in <a href="https://github.com/OGRECave/ogre-next/issues">Github</a>) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_rendering.html">Rendering</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
