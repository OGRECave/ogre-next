<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::StagingBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE-Next
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_staging_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_staging_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::StagingBuffer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However the access in both cases is limited.  
 <a href="class_ogre_1_1_staging_buffer.html#details">More...</a></p>

<p><code>#include &lt;OgreStagingBuffer.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::StagingBuffer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_staging_buffer__inherit__graph.svg" width="594" height="291"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae90c8303a85284ef6801919bfc4fdfd0"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ae90c8303a85284ef6801919bfc4fdfd0">DestinationVec</a></td></tr>
<tr class="separator:ae90c8303a85284ef6801919bfc4fdfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb4937c4f63bd15c0650146ba554efa3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#abb4937c4f63bd15c0650146ba554efa3">StagingBuffer</a> (size_t internalBufferStart, size_t sizeBytes, <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, bool uploadOnly)</td></tr>
<tr class="separator:abb4937c4f63bd15c0650146ba554efa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f67923bab757fa39e66903935a621c0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a7f67923bab757fa39e66903935a621c0">~StagingBuffer</a> ()</td></tr>
<tr class="separator:a7f67923bab757fa39e66903935a621c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fed0b896633e63d9cb112c0ae026bd3"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a3fed0b896633e63d9cb112c0ae026bd3">_asyncDownload</a> (<a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *source, size_t srcOffset, size_t srcLength)=0</td></tr>
<tr class="memdesc:a3fed0b896633e63d9cb112c0ae026bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the GPU data in <a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> to the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> so that it can be later read by the CPU using an <a class="el" href="class_ogre_1_1_async_ticket.html" title="In Ogre 2.0 data structures, reading data from GPU back to CPU is asynchronous.">AsyncTicket</a>.  <a href="class_ogre_1_1_staging_buffer.html#a3fed0b896633e63d9cb112c0ae026bd3">More...</a><br /></td></tr>
<tr class="separator:a3fed0b896633e63d9cb112c0ae026bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9db4541715b29e151043a09a24a527a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ad9db4541715b29e151043a09a24a527a">_cancelDownload</a> (size_t offset, size_t sizeBytes)</td></tr>
<tr class="memdesc:ad9db4541715b29e151043a09a24a527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory assigned to a download that hasn't been mapped yet, to make space for another _asyncDownload call.  <a href="class_ogre_1_1_staging_buffer.html#ad9db4541715b29e151043a09a24a527a">More...</a><br /></td></tr>
<tr class="separator:ad9db4541715b29e151043a09a24a527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6789c54909d4f248cb69a3a8a04f3e"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#abf6789c54909d4f248cb69a3a8a04f3e">_mapForRead</a> (size_t offset, size_t sizeBytes)</td></tr>
<tr class="memdesc:abf6789c54909d4f248cb69a3a8a04f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the buffer for read acces for the CPU.  <a href="class_ogre_1_1_staging_buffer.html#abf6789c54909d4f248cb69a3a8a04f3e">More...</a><br /></td></tr>
<tr class="separator:abf6789c54909d4f248cb69a3a8a04f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1facd7ade881eff937cd4ccfa998b83c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a1facd7ade881eff937cd4ccfa998b83c">addReferenceCount</a> ()</td></tr>
<tr class="memdesc:a1facd7ade881eff937cd4ccfa998b83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a reference count to the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a>.  <a href="class_ogre_1_1_staging_buffer.html#a1facd7ade881eff937cd4ccfa998b83c">More...</a><br /></td></tr>
<tr class="separator:a1facd7ade881eff937cd4ccfa998b83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad844466b16d039d78fe762a3e32f92c2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ad844466b16d039d78fe762a3e32f92c2">canDownload</a> (size_t length) const</td></tr>
<tr class="memdesc:ad844466b16d039d78fe762a3e32f92c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this staging buffer has enough free space to use _asyncDownload.  <a href="class_ogre_1_1_staging_buffer.html#ad844466b16d039d78fe762a3e32f92c2">More...</a><br /></td></tr>
<tr class="separator:ad844466b16d039d78fe762a3e32f92c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fde7ac828db275c0554d39f52adb7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a00f119d555e251922c695ec569ccfd95">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a55fde7ac828db275c0554d39f52adb7c">getLastUsedTimestamp</a> () const</td></tr>
<tr class="memdesc:a55fde7ac828db275c0554d39f52adb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time in millisecond when the ref. count became 0.  <a href="class_ogre_1_1_staging_buffer.html#a55fde7ac828db275c0554d39f52adb7c">More...</a><br /></td></tr>
<tr class="separator:a55fde7ac828db275c0554d39f52adb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf4e13a8a6544f8bb063a3cc8471000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#afdf4e13a8a6544f8bb063a3cc8471000">getLifetimeThreshold</a> () const</td></tr>
<tr class="memdesc:afdf4e13a8a6544f8bb063a3cc8471000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time in milliseconds in which a <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> should live with a reference count of 0 before being deleted.  <a href="class_ogre_1_1_staging_buffer.html#afdf4e13a8a6544f8bb063a3cc8471000">More...</a><br /></td></tr>
<tr class="separator:afdf4e13a8a6544f8bb063a3cc8471000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e2d619a61b234feefbb4401fae83f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a447e51d7625af79716667cebcfa6da57">MappingState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a72e2d619a61b234feefbb4401fae83f5">getMappingState</a> () const</td></tr>
<tr class="separator:a72e2d619a61b234feefbb4401fae83f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6558ff3b1a53431ffa195b647be7a2a8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a6558ff3b1a53431ffa195b647be7a2a8">getMaxSize</a> ()</td></tr>
<tr class="separator:a6558ff3b1a53431ffa195b647be7a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3341e6c04dbb18e3e1e55868e15d3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a626dceff763286830a1ef619f5468ab0">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ac3341e6c04dbb18e3e1e55868e15d3e6">getReferenceCount</a> () const</td></tr>
<tr class="separator:ac3341e6c04dbb18e3e1e55868e15d3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e34a37e28c0e54502ada87450743ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a3e34a37e28c0e54502ada87450743ad0">getUnfencedTimeThreshold</a> () const</td></tr>
<tr class="memdesc:a3e34a37e28c0e54502ada87450743ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time in milliseconds in which a <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> should hazards unfenced while with a reference count of 0.  <a href="class_ogre_1_1_staging_buffer.html#a3e34a37e28c0e54502ada87450743ad0">More...</a><br /></td></tr>
<tr class="separator:a3e34a37e28c0e54502ada87450743ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05b671b655e0119ce740a06d20b4170"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ae05b671b655e0119ce740a06d20b4170">getUploadOnly</a> () const</td></tr>
<tr class="memdesc:ae05b671b655e0119ce740a06d20b4170"><td class="mdescLeft">&#160;</td><td class="mdescRight">When true, this buffer can only be used for uploading to GPU.  <a href="class_ogre_1_1_staging_buffer.html#ae05b671b655e0119ce740a06d20b4170">More...</a><br /></td></tr>
<tr class="separator:ae05b671b655e0119ce740a06d20b4170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58661498c6fd0e054a0c261ebb3bbcf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ab58661498c6fd0e054a0c261ebb3bbcf">map</a> (size_t sizeBytes)</td></tr>
<tr class="memdesc:ab58661498c6fd0e054a0c261ebb3bbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the given amount of bytes.  <a href="class_ogre_1_1_staging_buffer.html#ab58661498c6fd0e054a0c261ebb3bbcf">More...</a><br /></td></tr>
<tr class="separator:ab58661498c6fd0e054a0c261ebb3bbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d425e7d85804eaa45c01f6476ec204a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a9d425e7d85804eaa45c01f6476ec204a">removeReferenceCount</a> ()</td></tr>
<tr class="memdesc:a9d425e7d85804eaa45c01f6476ec204a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count by one.  <a href="class_ogre_1_1_staging_buffer.html#a9d425e7d85804eaa45c01f6476ec204a">More...</a><br /></td></tr>
<tr class="separator:a9d425e7d85804eaa45c01f6476ec204a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438d82f09b5f657be30c30d7d1c0801d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a438d82f09b5f657be30c30d7d1c0801d">unmap</a> (const <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> &amp;destination)</td></tr>
<tr class="memdesc:a438d82f09b5f657be30c30d7d1c0801d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps the mapped region and copies the data to the given region.  <a href="class_ogre_1_1_staging_buffer.html#a438d82f09b5f657be30c30d7d1c0801d">More...</a><br /></td></tr>
<tr class="separator:a438d82f09b5f657be30c30d7d1c0801d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8e2853c21a7418218605a0b9cdf461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a9c8e2853c21a7418218605a0b9cdf461">unmap</a> (const <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> *destinations, size_t numDestinations)</td></tr>
<tr class="separator:a9c8e2853c21a7418218605a0b9cdf461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe091313c974edab09f0f9daabf8034d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#afe091313c974edab09f0f9daabf8034d">unmap</a> (const <a class="el" href="class_ogre_1_1_staging_buffer.html#ae90c8303a85284ef6801919bfc4fdfd0">DestinationVec</a> &amp;destinations)</td></tr>
<tr class="memdesc:afe091313c974edab09f0f9daabf8034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps the mapped region and copies the data to multiple buffers.  <a href="class_ogre_1_1_staging_buffer.html#afe091313c974edab09f0f9daabf8034d">More...</a><br /></td></tr>
<tr class="separator:afe091313c974edab09f0f9daabf8034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababb860ddfb4ecdf054766f145848465"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af48b48d39914b067541a62b674b80935">StagingStallType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ababb860ddfb4ecdf054766f145848465">uploadWillStall</a> (size_t sizeBytes)</td></tr>
<tr class="memdesc:ababb860ddfb4ecdf054766f145848465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if our next call to <a class="el" href="class_ogre_1_1_staging_buffer.html#ab58661498c6fd0e054a0c261ebb3bbcf" title="Maps the given amount of bytes.">map()</a> with the same parameters will stall.  <a href="class_ogre_1_1_staging_buffer.html#ababb860ddfb4ecdf054766f145848465">More...</a><br /></td></tr>
<tr class="separator:ababb860ddfb4ecdf054766f145848465"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However the access in both cases is limited. </p>
<p>GPUs can only copy (i.e. memcpy) to another real buffer (can't be used directly as i.e. texture or vertex buffer) and CPUs can only map it. In other words, a staging buffer is an intermediate buffer to transfer data between CPU &amp; GPU </p><dl class="section remark"><dt>Remarks</dt><dd>The interface is very similar to <a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a>) but it's not the same. A staging buffer can only map/unmap, and it's mapping operations don't accept an "elementStart" argument. Staging buffers always deal with bytes, not elements or bytes per element. <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a> implementations also synchronize the mapping differently to avoid excessive memory waste or stalling. </dd></dl>
<dl class="section user"><dt></dt><dd>Internally, the staging buffer will have a maximum size and use it as a ring buffer. i.e. if you have a 32MB staging buffer, you can upload 4 meshes of 8 MBs each. On the 5th one the system will first check if the first mesh has already been copied, otherwise it will stall. Trying to map more bytes than the total size is an error. </dd></dl>
<dl class="section user"><dt></dt><dd>Staging buffers can't be persistently mapped, since it beats the point. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae90c8303a85284ef6801919bfc4fdfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90c8303a85284ef6801919bfc4fdfd0">&#9670;&nbsp;</a></span>DestinationVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a>&gt;::type <a class="el" href="class_ogre_1_1_staging_buffer.html#ae90c8303a85284ef6801919bfc4fdfd0">Ogre::StagingBuffer::DestinationVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb4937c4f63bd15c0650146ba554efa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4937c4f63bd15c0650146ba554efa3">&#9670;&nbsp;</a></span>StagingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::StagingBuffer::StagingBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>internalBufferStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uploadOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f67923bab757fa39e66903935a621c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f67923bab757fa39e66903935a621c0">&#9670;&nbsp;</a></span>~StagingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::StagingBuffer::~StagingBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3fed0b896633e63d9cb112c0ae026bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fed0b896633e63d9cb112c0ae026bd3">&#9670;&nbsp;</a></span>_asyncDownload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::StagingBuffer::_asyncDownload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the GPU data in <a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> to the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> so that it can be later read by the CPU using an <a class="el" href="class_ogre_1_1_async_ticket.html" title="In Ogre 2.0 data structures, reading data from GPU back to CPU is asynchronous.">AsyncTicket</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_async_ticket.html" title="In Ogre 2.0 data structures, reading data from GPU back to CPU is asynchronous.">AsyncTicket</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For internal use. May throw if it can't handle the request (i.e. requested size is too big, or too many _asyncDownload operations are pending until calling _mapForRead) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#ad844466b16d039d78fe762a3e32f92c2" title="Checks if this staging buffer has enough free space to use _asyncDownload.">canDownload</a> mUploadOnly must be true. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The buffer to copy from. </td></tr>
    <tr><td class="paramname">srcOffset</td><td>The offset, in bytes, of the buffer to copy from. </td></tr>
    <tr><td class="paramname">srcLength</td><td>The size in bytes, of the data to transfer to this staging buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in bytes that will be used by </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#abf6789c54909d4f248cb69a3a8a04f3e" title="Maps the buffer for read acces for the CPU.">_mapForRead</a> </dd></dl>

<p>Implemented in <a class="el" href="class_ogre_1_1_vulkan_staging_buffer.html#a00a8065fe64ba9d090d71c8d1cd7099a">Ogre::VulkanStagingBuffer</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_staging_buffer.html#abb97b57bd8aac9410d5746350119507f">Ogre::NULLStagingBuffer</a>, <a class="el" href="class_ogre_1_1_metal_staging_buffer.html#a0bc36598d53b7aca2178b7ea3c97e608">Ogre::MetalStagingBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_staging_buffer.html#a3b2d417cb3ef65ba0f9733ddff3767bd">Ogre::GL3PlusStagingBuffer</a>, <a class="el" href="class_ogre_1_1_d3_d11_staging_buffer.html#adab609b0c5db7badf5b93a795aaf4580">Ogre::D3D11StagingBuffer</a>, and <a class="el" href="class_ogre_1_1_g_l_e_s2_staging_buffer.html#a66ebe4f87d071e9611aac7ec39fef7a2">Ogre::GLES2StagingBuffer</a>.</p>

</div>
</div>
<a id="ad9db4541715b29e151043a09a24a527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9db4541715b29e151043a09a24a527a">&#9670;&nbsp;</a></span>_cancelDownload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StagingBuffer::_cancelDownload </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases memory assigned to a download that hasn't been mapped yet, to make space for another _asyncDownload call. </p>
<p>Useful when you suddenly don't intend to call _mapForRead. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_metal_staging_buffer.html#abd53cf9891a5952d2fb35654565c1940">Ogre::MetalStagingBuffer</a>.</p>

</div>
</div>
<a id="abf6789c54909d4f248cb69a3a8a04f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6789c54909d4f248cb69a3a8a04f3e">&#9670;&nbsp;</a></span>_mapForRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* Ogre::StagingBuffer::_mapForRead </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the buffer for read acces for the CPU. </p>
<dl class="section remark"><dt>Remarks</dt><dd>For internal use. mUploadOnly must be true. Attempting to const cast the returned pointer and write to it is undefined behavior. Call unmap( 0, 0 ) to unmap. Once mapped and unmapped, the same region shouldn't be remapped. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The returned value from _asyncDownload. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the data to map. Should be parameter 'srcLength' passed to _asyncDownload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer with the data read from the GPU. Read only. </dd></dl>

</div>
</div>
<a id="a1facd7ade881eff937cd4ccfa998b83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1facd7ade881eff937cd4ccfa998b83c">&#9670;&nbsp;</a></span>addReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::addReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a reference count to the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#a9d425e7d85804eaa45c01f6476ec204a" title="Decreases the reference count by one.">removeReferenceCount</a> </dd></dl>

</div>
</div>
<a id="ad844466b16d039d78fe762a3e32f92c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad844466b16d039d78fe762a3e32f92c2">&#9670;&nbsp;</a></span>canDownload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::StagingBuffer::canDownload </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this staging buffer has enough free space to use _asyncDownload. </p>
<p>Otherwise such function would raise an exception. </p><dl class="section remark"><dt>Remarks</dt><dd>mUploadOnly must be true. It is the counter side of </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#ababb860ddfb4ecdf054766f145848465" title="Returns true if our next call to map() with the same parameters will stall.">uploadWillStall</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The size in bytes that need to be downloaded. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_metal_staging_buffer.html#a78ad96178baf9c41b67d8451a7a23743">Ogre::MetalStagingBuffer</a>.</p>

</div>
</div>
<a id="a55fde7ac828db275c0554d39f52adb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fde7ac828db275c0554d39f52adb7c">&#9670;&nbsp;</a></span>getLastUsedTimestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a00f119d555e251922c695ec569ccfd95">uint64</a> Ogre::StagingBuffer::getLastUsedTimestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time in millisecond when the ref. count became 0. </p>

</div>
</div>
<a id="afdf4e13a8a6544f8bb063a3cc8471000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf4e13a8a6544f8bb063a3cc8471000">&#9670;&nbsp;</a></span>getLifetimeThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::StagingBuffer::getLifetimeThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time in milliseconds in which a <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> should live with a reference count of 0 before being deleted. </p>

</div>
</div>
<a id="a72e2d619a61b234feefbb4401fae83f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e2d619a61b234feefbb4401fae83f5">&#9670;&nbsp;</a></span>getMappingState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a447e51d7625af79716667cebcfa6da57">MappingState</a> Ogre::StagingBuffer::getMappingState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6558ff3b1a53431ffa195b647be7a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6558ff3b1a53431ffa195b647be7a2a8">&#9670;&nbsp;</a></span>getMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::StagingBuffer::getMaxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3341e6c04dbb18e3e1e55868e15d3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3341e6c04dbb18e3e1e55868e15d3e6">&#9670;&nbsp;</a></span>getReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a626dceff763286830a1ef619f5468ab0">int16</a> Ogre::StagingBuffer::getReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e34a37e28c0e54502ada87450743ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e34a37e28c0e54502ada87450743ad0">&#9670;&nbsp;</a></span>getUnfencedTimeThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::StagingBuffer::getUnfencedTimeThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time in milliseconds in which a <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> should hazards unfenced while with a reference count of 0. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#afdf4e13a8a6544f8bb063a3cc8471000" title="Returns the time in milliseconds in which a StagingBuffer should live with a reference count of 0 bef...">getLifetimeThreshold</a> </dd></dl>

</div>
</div>
<a id="ae05b671b655e0119ce740a06d20b4170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05b671b655e0119ce740a06d20b4170">&#9670;&nbsp;</a></span>getUploadOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::StagingBuffer::getUploadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When true, this buffer can only be used for uploading to GPU. </p>
<p>When false, can only be used for downloading from GPU </p>

</div>
</div>
<a id="ab58661498c6fd0e054a0c261ebb3bbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58661498c6fd0e054a0c261ebb3bbcf">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Ogre::StagingBuffer::map </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the given amount of bytes. </p>
<p>May block if not ready. See <a class="el" href="class_ogre_1_1_staging_buffer.html#ababb860ddfb4ecdf054766f145848465" title="Returns true if our next call to map() with the same parameters will stall.">uploadWillStall()</a> if you wish to know. </p><dl class="section remark"><dt>Remarks</dt><dd>Will throw if sizeBytes &gt; this-&gt;<a class="el" href="class_ogre_1_1_staging_buffer.html#a6558ff3b1a53431ffa195b647be7a2a8">getMaxSize()</a> </dd></dl>

</div>
</div>
<a id="a9d425e7d85804eaa45c01f6476ec204a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d425e7d85804eaa45c01f6476ec204a">&#9670;&nbsp;</a></span>removeReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::removeReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decreases the reference count by one. </p>
<p>StagingBuffers are manually reference counted. The first reason is performance. The second main reason is that the pointer doesn't get immediately deleted when the reference hits 0. </p><dl class="section user"><dt></dt><dd>Instead, a reference count of 0 means the Vao manager will monitor its lifetime. If it has been 0 for too long (past certain time threshold) the Vao manager will destroy this staging buffer. </dd></dl>
<dl class="section user"><dt></dt><dd>Meanwhile, the Staging Buffer will live in a pool until it's requested again or the time threshold is met. This prevents unwanted hiccups due to buffers getting recreated and destroyed all the time. Keep a non-zero ref. count to ensure the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> won't be deleted due to timeouts (i.e. you know this buffer will get used at long regular intervals, like once every 15 minutes) </dd></dl>
<dl class="section user"><dt></dt><dd>Having a non-zero reference count doesn't mean the pointer will live forever though, as the memory is owned by the <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a>: if the <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> is shutdown, this <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> will be freed. </dd></dl>

</div>
</div>
<a id="a438d82f09b5f657be30c30d7d1c0801d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438d82f09b5f657be30c30d7d1c0801d">&#9670;&nbsp;</a></span>unmap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::unmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps the mapped region and copies the data to the given region. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> </dd></dl>

<p class="reference">References <a class="el" href="class_ogre_1_1_staging_buffer.html#a438d82f09b5f657be30c30d7d1c0801d">unmap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1_staging_buffer.html#a438d82f09b5f657be30c30d7d1c0801d">unmap()</a>.</p>

</div>
</div>
<a id="a9c8e2853c21a7418218605a0b9cdf461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8e2853c21a7418218605a0b9cdf461">&#9670;&nbsp;</a></span>unmap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::unmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> *&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numDestinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe091313c974edab09f0f9daabf8034d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe091313c974edab09f0f9daabf8034d">&#9670;&nbsp;</a></span>unmap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::unmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_staging_buffer.html#ae90c8303a85284ef6801919bfc4fdfd0">DestinationVec</a> &amp;&#160;</td>
          <td class="paramname"><em>destinations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps the mapped region and copies the data to multiple buffers. </p>
<p>Useful when loading many meshes or textures at once (i.e. from multiple threads) </p>

</div>
</div>
<a id="ababb860ddfb4ecdf054766f145848465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababb860ddfb4ecdf054766f145848465">&#9670;&nbsp;</a></span>uploadWillStall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af48b48d39914b067541a62b674b80935">StagingStallType</a> Ogre::StagingBuffer::uploadWillStall </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if our next call to <a class="el" href="class_ogre_1_1_staging_buffer.html#ab58661498c6fd0e054a0c261ebb3bbcf" title="Maps the given amount of bytes.">map()</a> with the same parameters will stall. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_ogre.html#af48b48d39914b067541a62b674b80935">StagingStallType</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Not all RenderSystems can accurately give this information and will always return STALL_PARTIAL (i.e. GLES2) The chances of getting a STALL_FULL get higher as sizeBytes gets closer to this-&gt;<a class="el" href="class_ogre_1_1_staging_buffer.html#a6558ff3b1a53431ffa195b647be7a2a8">getMaxSize()</a> mUploadOnly must be false. It is the counter side of </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#ad844466b16d039d78fe762a3e32f92c2" title="Checks if this staging buffer has enough free space to use _asyncDownload.">canDownload</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_staging_buffer.html#a92f666a971dae2b92120902890e52ef7">Ogre::VulkanStagingBuffer</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_staging_buffer.html#a1178bfe99355e09494e2e14bfc5ce1ab">Ogre::NULLStagingBuffer</a>, <a class="el" href="class_ogre_1_1_metal_staging_buffer.html#a7ffe5c09f2fdb06aa864f7af28d101ce">Ogre::MetalStagingBuffer</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_staging_buffer.html#a9e6939c0949b5c2152df3ea06f837e75">Ogre::GL3PlusStagingBuffer</a>, <a class="el" href="class_ogre_1_1_d3_d11_staging_buffer.html#a994aff1bc112598af02d3a75c53a4752">Ogre::D3D11StagingBuffer</a>, and <a class="el" href="class_ogre_1_1_g_l_e_s2_staging_buffer.html#a391b9d2ba733ea2400118bf330b9a561">Ogre::GLES2StagingBuffer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_staging_buffer_8h.html">OgreStagingBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
