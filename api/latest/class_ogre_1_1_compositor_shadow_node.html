<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::CompositorShadowNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_compositor_shadow_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_compositor_shadow_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::CompositorShadowNode Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___effects.html">Effects</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Shadow Nodes are special nodes (not to be confused with <a class="el" href="class_ogre_1_1_compositor_node.html" title="Compositor nodes are the core subject of compositing.">CompositorNode</a>) that are only used for rendering shadow maps.  
 <a href="class_ogre_1_1_compositor_shadow_node.html#details">More...</a></p>

<p><code>#include &lt;OgreCompositorShadowNode.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::CompositorShadowNode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_compositor_shadow_node__inherit__graph.svg" width="326" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac572709b6988d13b7e02634914bf531d" id="r_ac572709b6988d13b7e02634914bf531d"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; bool &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac572709b6988d13b7e02634914bf531d">LightsBitSet</a></td></tr>
<tr class="separator:ac572709b6988d13b7e02634914bf531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02c829c85182fea80636616af9296776" id="r_a02c829c85182fea80636616af9296776"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a02c829c85182fea80636616af9296776">CompositorShadowNode</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id, const <a class="el" href="class_ogre_1_1_compositor_shadow_node_def.html">CompositorShadowNodeDef</a> *definition, <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *workspace, <a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *renderSys, <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *finalTarget)</td></tr>
<tr class="separator:a02c829c85182fea80636616af9296776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3626c0e4950666004b41b6ec88dc98b8" id="r_a3626c0e4950666004b41b6ec88dc98b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a3626c0e4950666004b41b6ec88dc98b8">~CompositorShadowNode</a> () override</td></tr>
<tr class="separator:a3626c0e4950666004b41b6ec88dc98b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227313a84e19bafb0d69f287273a9562" id="r_a227313a84e19bafb0d69f287273a9562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a227313a84e19bafb0d69f287273a9562">_shouldUpdateShadowMapIdx</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadowMapIdx) const</td></tr>
<tr class="separator:a227313a84e19bafb0d69f287273a9562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f1fd121847d6d0f349ae207dac52af" id="r_a69f1fd121847d6d0f349ae207dac52af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a69f1fd121847d6d0f349ae207dac52af">_update</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *camera, const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager)</td></tr>
<tr class="memdesc:a69f1fd121847d6d0f349ae207dac52af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders into the shadow map, executes passes.  <br /></td></tr>
<tr class="separator:a69f1fd121847d6d0f349ae207dac52af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e91b900d7e9d85bafd312929f4724d4" id="r_a5e91b900d7e9d85bafd312929f4724d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a5e91b900d7e9d85bafd312929f4724d4">finalTargetResized01</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *finalTarget) override</td></tr>
<tr class="memdesc:a5e91b900d7e9d85bafd312929f4724d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> when (i.e.) the RenderWindow was resized, thus our RTs that depend on their resolution need to be recreated.    <br /></td></tr>
<tr class="separator:a5e91b900d7e9d85bafd312929f4724d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7e9c885be9aa654b04ac8e98f06630" id="r_a2b7e9c885be9aa654b04ac8e98f06630"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac572709b6988d13b7e02634914bf531d">LightsBitSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a2b7e9c885be9aa654b04ac8e98f06630">getAffectedLightsBitSet</a> () const</td></tr>
<tr class="separator:a2b7e9c885be9aa654b04ac8e98f06630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbc516312496f857c9b8b07be6c8ce6" id="r_a2bbc516312496f857c9b8b07be6c8ce6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a2bbc516312496f857c9b8b07be6c8ce6">getCastersBox</a> () const</td></tr>
<tr class="separator:a2bbc516312496f857c9b8b07be6c8ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43a0e8235a792dc1fe9901993716a8" id="r_aec43a0e8235a792dc1fe9901993716a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga732a9a0736fd3a64669170b18d3dc4d1">TextureGpuVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#aec43a0e8235a792dc1fe9901993716a8">getContiguousShadowMapTex</a> () const</td></tr>
<tr class="separator:aec43a0e8235a792dc1fe9901993716a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bf87d732dcc1c49c19aba5eb692de7" id="r_a42bf87d732dcc1c49c19aba5eb692de7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_shadow_node_def.html">CompositorShadowNodeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a42bf87d732dcc1c49c19aba5eb692de7">getDefinition</a> () const</td></tr>
<tr class="separator:a42bf87d732dcc1c49c19aba5eb692de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5768e502ca461ede1ba8398a50792843" id="r_a5768e502ca461ede1ba8398a50792843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a5768e502ca461ede1ba8398a50792843">getIndexToContiguousShadowMapTex</a> (size_t shadowMapIdx) const</td></tr>
<tr class="separator:a5768e502ca461ede1ba8398a50792843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaabe95bd3be529482db7b580e4cc53" id="r_a3aaabe95bd3be529482db7b580e4cc53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a3aaabe95bd3be529482db7b580e4cc53">getLightAssociatedWith</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:a3aaabe95bd3be529482db7b580e4cc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: May return null if there is no such shadowMapIdx, or if there is no light that could be linked with that shadow map index.  <br /></td></tr>
<tr class="separator:a3aaabe95bd3be529482db7b580e4cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7297ac09456ceff0056a7a0d03f88c" id="r_afc7297ac09456ceff0056a7a0d03f88c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#afc7297ac09456ceff0056a7a0d03f88c">getMinMaxDepthRange</a> (const <a class="el" href="class_ogre_1_1_frustum.html">Frustum</a> *shadowMapCamera, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMin, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMax) const</td></tr>
<tr class="memdesc:afc7297ac09456ceff0056a7a0d03f88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the min &amp; max depth range for the given camera.  <br /></td></tr>
<tr class="separator:afc7297ac09456ceff0056a7a0d03f88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912abb5a026185c4380b04856137fafd" id="r_a912abb5a026185c4380b04856137fafd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a912abb5a026185c4380b04856137fafd">getMinMaxDepthRange</a> (size_t shadowMapIdx, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMin, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMax) const</td></tr>
<tr class="separator:a912abb5a026185c4380b04856137fafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f461354ff93106456abd203a72a80f" id="r_ae1f461354ff93106456abd203a72a80f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ae1f461354ff93106456abd203a72a80f">getNormalOffsetBias</a> (const size_t shadowMapIdx) const</td></tr>
<tr class="separator:ae1f461354ff93106456abd203a72a80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422f16656a84122e0d253eff22fb8d07" id="r_a422f16656a84122e0d253eff22fb8d07"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a422f16656a84122e0d253eff22fb8d07">getNumActiveShadowCastingLights</a> () const</td></tr>
<tr class="memdesc:a422f16656a84122e0d253eff22fb8d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return value may change in the future, which happens when the number of lights changes to or from a value lower than the supported shadow casting lights by the definition.  <br /></td></tr>
<tr class="separator:a422f16656a84122e0d253eff22fb8d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14189ecdcfc0f73c86aa992871fc54b" id="r_aa14189ecdcfc0f73c86aa992871fc54b"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#aa14189ecdcfc0f73c86aa992871fc54b">getPssmBlends</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:aa14189ecdcfc0f73c86aa992871fc54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of points with the blend band boundaries of the closest N-1 PSSM split in projection space for the given shadow map index.  <br /></td></tr>
<tr class="separator:aa14189ecdcfc0f73c86aa992871fc54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2737b10d12e2af7f239411433297c122" id="r_a2737b10d12e2af7f239411433297c122"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a2737b10d12e2af7f239411433297c122">getPssmFade</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:a2737b10d12e2af7f239411433297c122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fade point of the last PSSM split in projection space for the given shadow map index.  <br /></td></tr>
<tr class="separator:a2737b10d12e2af7f239411433297c122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f4bab56035a7472133b892c32ff4d4" id="r_a85f4bab56035a7472133b892c32ff4d4"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a85f4bab56035a7472133b892c32ff4d4">getPssmSplits</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:a85f4bab56035a7472133b892c32ff4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of points with the limits of each PSSM split in projection space for the given shadow map index.  <br /></td></tr>
<tr class="separator:a85f4bab56035a7472133b892c32ff4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaafc8f4fd96ecacd724b3a68347deef" id="r_adaafc8f4fd96ecacd724b3a68347deef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___general.html#ga8795828980c8be4892c41f4f4b7a7337">LightClosestArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#adaafc8f4fd96ecacd724b3a68347deef">getShadowCastingLights</a> () const</td></tr>
<tr class="separator:adaafc8f4fd96ecacd724b3a68347deef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa015e01b5e725c3b8016e10cb5408" id="r_ae2fa015e01b5e725c3b8016e10cb5408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ae2fa015e01b5e725c3b8016e10cb5408">getShadowMapLightTypeMask</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadowMapIdx) const</td></tr>
<tr class="memdesc:ae2fa015e01b5e725c3b8016e10cb5408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not call this if isShadowMapIdxActive == false or isShadowMapIdxInValidRange == false.  <br /></td></tr>
<tr class="separator:ae2fa015e01b5e725c3b8016e10cb5408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add989e48cfe58cfa5639719fd72f6cfa" id="r_add989e48cfe58cfa5639719fd72f6cfa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#add989e48cfe58cfa5639719fd72f6cfa">getViewMatrix</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:add989e48cfe58cfa5639719fd72f6cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture view matrix for the given shadow map index.  <br /></td></tr>
<tr class="separator:add989e48cfe58cfa5639719fd72f6cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ce2ecc67f6585db0da69dfc4146037" id="r_a86ce2ecc67f6585db0da69dfc4146037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a86ce2ecc67f6585db0da69dfc4146037">getViewProjectionMatrix</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:a86ce2ecc67f6585db0da69dfc4146037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture view projection matrix for the given shadow map index.  <br /></td></tr>
<tr class="separator:a86ce2ecc67f6585db0da69dfc4146037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b152c56604315e6958790d6703e601" id="r_ac1b152c56604315e6958790d6703e601"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac1b152c56604315e6958790d6703e601">isShadowMapIdxActive</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:ac1b152c56604315e6958790d6703e601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the shadow map index is not active.  <br /></td></tr>
<tr class="separator:ac1b152c56604315e6958790d6703e601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0104d92ad5a14a2e36a92f46e9bfe88" id="r_aa0104d92ad5a14a2e36a92f46e9bfe88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#aa0104d92ad5a14a2e36a92f46e9bfe88">isShadowMapIdxInValidRange</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadowMapIdx) const</td></tr>
<tr class="separator:aa0104d92ad5a14a2e36a92f46e9bfe88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14607795f3aa90c91cdd6274d867899" id="r_ae14607795f3aa90c91cdd6274d867899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ae14607795f3aa90c91cdd6274d867899">postInitializePass</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass) override</td></tr>
<tr class="memdesc:ae14607795f3aa90c91cdd6274d867899"><td class="mdescLeft">&#160;</td><td class="mdescRight">We derive so we can override the camera with ours.  <br /></td></tr>
<tr class="separator:ae14607795f3aa90c91cdd6274d867899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4e9f7b9d8e5b8c61bce6d164185e5d" id="r_acf4e9f7b9d8e5b8c61bce6d164185e5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#acf4e9f7b9d8e5b8c61bce6d164185e5d">setLightFixedToShadowMap</a> (size_t shadowMapIdx, <a class="el" href="class_ogre_1_1_light.html">Light</a> *light)</td></tr>
<tr class="memdesc:acf4e9f7b9d8e5b8c61bce6d164185e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a shadow map as statically updated, and ties the given light to always use that shadow map.  <br /></td></tr>
<tr class="separator:acf4e9f7b9d8e5b8c61bce6d164185e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607c30415819742ad2bcfaa1d3959d5a" id="r_a607c30415819742ad2bcfaa1d3959d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a607c30415819742ad2bcfaa1d3959d5a">setStaticShadowMapDirty</a> (size_t shadowMapIdx, bool includeLinked=true)</td></tr>
<tr class="memdesc:a607c30415819742ad2bcfaa1d3959d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags a static shadow map as dirty, causing <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to update it on the next time this Shadow node gets executed.  <br /></td></tr>
<tr class="separator:a607c30415819742ad2bcfaa1d3959d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_ogre_1_1_compositor_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_ogre_1_1_compositor_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_ogre_1_1_compositor_node.html">Ogre::CompositorNode</a></td></tr>
<tr class="memitem:a8184bf04d1229243b121a3c1f1f080b7 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a8184bf04d1229243b121a3c1f1f080b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a8184bf04d1229243b121a3c1f1f080b7">CompositorNode</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> *definition, <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *workspace, <a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *renderSys, <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *finalTarget)</td></tr>
<tr class="memdesc:a8184bf04d1229243b121a3c1f1f080b7 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_ogre_1_1_id.html" title="Usage: OGRE_NEW SceneNode( Id::generateNewId&lt; Node &gt;() )">Id</a> must be unique across all engine so we can create unique named textures.  <br /></td></tr>
<tr class="separator:a8184bf04d1229243b121a3c1f1f080b7 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958b95a5fd93b1fbbf93e68795590274 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a958b95a5fd93b1fbbf93e68795590274"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a958b95a5fd93b1fbbf93e68795590274">~CompositorNode</a> ()</td></tr>
<tr class="separator:a958b95a5fd93b1fbbf93e68795590274 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5de14c9d267e93cd9c0adadba4052b inherit pub_methods_class_ogre_1_1_compositor_node" id="r_abc5de14c9d267e93cd9c0adadba4052b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa09712589d0e729a928ed664b98e30a7">CompositorPassVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#abc5de14c9d267e93cd9c0adadba4052b">_getPasses</a> () const</td></tr>
<tr class="separator:abc5de14c9d267e93cd9c0adadba4052b inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6ad71b3359a4bc626aacfb034557dc inherit pub_methods_class_ogre_1_1_compositor_node" id="r_aff6ad71b3359a4bc626aacfb034557dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aff6ad71b3359a4bc626aacfb034557dc">_notifyCleared</a> ()</td></tr>
<tr class="memdesc:aff6ad71b3359a4bc626aacfb034557dc inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Use.  <br /></td></tr>
<tr class="separator:aff6ad71b3359a4bc626aacfb034557dc inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4e112618b5ed2936391b2bfc45d224 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_aad4e112618b5ed2936391b2bfc45d224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aad4e112618b5ed2936391b2bfc45d224">_update</a> (const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager)</td></tr>
<tr class="memdesc:aad4e112618b5ed2936391b2bfc45d224 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this function every frame will cause us to execute all our passes (ie.  <br /></td></tr>
<tr class="separator:aad4e112618b5ed2936391b2bfc45d224 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183e74226d1c4fe91e2a2886459aba8a inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a183e74226d1c4fe91e2a2886459aba8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a183e74226d1c4fe91e2a2886459aba8a">areAllInputsConnected</a> () const</td></tr>
<tr class="separator:a183e74226d1c4fe91e2a2886459aba8a inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd2960e9ca1de509c9c3ff36d847997 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a5dd2960e9ca1de509c9c3ff36d847997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a5dd2960e9ca1de509c9c3ff36d847997">connectBufferTo</a> (size_t outChannelA, <a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *nodeB, size_t inChannelB)</td></tr>
<tr class="memdesc:a5dd2960e9ca1de509c9c3ff36d847997 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (buffer version)  <br /></td></tr>
<tr class="separator:a5dd2960e9ca1de509c9c3ff36d847997 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed3172d72e30cbd79ef663c8c1adfd7 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_aeed3172d72e30cbd79ef663c8c1adfd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aeed3172d72e30cbd79ef663c8c1adfd7">connectExternalBuffer</a> (<a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *buffer, size_t inChannelA)</td></tr>
<tr class="memdesc:aeed3172d72e30cbd79ef663c8c1adfd7 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects (injects) an external buffer into the given channel.  <br /></td></tr>
<tr class="separator:aeed3172d72e30cbd79ef663c8c1adfd7 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e812a39d91f5d59b335b81cc45d81a0 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a6e812a39d91f5d59b335b81cc45d81a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a6e812a39d91f5d59b335b81cc45d81a0">connectExternalRT</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *externalTexture, size_t inChannelA)</td></tr>
<tr class="memdesc:a6e812a39d91f5d59b335b81cc45d81a0 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects (injects) an external RT into the given channel.  <br /></td></tr>
<tr class="separator:a6e812a39d91f5d59b335b81cc45d81a0 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfd8041dbce265afd92ac9c11769fbb inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a0bfd8041dbce265afd92ac9c11769fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a0bfd8041dbce265afd92ac9c11769fbb">connectTo</a> (size_t outChannelA, <a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *nodeB, size_t inChannelB)</td></tr>
<tr class="memdesc:a0bfd8041dbce265afd92ac9c11769fbb inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (texture version)  <br /></td></tr>
<tr class="separator:a0bfd8041dbce265afd92ac9c11769fbb inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fce9ec85e8404ae2f0855e05f32afce inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a5fce9ec85e8404ae2f0855e05f32afce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a5fce9ec85e8404ae2f0855e05f32afce">createPasses</a> ()</td></tr>
<tr class="memdesc:a5fce9ec85e8404ae2f0855e05f32afce inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all passes based on our definition.  <br /></td></tr>
<tr class="separator:a5fce9ec85e8404ae2f0855e05f32afce inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dac90cc026287b9b0aee9264e9059f inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a53dac90cc026287b9b0aee9264e9059f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a53dac90cc026287b9b0aee9264e9059f">destroyAllPasses</a> ()</td></tr>
<tr class="separator:a53dac90cc026287b9b0aee9264e9059f inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44e15ffbff3bd7006aa45a6676d47f inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a9b44e15ffbff3bd7006aa45a6676d47f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a9b44e15ffbff3bd7006aa45a6676d47f">finalTargetResized02</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *finalTarget)</td></tr>
<tr class="separator:a9b44e15ffbff3bd7006aa45a6676d47f inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf10368c90e6df3f77b60d8c14cd7310 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_abf10368c90e6df3f77b60d8c14cd7310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#abf10368c90e6df3f77b60d8c14cd7310">getDefinedBuffer</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> bufferName) const</td></tr>
<tr class="memdesc:abf10368c90e6df3f77b60d8c14cd7310 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer pointer of a buffer based on it's name.  <br /></td></tr>
<tr class="separator:abf10368c90e6df3f77b60d8c14cd7310 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee31fc5aa0dd3ceaca3b2a5dcf817922 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_aee31fc5aa0dd3ceaca3b2a5dcf817922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aee31fc5aa0dd3ceaca3b2a5dcf817922">getDefinedBufferNoThrow</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> bufferName) const</td></tr>
<tr class="separator:aee31fc5aa0dd3ceaca3b2a5dcf817922 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af990864da9638f9a535514ef9eaa631a inherit pub_methods_class_ogre_1_1_compositor_node" id="r_af990864da9638f9a535514ef9eaa631a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#af990864da9638f9a535514ef9eaa631a">getDefinedTexture</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> textureName) const</td></tr>
<tr class="memdesc:af990864da9638f9a535514ef9eaa631a inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture pointer of a texture based on it's name &amp; mrt index.  <br /></td></tr>
<tr class="separator:af990864da9638f9a535514ef9eaa631a inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860defea61122d7d8d4dc278c1a876c8 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a860defea61122d7d8d4dc278c1a876c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a860defea61122d7d8d4dc278c1a876c8">getDefinition</a> () const</td></tr>
<tr class="separator:a860defea61122d7d8d4dc278c1a876c8 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7282de98f052c046880aefb7a838e760 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a7282de98f052c046880aefb7a838e760"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a7282de98f052c046880aefb7a838e760">getEnabled</a> () const</td></tr>
<tr class="memdesc:a7282de98f052c046880aefb7a838e760 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this instance is enabled.  <br /></td></tr>
<tr class="separator:a7282de98f052c046880aefb7a838e760 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77dd0b2b1cd5e8f3951a111596dbf14 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_ab77dd0b2b1cd5e8f3951a111596dbf14"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ab77dd0b2b1cd5e8f3951a111596dbf14">getInputChannel</a> () const</td></tr>
<tr class="separator:ab77dd0b2b1cd5e8f3951a111596dbf14 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff30ffaedc5a0fb7beabf21641a5109 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_aeff30ffaedc5a0fb7beabf21641a5109"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aeff30ffaedc5a0fb7beabf21641a5109">getLocalTextures</a> () const</td></tr>
<tr class="separator:aeff30ffaedc5a0fb7beabf21641a5109 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c98f58d980e3c3c628fd13de14e580 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a98c98f58d980e3c3c628fd13de14e580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a98c98f58d980e3c3c628fd13de14e580">getName</a> () const</td></tr>
<tr class="separator:a98c98f58d980e3c3c628fd13de14e580 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329444d41283a85be5e6191c525aedef inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a329444d41283a85be5e6191c525aedef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a329444d41283a85be5e6191c525aedef">getPassNumber</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass) const</td></tr>
<tr class="memdesc:a329444d41283a85be5e6191c525aedef inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_compositor_node_def.html#a6fa98a167d723f5296d48926980aa4f6" title="Returns the pass # of the given pass definition in this node.">CompositorNodeDef::getPassNumber</a>.  <br /></td></tr>
<tr class="separator:a329444d41283a85be5e6191c525aedef inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9116602d558b892c1cfb3a0e177274fb inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a9116602d558b892c1cfb3a0e177274fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a9116602d558b892c1cfb3a0e177274fb">getRenderSystem</a> () const</td></tr>
<tr class="separator:a9116602d558b892c1cfb3a0e177274fb inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7759ee5abdd3a3b2009a531a6916bb inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a4e7759ee5abdd3a3b2009a531a6916bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a4e7759ee5abdd3a3b2009a531a6916bb">getWorkspace</a> ()</td></tr>
<tr class="memdesc:a4e7759ee5abdd3a3b2009a531a6916bb inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our parent workspace.  <br /></td></tr>
<tr class="separator:a4e7759ee5abdd3a3b2009a531a6916bb inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc50bf597fa82a60d6dd1be25ea8500f inherit pub_methods_class_ogre_1_1_compositor_node" id="r_acc50bf597fa82a60d6dd1be25ea8500f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#acc50bf597fa82a60d6dd1be25ea8500f">getWorkspace</a> () const</td></tr>
<tr class="memdesc:acc50bf597fa82a60d6dd1be25ea8500f inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our parent workspace.  <br /></td></tr>
<tr class="separator:acc50bf597fa82a60d6dd1be25ea8500f inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9edc7379e9c8759de9abb0baaf2135 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a6e9edc7379e9c8759de9abb0baaf2135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a6e9edc7379e9c8759de9abb0baaf2135">notifyDestroyed</a> (const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *buffer)</td></tr>
<tr class="separator:a6e9edc7379e9c8759de9abb0baaf2135 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72f2d56524f23dc474d2634b06aeeeb inherit pub_methods_class_ogre_1_1_compositor_node" id="r_ae72f2d56524f23dc474d2634b06aeeeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ae72f2d56524f23dc474d2634b06aeeeb">notifyDestroyed</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *channel)</td></tr>
<tr class="memdesc:ae72f2d56524f23dc474d2634b06aeeeb inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when caller has destroyed a RenderTarget in which the callee may have a reference to that pointer, so that we can clean it up.  <br /></td></tr>
<tr class="separator:ae72f2d56524f23dc474d2634b06aeeeb inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e7c49813462a88761ff73f514d7ce8 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a01e7c49813462a88761ff73f514d7ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a01e7c49813462a88761ff73f514d7ce8">notifyRecreated</a> (const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *oldBuffer, <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *newBuffer)</td></tr>
<tr class="separator:a01e7c49813462a88761ff73f514d7ce8 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e701215d769e1890329c6e3e4a4ac9 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a17e701215d769e1890329c6e3e4a4ac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a17e701215d769e1890329c6e3e4a4ac9">notifyRecreated</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *channel)</td></tr>
<tr class="memdesc:a17e701215d769e1890329c6e3e4a4ac9 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you're replacing the textures from oldChannel with the ones in newChannel.  <br /></td></tr>
<tr class="separator:a17e701215d769e1890329c6e3e4a4ac9 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b216e017d9aa22718a5419a1e98a2a inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a07b216e017d9aa22718a5419a1e98a2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a07b216e017d9aa22718a5419a1e98a2a">resetAllNumPassesLeft</a> ()</td></tr>
<tr class="memdesc:a07b216e017d9aa22718a5419a1e98a2a inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of passes left for every pass (see <a class="el" href="class_ogre_1_1_compositor_pass_def.html#a70ba2384e061021d6eceb5dd20b66d47" title="Number of times to perform the pass before stopping. -1 to never stop.">CompositorPassDef::mNumInitialPasses</a>) Useful when you have a few starting 'initialization' passes and you want to reset them.    <br /></td></tr>
<tr class="separator:a07b216e017d9aa22718a5419a1e98a2a inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817bc10dbf5427a77912ab3bcd391f69 inherit pub_methods_class_ogre_1_1_compositor_node" id="r_a817bc10dbf5427a77912ab3bcd391f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a817bc10dbf5427a77912ab3bcd391f69">setEnabled</a> (bool bEnabled)</td></tr>
<tr class="memdesc:a817bc10dbf5427a77912ab3bcd391f69 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables all instances of this node.  <br /></td></tr>
<tr class="separator:a817bc10dbf5427a77912ab3bcd391f69 inherit pub_methods_class_ogre_1_1_compositor_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_ogre_1_1_id_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_ogre_1_1_id_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_ogre_1_1_id_object.html">Ogre::IdObject</a></td></tr>
<tr class="memitem:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object" id="r_a7884ec3abf1ed8c1b1514d3bda918370"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a7884ec3abf1ed8c1b1514d3bda918370">IdObject</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id)</td></tr>
<tr class="memdesc:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">We don't call generateNewId() here, to prevent objects in the stack (i.e.  <br /></td></tr>
<tr class="separator:a7884ec3abf1ed8c1b1514d3bda918370 inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object" id="r_ab152c8f646a835c2f88585ad4fe0413a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#ab152c8f646a835c2f88585ad4fe0413a">getId</a> () const</td></tr>
<tr class="memdesc:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique id of this object.  <br /></td></tr>
<tr class="separator:ab152c8f646a835c2f88585ad4fe0413a inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0523432c6e5133ff4fc251111a60e inherit pub_methods_class_ogre_1_1_id_object" id="r_a57e0523432c6e5133ff4fc251111a60e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a57e0523432c6e5133ff4fc251111a60e">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;right)</td></tr>
<tr class="separator:a57e0523432c6e5133ff4fc251111a60e inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae22596b5bd2a3faf2958ab3d109d1f inherit pub_methods_class_ogre_1_1_id_object" id="r_a0ae22596b5bd2a3faf2958ab3d109d1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a0ae22596b5bd2a3faf2958ab3d109d1f">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *right)</td></tr>
<tr class="separator:a0ae22596b5bd2a3faf2958ab3d109d1f inherit pub_methods_class_ogre_1_1_id_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shadow Nodes are special nodes (not to be confused with <a class="el" href="class_ogre_1_1_compositor_node.html" title="Compositor nodes are the core subject of compositing.">CompositorNode</a>) that are only used for rendering shadow maps. </p>
<p>Normal Compositor Nodes can share or own a ShadowNode. The ShadowNode will render the scene enough times to fill all shadow maps so the main scene pass can use them. </p><dl class="section user"><dt></dt><dd>ShadowNode are very flexible compared to <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x; as they allow mixing multiple shadow camera setups for different lights. </dd></dl>
<dl class="section user"><dt></dt><dd>Shadow Nodes derive from nodes so that they can be used as regular nodes </dd></dl>
<dl class="section user"><dt></dt><dd>During a render with shadow mapping enabled, we render first the Shadow <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>'s pass, then render the regular scene. In the past there used to be an AABB enclosing all visible objects that receive shadows that was used for calculating the shadow maps. This forced <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.x to split rendering into two stages: _cullPhase01 &amp; _renderPhase02. This is not needed anymore.</dd></dl>
<p>To summarize: a normal rendering flow with shadow map looks like this: shadowNode-&gt;setupShadowCamera( normal-&gt;getVisibleBoundsInfo() ); shadowNode-&gt;_cullPhase01(); shadowNode-&gt;_renderPhase02(); normal-&gt;_cullPhase01(); normal-&gt;_renderPhase02(); </p><dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>On forward lighting passes, shadow mapping is handled in the following way: 1) Build a list of all lights visible by all cameras (<a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> does this) 2) Traverse the list to get the closest lights to the current camera. These lights will cast shadows. 3) Build a list of the closest lights for each object (<a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> does this) 4) Traverse this list and find those that are actually casting a shadow 5) Send to the GPU &amp; engine the list in step 4, but shadow casting lights are put first, then sorted by proximity. See the comments inside the function setShadowMapsToPass for more information. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matias N. Goldberg </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac572709b6988d13b7e02634914bf531d" name="ac572709b6988d13b7e02634914bf531d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac572709b6988d13b7e02634914bf531d">&#9670;&#160;</a></span>LightsBitSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;bool&gt;::type <a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac572709b6988d13b7e02634914bf531d">Ogre::CompositorShadowNode::LightsBitSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a02c829c85182fea80636616af9296776" name="a02c829c85182fea80636616af9296776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c829c85182fea80636616af9296776">&#9670;&#160;</a></span>CompositorShadowNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::CompositorShadowNode::CompositorShadowNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_shadow_node_def.html">CompositorShadowNodeDef</a> *&#160;</td>
          <td class="paramname"><em>definition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>renderSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3626c0e4950666004b41b6ec88dc98b8" name="a3626c0e4950666004b41b6ec88dc98b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3626c0e4950666004b41b6ec88dc98b8">&#9670;&#160;</a></span>~CompositorShadowNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::CompositorShadowNode::~CompositorShadowNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a227313a84e19bafb0d69f287273a9562" name="a227313a84e19bafb0d69f287273a9562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227313a84e19bafb0d69f287273a9562">&#9670;&#160;</a></span>_shouldUpdateShadowMapIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorShadowNode::_shouldUpdateShadowMapIdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69f1fd121847d6d0f349ae207dac52af" name="a69f1fd121847d6d0f349ae207dac52af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f1fd121847d6d0f349ae207dac52af">&#9670;&#160;</a></span>_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders into the shadow map, executes passes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera</td><td><a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> used to calculate our shadow camera (in case of directional lights). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e91b900d7e9d85bafd312929f4724d4" name="a5e91b900d7e9d85bafd312929f4724d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e91b900d7e9d85bafd312929f4724d4">&#9670;&#160;</a></span>finalTargetResized01()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::finalTargetResized01 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> when (i.e.) the RenderWindow was resized, thus our RTs that depend on their resolution need to be recreated.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>We inform all connected nodes and passes related to us of RenderTargets/Textures that may have been recreated (pointers could become danlging otherwise). </dd></dl>
<dl class="section user"><dt></dt><dd>This is divided in two steps: recreateResizableTextures01 &amp; recreateResizableTextures02 since in some cases in <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a>, setting up MRT and depth textures requires all textures to be up to date, otherwise validation errors would occur since we'll have partial data (e.g. MRT 0 is 1024x768 while MRT 1 is 800x600) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finalTarget</td><td>The Final Target (i.e. RenderWindow) from which we'll base our local textures' resolution.   </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_compositor_node.html#ab5c743a62e8a202dc5816f0bd01fe8b9">Ogre::CompositorNode</a>.</p>

</div>
</div>
<a id="a2b7e9c885be9aa654b04ac8e98f06630" name="a2b7e9c885be9aa654b04ac8e98f06630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7e9c885be9aa654b04ac8e98f06630">&#9670;&#160;</a></span>getAffectedLightsBitSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac572709b6988d13b7e02634914bf531d">LightsBitSet</a> &amp; Ogre::CompositorShadowNode::getAffectedLightsBitSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bbc516312496f857c9b8b07be6c8ce6" name="a2bbc516312496f857c9b8b07be6c8ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbc516312496f857c9b8b07be6c8ce6">&#9670;&#160;</a></span>getCastersBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp; Ogre::CompositorShadowNode::getCastersBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>mCastersBox </dd></dl>

</div>
</div>
<a id="aec43a0e8235a792dc1fe9901993716a8" name="aec43a0e8235a792dc1fe9901993716a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec43a0e8235a792dc1fe9901993716a8">&#9670;&#160;</a></span>getContiguousShadowMapTex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#ga732a9a0736fd3a64669170b18d3dc4d1">TextureGpuVec</a> &amp; Ogre::CompositorShadowNode::getContiguousShadowMapTex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42bf87d732dcc1c49c19aba5eb692de7" name="a42bf87d732dcc1c49c19aba5eb692de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bf87d732dcc1c49c19aba5eb692de7">&#9670;&#160;</a></span>getDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_shadow_node_def.html">CompositorShadowNodeDef</a> * Ogre::CompositorShadowNode::getDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5768e502ca461ede1ba8398a50792843" name="a5768e502ca461ede1ba8398a50792843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5768e502ca461ede1ba8398a50792843">&#9670;&#160;</a></span>getIndexToContiguousShadowMapTex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::CompositorShadowNode::getIndexToContiguousShadowMapTex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aaabe95bd3be529482db7b580e4cc53" name="a3aaabe95bd3be529482db7b580e4cc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aaabe95bd3be529482db7b580e4cc53">&#9670;&#160;</a></span>getLightAssociatedWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_light.html">Light</a> * Ogre::CompositorShadowNode::getLightAssociatedWith </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note: May return null if there is no such shadowMapIdx, or if there is no light that could be linked with that shadow map index. </p>
<p>i.e. if isShadowMapIdxActive( shadowMapIdx ) is true, then we'll return a valid pointer. </p>

</div>
</div>
<a id="afc7297ac09456ceff0056a7a0d03f88c" name="afc7297ac09456ceff0056a7a0d03f88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7297ac09456ceff0056a7a0d03f88c">&#9670;&#160;</a></span>getMinMaxDepthRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::getMinMaxDepthRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_frustum.html">Frustum</a> *&#160;</td>
          <td class="paramname"><em>shadowMapCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the min &amp; max depth range for the given camera. </p>
<p>0 &amp; 100000 if camera not found </p><dl class="section remark"><dt>Remarks</dt><dd>Performs linear search O(N), except the overload that provides a shadowMapIdx </dd></dl>

</div>
</div>
<a id="a912abb5a026185c4380b04856137fafd" name="a912abb5a026185c4380b04856137fafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912abb5a026185c4380b04856137fafd">&#9670;&#160;</a></span>getMinMaxDepthRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::getMinMaxDepthRange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1f461354ff93106456abd203a72a80f" name="ae1f461354ff93106456abd203a72a80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f461354ff93106456abd203a72a80f">&#9670;&#160;</a></span>getNormalOffsetBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Ogre::CompositorShadowNode::getNormalOffsetBias </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a422f16656a84122e0d253eff22fb8d07" name="a422f16656a84122e0d253eff22fb8d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422f16656a84122e0d253eff22fb8d07">&#9670;&#160;</a></span>getNumActiveShadowCastingLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::CompositorShadowNode::getNumActiveShadowCastingLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The return value may change in the future, which happens when the number of lights changes to or from a value lower than the supported shadow casting lights by the definition. </p>

</div>
</div>
<a id="aa14189ecdcfc0f73c86aa992871fc54b" name="aa14189ecdcfc0f73c86aa992871fc54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14189ecdcfc0f73c86aa992871fc54b">&#9670;&#160;</a></span>getPssmBlends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::type * Ogre::CompositorShadowNode::getPssmBlends </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of points with the blend band boundaries of the closest N-1 PSSM split in projection space for the given shadow map index. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a85f4bab56035a7472133b892c32ff4d4" title="Returns a list of points with the limits of each PSSM split in projection space for the given shadow ...">getPssmSplits</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An array with the blend points. The number of elements is N-1 where N is the number of splits for that shadow map. Returns null if shadowMapIdx is out of bounds, or is not a PSSM technique. </dd></dl>

</div>
</div>
<a id="a2737b10d12e2af7f239411433297c122" name="a2737b10d12e2af7f239411433297c122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2737b10d12e2af7f239411433297c122">&#9670;&#160;</a></span>getPssmFade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> * Ogre::CompositorShadowNode::getPssmFade </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fade point of the last PSSM split in projection space for the given shadow map index. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a85f4bab56035a7472133b892c32ff4d4" title="Returns a list of points with the limits of each PSSM split in projection space for the given shadow ...">getPssmSplits</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The fade point. Returns null if shadowMapIdx is out of bounds, or is not a PSSM technique. </dd></dl>

</div>
</div>
<a id="a85f4bab56035a7472133b892c32ff4d4" name="a85f4bab56035a7472133b892c32ff4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f4bab56035a7472133b892c32ff4d4">&#9670;&#160;</a></span>getPssmSplits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::type * Ogre::CompositorShadowNode::getPssmSplits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of points with the limits of each PSSM split in projection space for the given shadow map index. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If shadow map 0, 1 &amp; 2 use light 0 with different splits, the return value should be the same for all of them. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An array with the split points. The number of elements is N+1 where N is the number of splits for that shadow map. Returns null if shadowMapIdx is out of bounds, or is not a PSSM technique. </dd></dl>

</div>
</div>
<a id="adaafc8f4fd96ecacd724b3a68347deef" name="adaafc8f4fd96ecacd724b3a68347deef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaafc8f4fd96ecacd724b3a68347deef">&#9670;&#160;</a></span>getShadowCastingLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___general.html#ga8795828980c8be4892c41f4f4b7a7337">LightClosestArray</a> &amp; Ogre::CompositorShadowNode::getShadowCastingLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2fa015e01b5e725c3b8016e10cb5408" name="ae2fa015e01b5e725c3b8016e10cb5408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fa015e01b5e725c3b8016e10cb5408">&#9670;&#160;</a></span>getShadowMapLightTypeMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::CompositorShadowNode::getShadowMapLightTypeMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not call this if isShadowMapIdxActive == false or isShadowMapIdxInValidRange == false. </p>

</div>
</div>
<a id="add989e48cfe58cfa5639719fd72f6cfa" name="add989e48cfe58cfa5639719fd72f6cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add989e48cfe58cfa5639719fd72f6cfa">&#9670;&#160;</a></span>getViewMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp; Ogre::CompositorShadowNode::getViewMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture view matrix for the given shadow map index. </p>

</div>
</div>
<a id="a86ce2ecc67f6585db0da69dfc4146037" name="a86ce2ecc67f6585db0da69dfc4146037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ce2ecc67f6585db0da69dfc4146037">&#9670;&#160;</a></span>getViewProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> Ogre::CompositorShadowNode::getViewProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture view projection matrix for the given shadow map index. </p>

</div>
</div>
<a id="ac1b152c56604315e6958790d6703e601" name="ac1b152c56604315e6958790d6703e601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b152c56604315e6958790d6703e601">&#9670;&#160;</a></span>isShadowMapIdxActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorShadowNode::isShadowMapIdxActive </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the shadow map index is not active. </p>
<p>For example:</p><ul>
<li>There are 3 shadow maps, but only 2 shadow casting lights</li>
<li>There are 3 directional maps for directional PSSM, but no directional light. </li>
</ul>

</div>
</div>
<a id="aa0104d92ad5a14a2e36a92f46e9bfe88" name="aa0104d92ad5a14a2e36a92f46e9bfe88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0104d92ad5a14a2e36a92f46e9bfe88">&#9670;&#160;</a></span>isShadowMapIdxInValidRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorShadowNode::isShadowMapIdxInValidRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae14607795f3aa90c91cdd6274d867899" name="ae14607795f3aa90c91cdd6274d867899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14607795f3aa90c91cdd6274d867899">&#9670;&#160;</a></span>postInitializePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::postInitializePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We derive so we can override the camera with ours. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_compositor_node.html">Ogre::CompositorNode</a>.</p>

</div>
</div>
<a id="acf4e9f7b9d8e5b8c61bce6d164185e5d" name="acf4e9f7b9d8e5b8c61bce6d164185e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4e9f7b9d8e5b8c61bce6d164185e5d">&#9670;&#160;</a></span>setLightFixedToShadowMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::setLightFixedToShadowMap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td>
          <td class="paramname"><em>light</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks a shadow map as statically updated, and ties the given light to always use that shadow map. </p>
<dl class="section remark"><dt>Remarks</dt><dd>By default <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> recalculates the shadow maps every single frame (even if nothing has changed). However if you know that whatever a light is illuminating is not changing at all (or barely changing), with static shadow maps you are the one who tells <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> when to update it (e.g. you may only need to update it three times during the whole level); hence the framerate goes up. Perceived quality may also go up because by default <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> applies shadow mapping on the closest lights; so shadows flip on and off as you move the camera (because lights that had no shadows get closer while lights that were using shadows get farther away). While often this is desirable, there are cases where the artist may want a particular light to always have shadows (regardless of distance); with static shadow maps you can force that; hence the perceived quality may go up (but that's up to the talent of the artist and the scene in particular). </dd></dl>
<dl class="section user"><dt></dt><dd>Note that for point &amp; spot lights, you have to consider if the light changed (e.g. moved, rotated) or if anything that is or could be lit by the light has moved Directional lights are harder because they depend on the camera placement as well. </dd></dl>
<dl class="section user"><dt></dt><dd>Use setStaticShadowMapDirty to tell <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to update the shadow map in the next render. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> may call light-&gt;setCastShadows( true ); on the light. </dd></dl>
<dl class="section user"><dt></dt><dd>IMPORTANT: Do not put static and dynamic shadow maps in the same UV atlas. It's asking for trouble and will probably not work. Keep the atlas separate. </dd></dl>
<dl class="section user"><dt></dt><dd>VERY IMPORTANT: You <em>must</em> respect lights are set in the following order:<ol type="1">
<li>Directional</li>
<li>Point</li>
<li>Spot If you have shadow maps defined that support both point &amp; spotlight, and you want to mix both static lights with dynamic ones; set fixed point lights in the first shadow map indices and spotlight in the last indices, to avoid <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> automatically (e.g.) placing a point light after your static spot light. </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shadowMapIdx</td><td>Shadow map index to tie this light to. If this shadow map index is part of a PSSM split, all PSSM splits will be affected (thus you only need to call it once for any of the split that belong to the same set) </td></tr>
    <tr><td class="paramname">light</td><td><a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Light</a> to tie to the given shadow map. Null pointer disables it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a607c30415819742ad2bcfaa1d3959d5a" name="a607c30415819742ad2bcfaa1d3959d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607c30415819742ad2bcfaa1d3959d5a">&#9670;&#160;</a></span>setStaticShadowMapDirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::setStaticShadowMapDirty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeLinked</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tags a static shadow map as dirty, causing <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to update it on the next time this Shadow node gets executed. </p>
<p>If drawing to a texture atlas, multiple shadow maps may be sharing the same texture, thus if you're doing a clear on the whole atlas, you will need to update all of the shadow maps, not just this one. Use includeLinked=true to mark as dirty all static shadow maps that share the same atlas. Set it to false if that's explicitly what you want, or if you're already going to call it for every shadow map (otherwise you will trigger a O(N^2) behavior). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_compositor_shadow_node_8h.html">OgreCompositorShadowNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
