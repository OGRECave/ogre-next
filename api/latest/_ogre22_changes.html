<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: What&#39;s new in Ogre 2.2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE-Next
   &#160;<span id="projectnumber">4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_ogre22_changes.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">What's new in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Ogre22LoadStoreSemantics">Load Store semantics</a><ul><li class="level2"><a href="#autotoc_md23">Now that we’ve explained how TBDRs work, we can explain load and store actions</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md24">More control over MSAA</a></li>
<li class="level1"><a href="#autotoc_md25">Porting to Ogre 2.2 from 2.1</a><ul><li class="level2"><a href="#autotoc_md26">PixelFormats</a><ul><li class="level3"><a href="#autotoc_md27">Common pixel format equivalencies</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md28">Useful code snippets</a><ul><li class="level3"><a href="#autotoc_md29">Create a TextureGpu based on a file</a></li>
<li class="level3"><a href="#autotoc_md30">Create a TextureGpu based that you manually fill</a></li>
<li class="level3"><a href="#autotoc_md31">Uploading data to a TextureGpu</a></li>
<li class="level3"><a href="#autotoc_md32">Upload streaming</a></li>
<li class="level3"><a href="#autotoc_md33">Downloading data from TextureGpu into CPU</a></li>
<li class="level3"><a href="#autotoc_md34">Downloading streaming</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md35">Difference between depth, numSlices and depthOrSlices</a></li>
<li class="level1"><a href="#autotoc_md36">Memory layout of textures and images</a></li>
<li class="level1"><a href="#autotoc_md37">Troubleshooting errors</a></li>
<li class="level1"><a href="#autotoc_md38">RenderPassDescriptors</a></li>
<li class="level1"><a href="#autotoc_md39">DescriptorSetTexture &amp; co.</a></li>
<li class="level1"><a href="#autotoc_md40">Does 2.2 interoperate well with the HLMS texture arrays?</a></li>
<li class="level1"><a href="#autotoc_md41">Hlms porting</a></li>
<li class="level1"><a href="#autotoc_md42">Things to watch out when porting</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_manual_Migrating_Ogre2_2_Changes"></a></p>
<p>The main change has been a full refactor of textures.</p>
<p>The main reason of 2.2 is a complete overhaul of the Texture system, with a focus on lowering GPU RAM consumption, background texture streaming, asynchronic GPU to CPU texture transfers, and reducing out of GPU memory scenarios (which are relatively easy to run into if your project is medium-to-large sized).</p>
<h1><a class="anchor" id="Ogre22LoadStoreSemantics"></a>
Load Store semantics</h1>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2 is much more mobile friendly. Metal introduced the concepts of “load” and “store” actions, and we follow that paradigm because it’s easy to implement and understand.</p>
<p>First we need to explain how mobile TBDR GPUs work (**T**iled **B**ased **D**eferred **R**enderers). In a regular immediate GPU (any Desktop GPU), the GPU just processes and draws triangles to the screen in the order they’re submitted, writing results to RAM, and reading from RAM if need to. Run the vertex shader, then the pixel shader, go on to the next triangle. The process is slightly more complex because there’s a lot of parallelization going on (i.e. multiple triangles worked on a the same time), but the overall scheme of things is that desktop GPUs process things in order.</p>
<p>TBDRs work differently: They process all the vertices first (i.e. run all of the vertex shaders), and then later it goes through each tile (usually of 8×8 pixels), finds which triangles touch that tile; sorts them front to back (unless alpha testing or alpha blending is used). and then runs the pixel shaders on all the triangles and pixels. Then proceeds to the next tile. This has the following advantages:</p>
<ol type="1">
<li>Most pixels filled by opaque triangles will only be shaded by a pixel shader only once.</li>
<li>Early-Z is implicit. This also means a depth-prepass is unnecessary and only a waste of time.</li>
<li>The whole tile stays in an on-chip cache (which has much lower latency, much greater bandwidth, and much lower power consumption). Once the tile is completely done, the cache gets flushed into RAM. In contrast, a desktop GPU could be constantly reading back and forth from main RAM (they have caches, but data doesn’t necessarily stay always in the cache).</li>
</ol>
<p>The main disadvantage is that it does not scale well to a large number of vertices (since the GPU must store <b>all</b> of the processed vertices somewhere). There’s a performance cliff past certain vertex count: Exceed certain threshold and you’ll see your framerate decrease very fast the more vertices you add once you’re beyond that limit.</p>
<p>This is not usually a problem in mobile because well… nobody expects a phone to process 4 million vertices or more per frame. Also you can make it up by using improved pixel shaders (because of the Early Z you get for free).</p>
<p>In TBDRs, each tile is a self-contained unit of work that never flushes the cache from start to end until all the works has been done (unless the GPU has ran out of space because we’ve submitted too much work, but let’s not dwell into that).</p>
<p>If you want a more in-depth explanation, read <a href="https://www.imgtec.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/">A look at the PowerVR graphics architecture: Tile-based rendering</a> and <a href="https://www.imgtec.com/blog/understanding-powervr-series5xt-powervr-tbdr-and-architecture-efficiency-part-4/">Understanding PowerVR Series5XT: PowerVR, TBDR and architecture efficiency</a>.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Now that we’ve explained how TBDRs work, we can explain load and store actions</h2>
<p>In an immediate renderer, clearing the colour and depth buffers means we instruct the GPU to basically memset the whole texture to a specific value. And then we render to it.</p>
<p>In TBDRs, this is inefficient; as the memset will store a value to RAM, that later needs to be read from RAM. TBDRs can:</p>
<ol type="1">
<li>Clear the cache instead, rather than loading it from RAM. (i.e. set the cache to a specific value each time the GPU begins a new tile)</li>
<li>If you don’t need the results of a particular buffer once you’re done rendering, you can discard them instead of flushing it to RAM. This saves bandwidth and power. For example you may not need to save the depth buffer. Or you may only need the resolved result of MSAA render, and discard the contents of the MSAA surface.</li>
</ol>
<p>The Metal RenderSystem in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.1 tried to merge clears alongside draws as much as possible, but it didn’t always get it right; and it glitched when doing complex MSAA rendering.</p>
<p>Now in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2 you can explicitly specify what you want to do. For load actions you can do:</p>
<ol type="1">
<li>DontCare: The cache is not initialized. This is the fastest option, and only works glitch-free if you can guarantee you will render to all the pixels in the screen with opaque geometry.</li>
<li>Clear: The cache is cleared to a particular value. This is fast.</li>
<li>Load: Load whatever was on RAM. This is the slowest, but also the default as it is the safest option.</li>
</ol>
<p>For store actions you also get:</p>
<ol type="1">
<li>DontCare: Discard the contents after we’re done with the current pass. Useful if you only want colour and don’t care what happens with the depth &amp; stencil buffers. Discarding contents either improves framerate or battery duration or makes rendering friendlier to SLI/Crossfire.</li>
<li>Store: Save results to RAM. This is the default.</li>
<li>MultisampleResolve: Resolve MSAA rendering into resolve texture. Contents of MSAA texture are discarded.</li>
<li>StoreAndMultisampleResolve: Resolve MSAA rendering into resolve texture. Contents of MSAA texture are kept.</li>
</ol>
<p>This gives you a lot of power and control over how mobile GPUs control their caches in order to achieve maximum performance. But be careful: If you set a load or store action to “DontCare” and then you do need the values, then you’ll end up reading garbage every frame (uninitialized values), which can result in glitches.</p>
<p>These semantics can also help on Desktop. Whenever we can, we emulate this behavior (to make porting to mobile easier), but we also tell the API about this information whenever the DX11 and GL APIs allow us. This can mostly help with SLI and Crossfire.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
More control over MSAA</h1>
<p>Explicit MSAA finally arrived in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2; and thanks to load and store actions; you have a lot of control over what happens with MSAA and when; which can result in high quality rendering by making MSAA a first class citizen.</p>
<p>There have been other numerous MSAA changes. In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.1 MRT + MSAA did not work correctly except for D3D11 (which makes SSR sample to only work with MSAA in D3D11). Now it works everywhere.</p>
<p>Another change for example that in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.1 all render textures in the compositor default to using MSAA if the main target is using MSAA. In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2; we default to not using MSAA unless told otherwise. We found out most textures do not need MSAA because they’re postprocessing FXs or similar; thus the MSAA is only a waste of memory and performance by doing useless resolves. Therefore only a few render textures actually need MSAA. This saves a lot of GPU RAM and some performance.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Porting to Ogre 2.2 from 2.1</h1>
<p>The impact from this change can vary a lot based on how you were using <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>:</p>
<ul>
<li>Users that mostly interacted with textures via material scripts will barely need porting efforts.</li>
<li>Users that heavily manipulated textures from code (creation, upload, download, destroying, using render textures) will have more work to do.</li>
</ul>
<p>The following classes belonged to the "old" texturing system were removed or are not functional and scheduled for removal:</p>
<ul>
<li>Texture</li>
<li>v1::HardwarePixelBuffer</li>
<li>RenderTarget</li>
<li>RenderTexture</li>
<li>RenderWindow</li>
<li>TextureManager</li>
<li>MultiRenderTarget</li>
</ul>
<p>They were instead replaced by the following classes:</p>
<ul>
<li>TextureGpu</li>
<li>TextureGpuManager</li>
<li>StagingTexture</li>
<li>AsyncTextureTicket</li>
<li>Window</li>
<li>RenderPassDescriptor</li>
</ul>
<p>There are a few things that need to be clarified first hand:</p>
<ol type="1">
<li>TextureGpu replaces most of these older classes.</li>
<li>You cannot map a TextureGpu directly. You can only update its data via a StagingTexture and read its contents via an AsyncTextureTicket. This better matches what GPUs actually do behind the scenes.</li>
</ol>
<p>The following table summarizes old and new classes:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Task   </th><th class="markdownTableHeadRight">2.1   </th><th class="markdownTableHeadRight">2.2    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Use a texture   </td><td class="markdownTableBodyRight">Texture   </td><td class="markdownTableBodyRight">TextureGpu    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Render to texture   </td><td class="markdownTableBodyRight">RenderTarget / RenderTexture   </td><td class="markdownTableBodyRight">TextureGpu    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Access a cubemap face or mipmap   </td><td class="markdownTableBodyRight">HardwarePixelBuffer   </td><td class="markdownTableBodyRight">TextureGpu    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Upload data (CPU → GPU)   </td><td class="markdownTableBodyRight">Map HardwarePixelBuffer   </td><td class="markdownTableBodyRight">StagingTexture    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Download data (GPU → CPU)   </td><td class="markdownTableBodyRight">Map HardwarePixelBuffer   </td><td class="markdownTableBodyRight">AsyncTextureTicket    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Setup MRT (Multiple Render Target)   </td><td class="markdownTableBodyRight">RenderTexture + MultiRenderTarget   </td><td class="markdownTableBodyRight">RenderPassDescriptor    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Creating / destroying textures. Loading from file   </td><td class="markdownTableBodyRight">TextureManager   </td><td class="markdownTableBodyRight">TextureGpuManager    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dealing with Hlms texture arrays   </td><td class="markdownTableBodyRight">HlmsTextureManager   </td><td class="markdownTableBodyRight">TextureGpuManager    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Managing a window (events, resizing, etc)   </td><td class="markdownTableBodyRight">RenderWindow   </td><td class="markdownTableBodyRight">Window    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rendering to a window   </td><td class="markdownTableBodyRight">RenderWindow   </td><td class="markdownTableBodyRight">TextureGpu    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Dealing with depth buffers   </td><td class="markdownTableBodyRight">DepthBuffer   </td><td class="markdownTableBodyRight">TextureGpu   </td></tr>
</table>
<p>You may have noticed that 'TextureGpu' is now repeated <em>a lot</em>. That is because in 2.1 the functionality was mainly fragmented between 3 classes:</p>
<ol type="1">
<li>Texture (owns multiple HardwarePixelBuffer, usually one per cubemap face and one per mipmap, but not consistently, e.g. all slices in a 3D volume texture belong to just one HardwarePixelBuffer)</li>
<li>HardwarePixelBuffer (owns a RenderTarget, which may be null if the texture cannot be used as RenderTarget)</li>
<li>RenderTarget (may have a DepthBuffer associated, but doesn't own it)</li>
<li>DepthBuffer</li>
</ol>
<p>This was madness because these distinctions were applied inconsistently and often made no sense. e.g. a RenderTexture is often drawn to, and then used as a texture source. Or we want to render to several mips (which are represented as separate RenderTargets) This means we had to constantly walk upwards and downwards the hierarchy to get the information we needed.</p>
<p>Now in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2, all of that is condensed into one class:</p>
<ol type="1">
<li>TextureGpu</li>
</ol>
<p>This doesn't mean that TextureGpu is an overgrown God Class. The fragmentation into 3 was a bad idea to begin with.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
PixelFormats</h2>
<p>PixelFormat is deprecated and will be removed. You should use PixelFormatGpu instead. The way to read the format is the following:</p>
<ul>
<li>PFG_RGBA8_UNORM: RGBA format, 8 bits per channel (so 32 bit per pixel), in unorm format; that means range is [0; 1]</li>
<li>PFG_RGBA32_FLOAT: RGBA format, 32 bits per channel (so 128 bit per pixel), in raw float format</li>
</ul>
<h3><a class="anchor" id="autotoc_md27"></a>
Common pixel format equivalencies</h3>
<p>The boolean "hwGamma" that usually came alongside the pixel format is gone. Now the gamma version is part of the format. For example PFG_RGBA8_UNORM and PFG_RGBA8_UNORM_SRGB are both the same format except one is.</p>
<p>Here's a table with common translations:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Old   </th><th class="markdownTableHeadNone">New    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PF_L8   </td><td class="markdownTableBodyNone">PFG_R8_UNORM    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PF_L16   </td><td class="markdownTableBodyNone">PFG_R16_UNORM    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PF_A8B8G8R8<br  />
PF_BYTE_BGR<br  />
PF_BYTE_BGRA   </td><td class="markdownTableBodyNone">PFG_RGBA8_UNORM<br  />
PFG_RGBA8_UNORM_SRGB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PF_A8R8G8B8<br  />
PF_BYTE_RGB<br  />
PF_BYTE_RGBA   </td><td class="markdownTableBodyNone">PFG_RGBA8_UNORM (*)<br  />
PFG_RGBA8_UNORM_SRGB(*)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PF_DXT1<br  />
PF_DXT2   </td><td class="markdownTableBodyNone">PFG_BC1_UNORM<br  />
PFG_BC1_UNORM_SRGB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PF_DXT3<br  />
PF_DXT4   </td><td class="markdownTableBodyNone">PFG_BC2_UNORM<br  />
PFG_BC2_UNORM_SRGB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PF_DXT5   </td><td class="markdownTableBodyNone">PFG_BC3_UNORM<br  />
PFG_BC3_UNORM_SRGB   </td></tr>
</table>
<p>(*)The correct format would be PFG_BGRA8_UNORM, PFG_BGRX8_UNORM, PFG_BGRA8_UNORM_SRGB and PFG_BGRX8_UNORM_SRGB. However avoid these, because:</p>
<ol type="1">
<li>The _SRGB variants didn't exist up until D3D11 (i.e. they're not available to D3D10)</li>
<li>These formats are mostly meant for dealing with swapchains (and thus renderwindows) rather than as regular textures or even RenderTargets.</li>
</ol>
<p><b>How do I change toggle gamma correction on and off dynamically?</b></p>
<p>Create the texture with the flag TextureFlags::Reinterpretable and then use DescriptorSetTexture2 to interpret it with a different format (advanced users).</p>
<p>Compute job passes use DescriptorSetTexture2 internally by default and support feature format reinterpretation out of the box.</p>
<p><b>Where are PF_L8 and PF_L16?</b></p>
<p>These no longer exist as they did not exist in D3D11 &amp; Metal and were being emulated in GL. Use PFG_R8_UNORM &amp; PFG_R16_UNORM instead, which return the data in the red channel, as opposed to L8 which in GL returned data in all 3 RGB channels (but in D3D11 &amp; Metal, only returned data in the red channel...). Use HlmsUnlitDatablock::setTextureSwizzle to control how the channels are routed to your liking.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Useful code snippets</h2>
<h3><a class="anchor" id="autotoc_md29"></a>
Create a TextureGpu based on a file</h3>
<p>The following snippet loads a texture from file: </p><div class="fragment"><div class="line">Ogre::Root *root = ...;</div>
<div class="line">Ogre::TextureGpuManager *textureMgr = root-&gt;getRenderSystem()-&gt;getTextureGpuManager();</div>
<div class="line">Ogre::TextureGpu *texture = textureMgr-&gt;createOrRetrieveTexture(</div>
<div class="line">                                &quot;SaintPetersBasilica.dds&quot;,</div>
<div class="line">                                Ogre::GpuPageOutStrategy::Discard,</div>
<div class="line">                                Ogre::TextureFlags::PrefersLoadingFromFileAsSRGB,</div>
<div class="line">                                Ogre::TextureTypes::TypeCube,</div>
<div class="line">                                Ogre::ResourceGroupManager::</div>
<div class="line">                                AUTODETECT_RESOURCE_GROUP_NAME,</div>
<div class="line">                                Ogre::TextureFilter::TypeGenerateDefaultMipmaps );</div>
</div><!-- fragment --><p>Note the texture is not loaded yet, so it consumes very little RAM, and functions like getWidth() and getHeight() won't return valid values. To load it, call:</p>
<div class="fragment"><div class="line">texture-&gt;scheduleTransitionTo( Ogre::GpuResidency::Resident );</div>
</div><!-- fragment --><p>This will begin loading <b>in the background</b>, in a secondary thread managed by TextureGpuManager.</p>
<p>For example, Trying to call texture-&gt;getWidth() immediately after scheduleTransitionTo will incur in a race condition: if the secondary thread didn't load the texture yet, you will get garbage values (probably 0 if the texture is new), or you'll get the real value if the thread managed to load the texture in that time.</p>
<p>To safely call texture-&gt;getWidth() you can call: </p><div class="fragment"><div class="line">texture-&gt;waitForMetadata();</div>
</div><!-- fragment --><p> This will block the calling thread until the metadata has been loaded. Metadata means:</p>
<ol type="1">
<li>Resolution (width, height, depth)</li>
<li>Pixel format</li>
<li>Number of mipmaps</li>
<li>Actual TextureType (e.g. 2D, 3D, 2DArray, Cubemap)</li>
</ol>
<p>But the actual texture contents aren't done loaded yet. For that we have:</p>
<div class="fragment"><div class="line">texture-&gt;waitForData();</div>
</div><!-- fragment --><p> This will block the calling thread until the texture is fully loaded.</p>
<p>Last, but not least, you can also call:</p>
<div class="fragment"><div class="line">textureMgr-&gt;waitForStreamingCompletion();</div>
</div><!-- fragment --><p> This will block the calling thread until <b>all</b> pending textures are loaded.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Create a TextureGpu based that you manually fill</h3>
<p>The following snippet creates a texture that will be filled by hand (e.g. manually loading from file yourself, procedural generation, etc):</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_root.html">Ogre::Root</a> *root = ...;</div>
<div class="line"><a class="code" href="class_ogre_1_1_texture_gpu_manager.html">Ogre::TextureGpuManager</a> *textureMgr = root-&gt;<a class="code" href="class_ogre_1_1_root.html#a302ae050078b8a845a6059201cf9469b">getRenderSystem</a>()-&gt;<a class="code" href="class_ogre_1_1_render_system.html#a687a8e7e19a73828a762461bc0419f1d">getTextureGpuManager</a>();</div>
<div class="line"><a class="code" href="class_ogre_1_1_texture_gpu.html">Ogre::TextureGpu</a> *texture = textureMgr-&gt;<a class="code" href="class_ogre_1_1_texture_gpu_manager.html#a6c611147ab065038c4727b75dffdac65">createOrRetrieveTexture</a>(</div>
<div class="line">                                <span class="stringliteral">&quot;MyPcgTexture&quot;</span>,</div>
<div class="line">                                <a class="code" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65a28135d9485a60bfa1a598cba471d6891">Ogre::GpuPageOutStrategy::Discard</a>,</div>
<div class="line">                                <a class="code" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434af3d439b1fb1b1aedfbea2c633da4e2b1">Ogre::TextureFlags::ManualTexture</a>,</div>
<div class="line">                                <a class="code" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82aaccb80fce163e32091af35b9de1c1001">Ogre::TextureTypes::Type2D</a>,</div>
<div class="line">                                <a class="code" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">Ogre::BLANKSTRING</a>,</div>
<div class="line">                                0u );</div>
<div class="line">texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a54dfe2523d8e5647e79caaf28c296d4e">setPixelFormat</a>( <a class="code" href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">Ogre::PFG_RGBA8_UNORM_SRGB</a> );</div>
<div class="line">texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#aeadb4961ae1af0313cbd253bd32285dd">setTextureType</a>( <a class="code" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82aaccb80fce163e32091af35b9de1c1001">Ogre::TextureTypes::Type2D</a> );</div>
<div class="line">texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a6ae40391d39c8feae00acaf25839c6f9">setNumMipmaps</a>( 1u );</div>
<div class="line">texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#af79e22c90559d13385d75dc19970806d">setResolution</a>(width, height);</div>
<div class="ttc" id="aclass_ogre_1_1_render_system_html_a687a8e7e19a73828a762461bc0419f1d"><div class="ttname"><a href="class_ogre_1_1_render_system.html#a687a8e7e19a73828a762461bc0419f1d">Ogre::RenderSystem::getTextureGpuManager</a></div><div class="ttdeci">TextureGpuManager * getTextureGpuManager() const</div><div class="ttdef"><b>Definition:</b> OgreRenderSystem.h:1194</div></div>
<div class="ttc" id="aclass_ogre_1_1_root_html"><div class="ttname"><a href="class_ogre_1_1_root.html">Ogre::Root</a></div><div class="ttdoc">The root class of the Ogre system.</div><div class="ttdef"><b>Definition:</b> OgreRoot.h:71</div></div>
<div class="ttc" id="aclass_ogre_1_1_root_html_a302ae050078b8a845a6059201cf9469b"><div class="ttname"><a href="class_ogre_1_1_root.html#a302ae050078b8a845a6059201cf9469b">Ogre::Root::getRenderSystem</a></div><div class="ttdeci">RenderSystem * getRenderSystem()</div><div class="ttdoc">Retrieve a pointer to the currently selected render system.</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html">Ogre::TextureGpu</a></div><div class="ttdef"><b>Definition:</b> OgreTextureGpu.h:291</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a54dfe2523d8e5647e79caaf28c296d4e"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a54dfe2523d8e5647e79caaf28c296d4e">Ogre::TextureGpu::setPixelFormat</a></div><div class="ttdeci">void setPixelFormat(PixelFormatGpu pixelFormat)</div><div class="ttdoc">Sets the pixel format.</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a6ae40391d39c8feae00acaf25839c6f9"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a6ae40391d39c8feae00acaf25839c6f9">Ogre::TextureGpu::setNumMipmaps</a></div><div class="ttdeci">void setNumMipmaps(uint8 numMipmaps)</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_aeadb4961ae1af0313cbd253bd32285dd"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#aeadb4961ae1af0313cbd253bd32285dd">Ogre::TextureGpu::setTextureType</a></div><div class="ttdeci">virtual void setTextureType(TextureTypes::TextureTypes textureType)</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_af79e22c90559d13385d75dc19970806d"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#af79e22c90559d13385d75dc19970806d">Ogre::TextureGpu::setResolution</a></div><div class="ttdeci">void setResolution(uint32 width, uint32 height, uint32 depthOrSlices=1u)</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_manager_html"><div class="ttname"><a href="class_ogre_1_1_texture_gpu_manager.html">Ogre::TextureGpuManager</a></div><div class="ttdoc">This class manages all textures (i.e.</div><div class="ttdef"><b>Definition:</b> OgreTextureGpuManager.h:242</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_manager_html_a6c611147ab065038c4727b75dffdac65"><div class="ttname"><a href="class_ogre_1_1_texture_gpu_manager.html#a6c611147ab065038c4727b75dffdac65">Ogre::TextureGpuManager::createOrRetrieveTexture</a></div><div class="ttdeci">TextureGpu * createOrRetrieveTexture(const String &amp;name, const String &amp;aliasName, GpuPageOutStrategy::GpuPageOutStrategy pageOutStrategy, uint32 textureFlags, TextureTypes::TextureTypes initialType, const String &amp;resourceGroup=BLANKSTRING, uint32 filters=0, uint32 poolId=0)</div></div>
<div class="ttc" id="agroup___general_html_gad842a4b416bd2f3245d2b44826a0aedc"><div class="ttname"><a href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">Ogre::BLANKSTRING</a></div><div class="ttdeci">const String BLANKSTRING</div><div class="ttdoc">Constant blank string, useful for returning by ref where local does not exist.</div><div class="ttdef"><b>Definition:</b> OgreCommon.h:785</div></div>
<div class="ttc" id="agroup___image_html_gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31"><div class="ttname"><a href="group___image.html#gga71f09fe41a1db41186262f1aa5814a18a1247103ed0c897244c2cdb511155ef31">Ogre::PFG_RGBA8_UNORM_SRGB</a></div><div class="ttdeci">@ PFG_RGBA8_UNORM_SRGB</div><div class="ttdef"><b>Definition:</b> OgrePixelFormatGpu.h:78</div></div>
<div class="ttc" id="anamespace_ogre_1_1_gpu_page_out_strategy_html_a4d2162c156be30917f38f15e2327ce65a28135d9485a60bfa1a598cba471d6891"><div class="ttname"><a href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65a28135d9485a60bfa1a598cba471d6891">Ogre::GpuPageOutStrategy::Discard</a></div><div class="ttdeci">@ Discard</div><div class="ttdoc">When the resource is no longer resident, we just throw the GPU data.</div><div class="ttdef"><b>Definition:</b> OgreGpuResource.h:89</div></div>
<div class="ttc" id="anamespace_ogre_1_1_texture_flags_html_a59b71e36a14465bd82595d6d467e1434af3d439b1fb1b1aedfbea2c633da4e2b1"><div class="ttname"><a href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434af3d439b1fb1b1aedfbea2c633da4e2b1">Ogre::TextureFlags::ManualTexture</a></div><div class="ttdeci">@ ManualTexture</div><div class="ttdoc">Indicates this texture will be filled by the user, and won't be loaded from file or a listener from w...</div><div class="ttdef"><b>Definition:</b> OgreTextureGpu.h:136</div></div>
<div class="ttc" id="anamespace_ogre_1_1_texture_types_html_aa364e348564060700791c9940d5ced82aaccb80fce163e32091af35b9de1c1001"><div class="ttname"><a href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82aaccb80fce163e32091af35b9de1c1001">Ogre::TextureTypes::Type2D</a></div><div class="ttdeci">@ Type2D</div><div class="ttdef"><b>Definition:</b> OgreTextureGpu.h:57</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31"></a>
Uploading data to a TextureGpu</h3>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> rowAlignment = 4u;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> dataSize = <a class="code" href="class_ogre_1_1_pixel_format_gpu_utils.html#aee2ade90d769c187b8192e0a234c5f17">Ogre::PixelFormatGpuUtils::getSizeBytes</a>( texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#add1ea0e81537e4b98ad11f6cc06f14cd">getWidth</a>(),</div>
<div class="line">                                                                 texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a0a8a88cae92d0f92e0b1b909e89ee418">getHeight</a>(),</div>
<div class="line">                                                                 texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a20508c2ba704e46e84453bc62aea85a0">getDepth</a>(),</div>
<div class="line">                                                                 texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a494d1ec99e6e6589c4059125a1d10966">getNumSlices</a>(),</div>
<div class="line">                                                                 texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#ad72ce773bbfd3c330fa3fbd5df40a649">getPixelFormat</a>(),</div>
<div class="line">                                                                 rowAlignment );</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> bytesPerRow = texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a0e61075bcb144b7ae9567892d8d27bb9">_getSysRamCopyBytesPerRow</a>( 0 );</div>
<div class="line"><a class="code" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> *imageData = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>*<span class="keyword">&gt;</span>( <a class="code" href="_ogre_memory_allocator_config_8h.html#afd7ddaef10ac9ea1ffbd18902167b9a2">OGRE_MALLOC_SIMD</a>( dataSize,</div>
<div class="line">                                                               <a class="code" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa04bad2e7f64cc2b6f4cda9f56b59e5b4">MEMCATEGORY_RESOURCE</a> ) );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... fill imageData ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//Tell the texture we&#39;re going resident. The imageData pointer is only needed</span></div>
<div class="line"><span class="comment">//if the texture pageout strategy is GpuPageOutStrategy::AlwaysKeepSystemRamCopy</span></div>
<div class="line"><span class="comment">//which is in this example is not, so a nullptr would also work just fine.</span></div>
<div class="line">texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a85f9670da9031ec138caf8b3e910b37e">_transitionTo</a>( <a class="code" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">GpuResidency::Resident</a>, imageData );</div>
<div class="line">texture-&gt;<a class="code" href="class_ogre_1_1_gpu_resource.html#a56ccef279ef9251c5a4b40bfaf7b9e05">_setNextResidencyStatus</a>( <a class="code" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">GpuResidency::Resident</a> );</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//We have to upload the data via a StagingTexture, which acts as an intermediate stash</span></div>
<div class="line"><span class="comment">//memory that is both visible to CPU and GPU.</span></div>
<div class="line">StagingTexture *stagingTexture = textureManager-&gt;getStagingTexture( texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#add1ea0e81537e4b98ad11f6cc06f14cd">getWidth</a>(),</div>
<div class="line">                                                                    texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a0a8a88cae92d0f92e0b1b909e89ee418">getHeight</a>(),</div>
<div class="line">                                                                    texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a20508c2ba704e46e84453bc62aea85a0">getDepth</a>(),</div>
<div class="line">                                                                    texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a494d1ec99e6e6589c4059125a1d10966">getNumSlices</a>(),</div>
<div class="line">                                                                    texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#ad72ce773bbfd3c330fa3fbd5df40a649">getPixelFormat</a>() );</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Call this function to indicate you&#39;re going to start calling mapRegion. startMapRegion</span></div>
<div class="line"><span class="comment">//must be called from main thread.</span></div>
<div class="line">stagingTexture-&gt;startMapRegion();</div>
<div class="line"><span class="comment">//Map region of the staging texture. This function can be called from any thread after</span></div>
<div class="line"><span class="comment">//startMapRegion has already been called.</span></div>
<div class="line">TextureBox texBox = stagingTexture-&gt;mapRegion( texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#add1ea0e81537e4b98ad11f6cc06f14cd">getWidth</a>(), texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a0a8a88cae92d0f92e0b1b909e89ee418">getHeight</a>(),</div>
<div class="line">                                               texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a20508c2ba704e46e84453bc62aea85a0">getDepth</a>(), texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a494d1ec99e6e6589c4059125a1d10966">getNumSlices</a>(),</div>
<div class="line">                                               texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#ad72ce773bbfd3c330fa3fbd5df40a649">getPixelFormat</a>() );</div>
<div class="line">texBox.copyFrom( imageData, texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#add1ea0e81537e4b98ad11f6cc06f14cd">getWidth</a>(), texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a0a8a88cae92d0f92e0b1b909e89ee418">getHeight</a>(), bytesPerRow );</div>
<div class="line"><span class="comment">//stopMapRegion indicates you&#39;re done calling mapRegion. Call this from the main thread.</span></div>
<div class="line"><span class="comment">//It is your responsability to ensure you&#39;re done using all pointers returned from</span></div>
<div class="line"><span class="comment">//previous mapRegion calls, and that you won&#39;t call it again.</span></div>
<div class="line"><span class="comment">//You cannot upload until you&#39;ve called this function.</span></div>
<div class="line"><span class="comment">//Do NOT call startMapRegion again until you&#39;re done with upload() calls.</span></div>
<div class="line">stagingTexture-&gt;stopMapRegion();</div>
<div class="line"><span class="comment">//Upload an area of the staging texture into the texture. Must be done from main thread.</span></div>
<div class="line"><span class="comment">//The last bool parameter, &#39;skipSysRamCopy&#39;, is only relevant for AlwaysKeepSystemRamCopy</span></div>
<div class="line"><span class="comment">//textures, and we set it to true because we know it&#39;s already up to date. Otherwise</span></div>
<div class="line"><span class="comment">//it needs to be false.</span></div>
<div class="line">stagingTexture-&gt;upload( texBox, texture, 0, 0, <span class="keyword">true</span> );</div>
<div class="line"><span class="comment">//Tell the TextureGpuManager we&#39;re done with this StagingTexture. Otherwise it will leak.</span></div>
<div class="line">textureManager-&gt;removeStagingTexture( stagingTexture );</div>
<div class="line">stagingTexture = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Do not free the pointer if texture&#39;s paging strategy is GpuPageOutStrategy::AlwaysKeepSystemRamCopy</span></div>
<div class="line"><a class="code" href="_ogre_memory_allocator_config_8h.html#af7501eb098fc6671420c628dc80af2a8">OGRE_FREE_SIMD</a>( imageData, <a class="code" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa04bad2e7f64cc2b6f4cda9f56b59e5b4">MEMCATEGORY_RESOURCE</a> );</div>
<div class="line">imageData = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//This call is very important. It notifies the texture is fully ready for being displayed.</span></div>
<div class="line"><span class="comment">//Since we&#39;ve scheduled the texture to become resident and pp until now, the texture knew</span></div>
<div class="line"><span class="comment">//it was being loaded and that only the metadata was certain. This call here signifies</span></div>
<div class="line"><span class="comment">//loading is done; and any registered listeners will be notified.</span></div>
<div class="line">texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a73d480691663c93439835ff7d11f7739">notifyDataIsReady</a>();</div>
<div class="ttc" id="a_ogre_memory_allocator_config_8h_html_af7501eb098fc6671420c628dc80af2a8"><div class="ttname"><a href="_ogre_memory_allocator_config_8h.html#af7501eb098fc6671420c628dc80af2a8">OGRE_FREE_SIMD</a></div><div class="ttdeci">#define OGRE_FREE_SIMD(ptr, category)</div><div class="ttdoc">Free the memory allocated with either OGRE_MALLOC_SIMD or OGRE_ALLOC_T_SIMD.</div><div class="ttdef"><b>Definition:</b> OgreMemoryAllocatorConfig.h:383</div></div>
<div class="ttc" id="a_ogre_memory_allocator_config_8h_html_afd7ddaef10ac9ea1ffbd18902167b9a2"><div class="ttname"><a href="_ogre_memory_allocator_config_8h.html#afd7ddaef10ac9ea1ffbd18902167b9a2">OGRE_MALLOC_SIMD</a></div><div class="ttdeci">#define OGRE_MALLOC_SIMD(bytes, category)</div><div class="ttdoc">Allocate a block of raw memory aligned to SIMD boundaries, and indicate the category of usage.</div><div class="ttdef"><b>Definition:</b> OgreMemoryAllocatorConfig.h:374</div></div>
<div class="ttc" id="aclass_ogre_1_1_gpu_resource_html_a56ccef279ef9251c5a4b40bfaf7b9e05"><div class="ttname"><a href="class_ogre_1_1_gpu_resource.html#a56ccef279ef9251c5a4b40bfaf7b9e05">Ogre::GpuResource::_setNextResidencyStatus</a></div><div class="ttdeci">void _setNextResidencyStatus(GpuResidency::GpuResidency nextResidency)</div></div>
<div class="ttc" id="aclass_ogre_1_1_pixel_format_gpu_utils_html_aee2ade90d769c187b8192e0a234c5f17"><div class="ttname"><a href="class_ogre_1_1_pixel_format_gpu_utils.html#aee2ade90d769c187b8192e0a234c5f17">Ogre::PixelFormatGpuUtils::getSizeBytes</a></div><div class="ttdeci">static size_t getSizeBytes(uint32 width, uint32 height, uint32 depth, uint32 slices, PixelFormatGpu format, uint32 rowAlignment=1u)</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a0a8a88cae92d0f92e0b1b909e89ee418"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a0a8a88cae92d0f92e0b1b909e89ee418">Ogre::TextureGpu::getHeight</a></div><div class="ttdeci">uint32 getHeight() const</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a0e61075bcb144b7ae9567892d8d27bb9"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a0e61075bcb144b7ae9567892d8d27bb9">Ogre::TextureGpu::_getSysRamCopyBytesPerRow</a></div><div class="ttdeci">uint32 _getSysRamCopyBytesPerRow(uint8 mipLevel)</div><div class="ttdoc">Note: Returns non-zero even if there is no system ram copy.</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a20508c2ba704e46e84453bc62aea85a0"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a20508c2ba704e46e84453bc62aea85a0">Ogre::TextureGpu::getDepth</a></div><div class="ttdeci">uint32 getDepth() const</div><div class="ttdoc">For TypeCube &amp; TypeCubeArray, this value returns 1.</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a494d1ec99e6e6589c4059125a1d10966"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a494d1ec99e6e6589c4059125a1d10966">Ogre::TextureGpu::getNumSlices</a></div><div class="ttdeci">uint32 getNumSlices() const</div><div class="ttdoc">For TypeCube this value returns 6.</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a73d480691663c93439835ff7d11f7739"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a73d480691663c93439835ff7d11f7739">Ogre::TextureGpu::notifyDataIsReady</a></div><div class="ttdeci">virtual void notifyDataIsReady()=0</div><div class="ttdoc">Notifies it is safe to use the real data. Everything has been uploaded.</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a85f9670da9031ec138caf8b3e910b37e"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a85f9670da9031ec138caf8b3e910b37e">Ogre::TextureGpu::_transitionTo</a></div><div class="ttdeci">void _transitionTo(GpuResidency::GpuResidency newResidency, uint8 *sysRamCopy, bool autoDeleteSysRamCopy=true)</div><div class="ttdoc">This function may be called manually (if user is manually managing a texture) or automatically (e....</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_ad72ce773bbfd3c330fa3fbd5df40a649"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#ad72ce773bbfd3c330fa3fbd5df40a649">Ogre::TextureGpu::getPixelFormat</a></div><div class="ttdeci">PixelFormatGpu getPixelFormat() const</div></div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_add1ea0e81537e4b98ad11f6cc06f14cd"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#add1ea0e81537e4b98ad11f6cc06f14cd">Ogre::TextureGpu::getWidth</a></div><div class="ttdeci">uint32 getWidth() const</div></div>
<div class="ttc" id="agroup___memory_html_gga830fab51be174d6f2849857cb1abb36aa04bad2e7f64cc2b6f4cda9f56b59e5b4"><div class="ttname"><a href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa04bad2e7f64cc2b6f4cda9f56b59e5b4">Ogre::MEMCATEGORY_RESOURCE</a></div><div class="ttdeci">@ MEMCATEGORY_RESOURCE</div><div class="ttdoc">Other resources.</div><div class="ttdef"><b>Definition:</b> OgreMemoryAllocatorConfig.h:174</div></div>
<div class="ttc" id="anamespace_ogre_1_1_gpu_residency_html_a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2"><div class="ttname"><a href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">Ogre::GpuResidency::Resident</a></div><div class="ttdeci">@ Resident</div><div class="ttdoc">VRAM and other GPU resources have been allocated for this resource.</div><div class="ttdef"><b>Definition:</b> OgreGpuResource.h:66</div></div>
<div class="ttc" id="anamespace_ogre_html_a5a7c15d68e8c7d585c410bc5a93682f4"><div class="ttname"><a href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">Ogre::uint32</a></div><div class="ttdeci">::uint32_t uint32</div><div class="ttdef"><b>Definition:</b> OgrePlatform.h:545</div></div>
<div class="ttc" id="anamespace_ogre_html_a9212e2b4c7d29d6fae3a004ac7ad137e"><div class="ttname"><a href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">Ogre::uint8</a></div><div class="ttdeci">::uint8_t uint8</div><div class="ttdef"><b>Definition:</b> OgrePlatform.h:543</div></div>
</div><!-- fragment --><p>You don't necessarily need to have one StagingTexture per TextureGpu for uploads. For example you could have four 1024x1024 TextureGpus and request one StagingTexture of 2048x2048 or one of 1024x1024x4; map it four times and perform four uploads. In pseudo code:</p>
<div class="fragment"><div class="line">StagingTexture *stagingTexture = textureManager-&gt;getStagingTexture( 2048u, 2048u,</div>
<div class="line">                                                                    1u, 1u,</div>
<div class="line">                                                                    pixelFormat );</div>
<div class="line">stagingTexture-&gt;startMapRegion();</div>
<div class="line"><span class="comment">//Bulk upload the 4 regions of the stash</span></div>
<div class="line">TextureBox texBox0 = stagingTexture-&gt;mapRegion( 1024u, 1024u, 1u, 1u, pixelFormat );</div>
<div class="line">texBox.copyFrom( imageData, 1024u, 1024u, bytesPerRow );</div>
<div class="line">TextureBox texBox1 = stagingTexture-&gt;mapRegion( 1024u, 1024u, 1u, 1u, pixelFormat );</div>
<div class="line">texBox.copyFrom( imageData, 1024u, 1024u, bytesPerRow );</div>
<div class="line">TextureBox texBox2 = stagingTexture-&gt;mapRegion( 1024u, 1024u, 1u, 1u, pixelFormat );</div>
<div class="line">texBox.copyFrom( imageData, 1024u, 1024u, bytesPerRow );</div>
<div class="line">TextureBox texBox3 = stagingTexture-&gt;mapRegion( 1024u, 1024u, 1u, 1u, pixelFormat );</div>
<div class="line">texBox.copyFrom( imageData, 1024u, 1024u, bytesPerRow );</div>
<div class="line">stagingTexture-&gt;stopMapRegion();</div>
<div class="line"><span class="comment">//Perform Stash -&gt; GPU transfers</span></div>
<div class="line">stagingTexture-&gt;upload( texBox0, texture0, 0, 0, <span class="keyword">true</span> );</div>
<div class="line">texture0-&gt;notifyDataIsReady();</div>
<div class="line">stagingTexture-&gt;upload( texBox1, texture1, 0, 0, <span class="keyword">true</span> );</div>
<div class="line">texture1-&gt;notifyDataIsReady();</div>
<div class="line">stagingTexture-&gt;upload( texBox2, texture2, 0, 0, <span class="keyword">true</span> );</div>
<div class="line">texture2-&gt;notifyDataIsReady();</div>
<div class="line">stagingTexture-&gt;upload( texBox3, texture3, 0, 0, <span class="keyword">true</span> );</div>
<div class="line">texture3-&gt;notifyDataIsReady();</div>
</div><!-- fragment --><p><b>Please watch out for three things:</b></p>
<ol type="1">
<li>Having many big StagingTextures can cause out of memory conditions. Incredibly big StagingTextures can also reveal unusual driver/kernel bugs. Don't make them too big. Don't keep too many of them that are small. Most people just need one StagingTexture per texture because uploads won't be frequent.</li>
<li>StagingTextures can run out of space. mapRegion can return a nullptr in <code>TextureBox::data</code> on failure. This space gets restored once stopMapRegion is called.</li>
<li>Use <code>StagingTexture::supportsFormat</code> to check if the parameters are compatible with the upload you're trying to do. However, mapRegion may still fail if it has run out of space. If supportsFormat returns false, it means mapRegion will always fail. If supportsFormat returns true, it means mapRegion may or may not succeed.</li>
<li>Due to API restrictions, StagingTextures larger than 2048x2048 can only call mapRegion for one slice at a time. For textures smaller than that, you can map several slices contiguously.</li>
</ol>
<h3><a class="anchor" id="autotoc_md32"></a>
Upload streaming</h3>
<p>Once you've called <code>StagingTexture::upload</code>; calling <code>StagingTexture::startMapRegion</code> again will stall until the copy is done. You can call <code>StagingTexture::uploadWillStall</code> to know if the StagingTexture is ready or not.</p>
<p>For streaming every frame (e.g. video playback, procedural animation from CPU), you should use two or three StagingTextures (double vs triple buffer), and use one each frame in cycle (do not release these StagingTextures every frame, hold on to them instead).</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Downloading data from TextureGpu into CPU</h3>
<p>For that we'll use AsyncTextureTickets. They're like StagingTextures, but in the opposite direction.</p>
<div class="fragment"><div class="line">AsyncTextureTicket *asyncTicket =</div>
<div class="line">        textureManager-&gt;createAsyncTextureTicket( width, height, depthOrSlices,</div>
<div class="line">                                                  texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#a4b75fd64ef4af817e1ce1e881132b78d">getTextureType</a>(),</div>
<div class="line">                                                  texture-&gt;<a class="code" href="class_ogre_1_1_texture_gpu.html#ad72ce773bbfd3c330fa3fbd5df40a649">getPixelFormat</a>() );</div>
<div class="line">asyncTicket-&gt;download( texture, mip, <span class="keyword">true</span> );</div>
<div class="line"> </div>
<div class="line">TextureBox dstBox = this-&gt;getData( mip - minMip );</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>( asyncTicket-&gt;canMapMoreThanOneSlice() )</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> TextureBox srcBox = asyncTicket-&gt;map( 0 );</div>
<div class="line">    dstBox.copyFrom( srcBox );</div>
<div class="line">    asyncTicket-&gt;unmap();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0; i&lt;asyncTicket-&gt;getNumSlices(); ++i )</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> TextureBox srcBox = asyncTicket-&gt;map( i );</div>
<div class="line">        dstBox.copyFrom( srcBox );</div>
<div class="line">        dstBox.data = dstBox.at( 0, 0, 1u );</div>
<div class="line">        --dstBox.numSlices;</div>
<div class="line">        asyncTicket-&gt;unmap();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">textureManager-&gt;destroyAsyncTextureTicket( asyncTicket );</div>
<div class="line">asyncTicket = 0;</div>
<div class="ttc" id="aclass_ogre_1_1_texture_gpu_html_a4b75fd64ef4af817e1ce1e881132b78d"><div class="ttname"><a href="class_ogre_1_1_texture_gpu.html#a4b75fd64ef4af817e1ce1e881132b78d">Ogre::TextureGpu::getTextureType</a></div><div class="ttdeci">TextureTypes::TextureTypes getTextureType() const</div></div>
</div><!-- fragment --><p>Downloading a single mip for a 2D texture from GPU is straightforward and this code should be enough. But a generic version that works on all types of textures has many small details e.g. what if the TextureGpu uses msaa? It needs to be resolved first.</p>
<p>It is for that reason that we advise to use <code>Image2::convertFromTexture</code>, which handles all the small details.</p>
<h3><a class="anchor" id="autotoc_md34"></a>
Downloading streaming</h3>
<p>Download streaming is very common in the case of video recording and web streaming.</p>
<p>After calling <code>AsyncTextureTicket::download</code>, calling <code>AsyncTextureTicket::map</code> to access the contents can stall until the GPU is done with the transfer. You can check if we're done by calling <code>AsyncTextureTicket::queryIsTransferDone</code>.</p>
<p>You should have two or three AsyncTextureTickets (double vs triple buffer) call download() at frame N, and call map() at frame N+3 and recycle them (rather than destroying them).</p>
<p>Additionally, since you'll be mapping 3 frames afterwards, you should call download( texture, mip, accurateTracking=false );</p>
<p>Using accurateTracking = false reduces tracking overhead, at the expense of more innacurate queryIsTransferDone calls (which are unnecessary if you are waiting for 3 frames to download).</p>
<p><em>Warning:</em> calling queryIsTransferDone too often when accurateTracking = false; will cause <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to switch to accurateTracking, and cause unnecessary overhead and can hurt your performance a lot. This is because <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will assume your code could be stuck in an infinite loop, e.g. </p><div class="fragment"><div class="line">while( !ticket-&gt;queryIsTransferDone() )</div>
<div class="line">    sleep( 1 );</div>
</div><!-- fragment --><p> and this loop would never exit unless <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> switches that ticket to accurate tracking. An warning in the Ogre.log will be logged if this happens.</p>
<p>Accurate tracking isn't slow, but switching from innaccurate to accurate is potentially very slow, depending on many circumstances; as worst case scenario it can produce a full stall (CPU waits until GPU has fully finished doing all pending jobs).</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Difference between depth, numSlices and depthOrSlices</h1>
<p>You may find that throughout <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> we refer to <code>depth</code>, <code>numSlices</code>, and <code>depthOrSlices</code>. They're similar, but conceptually different.</p>
<p><b>Depth</b> is associated with 3D volume textures. Depth is affected by mipmaps. Meaning that a 512x512x256 texture at mip 0 becomes 256x256x128 at mip 1. Current GPUs impose a maximum resolution of 2048x2048x2048 for 3D volume textures. Note however, depending on format, you may run out of GPU memory before reaching such high resolution.</p>
<p><b>NumSlices</b> is associated with everything else: 1D Array &amp; 2D Array textures, cubemap &amp; cubemap array textures. A cubemap has a hardcoded <code>numSlices</code> of 6. A cubemap array must be multiple of 6. Slices are not affected by mipmaps. Meaning that a 512x512x256 texture at mip 0 becomes 256x256x256 at mip 1.</p>
<p><b>depthOrSlices</b> means that we're storing both depth and numSlices in the same variable. When this happens, usually extra information is needed (in other words, is this a 3D texture or not?). For example TextureGpu declares <code>uint32 mDepthOrSlices</code> because it also declares &amp; knows the texture type <code>TextureTypes::TextureTypes mTextureType</code> If mipmapping isn't involved, then the texture type is not required, thus for the maths needed, depthOrSlices is the same as depth or numSlices.</p>
<p>AMD GCN Note: At the time of writing (2018/02/01), all known GCN cards add padding to round texture resolutions to the next power of 2 if they have mipmaps. This means a cubemap of 1024x1024x6 actually takes as much as 1024x1024x8. This is very particularly important for 2D Array textures. Always try to use powers of 2 for your slices, otherwise you'll be wasting memory.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Memory layout of textures and images</h1>
<p>All data manipulated by <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> (e.g. TextureBox, Image2, StagingTextures and AsyncTextureTickets) have the following memory layouts and rules:</p>
<p>Internal layout of data in memory: </p><div class="fragment"><div class="line">Mip0 -&gt; Slice 0, Slice 1, ..., Slice N</div>
<div class="line">Mip1 -&gt; Slice 0, Slice 1, ..., Slice N</div>
<div class="line">...</div>
<div class="line">MipN -&gt; Slice 0, Slice 1, ..., Slice N</div>
</div><!-- fragment --><p>The layout for 3D volume and array textures is the same. The only thing that changes is that for 3D volumes, the depth also decreases with each mip, while for array textures it is kept constant.</p>
<p>For 1D array textures, the number of slices is stored in mDepthOrSlices, not in Height.</p>
<p><b>For code reference, look at _getSysRamCopyAsBox implementation, and TextureBox::at.</b></p>
<p><b>Each row of pixels is aligned to 4 bytes (except for compressed formats that require more strict alignments, such as alignment to the block).</b></p>
<p>You can calculate bytesPerRow by doing: </p><div class="fragment"><div class="line">const uint32 rowAlignment = 4u;</div>
<div class="line">size_t bytesPerRow = Ogre::PixelFormatGpuUtils::getSizeBytes( width, 1u, 1u, 1u, pixelFormat, rowAlignment );</div>
<div class="line">size_t bytesPerImage = Ogre::PixelFormatGpuUtils::getSizeBytes( width, height, 1u, 1u, pixelFormat, rowAlignment );</div>
<div class="line">size_t bytesPerPixel = PixelFormatGpuUtils::getBytesPerPixel( pixelFormat );</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
Troubleshooting errors</h1>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2 code is new. While a lot of bugs have been ironed out already, the streaming code may still contain a few hidden bugs.</p>
<p>Particularly, most of these bugs only surface if textures are loaded in a particular order (because their resolution or pixel formats affect our algorithms in a way they misbehave).</p>
<p>This is problematic with threading because results become non-deterministic: the first run texture A was uploaded then B was uploaded, but on the second run texture A and B were both uploaded as part of the same batch. Likewise, different computers take different time to upload (because their CPUs and drives are slower/faster) unearthing bugs that didn't reproduce in your machine.</p>
<p>To troubleshoot these annoying bugs, you can go to OgreMain/src/OgreTextureGpuManager.cpp and uncomment the following macro: </p><div class="fragment"><div class="line">#define OGRE_FORCE_TEXTURE_STREAMING_ON_MAIN_THREAD 1</div>
</div><!-- fragment --><p>This will force <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to stream using the main thread, thus behaving deterministically in all machines.</p>
<p>Uncommenting the following macro may help finding out what's going on: </p><div class="fragment"><div class="line">#define OGRE_DEBUG_MEMORY_CONSUMPTION 1</div>
</div><!-- fragment --><p>If the problem does not reproduce at all when OGRE_FORCE_TEXTURE_STREAMING_ON_MAIN_THREAD is defined, then play with the following parameters until you nail the problem:</p>
<ul>
<li>mEntriesToProcessPerIteration</li>
<li>mMaxPreloadBytes</li>
<li>mStagingTextureMaxBudgetBytes</li>
<li>mBudget</li>
</ul>
<p>And of course, report your problem and findings in <a href="https://forums.ogre3d.org">https://forums.ogre3d.org</a></p>
<h1><a class="anchor" id="autotoc_md38"></a>
RenderPassDescriptors</h1>
<p>So far we've covered how to use regular textures. But we left out another big one: Render Textures. Well, that's easy: just create a texture with TextureFlags::RenderTexture flag: </p><div class="fragment"><div class="line">mTexture = textureManager-&gt;createTexture( texName, GpuPageOutStrategy::Discard,</div>
<div class="line">                                          TextureFlags::RenderToTexture,</div>
<div class="line">                                          TextureTypes::Type2D );</div>
</div><!-- fragment --><p>But... how do we render to it?</p>
<p>Compositors hide most of the complexity from you, and you will likely not be dealing with RenderPassDescriptors directly.</p>
<p>However if you're still reading here, chances are you're developing something advanced that requires low level rendering, like developing your own Hlms or rendering a third party GUI library.</p>
<p>RenderPassDescriptors describe self contained units of work to submit to GPUs, basically to keep mobile TBDRs happy as described in a previous section.</p>
<p>Setting up a basic RenderPassDescriptors is straightforward:</p>
<div class="fragment"><div class="line">renderPassDesc = renderSystem-&gt;createRenderPassDescriptor();</div>
<div class="line"> </div>
<div class="line">renderPassDesc-&gt;mColour[0].loadAction = LoadAction::Clear;</div>
<div class="line">renderPassDesc-&gt;mColour[0].storeAction = StoreAction::StoreAndMultisampleResolve;</div>
<div class="line">renderPassDesc-&gt;mColour[0].clearColour = ColourValue::White;</div>
<div class="line">renderPassDesc-&gt;mColour[0].allLayers = true;</div>
<div class="line">//Note that resolveTexture should be nullptr if texture isn&#39;t msaa.</div>
<div class="line">//Also if texture-&gt;hasMsaaExplicitResolves() == false, then resolveTexture = texture</div>
<div class="line">//is allowed, as the texture will have an internal texture to be used for resolving</div>
<div class="line">renderPassDesc-&gt;mColour[0].texture = texture;</div>
<div class="line">renderPassDesc-&gt;mColour[0].resolveTexture = resolveTexture;</div>
<div class="line"> </div>
<div class="line">renderPassDesc-&gt;mDepth.loadAction = LoadAction::Clear;</div>
<div class="line">renderPassDesc-&gt;mDepth.storeAction = StoreAction::Store;</div>
<div class="line">renderPassDesc-&gt;mDepth.clearDepth = 1.0f;</div>
<div class="line">renderPassDesc-&gt;mDepth.readOnly = false;</div>
<div class="line">renderPassDesc-&gt;mDepth.texture = depthBufferTexture;</div>
<div class="line"> </div>
<div class="line">//Same with renderPassDesc-&gt;mStencil as with mDepth</div>
<div class="line"> </div>
<div class="line">renderPassDesc-&gt;entriesModified( RenderPassDescriptor::All );</div>
<div class="line"> </div>
<div class="line">renderSystem-&gt;beginRenderPassDescriptor( renderPassDesc, texture, viewportSize,</div>
<div class="line">                                         scissors, overlaysEnabled, true );</div>
<div class="line">renderSystem-&gt;executeRenderPassDescriptorDelayedActions();</div>
<div class="line"> </div>
<div class="line">//Render();</div>
<div class="line"> </div>
<div class="line">renderSystem-&gt;endRenderPassDescriptor();</div>
<div class="line"> </div>
<div class="line">//Do this when you&#39;re done with renderPassDesc to avoid leaks. Also,</div>
<div class="line">//you are supposed to cache renderPassDesc rather than creating it and/or setting it up</div>
<div class="line">//every frame.</div>
<div class="line">renderSystem-&gt;destroyRenderPassDescriptor( renderPassDesc );</div>
</div><!-- fragment --><p>A few notes:</p>
<ol type="1">
<li>executeRenderPassDescriptorDelayedActions is of particular interest to Metal RenderSystem. In this API, blitting operations (copying buffers, copying textures, uploading to / downloading from textures, generating mipmaps) will break rendering. Your "Render()" functions should never contain these operations between executeRenderPassDescriptorDelayedActions and endRenderPassDescriptor. Those operations must be done either before or afterwards.</li>
<li>Calling beginRenderPassDescriptor implies calling endRenderPassDescriptor. It is encouraged to skip endRenderPassDescriptor and just call the next beginRenderPassDescriptor unless this is the last one for this frame, so we can perform certain optimizations in certain APIs. Ideally you should only call endRenderPassDescriptor at the end of the whole frame.</li>
</ol>
<p>Note RenderPassDescriptors have more parameters. For example, you can set which mipmap you want to render to, or which slice in an array. You can also render to a 1024x1024 MSAA texture and resolve the result into the mip 1 of a 2048x2048 texture (mip 1 is 1024x1024).</p>
<p>For further code reference on setting up RenderPassDescriptors you should look into <code>CompositorPass::setupRenderPassDesc</code>.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
DescriptorSetTexture &amp; co.</h1>
<p><em>Note: This section is only relevant to those writing their own Hlms implementations.</em></p>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2 uses a different binding model to make compatibility in the future with Vulkan and D3D12 easier.</p>
<p>Rather than binding one texture at a time into a huge table, these APIs work with the concept of "descriptor sets". We could say in very layman's terms, that these are just an array of textures, and every frame we bind the list instead.</p>
<p>Descriptor sets are managed in a similar way to how HlmsMacroblocks and HlmsBlendblocks are created and destroyed:</p>
<div class="fragment"><div class="line">DescriptorSetTexture baseSet;</div>
<div class="line"> </div>
<div class="line">baseSet.mTextures.push_back( textureA );</div>
<div class="line">baseSet.mTextures.push_back( textureB );</div>
<div class="line">baseSet.mTextures.push_back( textureC );</div>
<div class="line"> </div>
<div class="line">baseSet.mShaderTypeTexCount[VertexShader] = 1u; //textureA is bound to vertex shader</div>
<div class="line">baseSet.mShaderTypeTexCount[PixelShader] = 2u; //textureB &amp; C are bound to pixel shader</div>
<div class="line"> </div>
<div class="line">DescriptorSetTexture *mTexturesDescSet = hlmsManager-&gt;getDescriptorSetTexture( baseSet );</div>
<div class="line"> </div>
<div class="line">*commandBuffer-&gt;addCommand&lt;CbTextures&gt;() =</div>
<div class="line">        CbTextures( texUnit, hazardousTexIdx, mTexturesDescSet );</div>
<div class="line"> </div>
<div class="line">hlmsManager-&gt;destroyDescriptorSetTexture( mTexturesDescSet );</div>
</div><!-- fragment --><p>hazardousTexIdx is a special index for textures that are potential hazards, such as when a texture in particular in the descriptor set could be currently be also bound as RenderTarget (which is illegal / undefined behavior). hazardousTexIdx is in range [0; mTextureDescSet.mTextures.size()). If the value is outside that range, we assume there are no potentially hazardous texture inside the descriptor set. This value is only used by D3D11 &amp; Metal.</p>
<p>Creating a DescriptorSetTexture is this easy, and the same applies for DescriptorSetSampler and DescriptorSetUav. The difference between DescriptorSetTexture and DescriptorSetTexture2 is that the latter allows doing more advanced stuff (such as reinterpretting the texture using a different pixel format)</p>
<p>But if you take a look at <code>OGRE_HLMS_TEXTURE_BASE_CLASS::bakeTextures</code> in Components/Hlms/Common/include/OgreHlmsTextureBaseClass.inl you'll notice this routine that generates the descriptor texture &amp; sampler sets is overly complex. Why is that?</p>
<p>The complexity of bakeTextures comes from two parts:</p>
<p>First, we try to take advantage of D3D11 and Metal. In OpenGL, texture and samplers are tied together. This means that texture at slot 5 must use the sampler at slot 5. The main drawback from this approach is that OpenGL is often limited to 16 textures per shading stage (around 30 textures per shader stage for more modern cards and drivers). While D3D11 and Metal split these two, meaning that texture at slot 5 can use sampler at slot 1. This allows D3D11 and Metal to bind up to 128 textures and 16 samplers at the same time. That's a lot more than what OpenGL can do.</p>
<p>Because supporting more than 16 textures has been a popular complaint about <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.1, and dropping OpenGL is not an option, bakeTextures handles both paths. The code would be simplified if we just assumed one of these paths.</p>
<p>The second reason is descriptor reuse: Material A may use Texture X, Y &amp; Z. While Material B may use Texture Z, Y &amp; X (same textures, different order). This different order would cause two sets to be generated. However we sort and ensure textures are deterministically ordered; therefore the texture sets can be shared between both materials as only one will be generated.</p>
<p>Additionally, please note that descriptor sets need to be invalidated when a texture changes residency, which is why we listen for such changes via notifyTextureChanged.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Does 2.2 interoperate well with the HLMS texture arrays?</h1>
<p>Yes. <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.2 got rid of anything that used the "old" Textures. That includes the <code>HlmsTextureManager</code>.</p>
<p>The new <code>TextureGpuManager</code>, which replaces the old <code>TextureManager</code>, also replaces <code>HlmsTextureManager</code>.</p>
<p>The functionality that was provided by <code>HlmsTextureManager</code> (pretend "a texture" was just one texture when behind the scenes it's actually a slice from a Texture2D Array) became first class citizen in 2.2:</p>
<p>When <code>TextureFlags::AutomaticBatching</code> is present, the TextureGpu will assumes this is a <code>TextureTypes::Type2D</code> texture that behinds the scenes is actually a slices to shared <code>TextureTypes::Texture2DArray</code> texture.</p>
<p>The following routines are relevant when dealing with <code>AutomaticBatching</code> textures:</p>
<div class="fragment"><div class="line">class TextureGpu</div>
<div class="line">{</div>
<div class="line">    bool hasAutomaticBatching(void) const;</div>
<div class="line">    uint32 getInternalSliceStart(void) const;</div>
<div class="line">    const TexturePool* getTexturePool(void) const;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Most functions completely hide the fact that you're dealing with an array for you.</p>
<p>For example <code>getTextureType()</code> will return <code>Type2D</code> (which is actually a lie) and <code>TextureGpu::copyTo</code> will fail if dstBox parameter contains <code>z</code> or <code>sliceStart</code> &gt; 0, because <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will internally add the internal slice start offset to whatever you ask.</p>
<p>Same will happen with StagingTextures and AsyncTextureTickets.</p>
<p>If you want to get the <em>real</em> thing, you need to grab <code>TexturePool::masterTexture</code> (which is a <code>TextureGpu</code>) and <code>TextureGpu::getInternalSliceStart</code> to find the slice.</p>
<p>A lot of functionality from <code>TextureGpuManager</code> will result familiar as they came from <code>HlmsTextureManager</code>. For example:</p>
<div class="fragment"><div class="line">class TextureGpuManager</div>
<div class="line">{</div>
<div class="line">    TextureGpu* createOrRetrieveTexture( const String &amp;name,</div>
<div class="line">                                     const String &amp;aliasName,</div>
<div class="line">                                     GpuPageOutStrategy::GpuPageOutStrategy pageOutStrategy,</div>
<div class="line">                                     uint32 textureFlags,</div>
<div class="line">                                     TextureTypes::TextureTypes initialType,</div>
<div class="line">                                     const String &amp;resourceGroup=BLANKSTRING,</div>
<div class="line">                                     uint32 filters=0 );</div>
<div class="line">};</div>
</div><!-- fragment --><p>Just like with the old <code>HlmsTextureManager</code>, you can specify the resource filename where the texture should be loaded from (via <code>name</code> and <code>resourceGroup</code>) while also specifying an "alias" to reference it with another name.</p>
<p>This allows you for example to load MyNormalMap.png two times, one as a RGBA8_UNORM texture to display its contents, and as a RG8_SNORM texture for use as a normal map, as long as you assign them two different alias names.</p>
<p>At the time of writing a few restrictions from the past still remain though: Unlit will accept both any type of <code>TextureGpu</code>, while PBS will only accept <code>TextureGpu</code> that are <code>Texture2DArray</code> or <code>TextureGpu</code> with <code>AutomaticBatching</code> set (except for the reflections which must be <code>TypeCube</code>).</p>
<p>Since most TextureGpu textures are loaded as <code>AutomaticBatching</code> <b>by default</b>, this limitation on PBS should be less of an issue than it was on 2.1.</p>
<h1><a class="anchor" id="autotoc_md41"></a>
Hlms porting</h1>
<p>If you've done your own Hlms implementation (i.e. you're an advanced user), then there are a few changes you need to be aware:</p>
<p>A lot of texture shared functionality has been moved out of HlmsUnlitDatablock and HlmsPbsDatablock into <a class="el" href="_ogre_hlms_texture_base_class_8h.html">Components/Hlms/Common/include/OgreHlmsTextureBaseClass.h</a></p>
<p>This header uses macros (not ideal, I know) to alter hardcoded maximum numbers of textures supported.</p>
<p>For example HlmsPbsDatablock derives from it by including the header, but previously defining a few macros:</p>
<div class="fragment"><div class="line">#define OGRE_HLMS_TEXTURE_BASE_CLASS HlmsPbsBaseTextureDatablock</div>
<div class="line">#define OGRE_HLMS_TEXTURE_BASE_MAX_TEX NUM_PBSM_TEXTURE_TYPES</div>
<div class="line">#define OGRE_HLMS_CREATOR_CLASS HlmsPbs</div>
<div class="line">    #include &quot;../../Common/include/OgreHlmsTextureBaseClass.h&quot;</div>
<div class="line">#undef _OgreHlmsTextureBaseClassExport</div>
<div class="line">#undef OGRE_HLMS_TEXTURE_BASE_CLASS</div>
<div class="line">#undef OGRE_HLMS_TEXTURE_BASE_MAX_TEX</div>
<div class="line">#undef OGRE_HLMS_CREATOR_CLASS</div>
<div class="line"> </div>
<div class="line">// ... later on ...</div>
<div class="line"> </div>
<div class="line">// Note that we&#39;ve defined #define OGRE_HLMS_TEXTURE_BASE_CLASS HlmsPbsBaseTextureDatablock</div>
<div class="line">// So that the header would define a class named &#39;HlmsPbsBaseTextureDatablock&#39;</div>
<div class="line">class HlmsPbsDatablock : public HlmsPbsBaseTextureDatablock</div>
</div><!-- fragment --><p>What OgreHlmsTextureBaseClass does is to keep track of which textures have been assigned to the material at each slot; and register listeners to these textures whenever the textures finish loading (or are unloaded) in order to alter the DescriptorSetTextures and DescriptorSetSamplers.</p>
<p>Furthermore it is in charge of making sure when using GL3+ that DescriptorSetTextures and DescriptorSetSamplers both match 1:1 (see hasSeparateSamplers), while when using D3D11 &amp; Metal they're separated in order to improve performance and significantly raise the number of textures that can be bound per shader.</p>
<p>OgreHlmsTextureBaseClass also sorts DescriptorSetTextures given a specific criteria to allow sharing of descriptors between different materials (and better draw call sorting) For example if Material X uses texture A then B and Material Y uses texture B then A, OgreHlmsTextureBaseClass sorts the descriptor so that A always comes before B, and thus allow reuse.</p>
<p>Because textures and samplers have been separated, diffuse_map0_idx indicates the index into the texture array, and the new property "diffuse_map0_sampler" indicates the index of the sampler to use.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Things to watch out when porting</h1>
<p><b>Mipmaps</b></p>
<p>In 2.1 getNumMipmaps() = 0 means having just 1 mip (the mip 0). Only the extra mips are counted.</p>
<p>In 2.2 getNumMipmaps() cannot return 0, as the 1 mip is counted.</p>
<p>This can cause off by 1 errors. For example old code:</p>
<div class="fragment"><div class="line">for( size_t i=0; i&lt;=texture-&gt;getNumMipmaps(); ++i )</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//...or</div>
<div class="line">for( size_t i=0; i&lt;texture-&gt;getNumMipmaps() + 1u; ++i )</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//...or</div>
<div class="line">if( texture-&gt;getNumMipmaps() == 0 )</div>
<div class="line">{</div>
<div class="line">    //No extra mips</div>
<div class="line">}</div>
</div><!-- fragment --><p>Must now become:</p>
<div class="fragment"><div class="line">for( size_t i=0; i&lt;texture-&gt;getNumMipmaps(); ++i )</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//...or</div>
<div class="line">if( texture-&gt;getNumMipmaps() == 1 )</div>
<div class="line">{</div>
<div class="line">    //No extra mips</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>TexturePtr is default initialized to 0. TextureGpu is not</b>.</p>
<p>This causes common problems with arrays of textures in C++ i.e.<code>TexturePtr myTextures[5];</code> If you do not initialize your TextureGpu variable(s), they will contain uninitialized values, whereas your old code would be initialized to 0.</p>
<p><b>Compositor textures are non-msaa by default</b>. Use <code>msaa &lt;number of samples&gt;</code> to explicitly set MSAA on a compositor texture or <code>msaa_auto</code> to use the same MSAA setting as the final output of the workspace. Previous behavior was as if <code>msaa_auto</code> was present in all textures unless it was explicitly turned off by you.</p>
<p><b>RTV (Render Target Views) in Compositors are required</b> They're not implicit. In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.1 this was enough to render to a texture when setting up the compositor from C++:</p>
<div class="fragment"><div class="line">TextureDefinitionBase::TextureDefinition *texDef =</div>
<div class="line">        shadowNodeDef-&gt;addTextureDefinition( &quot;tmpCubemap&quot; );</div>
<div class="line"> </div>
<div class="line">texDef-&gt;width   = width;</div>
<div class="line">texDef-&gt;height  = height;</div>
<div class="line">texDef-&gt;depth   = 6u;</div>
<div class="line">texDef-&gt;textureType = TEX_TYPE_CUBE_MAP;</div>
<div class="line">texDef-&gt;formatList.push_back( PF_FLOAT32_R );</div>
<div class="line">texDef-&gt;depthBufferId = 1u;</div>
<div class="line">texDef-&gt;depthBufferFormat = PF_D32_FLOAT;</div>
<div class="line">texDef-&gt;preferDepthTexture = false;</div>
<div class="line">texDef-&gt;fsaa = false;</div>
<div class="line">texDef-&gt;uav = supportsCompute;</div>
</div><!-- fragment --><p>The equivalent code for 2.2 would be the following:</p>
<div class="fragment"><div class="line">TextureDefinitionBase::TextureDefinition *texDef =</div>
<div class="line">        nodeDef-&gt;addTextureDefinition( &quot;tmpCubemap&quot; );</div>
<div class="line"> </div>
<div class="line">texDef-&gt;width   = width;</div>
<div class="line">texDef-&gt;height  = height;</div>
<div class="line">texDef-&gt;depthOrSlices = 6u;</div>
<div class="line">texDef-&gt;textureType = TextureTypes::TypeCube;</div>
<div class="line">texDef-&gt;format = PFG_R32_FLOAT;</div>
<div class="line">texDef-&gt;depthBufferId = 1u;</div>
<div class="line">texDef-&gt;depthBufferFormat = PFG_D32_FLOAT;</div>
<div class="line">texDef-&gt;preferDepthTexture = false;</div>
<div class="line">if( supportsCompute )</div>
<div class="line">    texDef-&gt;textureFlags |= TextureFlags::Uav;</div>
</div><!-- fragment --><p>However this is not enough. We do not render to tmpCubemap. We render to an RTV, which references tmpCubemap. We'll now create this RTV and we will use the convenience function <code>RenderTargetViewDef::setForTextureDefinition</code> which does all the job for us:</p>
<div class="fragment"><div class="line">RenderTargetViewDef *rtv = nodeDef-&gt;addRenderTextureView( &quot;tmpCubemap&quot; );</div>
<div class="line">rtv-&gt;setForTextureDefinition( &quot;tmpCubemap&quot;, texDef );</div>
</div><!-- fragment --><p>Please note a few things things:</p>
<ol type="1">
<li>The RTV doesn't necessarily have to be named the same way as the texture. You could name it "MyRtv" and your node's passes will have to target "MyRtv" instead of "tmpCubemap". We use the same name to avoid user confusion.</li>
<li>setForTextureDefinition did all the heavy lifting because it assumes the RTV will be used to render to just one texture (i.e. tmpCubemap). You can just look at what <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>'s code is doing. More advanced RTV setup (i.e. not using setForTextureDefinition) is for the cases where you need MRT (Multiple Render Target) or want a very specific MSAA resolve behavior.</li>
<li><code>TextureDefinition</code> contains a few variables such as <code>depthBufferId</code>, <code>depthBufferFormat</code> and <code>preferDepthTexture</code> which are then repeated in <code>RenderTargetViewDef</code>. The settings that matters are the ones in <code>RenderTargetViewDef</code> and are often (but not necessarily) just a carbon copy. So why <code>TextureDefinition</code> has a duplicate? It's because when textures are used as output and input for inter-connecting nodes, the RTV settings are lost and the Compositor needs to evaluate at connection time what depth buffer settings the texture prefers. For more information see <code>CompositorPass::setupRenderPassDesc</code> snippet that starts with <code>if( rtv-&gt;isRuntimeAnalyzed() )</code> Also see <a class="el" href="struct_ogre_1_1_render_target_view_def.html#ac6ea3c7e635033ef74f8fe61d9640b6b" title="If the texture comes from an input channel, we don&#39;t have yet enough information, as we&#39;re missing:">Ogre::RenderTargetViewDef::setRuntimeAnalyzed</a> documentation.</li>
</ol>
<p><b>D3D11's specific:</b></p>
<p>You could use <code>getCustomAttribute</code> to retrieve several D3D11 internal pointers. These have changed:</p>
<ul>
<li>"FSAA" + "FSAAHint" -&gt; "FSAA"</li>
<li>"First_ID3D11Texture2D" -&gt; TextureGpu::getCustomAttribute( "ID3D11Resource" )</li>
<li>"ID3D11RenderTargetView" -&gt; RenderPassDescriptor::getCustomAttribute( "ID3D11RenderTargetView" )</li>
<li>"D3DDEVICE", "WINDOW" -&gt; Use Window::getCustomAttribute with the same parameter names </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_migrating_series.html">Migrating Series</a></li><li class="navelem"><a class="el" href="_migrating_21_to_22.html">Migrating from 2.1 to 2.2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
