<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Changes: Objects, Scene &amp; Nodes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_ogre20_changes.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Changes: Objects, Scene &amp; Nodes</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#NamesAreNowOptional">Names are now optional</a></li>
<li class="level1"><a href="#HowToDebugMovableObjectsData">How to debug MovableObjects&#39; (and Nodes) data</a><ul><li class="level2"><a href="#InterpretingArrayVector3">Interpreting ArrayVector3</a></li>
<li class="level2"><a href="#DummyPointers">Dummy pointers instead of NULL</a></li>
</ul>
</li>
<li class="level1"><a href="#AttachmentAndVisibility">Attachment and Visibility</a></li>
<li class="level1"><a href="#AttachingDetachingIsMoreExpensive">Attaching/Detaching is more expensive than hiding</a></li>
<li class="level1"><a href="#AllMovableObjectsRequireSceneNode">All MovableObjects require a SceneNode (Lights &amp; Cameras)</a></li>
<li class="level1"><a href="#DerivedTransforms">Obtaining derived transforms</a></li>
<li class="level1"><a href="#SceneStaticSceneDynamic">SCENE_STATIC and SCENE_DYNAMIC</a><ul><li class="level2"><a href="#SceneStaticNode">What means a Node to be SCENE_STATIC</a></li>
<li class="level2"><a href="#SceneStaticEntities">What means a Entities (and InstancedEntities) to be SCENE_STATIC</a></li>
<li class="level2"><a href="#SceneStaticGeneral">General</a></li>
</ul>
</li>
<li class="level1"><a href="#AssersionCachedOutOfDate">Ogre asserts mCachedAabbOutOfDate or mCachedTransformOutOfDate while in debug mode</a></li>
<li class="level1"><a href="#DerivingRenderable">Custom classes derived from Renderable or MovableObject</a></li>
<li class="level1"><a href="#V2MeshInformation">How do I get the vertex information from the new v2 Mesh classes?</a></li>
<li class="level1"><a href="#V2MeshElementOffset">How do I set the element offsets, vertex buffer&#39;s source and index?</a></li>
<li class="level1"><a href="#SceneLooksDarkDull">My scene looks too dark or dull!</a></li>
<li class="level1"><a href="#GUIWashedOut">I activated gamma correction, but now my GUI textures look washed out!</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="NamesAreNowOptional"></a>
Names are now optional</h1>
<p>Names no longer need to be unique and are optional (ie. two SceneNodes can have the same name). To identify uniqueness, classes derive from <code>IdObject</code>, and use <code>IdObject::getId()</code></p>
<p>Note that, for example, Entities are completely different from SceneNodes (they don't even share a common base class), so it is possible for an <code>Entity</code> and a <code>SceneNode</code> to have the same Id.</p>
<p>You won't find two Entities (or rather, two MovableObjects) with the same Id. Otherwise it's a bug.</p>
<p>This change quite affect the creation calls. For example it's quite common to see this snippet:</p>
<div class="fragment"><div class="line">sceneManager-&gt;createEntity( <span class="stringliteral">&quot;myEntityName&quot;</span>, <span class="stringliteral">&quot;meshName.mesh&quot;</span> );</div>
</div><!-- fragment --><p>However the new definition of create <code>Entity</code> is as follows:</p>
<div class="fragment"><div class="line">Entity* createEntity( <span class="keyword">const</span> String&amp; meshName, <span class="keyword">const</span> String&amp; groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,</div>
<div class="line">        SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );</div>
</div><!-- fragment --><p>In other words, your old snippet will try to look for the mesh <code>myEntityName</code> in the group <code>meshName.mesh</code>; which will probably fail. To port to <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0; one would just need to write:</p>
<div class="fragment"><div class="line">Entity *myEnt = sceneManager-&gt;createEntity( <span class="stringliteral">&quot;meshName.mesh&quot;</span> );</div>
<div class="line">myEnt-&gt;setName( <span class="stringliteral">&quot;myEntityName&quot;</span> ); <span class="comment">//This call is optional</span></div>
</div><!-- fragment --><h1><a class="anchor" id="HowToDebugMovableObjectsData"></a>
How to debug MovableObjects' (and Nodes) data</h1>
<p>All relevant data that needs to be updated every frame is stored in SoA form (Structure of Arrays) as opposed to AoS (Arrays of Structures)</p>
<p>This means that data in memory instead of being placed like the following:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Node</div>
<div class="line">{</div>
<div class="line">    Vector3     pos;</div>
<div class="line">    Quaternion  rotation;</div>
<div class="line">    Vector3     scale;</div>
<div class="line">};</div>
</div><!-- fragment --><p>It is layed out as the following</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Node</div>
<div class="line">{</div>
<div class="line">    Vector3     *pos;</div>
<div class="line">    Quaternion  *rotation;</div>
<div class="line">    Vector3     *scale;</div>
<div class="line">};</div>
</div><!-- fragment --><p>However our setup is actually quite different from other engines approaches, as 4 <code>Vector3</code>s are packed like the following in memory:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Vectors [0; 4)   </th><th class="markdownTableHeadNone">Vectors [4; 8)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">XXXX YYYY ZZZZ   </td><td class="markdownTableBodyNone">XXXX YYYY ZZZZ   </td></tr>
</table>
<p>Debugging SIMD builds can be quite counterintuitive at first, in which case defining <code>OGRE_USE_SIMD 0</code> and recompiling will force <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to use the C version of <code>ArrayMath</code>, and hence only pack 1 <code>Vector3</code> per <code>ArrayVector3</code>.</p>
<p>Nevertheless, debugging SSE builds directly isn't that difficult. MovableObjects store their SoA data in <code>MovableObject::mObjectData</code>. The following screenshot shows it's contents:</p>
<div class="image">
<img src="debug_sse.png" alt=""/>
</div>
    <p>The most important element in this picture is <b>mIndex</b>. Because this was taken from a SSE2 (single precision) build, its value can range between 0 and 3 (inclusive). The macro <code>ARRAY_PACKED_REALS</code> is defined as <code>4</code> for this build to let application know how many floats are being packed together.</p>
<p>In this case, <code>ObjectData::mParents</code> contains the parent nodes of all four <code>MovableObject</code>. In this case our parent is in <code>mObjectData.mParents[1]</code>; because <code>mIndex</code> = 1</p>
<div class="image">
<img src="debug_sse2.png" alt=""/>
</div>
    <p>In the picture above, we can now inspect the parent node of our object. Note that in the watch window adding a comma followed by a number forces MSVC debugger to interpret the variable as an array. Otherwise it may only show you the first element alone. Example: <code>mObjectData.mParents,4</code></p>
<p>The following is part of the declaration of <code>Transform</code> (which is used by <code>Node</code>s):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Transform</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>       mIndex;</div>
<div class="line">    Node            **mParents;</div>
<div class="line">    <span class="comment">/* ... */</span></div>
<div class="line">    <span class="keywordtype">bool</span>    * <a class="code hl_define" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> mInheritOrientation;</div>
<div class="line">};</div>
<div class="ttc" id="a_ogre_platform_8h_html_a6decd303d90f9cd75d6bb79d51ea2154"><div class="ttname"><a href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a></div><div class="ttdeci">#define RESTRICT_ALIAS</div><div class="ttdef"><b>Definition</b> OgrePlatform.h:588</div></div>
</div><!-- fragment --><p>When <code>ARRAY_PACKED_REALS</code> = 4 (i.e. SSE builds), though not strictly correct, we could say <code>mParents</code> is declared as:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Transform</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* ... */</span></div>
<div class="line">    Node            *mParents[4];</div>
<div class="line">    <span class="comment">/* ... */</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Hence to know which <code>mParents</code> belongs to us, we have to look at <code>mParents[mIndex]</code>.</p>
<p>Same happens with <code>mInheritOrientation</code>. When 9 consecutive <code>Node</code>s are created, if we take a look at <code>mParents</code> pointers, we would notice that first 4 point to the same memory location:</p>
<ol type="1">
<li>Transform::mParents = 0x00700000</li>
<li>Transform::mParents = 0x00700000</li>
<li>Transform::mParents = 0x00700000</li>
<li>Transform::mParents = 0x00700000</li>
<li>Transform::mParents = 0x00700010</li>
<li>Transform::mParents = 0x00700010</li>
<li>Transform::mParents = 0x00700010</li>
<li>Transform::mParents = 0x00700010</li>
<li>Transform::mParents = 0x00700020</li>
</ol>
<p>The Transform of the first 4 Nodes will have exactly the same pointers; <b>the only difference is the content of mIndex</b>. When we go to the 5th, the pointers increment by 4 elements. <code>mIndex</code> is used to determine where our data really is. This layout may be a bit hard to grasp at first, but it's quite easy once you get used to it. Notice we satisfy a very important property: all of our pointers are aligned to 16 bytes.</p>
<h2><a class="anchor" id="InterpretingArrayVector3"></a>
Interpreting ArrayVector3</h2>
<p><code>ArrayVector3</code>, <code>ArrayQuaternion</code> and <code>ArrayMatrix4</code> require a bit more of work when watching them through the debugger:</p>
<div class="image">
<img src="debug_arrayvector3.png" alt=""/>
</div>
    <p>Here the debugger is telling us that the center of the Aabb in local space is at (100; 100; 100). We're reading the 3rd column because <code>mIndex</code> is 1; if <code>mIndex</code> were 3; we would have to read the 1st column.</p>
<p><code>m_chunkBase[0]</code> contains four XX<b>X</b>X which are read right to left.</p>
<p><code>m_chunkBase[1]</code> contains four YY<b>Y</b>Y, ours is the second one (starting from the right)</p>
<p><code>m_chunkBase[3]</code> you should've guessed by now contains ZZ<b>Z</b>Z</p>
<p>Note that if, for example, the 4th element (in this case it reads (0, 0, 0)) is an empty slot (i.e. there are only 3 entities in the entire scene); it could contain complete garbage; even NaNs. This is ok. We fill the memory with valid values after releasing memory slots to prevent NaNs &amp; INFs; as some architectures are slowed down when such floating point special is present; but it is possible that some of them slip through (or it is also possible a neighbour Entity actually contains an infinite extent, for example).</p>
<p>Is <code>m_chunkBase</code> a transform matrix? <em>NO</em>. In SSE2 SIMD builds, <code>ArrayVector3</code> packs 4 vectors together (because <code>ARRAY_PACKED_REALS</code> = 4). If 4 Nodes are created named A, B, C, D; the picture above is saying:</p>
<ul>
<li><code>m_chunkBase[0] = { D.x, C.x, B.x, A.x }</code></li>
<li><code>m_chunkBase[1] = { D.y, C.y, B.y, A.y }</code></li>
<li><code>m_chunkBase[2] = { D.z, C.z, B.z, A.z }</code></li>
</ul>
<p>So, to know the contents of B, you need to look at the 3rd column.</p>
<h2><a class="anchor" id="DummyPointers"></a>
Dummy pointers instead of NULL</h2>
<p>Seeing a null pointer in <code>ObjectData::mParents[4]</code> is most likely a bug unless it's temporary. During SoA update; those memory slots that were not initialized (or whose MovableObjects haven't been attached to a SceneNode yet) are set to a dummy pointer owned by the MemoryManager instead of setting to null.</p>
<p>This prevents us from checking that the pointers are null every time we need access to them in SoA loops (which are usually hotspots); with the associated branch misspredictions that may be associated. <b>This is a pattern in Data Oriented Design.</b></p>
<p>Note however, that <code>MovableObject::mParentNode</code> <b>is</b> null when detached (since it isn't a SoA variable) while <code>MovableObject::mObjectData::mParents[mIndex]</code> points to the dummy node. When attached, both variables will point to the same pointer.</p>
<p>Same happens with other pointers like <code>ObjectData::mOwner[]</code> and <code>Transform::mParents[]</code></p>
<h1><a class="anchor" id="AttachmentAndVisibility"></a>
Attachment and Visibility</h1>
<p>In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x an object "was in the scene" when it was attached to a scene node whose ultimate parent was root. Hence a detached entity could never be displayed, and when attached, calling <code>setVisible( false )</code> would hide it.</p>
<p>In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.x, objects are always "in the scene". Nodes just hold position information, can be animated, and can inherit transforms from their parent. When an <code>Entity</code> is no longer associate with a node, it hides itself (<code>setVisible( false )</code> is implicitly called) to avoid being rendered without a position. Multiple entities can share the same position, hence the same <code>Node</code>.</p>
<p>This means that when attaching/detaching to/from a <code>SceneNode</code>, the previous value of <code>MovableObject::getVisible</code> is lost. Furthermore, calling <code>setVisible( true )</code> while detached is illegal and will result in a crash (there is a debug assertion for this).</p>
<h1><a class="anchor" id="AttachingDetachingIsMoreExpensive"></a>
Attaching/Detaching is more expensive than hiding</h1>
<p>Due to how slow was <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x in traversing SceneNodes (aka the Scene Graph), some users recommended to detach its objects or remove the SceneNode from its parent instead of calling <code>setVisible( false )</code>; despite the official documentation stating otherwise.</p>
<p>In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.x this is no longer true, and we do a significant effort to keep updates and iterations as fast as possible. This may have in turn increased the overhead of adding/removing nodes &amp; objects. Therefore hiding objects using setVisible is much more likely to be orders of magnitude faster than destroying them (unless they have to be hidden for a very long time)</p>
<h1><a class="anchor" id="AllMovableObjectsRequireSceneNode"></a>
All MovableObjects require a SceneNode (Lights &amp; Cameras)</h1>
<p>Unless hidden (see <a class="el" href="_ogre20_changes.html#AttachmentAndVisibility">Attachment and Visibility</a>), all <code>MovableObejct</code>s like <code>Entities</code>, <code>InstancedEntities</code>, <code>Light</code>s and even <code>Camera</code>s require being attached to a <code>SceneNode</code>; since <code>Node</code>s are the beholders of the transform (position and rotation).</p>
<p><b>There are no node-less Lights anymore</b>. Their transform data is in the Nodes as it works perfectly with the optimized, streamlined functions (particularly update derived bounding box for computing visibility) and have no longer their own position and direction; which is now hold by the Node.</p>
<p>Another reason for this decision is that combining the transform data from the node with the Light's was inefficient, while the overhead of using the additional Node is virtually eliminated in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0; and furthermore it works better for lights that require more than direction, but a full quaternion (e.g. textured spot lights and area lights).</p>
<p>Functions like <code>Light::getDirection</code> and <code>Light::setDirection</code> will redirect to the scene node, and fail when not attached. Lights when created aren't attached to a SceneNode, so you will have to attach to one first before trying to use it.</p>
<p>Cameras do however have their own position and rotation for simplicity and avoid breaking older coder so much (unlike Lights). Performance wasn't a concern since it's normal to have less than a dozen cameras in a scene, compared to possibly thousands of lights. By default cameras are attached to the root scene node on creation.</p>
<p>Therefore if your application was attaching Cameras to SceneNodes of your own, you will have to detach it first calling <code>Camera::detachFromParent</code>; <em>otherwise the engine will raise the well-known exception that the object has already been attached to a node.</em></p>
<h1><a class="anchor" id="DerivedTransforms"></a>
Obtaining derived transforms</h1>
<p>In the past, obtaining the derived position was a matter of calling <code>SceneNode::_getDerivedPosition</code>. <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> would keep a boolean flag to know if the derived transform was dirty or not. Same happened with orientation and scale.</p>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.0 removed the flag has for the sake of performance[^1] (except for debug builds which use a flag for triggering assertions).</p>
<p>The following functions will use the last cached derived transform without updating:</p>
<ul>
<li><code>Node::_getDerivedPosition</code></li>
<li><code>Node::_getDerivedOrientation</code></li>
<li><code>Node::_getDerivedScale</code></li>
</ul>
<p>What this means that the following snippet won't work as expected, and will trigger an assert in debug mode:</p>
<div class="fragment"><div class="line">sceneNode-&gt;setPosition( 1, 1, 1 );</div>
<div class="line"><a class="code hl_class" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a> derivedPos = sceneNode-&gt;_getDerivedPosition();</div>
<div class="ttc" id="aclass_ogre_1_1_vector3_html"><div class="ttname"><a href="class_ogre_1_1_vector3.html">Ogre::Vector3</a></div><div class="ttdoc">Standard 3-dimensional vector.</div><div class="ttdef"><b>Definition</b> OgreVector3.h:52</div></div>
</div><!-- fragment --><p>All derived transforms are efficiently updated in <code>SceneManager::updateAllTransforms</code> which happens inside updateSceneGraph. You should start using the derived transforms after the scene graph has been updated. Users can have fine-grained control on when the scene graph is updated by manually implementing (or modifying) <code>Root::renderOneFrame</code></p>
<p>Nonetheless, if the number of nodes that need to be up to date is low, users can call the "Updated" variants of these functions:</p>
<ul>
<li><code>Node::_getDerivedPositionUpdated</code></li>
<li><code>Node::_getDerivedOrientationUpdated</code></li>
<li><code>Node::_getDerivedScaleUpdated</code></li>
</ul>
<p>These functions will force an update of the parents' derived transforms, and its own. It is slower and not recommended for usage of a massive number of nodes. If such thing is required, consider refactoring your engine design to require the derived transforms after <code>SceneManager::updateAllTransforms</code>.</p>
<p>The following snippet demonstrates how to use updated variants:</p>
<div class="fragment"><div class="line">sceneNode-&gt;setPosition( 1, 1, 1 );</div>
<div class="line">sceneNode-&gt;setOrientation( Quaternion( Radian( 4.0f ), Vector3::UNIT_X ) );</div>
<div class="line">sceneNode-&gt;setScale( 6, 1, 2 );</div>
<div class="line"> </div>
<div class="line">Vector3 derivedPos  = sceneNode-&gt;_getDerivedPositionUpdated();</div>
<div class="line"><span class="comment">//There&#39;s no need to call the Updated variants anymore. The node is up to date now.</span></div>
<div class="line">Quaternion derivedRot   = sceneNode-&gt;_getDerivedQuaternion();</div>
<div class="line">Vector3 derivedScale    = sceneNode-&gt;_getDerivedScale();</div>
</div><!-- fragment --><p><code>MovableObject</code>'s world Aabb &amp; radius follows the same pattern and subject to the same issues.</p>
<h1><a class="anchor" id="SceneStaticSceneDynamic"></a>
SCENE_STATIC and SCENE_DYNAMIC</h1>
<p>Both MovableObjects[^2] and Nodes have a setting upon creation to specify whether they're dynamic or static. Static objects are meant to never move, rotate or scale; or at least they do it infrequently.</p>
<p>By default all objects are dynamic. Static objects can save a lot of performance on CPU side (and sometimes GPU side, for example with some instancing techniques) by telling the engine they won't be changing often.</p>
<h2><a class="anchor" id="SceneStaticNode"></a>
What means a Node to be SCENE_STATIC</h2>
<ul>
<li>Nodes created with <code>SCENE_STATIC</code> won't update their derived position/rotation/scale every frame. This means that modifying (eg) a static node position won't actually take effect until <code>SceneManager::notifyStaticDirty( mySceneNode )</code> is called or some other similar call that foces an update.</li>
</ul>
<p>If the static scene node is child of a dynamic parent node, modifying the dynamic node will not cause the static one to notice the change until explicitly notifying the <code>SceneManager</code> that the child node should be updated.</p>
<p>If a static scene node is child of another static scene node, explicitly notifying the <code>SceneManager</code> of the parent's change automatically causes the child to be updated as well.</p>
<p>Having a dynamic node to be child of a static node is perfectly plausible and encouraged, for example a moving pendulum hanging from a static clock. Having a static node being child of a dynamic node doesn't make much sense, and is probably a bug (unless the parent is the root node).</p>
<h2><a class="anchor" id="SceneStaticEntities"></a>
What means a Entities (and InstancedEntities) to be SCENE_STATIC</h2>
<p>Static entities are scheduled for culling and rendering like dynamic ones, but won't update their world AABB bounds (even if their scene node they're attached to changes) Static entities will update their aabb if user calls <code>SceneManager::notifyStaticDirty( myEntity )</code> or the static node they're attached to was also flagged as dirty. Note that updating the node's position doesn't flag the node as dirty (it's not implicit) and hence the entity won't be updated either.</p>
<p>Static entities can only be attached to static nodes, and dynamic entities can only be attached to dynamic nodes.</p>
<h2><a class="anchor" id="SceneStaticGeneral"></a>
General</h2>
<p>On most cases, changing a single static entity or node (or creating more) can cause a lot of other static objects to be scheduled to update, so don't do it often, <b>and do it all in the same frame</b>. An example is doing it at startup (i.e. during loading time)</p>
<p>Entities &amp; Nodes can switch between dynamic &amp; static at runtime by calling setStatic. However InstancedEntities can't.</p>
<p>You need to destroy the <code>InstancedEntity</code> and create a new one if you wish to switch (which, by the way, isn't expensive because batches preallocate the instances) InstancedEntities with different SceneMemoryMgrTypes will never share the same batch.</p>
<blockquote class="doxtable">
<p>&zwj; Attention #1!</p>
<p>Calling <code>SceneNode::setStatic</code> will also force a call to <code>MovableObject::setStatic</code> to all of its attached objects. If there are objects you wish not to switch flags, detach them first, and then reattach. If there are InstancedEntities attached to that node, you have to detach them first as they can't directly switch between types. Otherwise the engine will raise an exception.</p>
<p>Attention #2!</p>
<p>Calling <code>setStatic( true )</code> when it was previously false will automatically call <code>notifyStaticDirty</code> for you. </p>
</blockquote>
<p><b>Q: Do the changes mean that you can set a "static"-flag on any entity and it automatically gets treated as static geometry and the batch count goes down when there are many static entities sharing the same material?</b></p>
<p>A: No and yes. On normal entities, "static" allows <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to avoid updating the SceneNode transformation every frame (because it doesn't change) and the AABB bounds from the Entity (because it doesn't change either). This yields massive performance bump. But there is no batch count going down.</p>
<p>When using Instancing however, we're already batching everything together that has the same material, so it is indeed like Static Geometry, except that we cull per instance basis (which puts a bit more strain on CPU, but allows for very fine grained frustum culling for the GPU, giving it less work), and 2.0's culling code is several times faster than 1.9's.</p>
<p>When using normal entities, batch count won't go down when using the "static" flag. However it will greatly improve performance compared to 1.9, because we're skipping the scene node transform &amp; AABB update phases, and that takes a lot of CPU time.</p>
<h1><a class="anchor" id="AssersionCachedOutOfDate"></a>
Ogre asserts mCachedAabbOutOfDate or mCachedTransformOutOfDate while in debug mode</h1>
<p>If you get assertions that <code>mCachedAabbOutOfDate</code> or <code>mCachedTransformOutOfDate</code> are true, they mean mean that the derived world AABB wasn't updated but was attempted to be used, or that the derived transform[^3] was out of date and an attempt to use it was made; respectively.</p>
<p>They can trigger for various reasons:</p>
<ol type="1">
<li><p class="startli">Nodes/Objects are of type <code>SCENE_STATIC</code> and their data changed (i.e. you called <code>setPosition</code>) but no call to <code>SceneManager::notifyStaticDirty</code> was made.</p>
<p class="startli">Solution: Call <code>SceneManager::notifyStaticDirty</code>, or use a function that implicitly calls that function.</p>
</li>
<li><p class="startli">You've manually modified their data (i.e. you called setPosition) after <code>SceneManager::updateAllTransforms</code> or <code>SceneManager::updateAllBounds</code> happened; most likely through a listener.</p>
<p class="startli">Solutions:</p><ol type="a">
<li>Move your calculations so that they happen before <code>updateAllTransforms</code>.</li>
<li>If it's just a few nodes, call <code>Node::_getFullTransformUpdated</code> or <code>MovableObject::getWorldAabbUpdate</code> after modifying the object to force a full update on that node/entity only. You only need to call these functions once, and its transform will be updated and cached; if you keep calling the "Updated" variations, you're just going to eat CPU cycles recalculating the whole transform every time.</li>
<li>If it they're many nodes/entities, manually call <code>updateAllTransforms</code>/<code>updateAllBounds</code> again.</li>
</ol>
</li>
<li><p class="startli">It's a bug in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>. Because the refactor was very large, some components still try to modify nodes and movables after the call to <code>updateAllTransforms</code>/<code>updateAllBounds</code>.</p>
<p class="startli">Solution: <a href="https://ogre3d.atlassian.net/browse/OGRE">Report the bug to JIRA</a>. When we get to refactor that faulty component, the node will be touched before the call to <code>updateAllTransforms</code>, but if the component isn't yet scheduled for refactor we might just fix it by calling <code>getDerivedPositionUpdated</code></p>
</li>
</ol>
<h1><a class="anchor" id="DerivingRenderable"></a>
Custom classes derived from Renderable or MovableObject</h1>
<p>In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x; advanced users could submit or inject <code>Renderable</code>s directly to the <code>RenderQueue</code> without the need of a <code>MovableObject</code>. This was possible because there was redundancy (both classes duplicated the same data), or <code>Renderable</code> used virtual functions to query data from the <code>MovableObject</code> (which advanced users could overload to submit this data directly instead of relying on a MO).</p>
<p>Since <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.x; a Renderable <em><b>must</b></em> have a <code>MovableObject</code> linked to it, as <code>RenderQueue</code>'s <code>addRenderable</code> function requires two parameters, one for the <code>MovableObject</code>, another for the <code>Renderable</code>. Providing a null pointer as the <code>MovableObject</code> will likely result in a crash.</p>
<p>Multiple <code>Renderable</code>s can still share the same <code>MovableObject</code> though and implementations don't have to derive from both at the same time either.</p>
<p>For objects that are part of the scene, <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 1.x employed the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a> to query all the <code>Renderable</code>s that a <code>MovableObject</code> contained. In <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.x; this pattern was removed.</p>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> users implementing their own classes that derive from MO must populate the <code>MovableObject::mRenderables</code> vector instead; which the <code>SceneManager</code> will access directly to add the renderables to the <code>RenderQueue</code>.</p>
<p>The reason behind this change is performance. The visitor pattern is too costly for this task.</p>
<h1><a class="anchor" id="V2MeshInformation"></a>
How do I get the vertex information from the new v2 Mesh classes?</h1>
<p>Once you have the <code>Mesh</code> pointer, get the <code>Submesh</code>. Then grab the Vao:</p>
<div class="fragment"><div class="line">Mesh *mesh;</div>
<div class="line">SubMesh *submesh = mesh-&gt;getSubMesh(0);</div>
<div class="line">VertexArrayObjectArray vaos = submesh-&gt;mVao;</div>
</div><!-- fragment --><p>There is one Vao per LOD level. Note that multiple LODs may share the same vertex buffers:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( !vaos.empty() )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//Get the first LOD level</span></div>
<div class="line">    VertexArrayObject *vao = vaos[0];</div>
<div class="line">    <span class="keyword">const</span> VertexBufferPackedVec &amp;vertexBuffers = vao-&gt;getVertexBuffers();</div>
<div class="line">    IndexBufferPacked *indexBuffer = vao-&gt;getIndexBuffer();</div>
<div class="line">}</div>
</div><!-- fragment --><p>From there you can get the vertex declaration for each vertex buffer:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0; i&lt;vertexBuffers.size(); ++i )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//There could be more than one vertex buffer, or even none!</span></div>
<div class="line">    VertexBufferPacked *vertexBuffer = vertexBuffers[i];</div>
<div class="line">    <span class="keyword">const</span> VertexElement2Vec &amp;vertexElements = vertexBuffer-&gt;getVertexElements();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="V2MeshElementOffset"></a>
How do I set the element offsets, vertex buffer's source and index?</h1>
<p>The v1 interface allowed to explicitly specify this data. However this can be automatically calculated:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>VertexDeclaration</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> VertexElement&amp; addElement(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> source,</div>
<div class="line">                                            <span class="keywordtype">size_t</span> offset,</div>
<div class="line">                                            VertexElementType theType,</div>
<div class="line">                                            VertexElementSemantic semantic,</div>
<div class="line">                                            <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> index = 0);</div>
<div class="line">};</div>
</div><!-- fragment --><p>The offset can be automatically calculated from the previous element's size. The index parameter can also be automatically calculated by counting the numbers of elements already in the array. And the source can be arranged by having an array of vertex elements.</p>
<p>The following code is equivalent, v1 vs v2 format:</p>
<div class="fragment"><div class="line"><span class="comment">//V1 format</span></div>
<div class="line">v1::VertexDeclaration vertexDecl;</div>
<div class="line"><span class="keywordtype">size_t</span> offset = 0;</div>
<div class="line">vertexDecl.addElement( 0, offset, VET_FLOAT3, VES_POSITION, 0 );</div>
<div class="line">offset += vertexDecl.getVertexSize();</div>
<div class="line">vertexDecl.addElement( 0, offset, VET_FLOAT3, VES_NORMAL, 0 );</div>
<div class="line">offset += vertexDecl.getVertexSize();</div>
<div class="line">vertexDecl.addElement( 0, offset, VET_FLOAT2, VES_TEXTURE_COORDINATES, 0 );</div>
<div class="line">offset += vertexDecl.getVertexSize();</div>
<div class="line"><span class="comment">//Second pair of tex coords</span></div>
<div class="line">vertexDecl.addElement( 0, offset, VET_FLOAT2, VES_TEXTURE_COORDINATES, 1 );</div>
<div class="line">offset += vertexDecl.getVertexSize();</div>
<div class="line"><span class="comment">//Third pair of tex coords, in a second buffer</span></div>
<div class="line">vertexDecl.addElement( 1, 0, VET_FLOAT2, VES_TEXTURE_COORDINATES, 2 );</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">//V2 format</span></div>
<div class="line">VertexElement2VecVec multVertexDecl;</div>
<div class="line">multVertexDecl.reserve( 2 ); <span class="comment">//Not strictly necessary.</span></div>
<div class="line">VertexElement2Vec vertexDecl;</div>
<div class="line">vertexDecl.reserve( 4 ); <span class="comment">//Not strictly necessary.</span></div>
<div class="line">vertexDecl.push_back( VertexElement2( VET_FLOAT3, VES_POSITION ) );</div>
<div class="line">vertexDecl.push_back( VertexElement2( VET_FLOAT3, VES_NORMAL ) );</div>
<div class="line">vertexDecl.push_back( VertexElement2( VET_FLOAT2, VES_TEXTURE_COORDINATES ) );</div>
<div class="line"><span class="comment">//Second pair of tex coords</span></div>
<div class="line">vertexDecl.push_back( VertexElement2( VET_FLOAT2, VES_TEXTURE_COORDINATES ) );</div>
<div class="line">multVertexDecl.push_back( vertexDecl ); <span class="comment">//Add the decl. of the first buffer</span></div>
<div class="line">vertexDecl.clear();</div>
<div class="line"><span class="comment">//Third pair of tex coords, in a second buffer</span></div>
<div class="line">vertexDecl.push_back( VertexElement2( VET_FLOAT2, VES_TEXTURE_COORDINATES ) );</div>
<div class="line">multVertexDecl.push_back( vertexDecl ); <span class="comment">//Add the decl. of the second buffer</span></div>
</div><!-- fragment --><p>This method is more convenient as users often messed up the offset argument (i.e. forgot to update it), and more compact too. After all it's just an <code>std::vector</code> container. The only gotcha is that the order in which elements are inserted into the vector is now relevant.</p>
<p>You can use the static function <code>VaoManager::calculateVertexSize( const VertexElement2Vec &amp;vertexElements )</code> to calculate the vertex size in bytes that a declaration vector is holding.</p>
<h1><a class="anchor" id="SceneLooksDarkDull"></a>
My scene looks too dark or dull!</h1>
<ol type="1">
<li>Check you're using <b>GAMMA CORRECTION</b>. If you're letting <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> create the <code>RenderWindow</code> through the configuration, this snippet can force it:</li>
</ol>
<div class="fragment"><div class="line">mRoot-&gt;getRenderSystem()-&gt;setConfigOption( <span class="stringliteral">&quot;sRGB Gamma Conversion&quot;</span>, <span class="stringliteral">&quot;Yes&quot;</span> );</div>
<div class="line">mRoot-&gt;initialise(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p>If you're manually creating the <code>RenderWindow</code>, then you need this snippet:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ogre_1_1_std_map.html">Ogre::NameValuePairList</a> params;</div>
<div class="line">params.insert( std::make_pair(<span class="stringliteral">&quot;gamma&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>) );</div>
<div class="line">mRenderWindow = <a class="code hl_function" href="class_ogre_1_1_root.html#a7804860e0c2f1d6f69c9659125a48abb">Ogre::Root::getSingleton</a>().<a class="code hl_function" href="class_ogre_1_1_root.html#a8403735a385c7f13075cc6a1ed52f472">createRenderWindow</a>( windowTitle, width, height, fullscreen, &amp;params );</div>
<div class="ttc" id="aclass_ogre_1_1_root_html_a7804860e0c2f1d6f69c9659125a48abb"><div class="ttname"><a href="class_ogre_1_1_root.html#a7804860e0c2f1d6f69c9659125a48abb">Ogre::Root::getSingleton</a></div><div class="ttdeci">static Root &amp; getSingleton()</div><div class="ttdoc">Override standard Singleton retrieval.</div></div>
<div class="ttc" id="aclass_ogre_1_1_root_html_a8403735a385c7f13075cc6a1ed52f472"><div class="ttname"><a href="class_ogre_1_1_root.html#a8403735a385c7f13075cc6a1ed52f472">Ogre::Root::createRenderWindow</a></div><div class="ttdeci">Window * createRenderWindow(const String &amp;name, uint32 width, uint32 height, bool fullScreen, const NameValuePairList *miscParams=0)</div><div class="ttdoc">Creates a new rendering window.</div></div>
<div class="ttc" id="aclass_ogre_1_1_std_map_html"><div class="ttname"><a href="class_ogre_1_1_std_map.html">Ogre::StdMap&lt; String, String &gt;</a></div></div>
</div><!-- fragment --><p>PBS expects gamma correction, otherwise it won't look right.</p>
<ol type="1">
<li>It is a common misconception to switch to a PBS pipeline and expect everything to still work as it was. The material parameters may need serious adjustments. High Fresnel coefficient can take away the diffuse component out of the material, which can result in darker materials, roughness coefficient can also directly affect how dark or bright the material looks.</li>
</ol>
<p>Even the colours are different, as real life values should be used. A white material of RGB (1.0, 1.0, 1.0) means an incredibly bright material. Not even paper is so white.</p>
<p><b>PBS also work best with HDR pipelines</b> because real life values means the sun has a colour power in the <a href="http://en.wikipedia.org/wiki/Lux#Illuminance">tens thousands of lums</a> (see also <a href="http://docs.cryengine.com/display/SDKDOC2/Lighting+Levels+using+Physically+Based+Shading">Crytek's reference</a>; see <a href="http://www.slideshare.net/DICEStudio/moving-frostbite-to-physically-based-rendering">Frostbite's slides</a> starting 35). Of course without HDR, a sun power that bright would definitely overflow a regular 32-bit RGBA render target.</p>
<p>Colour values need to be calibrated, see <a href="http://blogs.unity3d.com/2015/02/18/working-with-physically-based-shading-a-practical-approach/">Unity's</a>, <a href="https://seblagarde.wordpress.com/2014/04/14/dontnod-physically-based-rendering-chart-for-unreal-engine-4/">Sebastien Lagarde's</a> (<a href="https://seblagarde.wordpress.com/2011/08/17/feeding-a-physical-based-lighting-mode/">more</a>) and <a href="https://seblagarde.wordpress.com/2011/08/17/feeding-a-physical-based-lighting-mode/">FarCry's</a> (<a href="http://blog.selfshadow.com/publications/s2012-shading-course/mcauley/s2012_pbs_farcry3_slides_v2.pptx">more from FarCry</a>).</p>
<p>Even textures may need to be tweaked, see <a href="http://www.crytek.com/download/gdce2013_shining_the_light_on_crysis_3_donzallaz_final_plus_bonus.pdf">Crytek's slides</a> (slide 56) about what constitutes a "good" diffuse texture and a "bad" diffuse texture (should contain barely any self shadowing; detail is given by the gloss map and a very strong normal map that usually looks bad if look through 3DS Max or Maya). This is a common cause for scenes to look "dull" and lifeless.</p>
<p>Bottom line, this is an art problem, not a technical one.</p>
<ol type="1">
<li>By default the PBS implementation will divide the diffuse colour by <code>PI</code> for correctness. If you're using an LDR pipeline instead of an HDR one; set the light's power (<code>Light::setPowerScale</code>) to <code>PI</code> (3,14159265...) to compensate.</li>
</ol>
<h1><a class="anchor" id="GUIWashedOut"></a>
I activated gamma correction, but now my GUI textures look washed out!</h1>
<p>The <code>HlmsTextureManager</code> will load diffuse textures w/ gamma correction to avoid the problem.</p>
<p>However if you're loading them via external means (i.e. using the regular <code>TextureManager</code>; for example CEGUI) you will need to load them with gamma correction explicitly.</p>
<p>[^1]: This is a performance optimization. For a reasoning behind this, read the <a href="http://ogre3d.org/forums/viewtopic.php?f=25&amp;t=75459">Ogre 2.0 design slides</a>.</p>
<p>[^2]: i.e. Entities, InstancedEntities</p>
<p>[^3]: Derived position, orientation, scale or the 4x4 matrix transform. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_introduction_and_changes.html">Introduction &amp; Changes from Ogre 1.x</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
