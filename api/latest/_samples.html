<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre Next Samples (Feature demonstrations)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE-Next
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_samples.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> Next Samples (Feature demonstrations) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#forward3d">Showcase: Forward3D</a></li>
<li class="level1"><a href="#hdr">Showcase: HDR</a></li>
<li class="level1"><a href="#hdrsmaa">Showcase: HDR/SMAA</a></li>
<li class="level1"><a href="#pbsmaterials">Showcase: PBS Materials</a></li>
<li class="level1"><a href="#postprocessing">Showcase: Post Processing</a></li>
<li class="level1"><a href="#animationtagpoints">API Usage: Animation tag points</a></li>
<li class="level1"><a href="#arealighapprox">API Usage: Area Light Approximation</a></li>
<li class="level1"><a href="#customrenderable">API Usage: Custom Renderable</a></li>
<li class="level1"><a href="#decals">API Usage: Decals</a></li>
<li class="level1"><a href="#dynamicgeometry">API Usage: Dynamic Geometry</a></li>
<li class="level1"><a href="#iesprofiles">API Usage: IES Photometric Profiles</a></li>
<li class="level1"><a href="#sharedskeleton">API Usage: Shared Skeleton</a></li>
<li class="level1"><a href="#instancedstero">API Usage: Instanced Stereo</a></li>
<li class="level1"><a href="#instantradiosity">API Usage: Instant Radiosity</a></li>
<li class="level1"><a href="#localcubemaps">API Usage: Local Reflections Using Parallax Corrected Cubemaps</a></li>
<li class="level1"><a href="#localcubemapsmp">API Usage: Local Reflections Using Parallax Corrected Cubemaps With Manual Probes</a></li>
<li class="level1"><a href="#autolod">API Usage: Automatic LOD Generation</a></li>
<li class="level1"><a href="#morphanimation">API Usage: Morph Animations</a></li>
<li class="level1"><a href="#autopcc">API Usage: Automatically Placed Parallax Corrected Cubemap Probes Via PccPerPixelGridPlacement</a></li>
<li class="level1"><a href="#planarreflections">API Usage: Planar Reflections</a></li>
<li class="level1"><a href="#refractions">API Usage: Refractions</a></li>
<li class="level1"><a href="#sceneformat">API Usage: SceneFormat Export / Import Sample</a></li>
<li class="level1"><a href="#ssreflections">API Usage: Screen Space Reflections</a></li>
<li class="level1"><a href="#shadowdebug">API Usage: Shadow Map Debugging</a></li>
<li class="level1"><a href="#shadowfromcode">API Usage: Shadow Map From Code</a></li>
<li class="level1"><a href="#staticshadowmap">API Usage: Static Shadow Map</a></li>
<li class="level1"><a href="#stenciltest">API Usage: Stencil Test</a></li>
<li class="level1"><a href="#stereorendering">API Usage: Stereo Rendering</a></li>
<li class="level1"><a href="#updatedecal">API Usage: Updating Decals And Area Lights&#39; Textures</a></li>
<li class="level1"><a href="#v1interface">API Usage: Ogre V1 Interfaces</a></li>
<li class="level1"><a href="#onmanualobject">API Usage: Ogre Next Manual Object</a></li>
<li class="level1"><a href="#v2Mesh">API Usage: Ogre Next V2 Meshes</a></li>
<li class="level1"><a href="#tutorial00">Tutorial: Tutorial 00 - Basic</a></li>
<li class="level1"><a href="#tutorial01">Tutorial: Tutorial 01 - Initialisation</a></li>
<li class="level1"><a href="#tutorial02">Tutorial: Tutorial 02 - Variable Framerate</a></li>
<li class="level1"><a href="#tutorial03">Tutorial: Tutorial 03 - Deterministic Loop</a></li>
<li class="level1"><a href="#tutorial04">Tutorial: Tutorial 04 - Interpolation Loop</a></li>
<li class="level1"><a href="#tutorial05">Tutorial: Tutorial 05 - Multithreading Basics</a></li>
<li class="level1"><a href="#tutorial06">Tutorial: Tutorial 06 - Multithreading</a></li>
<li class="level1"><a href="#compute01">Tutorial: Compute 01 - UAV Textures</a></li>
<li class="level1"><a href="#compute02">Tutorial: Compute 02 - UAV Buffers</a></li>
<li class="level1"><a href="#tut_distortion">Tutorial: Distortion</a></li>
<li class="level1"><a href="#dyncubemap">Tutorial: Dynamic Cube Map</a></li>
<li class="level1"><a href="#eglheadless">Tutorial: EGL Headless</a></li>
<li class="level1"><a href="#openVR">Tutorial: Open VR</a></li>
<li class="level1"><a href="#reconpfromd">Tutorial: Reconstructing Position From Depth</a></li>
<li class="level1"><a href="#skypost">Tutorial: Rendering Sky As A Postprocess With A Single Shader</a></li>
<li class="level1"><a href="#SMAA">Tutorial: SMAA</a></li>
<li class="level1"><a href="#ssao">Tutorial: SSAO</a></li>
<li class="level1"><a href="#terrain">Tutorial: Terra Terrain</a></li>
<li class="level1"><a href="#texturebaking">Tutorial: Texture Baking</a></li>
<li class="level1"><a href="#uav1">Tutorial: UAV Setup 1 Example</a></li>
<li class="level1"><a href="#uav2">Tutorial: UAV Setup 2 Example</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_manual_Samples"></a></p>
<p>Here is a list of all the samples provided with <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> Next and the features that they demonstrate. They are seperated into three categories: Showcases, API usage &amp; Tutorials. The samples can be downloaded as a binary package from <a href="https://github.com/OGRECave/ogre-next/releases">github.</a></p>
<h1><a class="anchor" id="forward3d"></a>
Showcase: Forward3D</h1>
<p>This sample demonstrates Forward3D &amp; Clustered techniques. These techniques are capable of rendering many non shadow casting lights.</p>
<p><img src="showcase_forward3d.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="hdr"></a>
Showcase: HDR</h1>
<p>This sample demonstrates the HDR (High Dynamic Range) pipeline in action. HDR combined with PBR let us use real world values as input for our lighting and a real world scale such as lumen, lux and EV Stops.</p>
<p><img src="showcase_hdr.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="hdrsmaa"></a>
Showcase: HDR/SMAA</h1>
<p>This sample demonstrates HDR in combination with SMAA.</p>
<p><img src="showcase_hdrsmaa.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="pbsmaterials"></a>
Showcase: PBS Materials</h1>
<p>This sample demonstrates the PBS material system.</p>
<p><img src="showcase_pbsmaterial.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="postprocessing"></a>
Showcase: Post Processing</h1>
<p>This sample demonstrates using the compositor for postprocessing effects.</p>
<p><img src="showcase_postprocessing.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="animationtagpoints"></a>
API Usage: Animation tag points</h1>
<p>This sample demonstrates multiple ways in which TagPoints are used to attach to bones.</p>
<p><img src="api_animationtag.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="arealighapprox"></a>
API Usage: Area Light Approximation</h1>
<p>This sample demonstrates area light approximation methods.</p>
<p><img src="api_arealightapprox.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="customrenderable"></a>
API Usage: Custom Renderable</h1>
<p>This sample demonstrates creating a custom class derived from both MovableObject and Renderable for fine control over rendering. Also see related DynamicGeometry sample.</p>
<p><img src="api_customrenderable.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="decals"></a>
API Usage: Decals</h1>
<p>This sample demonstrates screen space decals.</p>
<p><img src="api_decal.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="dynamicgeometry"></a>
API Usage: Dynamic Geometry</h1>
<p>This sample demonstrates creating a Mesh programmatically from code and updating it.</p>
<p><img src="api_dynamicgeom.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="iesprofiles"></a>
API Usage: IES Photometric Profiles</h1>
<p>This sample demonstrates the use of IES photometric profiles.</p>
<p><img src="api_lesprofiles.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="sharedskeleton"></a>
API Usage: Shared Skeleton</h1>
<p>This sample demonstrates the importing of animation clips from multiple .skeleton files directly into a single skeleton from a v2Mesh and also how to share the same skeleton instance between components of the same actor/character. For example, an RPG player wearing armour, boots, helmets, etc. In this sample, the feet, hands, head, legs and torso are all separate items using the same skeleton.</p>
<p><img src="api_sharedskeleton.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="instancedstero"></a>
API Usage: Instanced Stereo</h1>
<p>This sample demonstrates instanced stereo rendering. Related to VR.</p>
<h1><a class="anchor" id="instantradiosity"></a>
API Usage: Instant Radiosity</h1>
<p>This sample demonstrates the use of 'Instant Radiosity' (IR). IR traces rays in CPU and creates a VPL (Virtual Point Light) at every hit point to mimic the effect of Global Illumination.</p>
<p><img src="api_ir.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="localcubemaps"></a>
API Usage: Local Reflections Using Parallax Corrected Cubemaps</h1>
<p>This sample demonstrates using parallax reflect cubemaps for accurate local reflections.</p>
<p><img src="api_localcubemap.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="localcubemapsmp"></a>
API Usage: Local Reflections Using Parallax Corrected Cubemaps With Manual Probes</h1>
<p>This sample demonstrates using parallax reflect cubemaps for accurate local reflections. This time, we showcase the differences between manual and automatic modes. Manual probes are camera independent and work best for static objects.</p>
<p><img src="api_localcubemap_manual.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="autolod"></a>
API Usage: Automatic LOD Generation</h1>
<p>This sample demonstrates the automatic generation of LODs from an existing mesh.</p>
<p><img src="api_meshlod.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="morphanimation"></a>
API Usage: Morph Animations</h1>
<p>This sample demonstrates morph animations.</p>
<p><img src="api_morphanimation.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="autopcc"></a>
API Usage: Automatically Placed Parallax Corrected Cubemap Probes Via PccPerPixelGridPlacement</h1>
<p>This sample demonstrates placing multiple PCC probes automatically.</p>
<p><img src="api_autopcc.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="planarreflections"></a>
API Usage: Planar Reflections</h1>
<p>This sample demonstrates planar reflections.</p>
<p><img src="api_planarreflections.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="refractions"></a>
API Usage: Refractions</h1>
<p>This sample demonstrates refractions.</p>
<p><img src="api_refractions.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="sceneformat"></a>
API Usage: SceneFormat Export / Import Sample</h1>
<p>This sample demonstrates exporting/importing of a scene to JSON format. Includes the exporting of meshes and textures to a binary format.</p>
<h1><a class="anchor" id="ssreflections"></a>
API Usage: Screen Space Reflections</h1>
<p>This sample demonstrates screen space reflections</p>
<p><img src="api_ssreflections.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="shadowdebug"></a>
API Usage: Shadow Map Debugging</h1>
<p>This sample demonstrates rendering the shadow map textures from a shadow node (compositor).</p>
<p><img src="api_shadowdebug.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="shadowfromcode"></a>
API Usage: Shadow Map From Code</h1>
<p>This is similar to 'Shadow Map Debugging' sample. The main difference is that the shadow nodes are being generated programmatically via ShadowNodeHelper::createShadowNodeWithSettings instead of relying on Compositor scripts.</p>
<p><img src="api_shadowfromcode.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="staticshadowmap"></a>
API Usage: Static Shadow Map</h1>
<p>This sample demonstrates the use of static/fixed shadow maps to increase performance.</p>
<p><img src="api_shadowstaticmap.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="stenciltest"></a>
API Usage: Stencil Test</h1>
<p>This sample demonstrates the use of stencil test. A sphere is drawn in one pass, filling the stencil with 1s. The next pass a cube is drawn, only drawing when stencil == 1.</p>
<p><img src="api_stenciltest.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="stereorendering"></a>
API Usage: Stereo Rendering</h1>
<p>This sample demonstrates stereo rendering.</p>
<p><img src="api_stereorendering.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="updatedecal"></a>
API Usage: Updating Decals And Area Lights' Textures</h1>
<p>This sample demonstrates the creation of area light textures dynamically and individually. This can also be used for decals texture use.</p>
<p><img src="api_updatedecal.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="v1interface"></a>
API Usage: Ogre V1 Interfaces</h1>
<p>This sample demonstrates the use of <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> V1 objects (e.g. Entity) in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> Next.</p>
<p><img src="api_v1interface.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="onmanualobject"></a>
API Usage: Ogre Next Manual Object</h1>
<p>This sample demonstrates the use of <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> Next manual objects. This eases porting code from <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> V1. For increased speed, see sample: 'Dynamic Geometry'.</p>
<p><img src="api_v2manualobject.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="v2Mesh"></a>
API Usage: Ogre Next V2 Meshes</h1>
<p>This sample demonstrates converting <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> V1 meshes to <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> Next V2 format.</p>
<p><img src="api_v2mesh.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="tutorial00"></a>
Tutorial: Tutorial 00 - Basic</h1>
<p>This tutorial demonstrates the basic setup of <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> Next to render to a window. Uses hardcoded paths. See next tutorial to properly handle all OS's setup a render loop.</p>
<h1><a class="anchor" id="tutorial01"></a>
Tutorial: Tutorial 01 - Initialisation</h1>
<p>This tutorial demonstrates the setup of <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> Next in a basis framework.</p>
<h1><a class="anchor" id="tutorial02"></a>
Tutorial: Tutorial 02 - Variable Framerate</h1>
<p>This tutorial demonstrates the most basic rendering loop: Variable framerate. Variable framerate means the application adapts to the current frame rendering performance and boosts or decreases the movement speed of objects to maintain the appearance that objects are moving at a constant velocity. Despite what it seems, this is the most basic form of updating. Progress through the tutorials for superior methods of updating the rendering loop. Note: The cube is black because there is no lighting.</p>
<p><img src="tutorial_02.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="tutorial03"></a>
Tutorial: Tutorial 03 - Deterministic Loop</h1>
<p>This is very similar to Tutorial 02, however it uses a fixed framerate instead of a variable one. There are many reasons to using a fixed framerate instead of a variable one:</p><ul>
<li>It is more stable. High framerates (i.e. 10000 fps) cause floating point precision issues in 'timeSinceLast' as it becomes very small. The value may even round to 0!</li>
<li>Physics stability, physics and logic simulations don't like variable framerate.</li>
<li>Determinism: given the same input, every run of the program will always return the same output. Variable framerate and determinism don't play together. For more information, see <a href="http://gafferongames.com/game-physics/fix-your-timestep/">Fix Your TimeStep!</a></li>
</ul>
<p><img src="tutorial_03.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="tutorial04"></a>
Tutorial: Tutorial 04 - Interpolation Loop</h1>
<p>This tutorial demonstrates combined fixed and variable framerate: Logic is executed at 25hz, while graphics are being rendered at a variable rate, interpolating between frames to achieve a smooth result. When OGRE or the GPU is taking too long, you will see a 'frame skip' effect, when the CPU is taking too long to process the Logic code, you will see a 'slow motion' effect. This combines the best of both worlds and is the recommended approach for serious game development. The only two disadvantages from this technique are:</p><ul>
<li>We introduce 1 frame of latency.</li>
<li>Teleporting may be shown as very fast movement; as the graphics state will try to blend between the last and current position. This can be solved though, by writing to both the previous and current position in case of teleportation. We purposely don't do this to show the effect/'glitch'.</li>
</ul>
<p><img src="tutorial_04.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="tutorial05"></a>
Tutorial: Tutorial 05 - Multithreading Basics</h1>
<p>This tutorial demonstrates how to setup two update loops: One for graphics, another for logic, each in its own thread. We don't render anything because we will now need to do a robust synchronization for creating, destroying and updating Entities. This is potentially too complex to show in just one tutorial step.</p>
<h1><a class="anchor" id="tutorial06"></a>
Tutorial: Tutorial 06 - Multithreading</h1>
<p>This tutorial demonstrates advanced multithreadingl. We introduce the 'GameEntity' structure which encapsulates a game object data. It contains its graphics (i.e. Entity and SceneNode) and its physics/logic data (a transform, the hkpEntity/btRigidBody pointers, etc). The GameEntityManager is responsible for telling the render thread to create the graphics and delays deleting the GameEntity until all threads are done using it.</p>
<p><img src="tutorial_06.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="compute01"></a>
Tutorial: Compute 01 - UAV Textures</h1>
<p>This tutorial demonstrates how to setup and use UAV textures with compute shaders.</p>
<p><img src="tutorial_compute01.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="compute02"></a>
Tutorial: Compute 02 - UAV Buffers</h1>
<p>This tutorial demonstrates how to setup and use UAV buffers with compute shaders.</p>
<p><img src="tutorial_compute02.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="tut_distortion"></a>
Tutorial: Distortion</h1>
<p>This tutorial demonstrates how to make compositing setup that renders different parts of the scene to different textures. Here we will render distortion pass to its own texture and use shader to compose the scene and distortion pass. Distortion setup can be used to create blastwave effects, mix with fire particle effects to get heat distortion etc. You can use this setup with all kind of objects but in this example we are using only textured simple spheres. For proper use, you should use particle systems to get better results.</p>
<p><img src="tutorial_distortion.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="dyncubemap"></a>
Tutorial: Dynamic Cube Map</h1>
<p>This tutorial demonstrates how to setup dynamic cubemapping via the compositor, so that it can be used for dynamic reflections.</p>
<p><img src="tutorial_dynamiccubemap.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="eglheadless"></a>
Tutorial: EGL Headless</h1>
<p>This tutorial demonstrates how to run <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> in EGL headless, which can be useful for running in a VM or in the Cloud.</p>
<h1><a class="anchor" id="openVR"></a>
Tutorial: Open VR</h1>
<p>This tutorial demonstrates the use of Open VR.</p>
<h1><a class="anchor" id="reconpfromd"></a>
Tutorial: Reconstructing Position From Depth</h1>
<p>This tutorial demonstrates how to reconstruct the position from only the depth buffer in a very efficient way. This is very useful for Deferred Shading, SSAO, etc.</p>
<p><img src="tutorial_posfromdepth.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="skypost"></a>
Tutorial: Rendering Sky As A Postprocess With A Single Shader</h1>
<p>This tutorial demonstrates how to create a sky as simple postprocess effect.</p>
<p><img src="tutorial_skypost.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="SMAA"></a>
Tutorial: SMAA</h1>
<p>This tutorial demonstrates SMAA.</p>
<p><img src="tutorial_smaa.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="ssao"></a>
Tutorial: SSAO</h1>
<p>This tutorial demonstrates SSAO.</p>
<p><img src="tutorial_ssao.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="terrain"></a>
Tutorial: Terra Terrain</h1>
<p>This tutorial is advanced and shows several things working together:</p><ul>
<li>Own Hlms implementation to render the terrain</li>
<li>Vertex buffer-less rendering: The terrain is generated purely using SV_VertexID tricks and a heightmap texture.</li>
<li>Hlms customizations to PBS to make terrain shadows affect regular objects</li>
<li>Compute Shaders to generate terrain shadows every frame</li>
<li>Common terrain functionality such as loading the heightmap, generating normals, LOD.</li>
</ul>
<p><img src="tutorial_terrain.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="texturebaking"></a>
Tutorial: Texture Baking</h1>
<p>This tutorial demonstrates how to bake the render result of <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> into a texture (e.g. for lightmaps).</p>
<p><img src="tutorial_texturebake.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="uav1"></a>
Tutorial: UAV Setup 1 Example</h1>
<p>This tutorial demonstrates how to setup an UAV (Unordered Access View). UAVs are complex and for advanced users, but they're very powerful and enable a whole new level of features and possibilities. This sample first fills an UAV with some data, then renders to screen sampling from it as a texture.</p>
<p><img src="tutorial_uav1.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="uav2"></a>
Tutorial: UAV Setup 2 Example</h1>
<p>This sample is exactly as 'UAV Setup 1 Example', except that it shows reading from the UAVs as an UAV (e.g. use imageLoad) instead of using it as a texture for reading.</p>
<p><img src="tutorial_uav2.png" alt="" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
