<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Root Layouts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;4.0.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_root_layouts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Root Layouts</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#RootLayoutsOldAPIs">Old APIs (i.e. D3D11 and GL)</a></li>
<li class="level1"><a href="#RootLayoutsNewAPIs">New APIs and Root Layouts</a></li>
<li class="level1"><a href="#RootLayoutsSettingUp">Setting up root layouts</a><ul><li class="level2"><a href="#autotoc_md106">Could you have used e.g. &quot;const_buffers&quot; : [0,7] instead of [4,7]?</a></li>
</ul>
</li>
<li class="level1"><a href="#RootLayoutsDeclaringInShaders">Declaring Root Layouts in shaders</a></li>
<li class="level1"><a href="#RootLayoutsBakedSets">Baked sets</a></li>
<li class="level1"><a href="#RootLayoutPrefabs">Prefab Root Layouts for low level materials</a></li>
<li class="level1"><a href="#RootLayoutsArraysOfTextures">Arrays of Textures</a><ul><li class="level2"><a href="#RootLayoutsAoTCpp">C++</a></li>
<li class="level2"><a href="#RootLayoutsAoTInlineShader">Inline shader declaration</a></li>
<li class="level2"><a href="#RootLayoutsAoTAuto">Automatic</a></li>
<li class="level2"><a href="#RootLayoutsGLSLForGLandVK">Making GLSL shaders compatible with both Vulkan and OpenGL</a><ul><li class="level3"><a href="#RootLayoutsGLSLForGLandVKExample">Example:</a><ul><li class="level4"><a href="#autotoc_md107">OpenGL</a></li>
<li class="level4"><a href="#autotoc_md108">Vulkan</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> 2.3 introduced the concept of root layouts, and they need to be setup for Vulkan.</p>
<p>If you're familiar with D3D12, you may have noted we borrowed this concept.</p>
<h1><a class="anchor" id="RootLayoutsOldAPIs"></a>
Old APIs (i.e. D3D11 and GL)</h1>
<p>Older APIs like D3D11 and GL (and Metal 1) use a 'table binding' model. It is very simple to understand:</p>
<p>D3D11 offers 128 texture slots, thus textures can be bound to each slot:</p>
<div class="fragment"><div class="line">table[textures][0] = textureA;         <span class="comment">// Bind to slot 0</span></div>
<div class="line">table[textures][10] = textureB;        <span class="comment">// Bind to slot 10</span></div>
<div class="line">table[textures][50] = <span class="keyword">nullptr</span>;         <span class="comment">// Bind nothing to slot 50</span></div>
<div class="line">table[textures][127] = anotherTexture; <span class="comment">// Bind to slot 127</span></div>
</div><!-- fragment --><p>And its corresponding shader declaration:</p>
<div class="fragment"><div class="line">uniform Texture2D textureA : register( t0 );</div>
<div class="line">uniform Texture2D textureB : register( t10 );</div>
<div class="line">uniform Texture2D textureA : register( t127 );</div>
</div><!-- fragment --><p>IHVs recommend to not leave gaps because they flush based on min-max. touched slots, e.g. if we have 10 textures and bind the first 9 at slots [0; 8] and the last one at slot 127, the driver will flush all 127 slots instead of just flushing 10.</p>
<p>The same table model is used for other resources: Const buffers, UAV buffers, UAV textures:</p>
<div class="fragment"><div class="line">table[const_buffers][2] = materialConstBufferA; <span class="comment">// Bind to slot 2</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">cbuffer myObject : register(b2)</div>
<div class="line">{       </div>
<div class="line">    float4x4 matWorld;</div>
<div class="line">    float3   vObjectPosition;</div>
<div class="line">    int      arrayIndex;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This table model is simple to understand, although not all APIs agree on what goes together, e.g. in Metal regular textures and UAV textures share the same table. In D3D11 they have separate tables, thus regularTexture can be bound to slot <code>t1</code> and uavTexture to slot <code>u1</code>; while on Metal only one of them can be bound to slot <code>[[ texture( 1 ) ]]</code></p>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> tries to abstract these differences.</p>
<h1><a class="anchor" id="RootLayoutsNewAPIs"></a>
New APIs and Root Layouts</h1>
<p>In newer APIs, these tables don't exist. Developers can layout resources in arbitrary ways and then describe the API what is in each offset. A binding can contain ANYTHING: sampler, const buffer, textures, etc</p>
<p>e.g. in pseudo code:</p>
<div class="fragment"><div class="line">// Example A</div>
<div class="line">uniform Texture2D textureA : register( slot 0 );</div>
<div class="line">uniform Texture2D textureB : register( slot 1 );</div>
<div class="line">cbuffer myObject : register( slot 2 ) {};</div>
<div class="line">uniform Texture2D textureD : register( slot 3 );</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">// Example B</div>
<div class="line">uniform Texture2D textureA : register( slot 0 );</div>
<div class="line">uniform Texture2D textureB : register( slot 1 );</div>
<div class="line">uniform Texture2D textureC : register( slot 2 );</div>
<div class="line">uniform Texture2D textureD : register( slot 3 );</div>
</div><!-- fragment --><p>Two shaders that have the same root layout (even if they don't need to use all the resources declared) are said to be compatible.</p>
<p>In the example A &amp; B are not compatible because slot 2 uses a different type. This means their size in bytes could be different, so even though <code>textureD</code> is in slot 3 in both shaders, their offset in bytes could be completely different.</p>
<p>Thus when switching from A to B we'd need to rebind everything again (or at best rebind slots 2 and 3, not just slot 2)</p>
<p>Sharing root layouts maximize CPU &amp; GPU performance by lowering the amount of switching. Conversely, very big root layouts can hurt GPU performance due to their size and amount of registers consumed.</p>
<p>Ultimately we want to share as much as possible but not make the Root Layout gigantic to just to achieve maximum sharing.</p>
<p>The fact that resource declaration can be so arbitrary gives a lot of power and flexibility but it can be difficult to setup, easy to mess up; and how to approach the problem can be overwhelming.</p>
<p>There are three ways to approach it:</p>
<ol type="1">
<li>The shader is first compiled, the layout is manually and carefully maintained. The C++ and shader code assume the layout is preserved as is. <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> cannot do this as we have to preserve compatibility with other APIs and we cannot enforce a layout to nor from our user either. This is too low level.</li>
<li>The shader is first compiled, reflected, their slots extracted, a Root Layout is created out of it, the Root Layout is modified to work with how <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> expects to bind data, and then the shader is recompiled again with patched binding slots.</li>
<li>The root layout is first specified, then the shader is built with patched binding slots</li>
</ol>
<p><a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> follows the 3rd approach (except when arrays of textures are used, which use the 2nd approach).</p>
<p>Root Layouts can have up to 4 sets (which is the minimum guaranteed by Vulkan).</p>
<p>It is common practice in <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> to leave set 0 for resources bound in the traditional way (i.e. like a table model in D3D11 / OpenGL) while set 1 is set to 'baked' where DescriptorSetTexture/Sampler/Texture2/Uav are bound to it.</p>
<p><b>Another way to look at <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a>'s RootLayout is that it basically tells <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> what resources will the shader use so that we can properly emulate tables and compile the shader using slot locations calculated by us while the shader author can use binding slot index that have the same number as the shader code for other APIs (i.e. D3D11, GL)</b></p>
<h1><a class="anchor" id="RootLayoutsSettingUp"></a>
Setting up root layouts</h1>
<p>An HLSL shader that ONLY declares and uses the following resources:</p>
<div class="fragment"><div class="line">cbuffer myConstBuffer0      : register(b4) {};</div>
<div class="line">cbuffer myConstBuffer1      : register(b5) {};</div>
<div class="line">cbuffer myConstBuffer2      : register(b6) {};</div>
<div class="line">Buffer&lt;float4&gt; myTexBuffer  : register(t1);</div>
<div class="line">Texture2D myTex0            : register(t3);</div>
<div class="line">Texture2D myTex1            : register(t4);</div>
<div class="line">SamplerState mySampler      : register(s1);</div>
<div class="line">RWTexture3D&lt;float&gt; myUavTex : register(u0);</div>
<div class="line">RWBuffer&lt;float&gt; myUavBuffer : register(u1);</div>
</div><!-- fragment --><p>Would work using the following RootLayout:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;0&quot; :</div>
<div class="line">    {</div>
<div class="line">        &quot;const_buffers&quot;     : [4,7],</div>
<div class="line">        &quot;tex_buffers&quot;       : [1,2],</div>
<div class="line">        &quot;textures&quot;          : [3,4],</div>
<div class="line">        &quot;samplers&quot;          : [1,2],</div>
<div class="line">        &quot;uav_buffers&quot;       : [1,2],</div>
<div class="line">        &quot;uav_textures&quot;      : [0,1]</div>
<div class="line">    },</div>
<div class="line">    &quot;1&quot; :</div>
<div class="line">    {</div>
<div class="line">        &quot;baked&quot; : true,</div>
<div class="line">        &quot;uav_buffers&quot;       : [1,2],</div>
<div class="line">        &quot;uav_textures&quot;      : [0,1]</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>That is, explicitly declare that you're using const buffer range [4; 7), tex buffer range [1; 2) etc.</p>
<p>In Vulkan we will automatically generate macros for use in bindings (buffers are uppercase letter, textures lowercase):</p>
<div class="fragment"><div class="line"><span class="comment">// Const buffers</span></div>
<div class="line"><span class="preprocessor">#define ogre_B4 set = 0, binding = 0</span></div>
<div class="line"><span class="preprocessor">#define ogre_B5 set = 0, binding = 1</span></div>
<div class="line"><span class="preprocessor">#define ogre_B6 set = 0, binding = 2</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Texture buffers</span></div>
<div class="line"><span class="preprocessor">#define ogre_T1 set = 0, binding = 3</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Textures</span></div>
<div class="line"><span class="preprocessor">#define ogre_t3 set = 0, binding = 4</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Samplers</span></div>
<div class="line"><span class="preprocessor">#define ogre_s1 set = 0, binding = 5</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// UAV buffers</span></div>
<div class="line"><span class="preprocessor">#define ogre_U1 set = 0, binding = 6</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// UAV textures</span></div>
<div class="line"><span class="preprocessor">#define ogre_u0 set = 0, binding = 7</span></div>
</div><!-- fragment --><p>Thus a GLSL shader can use it like this:</p>
<div class="fragment"><div class="line">layout( ogre_B4 ) uniform bufferName</div>
<div class="line">{</div>
<div class="line">    uniform <span class="keywordtype">float</span> myParam;</div>
<div class="line">    uniform float2 myParam2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">layout( ogre_t3 ) uniform texture2D myTexture;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md106"></a>
Could you have used e.g. "const_buffers" : [0,7] instead of [4,7]?</h2>
<p>i.e. declare slots in range [0;4) even though they won't be used?</p>
<p>Yes. But you would be consuming more memory.</p>
<p>Note that if your vertex shader uses slots [0; 3) and pixel shader uses range [4; 7) then BOTH shaders must use a RootLayout that at least declares range [0; 7) so they can be paired together</p>
<p>RootLayouts have a memory vs performance trade off:</p>
<ul>
<li>Declaring unused slots helps reusing RootLayout. Reuse leads to fewer descriptor swapping</li>
<li>Unused slots waste RAM and VRAM</li>
</ul>
<p>That's why low level materials provide prefab RootLayouts, in order to maximize RootLayout reuse while also keeping reasonable memory consumption.</p>
<p>See <code>GpuProgram::setPrefabRootLayout</code></p>
<h1><a class="anchor" id="RootLayoutsDeclaringInShaders"></a>
Declaring Root Layouts in shaders</h1>
<p>Shaders can declare their Root Layouts in JSON in comments as long as it starts with <code>## ROOT LAYOUT BEGIN</code> and end with <code>## ROOT LAYOUT END</code>:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">## ROOT LAYOUT BEGIN</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">    &quot;0&quot; :</span></div>
<div class="line"><span class="comment">    {</span></div>
<div class="line"><span class="comment">        &quot;has_params&quot; : true</span></div>
<div class="line"><span class="comment">        &quot;const_buffers&quot; : [2, 4]</span></div>
<div class="line"><span class="comment">        &quot;tex_buffers&quot; : [0, 1]</span></div>
<div class="line"><span class="comment">        &quot;samplers&quot; : [1, 2],</span></div>
<div class="line"><span class="comment">        &quot;textures&quot; : [1, 2]</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">## ROOT LAYOUT END</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#version 450</span></div>
<div class="line"> </div>
<div class="line">layout( ogre_P0 ) uniform Params {</div>
<div class="line">    uniform <span class="keywordtype">float</span> myParams;</div>
<div class="line">};</div>
<div class="line">layout( ogre_B2 ) uniform MyUBO {</div>
<div class="line">    uniform <span class="keywordtype">float</span> anotherParam;</div>
<div class="line">};</div>
<div class="line">layout( ogre_t1 ) texture2d myTexA;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// glsl code...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Or it can be declared in C++. This is the preferred method for Hlms shader code to maximize performance.</p>
<p><code>HlmsUnlit::setupRootLayout</code> has a simple example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> HlmsUnlit::setupRootLayout( RootLayout &amp;rootLayout )</div>
<div class="line">{</div>
<div class="line">    DescBindingRange *descBindingRanges = rootLayout.mDescBindingRanges[0];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We have up to 3 const buffers at slots 0, 1 and 2</span></div>
<div class="line">    descBindingRanges[DescBindingTypes::ConstBuffer].end = 3u;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// When there&#39;s texture matrix animations, we must consume one extra buffer slot</span></div>
<div class="line">    <span class="keywordflow">if</span>( getProperty( UnlitProperty::TextureMatrix ) == 0 )</div>
<div class="line">        descBindingRanges[DescBindingTypes::ReadOnlyBuffer].end = 1u;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        descBindingRanges[DescBindingTypes::ReadOnlyBuffer].end = 2u;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Baked sets are the ones that use DescriptorSetTexture/Sampler/Texture2/Uav</span></div>
<div class="line">    rootLayout.mBaked[1] = <span class="keyword">true</span>;</div>
<div class="line">    DescBindingRange *bakedRanges = rootLayout.mDescBindingRanges[1];</div>
<div class="line">    bakedRanges[DescBindingTypes::Sampler].start = (uint16)mSamplerUnitSlotStart;</div>
<div class="line">    bakedRanges[DescBindingTypes::Sampler].end =</div>
<div class="line">        (uint16)mSamplerUnitSlotStart + (uint16)getProperty( UnlitProperty::NumSamplers );</div>
<div class="line"> </div>
<div class="line">    bakedRanges[DescBindingTypes::Texture].start = (uint16)mTexUnitSlotStart;</div>
<div class="line">    bakedRanges[DescBindingTypes::Texture].end =</div>
<div class="line">        (uint16)mTexUnitSlotStart + (uint16)getProperty( UnlitProperty::NumTextures );</div>
<div class="line"> </div>
<div class="line">    mListener-&gt;setupRootLayout( rootLayout, mSetProperties );</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="RootLayoutsBakedSets"></a>
Baked sets</h1>
<p>Non-baked sets are meant to behave very similarly to table models in D3D11 and OpenGL.</p>
<p>Baked sets on the other hand are meant exclusively for binding <code>DescriptorSetTexture</code>, <code>DescriptorSetSampler</code>, <code>DescriptorSetTexture2</code> and <code>DescriptorSetUav</code>.</p>
<p>The size of the DescriptorSet* must match <em>exactly</em> the amount of bindings slots in the RootLayout.</p>
<p>Since UAVs can only be bound via <code>DescriptorSetUav</code>, UAVs must be placed in baked sets.</p>
<h1><a class="anchor" id="RootLayoutPrefabs"></a>
Prefab Root Layouts for low level materials</h1>
<p>To ease porting of low level materials (i.e. *.material and *.program scripts), most low level materials don't need to declare Root Layouts because we have prefabs for them:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Prefab   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Defined in shader source or externally via C++    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Standard   </td><td class="markdownTableBodyNone">4 textures per material, VS and PS only (default)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">High   </td><td class="markdownTableBodyNone">8 textures per material, VS and PS only    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Max   </td><td class="markdownTableBodyNone">32 textures per material, all shader stages   </td></tr>
</table>
<p>The majority of low level materials are fine with Standard, and this allows us to maximize Root Layout reuse.</p>
<p>If you need something different, you can either:</p>
<p>Change the prefab with <code>root_layout standard|high|max|none</code> in the shader program script definition, or declare the root layout inside the shader code.</p>
<h1><a class="anchor" id="RootLayoutsArraysOfTextures"></a>
Arrays of Textures</h1>
<p>When a shader contains arrays of textures or samplers with an array length &gt; 1, e.g.</p>
<div class="fragment"><div class="line">layout( ogre_t0 ) texture2d myTexA[5];</div>
<div class="line">layout( ogre_t6 ) texture2d myTexB[4];</div>
<div class="line"> </div>
<div class="line">layout( ogre_s0 ) texture2d mySamplers[3];</div>
<div class="line">layout( ogre_s4 ) texture2d anotherSampler;</div>
</div><!-- fragment --><p>We need one of the following to specify that these slots are array, and what's their length:</p>
<h2><a class="anchor" id="RootLayoutsAoTCpp"></a>
C++</h2>
<div class="fragment"><div class="line">rootLayout.addArrayBinding( DescBindingTypes::Texture, ArrayDesc( 0, 5 ) );</div>
<div class="line">rootLayout.addArrayBinding( DescBindingTypes::Texture, ArrayDesc( 6, 4 ) );</div>
<div class="line">rootLayout.addArrayBinding( DescBindingTypes::Sampler, ArrayDesc( 0, 3 ) );</div>
</div><!-- fragment --><h2><a class="anchor" id="RootLayoutsAoTInlineShader"></a>
Inline shader declaration</h2>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;0&quot; :</div>
<div class="line">    {</div>
<div class="line">        &quot;textures&quot; : [0, 10],</div>
<div class="line">        &quot;samplers&quot; : [0, 4],</div>
<div class="line">        &quot;baked&quot; : false</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    &quot;arrays&quot; :</div>
<div class="line">    {</div>
<div class="line">        &quot;textures&quot; : [[0, 5], [0, 4]],</div>
<div class="line">        &quot;samplers&quot; : [[0, 3]],</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="RootLayoutsAoTAuto"></a>
Automatic</h2>
<p>In automatic, arrays are not declared. But the shader will be compiled, reflected, <b>and then compiled again</b> with a patched Root Layout (unless there were no arrays).</p>
<p>On Debug builds, <a class="el" href="namespace_ogre.html" title="bswapNN may be defined as macros in &lt;sys/endian.h&gt; or &lt;sys/bswap.h&gt;">Ogre</a> will always reflect shaders to check the declared arrays in root layouts match the arrays used by the shader.</p>
<p>Automatic is the default behavior for low level materials. For Hlms shaders it's turned off</p>
<p>Automatic can be turned on or off via <code>GpuProgram::setAutoReflectArrayBindingsInRootLayout</code> or its script counterpart <code>uses_array_bindings</code></p>
<p>Compute Shaders can turn on automatic mode by setting the <code>uses_array_bindings</code> property via Hlms, e.g.</p>
<div class="fragment"><div class="line">@pset( uses_array_bindings, 1 )</div>
</div><!-- fragment --><h2><a class="anchor" id="RootLayoutsGLSLForGLandVK"></a>
Making GLSL shaders compatible with both Vulkan and OpenGL</h2>
<p>Vulkan and OpenGL both use GLSL. However there are a few differences mostly because of the different binding model.</p>
<p>As a result we provide a few abstractions to separate these differences:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Expression   </th><th class="markdownTableHeadNone">Vulkan   </th><th class="markdownTableHeadNone">OpenGL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vulkan()</code> macro   </td><td class="markdownTableBodyNone">Anything inside is kept   </td><td class="markdownTableBodyNone">Anything inside is removed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vulkan_layout()</code> macro   </td><td class="markdownTableBodyNone">It is converted to <code>layout()</code>   </td><td class="markdownTableBodyNone">It is removed    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>#version ogre_glsl_ver_xxx</code>   </td><td class="markdownTableBodyNone">Always converted to <code>#version 450</code>   </td><td class="markdownTableBodyNone">The <code>ogre_glsl_ver_</code> part is removed and will be translated to <code>#version xxx</code>   </td></tr>
</table>
<h3><a class="anchor" id="RootLayoutsGLSLForGLandVKExample"></a>
Example:</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#version ogre_glsl_ver_330</span></div>
<div class="line"> </div>
<div class="line">vulkan_layout( ogre_t0 ) uniform texture2D tex;</div>
<div class="line">vulkan( layout( ogre_s0 ) uniform sampler texSampler );</div>
<div class="line"> </div>
<div class="line">vulkan_layout( location = 0 )</div>
<div class="line">in block</div>
<div class="line">{</div>
<div class="line">    vec2 uv0;</div>
<div class="line">} inPs;</div>
<div class="line"> </div>
<div class="line">vulkan( layout( ogre_P0 ) uniform Params { )</div>
<div class="line">    uniform float4x4 worldViewProjMatrix;</div>
<div class="line">    uniform uint vertexBase;</div>
<div class="line">    uniform uint3 bandMaskPower;</div>
<div class="line">    uniform float2 sectionsBandArc;</div>
<div class="line"> </div>
<div class="line">    uniform uint3 numProbes;</div>
<div class="line">    uniform float3 aspectRatioFixer;</div>
<div class="line">vulkan( }; )</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md107"></a>
OpenGL</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line">uniform texture2D tex;</div>
<div class="line"> </div>
<div class="line">in block</div>
<div class="line">{</div>
<div class="line">    vec2 uv0;</div>
<div class="line">} inPs;</div>
<div class="line"> </div>
<div class="line">    uniform float4x4 worldViewProjMatrix;</div>
<div class="line">    uniform uint vertexBase;</div>
<div class="line">    uniform uint3 bandMaskPower;</div>
<div class="line">    uniform float2 sectionsBandArc;</div>
<div class="line"> </div>
<div class="line">    uniform uint3 numProbes;</div>
<div class="line">    uniform float3 aspectRatioFixer;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md108"></a>
Vulkan</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#version 450</span></div>
<div class="line"> </div>
<div class="line">layout( ogre_t0 ) uniform texture2D tex;</div>
<div class="line">layout( ogre_s0 ) uniform sampler texSampler;</div>
<div class="line"> </div>
<div class="line">layout( location = 0 )</div>
<div class="line">in block</div>
<div class="line">{</div>
<div class="line">    vec2 uv0;</div>
<div class="line">} inPs;</div>
<div class="line"> </div>
<div class="line">layout( ogre_P0 ) uniform Params {</div>
<div class="line">    uniform float4x4 worldViewProjMatrix;</div>
<div class="line">    uniform uint vertexBase;</div>
<div class="line">    uniform uint3 bandMaskPower;</div>
<div class="line">    uniform float2 sectionsBandArc;</div>
<div class="line"> </div>
<div class="line">    uniform uint3 numProbes;</div>
<div class="line">    uniform float3 aspectRatioFixer;</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_rendering.html">Rendering</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
