<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::v1::GL3PlusHardwareBufferManagerBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;2.1</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::v1::GL3PlusHardwareBufferManagerBase Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> for OpenGL.  
 <a href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#details">More...</a></p>

<p><code>#include &lt;OgreGL3PlusHardwareBufferManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::v1::GL3PlusHardwareBufferManagerBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base__inherit__graph.svg" width="194" height="214"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a73af0e384fffafd30ec13438507d31eb" id="r_a73af0e384fffafd30ec13438507d31eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a73af0e384fffafd30ec13438507d31eb">BufferLicenseType</a> { <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a73af0e384fffafd30ec13438507d31ebaefbef8f3135135145a860b8647faba4c">BLT_MANUAL_RELEASE</a>
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a73af0e384fffafd30ec13438507d31eba2b12eec76abb4c56344b6c6ff1cdb65f">BLT_AUTOMATIC_RELEASE</a>
 }</td></tr>
<tr class="separator:a73af0e384fffafd30ec13438507d31eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a520ef2e60b7615abfcf6fda999b65104" id="r_a520ef2e60b7615abfcf6fda999b65104"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a520ef2e60b7615abfcf6fda999b65104">GL3PlusHardwareBufferManagerBase</a> ()</td></tr>
<tr class="separator:a520ef2e60b7615abfcf6fda999b65104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fa9b13d874bf81377dd72fce88e13f" id="r_a59fa9b13d874bf81377dd72fce88e13f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a59fa9b13d874bf81377dd72fce88e13f">~GL3PlusHardwareBufferManagerBase</a> ()</td></tr>
<tr class="separator:a59fa9b13d874bf81377dd72fce88e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f51811f14dcf9cc9c62311bf5952ce1" id="r_a7f51811f14dcf9cc9c62311bf5952ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a7f51811f14dcf9cc9c62311bf5952ce1">_forceReleaseBufferCopies</a> (<a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1map.html">sourceBuffer</a>)</td></tr>
<tr class="memdesc:a7f51811f14dcf9cc9c62311bf5952ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method that forces the release of copies of a given buffer.  <br /></td></tr>
<tr class="separator:a7f51811f14dcf9cc9c62311bf5952ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac7eb3844eae2dbceecfab0e0eb034c" id="r_adac7eb3844eae2dbceecfab0e0eb034c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#adac7eb3844eae2dbceecfab0e0eb034c">_forceReleaseBufferCopies</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer.html">HardwareVertexBuffer</a> *<a class="el" href="struct_ogre_1_1map.html">sourceBuffer</a>)</td></tr>
<tr class="memdesc:adac7eb3844eae2dbceecfab0e0eb034c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method that forces the release of copies of a given buffer.  <br /></td></tr>
<tr class="separator:adac7eb3844eae2dbceecfab0e0eb034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79513a524782fcac13a6d91e68013ad7" id="r_a79513a524782fcac13a6d91e68013ad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a79513a524782fcac13a6d91e68013ad7">_freeUnusedBufferCopies</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>)</td></tr>
<tr class="memdesc:a79513a524782fcac13a6d91e68013ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all unused vertex buffer copies.  <br /></td></tr>
<tr class="separator:a79513a524782fcac13a6d91e68013ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a0ad696cd4a4a56f31ed5a2d954351" id="r_ad1a0ad696cd4a4a56f31ed5a2d954351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#ad1a0ad696cd4a4a56f31ed5a2d954351">_notifyCounterBufferDestroyed</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_counter_buffer.html">HardwareCounterBuffer</a> *buf)</td></tr>
<tr class="memdesc:ad1a0ad696cd4a4a56f31ed5a2d954351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that at hardware counter buffer has been destroyed.  <br /></td></tr>
<tr class="separator:ad1a0ad696cd4a4a56f31ed5a2d954351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d79f386a09e77e911112e9988838d1" id="r_a99d79f386a09e77e911112e9988838d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a99d79f386a09e77e911112e9988838d1">_notifyIndexBufferDestroyed</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html">HardwareIndexBuffer</a> *buf)</td></tr>
<tr class="memdesc:a99d79f386a09e77e911112e9988838d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that a hardware index buffer has been destroyed.  <br /></td></tr>
<tr class="separator:a99d79f386a09e77e911112e9988838d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7858c87b21a22eb251aef043bf04285" id="r_ad7858c87b21a22eb251aef043bf04285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#ad7858c87b21a22eb251aef043bf04285">_notifyUniformBufferDestroyed</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer.html">HardwareUniformBuffer</a> *buf)</td></tr>
<tr class="memdesc:ad7858c87b21a22eb251aef043bf04285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that at hardware uniform buffer has been destroyed.  <br /></td></tr>
<tr class="separator:ad7858c87b21a22eb251aef043bf04285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d598f5c8dd22d52ce27fd9e73a7b23a" id="r_a3d598f5c8dd22d52ce27fd9e73a7b23a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a3d598f5c8dd22d52ce27fd9e73a7b23a">_notifyVertexBufferDestroyed</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer.html">HardwareVertexBuffer</a> *buf)</td></tr>
<tr class="memdesc:a3d598f5c8dd22d52ce27fd9e73a7b23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that a hardware vertex buffer has been destroyed.  <br /></td></tr>
<tr class="separator:a3d598f5c8dd22d52ce27fd9e73a7b23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08297892d344182b4daa24b1b6bde626" id="r_a08297892d344182b4daa24b1b6bde626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a08297892d344182b4daa24b1b6bde626">_releaseBufferCopies</a> (<a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">forceFreeUnused</a>=<a class="el" href="struct_ogre_1_1map.html">false</a>)</td></tr>
<tr class="memdesc:a08297892d344182b4daa24b1b6bde626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for releasing all temporary buffers which have been allocated using BLT_AUTOMATIC_RELEASE; is called by OGRE.  <br /></td></tr>
<tr class="separator:a08297892d344182b4daa24b1b6bde626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c2aa58d8f812cbf7e0e38a04da1118" id="r_a11c2aa58d8f812cbf7e0e38a04da1118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a11c2aa58d8f812cbf7e0e38a04da1118">allocateScratch</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> size)</td></tr>
<tr class="memdesc:a11c2aa58d8f812cbf7e0e38a04da1118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator method to allow us to use a pool of memory as a scratch area for hardware buffers.  <br /></td></tr>
<tr class="separator:a11c2aa58d8f812cbf7e0e38a04da1118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b495397711f2183c49b4900bb425e78" id="r_a4b495397711f2183c49b4900bb425e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a4b495397711f2183c49b4900bb425e78">allocateVertexBufferCopy</a> (<a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1map.html">sourceBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a73af0e384fffafd30ec13438507d31eb">BufferLicenseType</a> licenseType, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_licensee.html">HardwareBufferLicensee</a> *licensee, <a class="el" href="struct_ogre_1_1map.html">bool</a> copyData=<a class="el" href="struct_ogre_1_1map.html">false</a>)</td></tr>
<tr class="memdesc:a4b495397711f2183c49b4900bb425e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a copy of a given vertex buffer.  <br /></td></tr>
<tr class="separator:a4b495397711f2183c49b4900bb425e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5da13b5e1122a5f1195dccdfa45ae5" id="r_a2b5da13b5e1122a5f1195dccdfa45ae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_counter_buffer_shared_ptr.html">HardwareCounterBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a2b5da13b5e1122a5f1195dccdfa45ae5">createCounterBuffer</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">useShadowBuffer</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a2b5da13b5e1122a5f1195dccdfa45ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a counter buffer.  <br /></td></tr>
<tr class="separator:a2b5da13b5e1122a5f1195dccdfa45ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fb72a09a4656729106b410c47dc7ff" id="r_a56fb72a09a4656729106b410c47dc7ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_counter_buffer_shared_ptr.html">HardwareCounterBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a56fb72a09a4656729106b410c47dc7ff">createCounterBuffer</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">useShadowBuffer</a>, <a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">binding</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a56fb72a09a4656729106b410c47dc7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a counter buffer.  <br /></td></tr>
<tr class="separator:a56fb72a09a4656729106b410c47dc7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330c36379ed36c5194a36bc516c5df8e" id="r_a330c36379ed36c5194a36bc516c5df8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer_shared_ptr.html">HardwareIndexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a330c36379ed36c5194a36bc516c5df8e">createIndexBuffer</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#a525fa4b4e666c29a2eae7d5993c74d6f">HardwareIndexBuffer::IndexType</a> <a class="el" href="struct_ogre_1_1map.html">itype</a>, <a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">numIndexes</a>, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">useShadowBuffer</a>=<a class="el" href="struct_ogre_1_1map.html">false</a>)</td></tr>
<tr class="memdesc:a330c36379ed36c5194a36bc516c5df8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hardware vertex buffer.  <br /></td></tr>
<tr class="separator:a330c36379ed36c5194a36bc516c5df8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4340fe9d96d68dfbd1a091171c4239c5" id="r_a4340fe9d96d68dfbd1a091171c4239c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1v1.html#a2f7057decf95fb9c5529bfab76d10e26">RenderToVertexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a4340fe9d96d68dfbd1a091171c4239c5">createRenderToVertexBuffer</a> ()</td></tr>
<tr class="memdesc:a4340fe9d96d68dfbd1a091171c4239c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render to vertex buffer.  <br /></td></tr>
<tr class="separator:a4340fe9d96d68dfbd1a091171c4239c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b870cffa0edad2fe26e3f03b267d193" id="r_a1b870cffa0edad2fe26e3f03b267d193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer_shared_ptr.html">HardwareUniformBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a1b870cffa0edad2fe26e3f03b267d193">createShaderStorageBuffer</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">useShadowBuffer</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a1b870cffa0edad2fe26e3f03b267d193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shader storage buffer.  <br /></td></tr>
<tr class="separator:a1b870cffa0edad2fe26e3f03b267d193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a03e1c039eac49dc408d550913ad53b" id="r_a8a03e1c039eac49dc408d550913ad53b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer_shared_ptr.html">HardwareUniformBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a8a03e1c039eac49dc408d550913ad53b">createShaderStorageBuffer</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">useShadowBuffer</a>, <a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">binding</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a8a03e1c039eac49dc408d550913ad53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shader storage buffer.  <br /></td></tr>
<tr class="separator:a8a03e1c039eac49dc408d550913ad53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e08c5500cb3625742cec43eb4c35979" id="r_a7e08c5500cb3625742cec43eb4c35979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer_shared_ptr.html">HardwareUniformBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a7e08c5500cb3625742cec43eb4c35979">createUniformBuffer</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">useShadowBuffer</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a7e08c5500cb3625742cec43eb4c35979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform buffer.  <br /></td></tr>
<tr class="separator:a7e08c5500cb3625742cec43eb4c35979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeda56733ebdc3c8e0644ade21d14f1e" id="r_aeeda56733ebdc3c8e0644ade21d14f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer_shared_ptr.html">HardwareUniformBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#aeeda56733ebdc3c8e0644ade21d14f1e">createUniformBuffer</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">useShadowBuffer</a>, <a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">binding</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:aeeda56733ebdc3c8e0644ade21d14f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uniform buffer.  <br /></td></tr>
<tr class="separator:aeeda56733ebdc3c8e0644ade21d14f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff952bdfcdb09cbc0fd84da1c99d65e" id="r_a8ff952bdfcdb09cbc0fd84da1c99d65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a8ff952bdfcdb09cbc0fd84da1c99d65e">createVertexBuffer</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">vertexSize</a>, <a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">numVerts</a>, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">useShadowBuffer</a>=<a class="el" href="struct_ogre_1_1map.html">false</a>)</td></tr>
<tr class="memdesc:a8ff952bdfcdb09cbc0fd84da1c99d65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vertex buffer.  <br /></td></tr>
<tr class="separator:a8ff952bdfcdb09cbc0fd84da1c99d65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811fe109c1329bdb8357e93f001c7cee" id="r_a811fe109c1329bdb8357e93f001c7cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="class_ogre_1_1v1_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a811fe109c1329bdb8357e93f001c7cee">createVertexBufferBinding</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>)</td></tr>
<tr class="memdesc:a811fe109c1329bdb8357e93f001c7cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_ogre_1_1v1_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a>.  <br /></td></tr>
<tr class="separator:a811fe109c1329bdb8357e93f001c7cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14593f984cbbcc9b99ab6db1e1b0e8e" id="r_ad14593f984cbbcc9b99ab6db1e1b0e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="class_ogre_1_1v1_1_1_vertex_declaration.html">VertexDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#ad14593f984cbbcc9b99ab6db1e1b0e8e">createVertexDeclaration</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>)</td></tr>
<tr class="memdesc:ad14593f984cbbcc9b99ab6db1e1b0e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vertex declaration.  <br /></td></tr>
<tr class="separator:ad14593f984cbbcc9b99ab6db1e1b0e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b03b3afb7c0f5d5cbf9f81273cfb237" id="r_a2b03b3afb7c0f5d5cbf9f81273cfb237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a2b03b3afb7c0f5d5cbf9f81273cfb237">deallocateScratch</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr)</td></tr>
<tr class="separator:a2b03b3afb7c0f5d5cbf9f81273cfb237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec7f834aff615ec9efd3169658950b0" id="r_aaec7f834aff615ec9efd3169658950b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#aaec7f834aff615ec9efd3169658950b0">destroyVertexBufferBinding</a> (<a class="el" href="class_ogre_1_1v1_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *<a class="el" href="struct_ogre_1_1map.html">binding</a>)</td></tr>
<tr class="memdesc:aaec7f834aff615ec9efd3169658950b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <a class="el" href="class_ogre_1_1v1_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a>.  <br /></td></tr>
<tr class="separator:aaec7f834aff615ec9efd3169658950b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b732d773d680492f36f23c5d217bade" id="r_a5b732d773d680492f36f23c5d217bade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a5b732d773d680492f36f23c5d217bade">destroyVertexDeclaration</a> (<a class="el" href="class_ogre_1_1v1_1_1_vertex_declaration.html">VertexDeclaration</a> *<a class="el" href="struct_ogre_1_1map.html">decl</a>)</td></tr>
<tr class="memdesc:a5b732d773d680492f36f23c5d217bade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a vertex declaration.  <br /></td></tr>
<tr class="separator:a5b732d773d680492f36f23c5d217bade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e328f5e1494acb5594cc32f7f9a8d1" id="r_ae7e328f5e1494acb5594cc32f7f9a8d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#ae7e328f5e1494acb5594cc32f7f9a8d1">getGLMapBufferThreshold</a> () <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="memdesc:ae7e328f5e1494acb5594cc32f7f9a8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold after which glMapBuffer is used and not glBufferSubData.  <br /></td></tr>
<tr class="separator:ae7e328f5e1494acb5594cc32f7f9a8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded" id="r_a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792" id="r_acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *, <a class="el" href="struct_ogre_1_1map.html">int</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144" id="r_a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr, <a class="el" href="struct_ogre_1_1map.html">void</a> *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c" id="r_a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d" id="r_a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *, <a class="el" href="struct_ogre_1_1map.html">int</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f1a983f9e2dfddee802c47bb0b1ca9" id="r_ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ad1f1a983f9e2dfddee802c47bb0b1ca9">operator new</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>)</td></tr>
<tr class="separator:ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422c67a2c8844f410fe822a357cba3b" id="r_ab422c67a2c8844f410fe822a357cba3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab422c67a2c8844f410fe822a357cba3b">operator new</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *file, <a class="el" href="struct_ogre_1_1map.html">int</a> line, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *<a class="el" href="struct_ogre_1_1map.html">func</a>)</td></tr>
<tr class="memdesc:ab422c67a2c8844f410fe822a357cba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <br /></td></tr>
<tr class="separator:ab422c67a2c8844f410fe822a357cba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc6bdc2eb6aeac24898a77ec5e2023" id="r_a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a63fc6bdc2eb6aeac24898a77ec5e2023">operator new</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>, <a class="el" href="struct_ogre_1_1map.html">void</a> *ptr)</td></tr>
<tr class="memdesc:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <br /></td></tr>
<tr class="separator:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce32528577d71b228692df906ecd17c" id="r_adce32528577d71b228692df906ecd17c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#adce32528577d71b228692df906ecd17c">operator new[]</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>)</td></tr>
<tr class="separator:adce32528577d71b228692df906ecd17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1464ac3de21ff20db8f9f1f8608dc7" id="r_aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#aed1464ac3de21ff20db8f9f1f8608dc7">operator new[]</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *file, <a class="el" href="struct_ogre_1_1map.html">int</a> line, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *<a class="el" href="struct_ogre_1_1map.html">func</a>)</td></tr>
<tr class="memdesc:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <br /></td></tr>
<tr class="separator:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c24edf06c085c0d4493eb027f830cb" id="r_a09c24edf06c085c0d4493eb027f830cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a09c24edf06c085c0d4493eb027f830cb">registerVertexBufferSourceAndCopy</a> (<a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1map.html">sourceBuffer</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;copy)</td></tr>
<tr class="memdesc:a09c24edf06c085c0d4493eb027f830cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a vertex buffer as a copy of another.  <br /></td></tr>
<tr class="separator:a09c24edf06c085c0d4493eb027f830cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39247a31786d77e3da0200052e5be0c" id="r_ad39247a31786d77e3da0200052e5be0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#ad39247a31786d77e3da0200052e5be0c">releaseVertexBufferCopy</a> (<a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1map.html">bufferCopy</a>)</td></tr>
<tr class="memdesc:ad39247a31786d77e3da0200052e5be0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually release a vertex buffer copy for others to subsequently use.  <br /></td></tr>
<tr class="separator:ad39247a31786d77e3da0200052e5be0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c0e8e458882807d0879795304aeb38" id="r_a00c0e8e458882807d0879795304aeb38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a00c0e8e458882807d0879795304aeb38">setGLMapBufferThreshold</a> (<a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">size_t</a> value)</td></tr>
<tr class="separator:a00c0e8e458882807d0879795304aeb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b1ee3a62509c78ab8c6c7a13ad8059" id="r_a28b1ee3a62509c78ab8c6c7a13ad8059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a28b1ee3a62509c78ab8c6c7a13ad8059">touchVertexBufferCopy</a> (<a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;<a class="el" href="struct_ogre_1_1map.html">bufferCopy</a>)</td></tr>
<tr class="memdesc:a28b1ee3a62509c78ab8c6c7a13ad8059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell engine that the vertex buffer copy intent to reuse.  <br /></td></tr>
<tr class="separator:a28b1ee3a62509c78ab8c6c7a13ad8059"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8bfd17628ae9c6b8cd052c43a15803df" id="r_a8bfd17628ae9c6b8cd052c43a15803df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">static</a> <a class="el" href="struct_ogre_1_1map.html">GLenum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a8bfd17628ae9c6b8cd052c43a15803df">getGLType</a> (<a class="el" href="struct_ogre_1_1map.html">unsigned</a> <a class="el" href="struct_ogre_1_1map.html">int</a> type)</td></tr>
<tr class="memdesc:a8bfd17628ae9c6b8cd052c43a15803df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to get the correct GL type based on VET's.  <br /></td></tr>
<tr class="separator:a8bfd17628ae9c6b8cd052c43a15803df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf5631e8199ca7c3bfc0def98c6864e" id="r_aebf5631e8199ca7c3bfc0def98c6864e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">static</a> <a class="el" href="struct_ogre_1_1map.html">GLenum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#aebf5631e8199ca7c3bfc0def98c6864e">getGLUsage</a> (<a class="el" href="struct_ogre_1_1map.html">unsigned</a> <a class="el" href="struct_ogre_1_1map.html">int</a> <a class="el" href="struct_ogre_1_1map.html">usage</a>)</td></tr>
<tr class="memdesc:aebf5631e8199ca7c3bfc0def98c6864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to get the correct GL usage based on HBU's.  <br /></td></tr>
<tr class="separator:aebf5631e8199ca7c3bfc0def98c6864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> for OpenGL. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a73af0e384fffafd30ec13438507d31eb" name="a73af0e384fffafd30ec13438507d31eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73af0e384fffafd30ec13438507d31eb">&#9670;&#160;</a></span>BufferLicenseType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">enum</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a73af0e384fffafd30ec13438507d31eb">Ogre::v1::HardwareBufferManagerBase::BufferLicenseType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a73af0e384fffafd30ec13438507d31ebaefbef8f3135135145a860b8647faba4c" name="a73af0e384fffafd30ec13438507d31ebaefbef8f3135135145a860b8647faba4c"></a>BLT_MANUAL_RELEASE&#160;</td><td class="fielddoc"><p>Licensee will only release buffer when it says so. </p>
</td></tr>
<tr><td class="fieldname"><a id="a73af0e384fffafd30ec13438507d31eba2b12eec76abb4c56344b6c6ff1cdb65f" name="a73af0e384fffafd30ec13438507d31eba2b12eec76abb4c56344b6c6ff1cdb65f"></a>BLT_AUTOMATIC_RELEASE&#160;</td><td class="fielddoc"><p>Licensee can have license revoked. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a520ef2e60b7615abfcf6fda999b65104" name="a520ef2e60b7615abfcf6fda999b65104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520ef2e60b7615abfcf6fda999b65104">&#9670;&#160;</a></span>GL3PlusHardwareBufferManagerBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::GL3PlusHardwareBufferManagerBase::GL3PlusHardwareBufferManagerBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59fa9b13d874bf81377dd72fce88e13f" name="a59fa9b13d874bf81377dd72fce88e13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fa9b13d874bf81377dd72fce88e13f">&#9670;&#160;</a></span>~GL3PlusHardwareBufferManagerBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::GL3PlusHardwareBufferManagerBase::~GL3PlusHardwareBufferManagerBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7f51811f14dcf9cc9c62311bf5952ce1" name="a7f51811f14dcf9cc9c62311bf5952ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f51811f14dcf9cc9c62311bf5952ce1">&#9670;&#160;</a></span>_forceReleaseBufferCopies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::_forceReleaseBufferCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method that forces the release of copies of a given buffer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This usually means that the buffer which the copies are based on has been changed in some fundamental way, and the owner of the original wishes to make that known so that new copies will reflect the changes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceBuffer</td><td>The source buffer as a shared pointer. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> buffer copies created from the source buffer are deleted. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ad31a801ac5e410a06a20706f437cdebd">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ad31a801ac5e410a06a20706f437cdebd">Ogre::v1::HardwareBufferManager::_forceReleaseBufferCopies()</a>, and <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ab89c749b1de0d07abf2d10cdde39d457">Ogre::v1::HardwareBufferManager::_forceReleaseBufferCopies()</a>.</p>

</div>
</div>
<a id="adac7eb3844eae2dbceecfab0e0eb034c" name="adac7eb3844eae2dbceecfab0e0eb034c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac7eb3844eae2dbceecfab0e0eb034c">&#9670;&#160;</a></span>_forceReleaseBufferCopies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::_forceReleaseBufferCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer.html">HardwareVertexBuffer</a> *&#160;</td>
          <td class="paramname"><em>sourceBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method that forces the release of copies of a given buffer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This usually means that the buffer which the copies are based on has been changed in some fundamental way, and the owner of the original wishes to make that known so that new copies will reflect the changes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceBuffer</td><td>The source buffer as a pointer. <a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> buffer copies created from the source buffer are deleted. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ab89c749b1de0d07abf2d10cdde39d457">Ogre::v1::HardwareBufferManager</a>.</p>

</div>
</div>
<a id="a79513a524782fcac13a6d91e68013ad7" name="a79513a524782fcac13a6d91e68013ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79513a524782fcac13a6d91e68013ad7">&#9670;&#160;</a></span>_freeUnusedBufferCopies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::_freeUnusedBufferCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all unused vertex buffer copies. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method free all temporary vertex buffers that not in used. In normally, temporary vertex buffers are subsequently stored and can be made available for other purposes later without incurring the cost of construction / destruction. But in some cases you want to free them to save hardware memory (e.g. application was runs in a long time, you might free temporary buffers periodically to avoid memory overload). </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#aefebeab1dc9817a749f72d6c6a66c07f">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#aefebeab1dc9817a749f72d6c6a66c07f">Ogre::v1::HardwareBufferManager::_freeUnusedBufferCopies()</a>.</p>

</div>
</div>
<a id="ad1a0ad696cd4a4a56f31ed5a2d954351" name="ad1a0ad696cd4a4a56f31ed5a2d954351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a0ad696cd4a4a56f31ed5a2d954351">&#9670;&#160;</a></span>_notifyCounterBufferDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::_notifyCounterBufferDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_counter_buffer.html">HardwareCounterBuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notification that at hardware counter buffer has been destroyed. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#af806a0585b212d4b179e77770b22eaef">Ogre::v1::HardwareBufferManager::_notifyConterBufferDestroyed()</a>.</p>

</div>
</div>
<a id="a99d79f386a09e77e911112e9988838d1" name="a99d79f386a09e77e911112e9988838d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d79f386a09e77e911112e9988838d1">&#9670;&#160;</a></span>_notifyIndexBufferDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::_notifyIndexBufferDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html">HardwareIndexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notification that a hardware index buffer has been destroyed. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#affc9ded1625ecbd07556ba24a15b6429">Ogre::v1::HardwareBufferManager::_notifyIndexBufferDestroyed()</a>.</p>

</div>
</div>
<a id="ad7858c87b21a22eb251aef043bf04285" name="ad7858c87b21a22eb251aef043bf04285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7858c87b21a22eb251aef043bf04285">&#9670;&#160;</a></span>_notifyUniformBufferDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::_notifyUniformBufferDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer.html">HardwareUniformBuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notification that at hardware uniform buffer has been destroyed. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a95108cb8cebac0fae72bc4439fdd6e65">Ogre::v1::HardwareBufferManager::_notifyUniformBufferDestroyed()</a>.</p>

</div>
</div>
<a id="a3d598f5c8dd22d52ce27fd9e73a7b23a" name="a3d598f5c8dd22d52ce27fd9e73a7b23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d598f5c8dd22d52ce27fd9e73a7b23a">&#9670;&#160;</a></span>_notifyVertexBufferDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::_notifyVertexBufferDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer.html">HardwareVertexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notification that a hardware vertex buffer has been destroyed. </p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ab3fc128d148ce3954e184a505199e0d2">Ogre::v1::HardwareBufferManager::_notifyVertexBufferDestroyed()</a>.</p>

</div>
</div>
<a id="a08297892d344182b4daa24b1b6bde626" name="a08297892d344182b4daa24b1b6bde626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08297892d344182b4daa24b1b6bde626">&#9670;&#160;</a></span>_releaseBufferCopies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::_releaseBufferCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>forceFreeUnused</em> = <code><a class="el" href="struct_ogre_1_1map.html">false</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method for releasing all temporary buffers which have been allocated using BLT_AUTOMATIC_RELEASE; is called by OGRE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forceFreeUnused</td><td>If <code>true</code>, free all unused temporary buffers. If <code>false</code>, auto detect and free all unused temporary buffers based on temporary buffers utilization. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a837b8d79883d0776fde7a0ccc3a4c905">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a837b8d79883d0776fde7a0ccc3a4c905">Ogre::v1::HardwareBufferManager::_releaseBufferCopies()</a>.</p>

</div>
</div>
<a id="a11c2aa58d8f812cbf7e0e38a04da1118" name="a11c2aa58d8f812cbf7e0e38a04da1118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c2aa58d8f812cbf7e0e38a04da1118">&#9670;&#160;</a></span>allocateScratch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * Ogre::v1::GL3PlusHardwareBufferManagerBase::allocateScratch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator method to allow us to use a pool of memory as a scratch area for hardware buffers. </p>
<p>This is because glMapBuffer is incredibly inefficient, seemingly no matter what options we give it. So for the period of lock/unlock, we will instead allocate a section of a local memory pool, and use glBufferSubDataARB / glGetBufferSubDataARB instead. </p>

</div>
</div>
<a id="a4b495397711f2183c49b4900bb425e78" name="a4b495397711f2183c49b4900bb425e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b495397711f2183c49b4900bb425e78">&#9670;&#160;</a></span>allocateVertexBufferCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> Ogre::v1::HardwareBufferManagerBase::allocateVertexBufferCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a73af0e384fffafd30ec13438507d31eb">BufferLicenseType</a>&#160;</td>
          <td class="paramname"><em>licenseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_licensee.html">HardwareBufferLicensee</a> *&#160;</td>
          <td class="paramname"><em>licensee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>copyData</em> = <code><a class="el" href="struct_ogre_1_1map.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a copy of a given vertex buffer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method allocates a temporary copy of an existing vertex buffer. This buffer is subsequently stored and can be made available for other purposes later without incurring the cost of construction / destruction. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceBuffer</td><td>The source buffer to use as a copy. </td></tr>
    <tr><td class="paramname">licenseType</td><td>The type of license required on this buffer - automatic release causes this class to release licenses every frame so that they can be reallocated anew. </td></tr>
    <tr><td class="paramname">licensee</td><td>Pointer back to the class requesting the copy, which must implement HardwareBufferLicense in order to be notified when the license expires. </td></tr>
    <tr><td class="paramname">copyData</td><td>If <code>true</code>, the current data is copied as well as the structure of the buffer/ </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a9cbf1bd5a5a6a7665ae98a7cfca4e225">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a9cbf1bd5a5a6a7665ae98a7cfca4e225">Ogre::v1::HardwareBufferManager::allocateVertexBufferCopy()</a>.</p>

</div>
</div>
<a id="a2b5da13b5e1122a5f1195dccdfa45ae5" name="a2b5da13b5e1122a5f1195dccdfa45ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5da13b5e1122a5f1195dccdfa45ae5">&#9670;&#160;</a></span>createCounterBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_counter_buffer_shared_ptr.html">HardwareCounterBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createCounterBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a counter buffer. </p>

<p>Implements <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a9abe2acaada6227d323763be810646c7">Ogre::v1::HardwareBufferManagerBase</a>.</p>

</div>
</div>
<a id="a56fb72a09a4656729106b410c47dc7ff" name="a56fb72a09a4656729106b410c47dc7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fb72a09a4656729106b410c47dc7ff">&#9670;&#160;</a></span>createCounterBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_counter_buffer_shared_ptr.html">HardwareCounterBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createCounterBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a counter buffer. </p>

</div>
</div>
<a id="a330c36379ed36c5194a36bc516c5df8e" name="a330c36379ed36c5194a36bc516c5df8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330c36379ed36c5194a36bc516c5df8e">&#9670;&#160;</a></span>createIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer_shared_ptr.html">HardwareIndexBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#a525fa4b4e666c29a2eae7d5993c74d6f">HardwareIndexBuffer::IndexType</a>&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em> = <code><a class="el" href="struct_ogre_1_1map.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a hardware vertex buffer. </p>

<p>Implements <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a07417aa802af09c92edbfe95763b488a">Ogre::v1::HardwareBufferManagerBase</a>.</p>

</div>
</div>
<a id="a4340fe9d96d68dfbd1a091171c4239c5" name="a4340fe9d96d68dfbd1a091171c4239c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4340fe9d96d68dfbd1a091171c4239c5">&#9670;&#160;</a></span>createRenderToVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1v1.html#a2f7057decf95fb9c5529bfab76d10e26">RenderToVertexBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createRenderToVertexBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a render to vertex buffer. </p>

<p>Implements <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#ac8479449e4eba5e3a5ce31550e376130">Ogre::v1::HardwareBufferManagerBase</a>.</p>

</div>
</div>
<a id="a1b870cffa0edad2fe26e3f03b267d193" name="a1b870cffa0edad2fe26e3f03b267d193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b870cffa0edad2fe26e3f03b267d193">&#9670;&#160;</a></span>createShaderStorageBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer_shared_ptr.html">HardwareUniformBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shader storage buffer. </p>

</div>
</div>
<a id="a8a03e1c039eac49dc408d550913ad53b" name="a8a03e1c039eac49dc408d550913ad53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a03e1c039eac49dc408d550913ad53b">&#9670;&#160;</a></span>createShaderStorageBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer_shared_ptr.html">HardwareUniformBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shader storage buffer. </p>

</div>
</div>
<a id="a7e08c5500cb3625742cec43eb4c35979" name="a7e08c5500cb3625742cec43eb4c35979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e08c5500cb3625742cec43eb4c35979">&#9670;&#160;</a></span>createUniformBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer_shared_ptr.html">HardwareUniformBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a uniform buffer. </p>

<p>Implements <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#a20c21daf3a0922fc1f9329882a85ba6e">Ogre::v1::HardwareBufferManagerBase</a>.</p>

</div>
</div>
<a id="aeeda56733ebdc3c8e0644ade21d14f1e" name="aeeda56733ebdc3c8e0644ade21d14f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeda56733ebdc3c8e0644ade21d14f1e">&#9670;&#160;</a></span>createUniformBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_uniform_buffer_shared_ptr.html">HardwareUniformBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a uniform buffer. </p>

</div>
</div>
<a id="a8ff952bdfcdb09cbc0fd84da1c99d65e" name="a8ff952bdfcdb09cbc0fd84da1c99d65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff952bdfcdb09cbc0fd84da1c99d65e">&#9670;&#160;</a></span>createVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::createVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>vertexSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em> = <code><a class="el" href="struct_ogre_1_1map.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vertex buffer. </p>

<p>Implements <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html#aebf1002f2335a0f3587e9ff0c0b41b55">Ogre::v1::HardwareBufferManagerBase</a>.</p>

</div>
</div>
<a id="a811fe109c1329bdb8357e93f001c7cee" name="a811fe109c1329bdb8357e93f001c7cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811fe109c1329bdb8357e93f001c7cee">&#9670;&#160;</a></span>createVertexBufferBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="class_ogre_1_1v1_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> * Ogre::v1::HardwareBufferManagerBase::createVertexBufferBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_ogre_1_1v1_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a>. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a81a86fb9b9f772c6ae0296ca01b322f0">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a81a86fb9b9f772c6ae0296ca01b322f0">Ogre::v1::HardwareBufferManager::createVertexBufferBinding()</a>.</p>

</div>
</div>
<a id="ad14593f984cbbcc9b99ab6db1e1b0e8e" name="ad14593f984cbbcc9b99ab6db1e1b0e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14593f984cbbcc9b99ab6db1e1b0e8e">&#9670;&#160;</a></span>createVertexDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="class_ogre_1_1v1_1_1_vertex_declaration.html">VertexDeclaration</a> * Ogre::v1::HardwareBufferManagerBase::createVertexDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vertex declaration. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ab2742dc658728cee814970926f85e1d0">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ab2742dc658728cee814970926f85e1d0">Ogre::v1::HardwareBufferManager::createVertexDeclaration()</a>.</p>

</div>
</div>
<a id="a2b03b3afb7c0f5d5cbf9f81273cfb237" name="a2b03b3afb7c0f5d5cbf9f81273cfb237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b03b3afb7c0f5d5cbf9f81273cfb237">&#9670;&#160;</a></span>deallocateScratch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::deallocateScratch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html#a11c2aa58d8f812cbf7e0e38a04da1118" title="Allocator method to allow us to use a pool of memory as a scratch area for hardware buffers.">allocateScratch</a> </dd></dl>

</div>
</div>
<a id="aaec7f834aff615ec9efd3169658950b0" name="aaec7f834aff615ec9efd3169658950b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec7f834aff615ec9efd3169658950b0">&#9670;&#160;</a></span>destroyVertexBufferBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::destroyVertexBufferBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_vertex_buffer_binding.html">VertexBufferBinding</a> *&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a <a class="el" href="class_ogre_1_1v1_1_1_vertex_buffer_binding.html" title="Records the state of all the vertex buffer bindings required to provide a vertex declaration with the...">VertexBufferBinding</a>. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a15077ee295a2fa1e0673b55b1ad7f944">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a15077ee295a2fa1e0673b55b1ad7f944">Ogre::v1::HardwareBufferManager::destroyVertexBufferBinding()</a>.</p>

</div>
</div>
<a id="a5b732d773d680492f36f23c5d217bade" name="a5b732d773d680492f36f23c5d217bade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b732d773d680492f36f23c5d217bade">&#9670;&#160;</a></span>destroyVertexDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::destroyVertexDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_vertex_declaration.html">VertexDeclaration</a> *&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a vertex declaration. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#afae0e3c4fb95f96b60147cde62b0bacb">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#afae0e3c4fb95f96b60147cde62b0bacb">Ogre::v1::HardwareBufferManager::destroyVertexDeclaration()</a>.</p>

</div>
</div>
<a id="ae7e328f5e1494acb5594cc32f7f9a8d1" name="ae7e328f5e1494acb5594cc32f7f9a8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e328f5e1494acb5594cc32f7f9a8d1">&#9670;&#160;</a></span>getGLMapBufferThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">size_t</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::getGLMapBufferThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threshold after which glMapBuffer is used and not glBufferSubData. </p>

</div>
</div>
<a id="a8bfd17628ae9c6b8cd052c43a15803df" name="a8bfd17628ae9c6b8cd052c43a15803df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfd17628ae9c6b8cd052c43a15803df">&#9670;&#160;</a></span>getGLType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">static</a> <a class="el" href="struct_ogre_1_1map.html">GLenum</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::getGLType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">unsigned</a> <a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to get the correct GL type based on VET's. </p>

</div>
</div>
<a id="aebf5631e8199ca7c3bfc0def98c6864e" name="aebf5631e8199ca7c3bfc0def98c6864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf5631e8199ca7c3bfc0def98c6864e">&#9670;&#160;</a></span>getGLUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">static</a> <a class="el" href="struct_ogre_1_1map.html">GLenum</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::getGLUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">unsigned</a> <a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname"><em>usage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to get the correct GL usage based on HBU's. </p>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded" name="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&#160;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792" name="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&#160;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144" name="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&#160;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c" name="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&#160;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d" name="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&#160;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f1a983f9e2dfddee802c47bb0b1ca9" name="ad1f1a983f9e2dfddee802c47bb0b1ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f1a983f9e2dfddee802c47bb0b1ca9">&#9670;&#160;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab422c67a2c8844f410fe822a357cba3b" name="ab422c67a2c8844f410fe822a357cba3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422c67a2c8844f410fe822a357cba3b">&#9670;&#160;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="a63fc6bdc2eb6aeac24898a77ec5e2023" name="a63fc6bdc2eb6aeac24898a77ec5e2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc6bdc2eb6aeac24898a77ec5e2023">&#9670;&#160;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="adce32528577d71b228692df906ecd17c" name="adce32528577d71b228692df906ecd17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce32528577d71b228692df906ecd17c">&#9670;&#160;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed1464ac3de21ff20db8f9f1f8608dc7" name="aed1464ac3de21ff20db8f9f1f8608dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1464ac3de21ff20db8f9f1f8608dc7">&#9670;&#160;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="a09c24edf06c085c0d4493eb027f830cb" name="a09c24edf06c085c0d4493eb027f830cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c24edf06c085c0d4493eb027f830cb">&#9670;&#160;</a></span>registerVertexBufferSourceAndCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::registerVertexBufferSourceAndCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a vertex buffer as a copy of another. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful for registering an existing buffer as a temporary buffer which can be allocated just like a copy. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a78d100749d4bc2d491fa77ab3b92d5b7">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#a78d100749d4bc2d491fa77ab3b92d5b7">Ogre::v1::HardwareBufferManager::registerVertexBufferSourceAndCopy()</a>.</p>

</div>
</div>
<a id="ad39247a31786d77e3da0200052e5be0c" name="ad39247a31786d77e3da0200052e5be0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39247a31786d77e3da0200052e5be0c">&#9670;&#160;</a></span>releaseVertexBufferCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::releaseVertexBufferCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferCopy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually release a vertex buffer copy for others to subsequently use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only required if the original call to allocateVertexBufferCopy included a licenseType of BLT_MANUAL_RELEASE. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferCopy</td><td>The buffer copy. The caller is expected to delete or at least no longer use this reference, since another user may well begin to modify the contents of the buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#acf84c58415d8da16909c212929dbf825">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#acf84c58415d8da16909c212929dbf825">Ogre::v1::HardwareBufferManager::releaseVertexBufferCopy()</a>.</p>

</div>
</div>
<a id="a00c0e8e458882807d0879795304aeb38" name="a00c0e8e458882807d0879795304aeb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c0e8e458882807d0879795304aeb38">&#9670;&#160;</a></span>setGLMapBufferThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::GL3PlusHardwareBufferManagerBase::setGLMapBufferThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28b1ee3a62509c78ab8c6c7a13ad8059" name="a28b1ee3a62509c78ab8c6c7a13ad8059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b1ee3a62509c78ab8c6c7a13ad8059">&#9670;&#160;</a></span>touchVertexBufferCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::v1::HardwareBufferManagerBase::touchVertexBufferCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferCopy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell engine that the vertex buffer copy intent to reuse. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="namespace_ogre.html">Ogre</a> internal keep an expired delay counter of BLT_AUTOMATIC_RELEASE buffers, when the counter count down to zero, it'll release for other purposes later. But you can use this function to reset the counter to the internal configured value, keep the buffer not get released for some frames. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferCopy</td><td>The buffer copy. The caller is expected to keep this buffer copy for use. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ae3e26b4572d8f07a6a393f4d04dea36c">Ogre::v1::HardwareBufferManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager.html#ae3e26b4572d8f07a6a393f4d04dea36c">Ogre::v1::HardwareBufferManager::touchVertexBufferCopy()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_g_l3_plus_hardware_buffer_manager_8h.html">OgreGL3PlusHardwareBufferManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="namespace_ogre_1_1v1.html">v1</a></li><li class="navelem"><a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_hardware_buffer_manager_base.html">GL3PlusHardwareBufferManagerBase</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
