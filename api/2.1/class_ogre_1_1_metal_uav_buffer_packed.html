<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::MetalUavBufferPacked Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;2.1</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_metal_uav_buffer_packed.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_metal_uav_buffer_packed-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::MetalUavBufferPacked Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreMetalUavBufferPacked.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::MetalUavBufferPacked:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_metal_uav_buffer_packed__inherit__graph.svg" width="299" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9008790fcf5ebe4c0eb63054229fafbd" id="r_a9008790fcf5ebe4c0eb63054229fafbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_metal_uav_buffer_packed.html#a9008790fcf5ebe4c0eb63054229fafbd">MetalUavBufferPacked</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">internalBufStartBytes</a>, <a class="el" href="struct_ogre_1_1map.html">size_t</a> numElements, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> bytesPerElement, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> bindFlags, <a class="el" href="struct_ogre_1_1map.html">void</a> *<a class="el" href="struct_ogre_1_1map.html">initialData</a>, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">keepAsShadow</a>, <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *<a class="el" href="struct_ogre_1_1map.html">vaoManager</a>, <a class="el" href="class_ogre_1_1_metal_buffer_interface.html">MetalBufferInterface</a> *<a class="el" href="struct_ogre_1_1map.html">bufferInterface</a>, <a class="el" href="struct_ogre_1_1_metal_device.html">MetalDevice</a> *device)</td></tr>
<tr class="separator:a9008790fcf5ebe4c0eb63054229fafbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23275b193d239d549cbefdbd6f8bd492" id="r_a23275b193d239d549cbefdbd6f8bd492"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_metal_uav_buffer_packed.html#a23275b193d239d549cbefdbd6f8bd492">~MetalUavBufferPacked</a> ()</td></tr>
<tr class="separator:a23275b193d239d549cbefdbd6f8bd492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac73dd5b3bfea12dca1c5a64e6e95c7a" id="r_aac73dd5b3bfea12dca1c5a64e6e95c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#aac73dd5b3bfea12dca1c5a64e6e95c7a">_getFinalBufferStart</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:aac73dd5b3bfea12dca1c5a64e6e95c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481ad7b97cb88501c5777f4703ff2320" id="r_a481ad7b97cb88501c5777f4703ff2320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a481ad7b97cb88501c5777f4703ff2320">_getInternalBufferStart</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:a481ad7b97cb88501c5777f4703ff2320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb93f9fe49eedbdbc91ea6eb5feed56" id="r_aceb93f9fe49eedbdbc91ea6eb5feed56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#aceb93f9fe49eedbdbc91ea6eb5feed56">_getInternalNumElements</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:aceb93f9fe49eedbdbc91ea6eb5feed56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe6a1ecb4b3ab2b2a5208e9daeb4168" id="r_a8fe6a1ecb4b3ab2b2a5208e9daeb4168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a8fe6a1ecb4b3ab2b2a5208e9daeb4168">_getInternalTotalSizeBytes</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:a8fe6a1ecb4b3ab2b2a5208e9daeb4168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfd9629389ccf2aedec4b37f5a1b403" id="r_a7cfd9629389ccf2aedec4b37f5a1b403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a7cfd9629389ccf2aedec4b37f5a1b403">_setBufferInterface</a> (<a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> *<a class="el" href="struct_ogre_1_1map.html">bufferInterface</a>)</td></tr>
<tr class="memdesc:a7cfd9629389ccf2aedec4b37f5a1b403"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <br /></td></tr>
<tr class="separator:a7cfd9629389ccf2aedec4b37f5a1b403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564935579f2252627f46dff29142e7ff" id="r_a564935579f2252627f46dff29142e7ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a564935579f2252627f46dff29142e7ff">_setShadowCopy</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *copy)</td></tr>
<tr class="memdesc:a564935579f2252627f46dff29142e7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will not delete the existing shadow copy so it can be used for other purposes if it is not needed call OGRE_FREE_SIMD( m-&gt;<a class="el" href="class_ogre_1_1_buffer_packed.html#a3161f7d1ca4a5aa6705dea4efc0a58a8">getShadowCopy()</a>, MEMCATEGORY_GEOMETRY ) before calling this function.  <br /></td></tr>
<tr class="separator:a564935579f2252627f46dff29142e7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f35a4a63b023187026b9abc1c897a71" id="r_a1f35a4a63b023187026b9abc1c897a71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a1f35a4a63b023187026b9abc1c897a71">advanceFrame</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>)</td></tr>
<tr class="separator:a1f35a4a63b023187026b9abc1c897a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dad93c786c6f00fca12a631d05e9fd" id="r_a98dad93c786c6f00fca12a631d05e9fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_metal_uav_buffer_packed.html#a98dad93c786c6f00fca12a631d05e9fd">bindBufferAllRenderStages</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot, <a class="el" href="struct_ogre_1_1map.html">size_t</a> offset=0)</td></tr>
<tr class="separator:a98dad93c786c6f00fca12a631d05e9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e02c2a04eea583c906fdb707782c76b" id="r_a1e02c2a04eea583c906fdb707782c76b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_metal_uav_buffer_packed.html#a1e02c2a04eea583c906fdb707782c76b">bindBufferCS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot, <a class="el" href="struct_ogre_1_1map.html">size_t</a> offset=0, <a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes=0)</td></tr>
<tr class="memdesc:a1e02c2a04eea583c906fdb707782c76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the texture buffer to the given slot in the Vertex/Pixel/Geometry/Hull/Domain/Compute Shader.  <br /></td></tr>
<tr class="separator:a1e02c2a04eea583c906fdb707782c76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293f67717c593f402f7739e5b7d244e0" id="r_a293f67717c593f402f7739e5b7d244e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_metal_uav_buffer_packed.html#a293f67717c593f402f7739e5b7d244e0">bindBufferPS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot, <a class="el" href="struct_ogre_1_1map.html">size_t</a> offset=0, <a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes=0)</td></tr>
<tr class="separator:a293f67717c593f402f7739e5b7d244e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06adc5b3c40e5bc23950b479b8820adf" id="r_a06adc5b3c40e5bc23950b479b8820adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_metal_uav_buffer_packed.html#a06adc5b3c40e5bc23950b479b8820adf">bindBufferVS</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slot, <a class="el" href="struct_ogre_1_1map.html">size_t</a> offset=0, <a class="el" href="struct_ogre_1_1map.html">size_t</a> sizeBytes=0)</td></tr>
<tr class="separator:a06adc5b3c40e5bc23950b479b8820adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab081334829993c5fcd4302777807cd9d" id="r_ab081334829993c5fcd4302777807cd9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html#ab081334829993c5fcd4302777807cd9d">destroyAllTexBufferViews</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>)</td></tr>
<tr class="separator:ab081334829993c5fcd4302777807cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da16a38736fc02b3a8f5f773e751f7c" id="r_a8da16a38736fc02b3a8f5f773e751f7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html#a8da16a38736fc02b3a8f5f773e751f7c">destroyTexBufferView</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pixelFormat)</td></tr>
<tr class="memdesc:a8da16a38736fc02b3a8f5f773e751f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory from a view created by getAsTexBufferView Does nothing if a view of the given pixel format did not exist.  <br /></td></tr>
<tr class="separator:a8da16a38736fc02b3a8f5f773e751f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a512da35a9771487c49d7d24652b3a" id="r_a23a512da35a9771487c49d7d24652b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html#a23a512da35a9771487c49d7d24652b3a">getAsTexBufferView</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pixelFormat)</td></tr>
<tr class="memdesc:a23a512da35a9771487c49d7d24652b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_ogre_1_1_tex_buffer_packed.html" title="Represents Texture buffers (also known as tbuffers in D3D11)">TexBufferPacked</a> for binding to the GPU as a texture w/ read-only access.  <br /></td></tr>
<tr class="separator:a23a512da35a9771487c49d7d24652b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ff95c6bebe87dcfe2d43a02cc0ba6c" id="r_a29ff95c6bebe87dcfe2d43a02cc0ba6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a29ff95c6bebe87dcfe2d43a02cc0ba6c">getBufferInterface</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:a29ff95c6bebe87dcfe2d43a02cc0ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856e7d7f45915efd5289793462befc2b" id="r_a856e7d7f45915efd5289793462befc2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="namespace_ogre.html#ab66e67b60d5f40dacf69ea55b82868ab">BufferPackedTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html#a856e7d7f45915efd5289793462befc2b">getBufferPackedType</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="memdesc:a856e7d7f45915efd5289793462befc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful to query which one is the derived class.  <br /></td></tr>
<tr class="separator:a856e7d7f45915efd5289793462befc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50080eb729acd0c995606d512d5633c9" id="r_a50080eb729acd0c995606d512d5633c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a50080eb729acd0c995606d512d5633c9">getBufferType</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:a50080eb729acd0c995606d512d5633c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98ad9606c188cc815fc647a21f20498" id="r_af98ad9606c188cc815fc647a21f20498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#af98ad9606c188cc815fc647a21f20498">getBytesPerElement</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:af98ad9606c188cc815fc647a21f20498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542b46fc7a7cf5fe524cfc7b4b389ba9" id="r_a542b46fc7a7cf5fe524cfc7b4b389ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a447e51d7625af79716667cebcfa6da57">MappingState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a542b46fc7a7cf5fe524cfc7b4b389ba9">getMappingState</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="memdesc:a542b46fc7a7cf5fe524cfc7b4b389ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping state.  <br /></td></tr>
<tr class="separator:a542b46fc7a7cf5fe524cfc7b4b389ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69984ccd67bf7c801cc33dd20780b581" id="r_a69984ccd67bf7c801cc33dd20780b581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a69984ccd67bf7c801cc33dd20780b581">getNumElements</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:a69984ccd67bf7c801cc33dd20780b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3161f7d1ca4a5aa6705dea4efc0a58a8" id="r_a3161f7d1ca4a5aa6705dea4efc0a58a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a3161f7d1ca4a5aa6705dea4efc0a58a8">getShadowCopy</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:a3161f7d1ca4a5aa6705dea4efc0a58a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155f9b4ef9bc20239691a869d4daa08d" id="r_a155f9b4ef9bc20239691a869d4daa08d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a155f9b4ef9bc20239691a869d4daa08d">getTotalSizeBytes</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="separator:a155f9b4ef9bc20239691a869d4daa08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7d5a7fc76d5e3086620800003e55b5" id="r_aac7d5a7fc76d5e3086620800003e55b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#aac7d5a7fc76d5e3086620800003e55b5">isCurrentlyMapped</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>) <a class="el" href="struct_ogre_1_1map.html">const</a></td></tr>
<tr class="memdesc:aac7d5a7fc76d5e3086620800003e55b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the buffer is currently mapped.  <br /></td></tr>
<tr class="separator:aac7d5a7fc76d5e3086620800003e55b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a2ccddbb2fc851304ae81eb78243ed" id="r_a24a2ccddbb2fc851304ae81eb78243ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *<a class="el" href="_ogre_platform_8h.html#a59a62dcc672b5775f3bd2a8d08bb60a4">RESTRICT_ALIAS_RETURN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a24a2ccddbb2fc851304ae81eb78243ed">map</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> elementStart, <a class="el" href="struct_ogre_1_1map.html">size_t</a> elementCount, <a class="el" href="struct_ogre_1_1map.html">bool</a> <a class="el" href="struct_ogre_1_1map.html">bAdvanceFrame</a>=<a class="el" href="struct_ogre_1_1map.html">true</a>)</td></tr>
<tr class="memdesc:a24a2ccddbb2fc851304ae81eb78243ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the specified region to a pointer the CPU can access.  <br /></td></tr>
<tr class="separator:a24a2ccddbb2fc851304ae81eb78243ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded" id="r_a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792" id="r_acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *, <a class="el" href="struct_ogre_1_1map.html">int</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144" id="r_a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr, <a class="el" href="struct_ogre_1_1map.html">void</a> *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c" id="r_a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d" id="r_a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (<a class="el" href="struct_ogre_1_1map.html">void</a> *ptr, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *, <a class="el" href="struct_ogre_1_1map.html">int</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f1a983f9e2dfddee802c47bb0b1ca9" id="r_ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ad1f1a983f9e2dfddee802c47bb0b1ca9">operator new</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>)</td></tr>
<tr class="separator:ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422c67a2c8844f410fe822a357cba3b" id="r_ab422c67a2c8844f410fe822a357cba3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab422c67a2c8844f410fe822a357cba3b">operator new</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *file, <a class="el" href="struct_ogre_1_1map.html">int</a> line, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *<a class="el" href="struct_ogre_1_1map.html">func</a>)</td></tr>
<tr class="memdesc:ab422c67a2c8844f410fe822a357cba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <br /></td></tr>
<tr class="separator:ab422c67a2c8844f410fe822a357cba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc6bdc2eb6aeac24898a77ec5e2023" id="r_a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a63fc6bdc2eb6aeac24898a77ec5e2023">operator new</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>, <a class="el" href="struct_ogre_1_1map.html">void</a> *ptr)</td></tr>
<tr class="memdesc:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <br /></td></tr>
<tr class="separator:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce32528577d71b228692df906ecd17c" id="r_adce32528577d71b228692df906ecd17c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#adce32528577d71b228692df906ecd17c">operator new[]</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>)</td></tr>
<tr class="separator:adce32528577d71b228692df906ecd17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1464ac3de21ff20db8f9f1f8608dc7" id="r_aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#aed1464ac3de21ff20db8f9f1f8608dc7">operator new[]</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">sz</a>, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *file, <a class="el" href="struct_ogre_1_1map.html">int</a> line, <a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *<a class="el" href="struct_ogre_1_1map.html">func</a>)</td></tr>
<tr class="memdesc:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <br /></td></tr>
<tr class="separator:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c6682bd4adc315782091679d230cee" id="r_a80c6682bd4adc315782091679d230cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aef9bfd2a5567613e99bc8d7eae1c1bf9">AsyncTicketPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a80c6682bd4adc315782091679d230cee">readRequest</a> (<a class="el" href="struct_ogre_1_1map.html">size_t</a> elementStart, <a class="el" href="struct_ogre_1_1map.html">size_t</a> elementCount)</td></tr>
<tr class="memdesc:a80c6682bd4adc315782091679d230cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Async data read request.  <br /></td></tr>
<tr class="separator:a80c6682bd4adc315782091679d230cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba157f97e7a2c5d08ddda393aeb028f8" id="r_aba157f97e7a2c5d08ddda393aeb028f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#aba157f97e7a2c5d08ddda393aeb028f8">regressFrame</a> (<a class="el" href="struct_ogre_1_1map.html">void</a>)</td></tr>
<tr class="memdesc:aba157f97e7a2c5d08ddda393aeb028f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the opposite of.  <br /></td></tr>
<tr class="separator:aba157f97e7a2c5d08ddda393aeb028f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e02f6b2fa2c16340c1a9359926b481" id="r_a73e02f6b2fa2c16340c1a9359926b481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a73e02f6b2fa2c16340c1a9359926b481">unmap</a> (<a class="el" href="namespace_ogre.html#a118de288d2577e6d95183777f40e57c7">UnmapOptions</a> <a class="el" href="struct_ogre_1_1map.html">unmapOption</a>, <a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">flushStartElem</a>=0, <a class="el" href="struct_ogre_1_1map.html">size_t</a> <a class="el" href="struct_ogre_1_1map.html">flushSizeElem</a>=0)</td></tr>
<tr class="memdesc:a73e02f6b2fa2c16340c1a9359926b481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps or flushes the region mapped with.  <br /></td></tr>
<tr class="separator:a73e02f6b2fa2c16340c1a9359926b481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6fb3d387685e50e2b5069164b95e6b" id="r_a0c6fb3d387685e50e2b5069164b95e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_buffer_packed.html#a0c6fb3d387685e50e2b5069164b95e6b">upload</a> (<a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">void</a> *data, <a class="el" href="struct_ogre_1_1map.html">size_t</a> elementStart, <a class="el" href="struct_ogre_1_1map.html">size_t</a> elementCount)</td></tr>
<tr class="memdesc:a0c6fb3d387685e50e2b5069164b95e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the provided data to the GPU.  <br /></td></tr>
<tr class="separator:a0c6fb3d387685e50e2b5069164b95e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9008790fcf5ebe4c0eb63054229fafbd" name="a9008790fcf5ebe4c0eb63054229fafbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9008790fcf5ebe4c0eb63054229fafbd">&#9670;&#160;</a></span>MetalUavBufferPacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::MetalUavBufferPacked::MetalUavBufferPacked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>internalBufStartBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>bytesPerElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>bindFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_metal_buffer_interface.html">MetalBufferInterface</a> *&#160;</td>
          <td class="paramname"><em>bufferInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_metal_device.html">MetalDevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23275b193d239d549cbefdbd6f8bd492" name="a23275b193d239d549cbefdbd6f8bd492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23275b193d239d549cbefdbd6f8bd492">&#9670;&#160;</a></span>~MetalUavBufferPacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::MetalUavBufferPacked::~MetalUavBufferPacked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aac73dd5b3bfea12dca1c5a64e6e95c7a" name="aac73dd5b3bfea12dca1c5a64e6e95c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac73dd5b3bfea12dca1c5a64e6e95c7a">&#9670;&#160;</a></span>_getFinalBufferStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">size_t</a> Ogre::BufferPacked::_getFinalBufferStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a481ad7b97cb88501c5777f4703ff2320" name="a481ad7b97cb88501c5777f4703ff2320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481ad7b97cb88501c5777f4703ff2320">&#9670;&#160;</a></span>_getInternalBufferStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">size_t</a> Ogre::BufferPacked::_getInternalBufferStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aceb93f9fe49eedbdbc91ea6eb5feed56" name="aceb93f9fe49eedbdbc91ea6eb5feed56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb93f9fe49eedbdbc91ea6eb5feed56">&#9670;&#160;</a></span>_getInternalNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">size_t</a> Ogre::BufferPacked::_getInternalNumElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fe6a1ecb4b3ab2b2a5208e9daeb4168" name="a8fe6a1ecb4b3ab2b2a5208e9daeb4168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe6a1ecb4b3ab2b2a5208e9daeb4168">&#9670;&#160;</a></span>_getInternalTotalSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">size_t</a> Ogre::BufferPacked::_getInternalTotalSizeBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cfd9629389ccf2aedec4b37f5a1b403" name="a7cfd9629389ccf2aedec4b37f5a1b403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfd9629389ccf2aedec4b37f5a1b403">&#9670;&#160;</a></span>_setBufferInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::BufferPacked::_setBufferInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> *&#160;</td>
          <td class="paramname"><em>bufferInterface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use. </p>

</div>
</div>
<a id="a564935579f2252627f46dff29142e7ff" name="a564935579f2252627f46dff29142e7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564935579f2252627f46dff29142e7ff">&#9670;&#160;</a></span>_setShadowCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::BufferPacked::_setShadowCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will not delete the existing shadow copy so it can be used for other purposes if it is not needed call OGRE_FREE_SIMD( m-&gt;<a class="el" href="class_ogre_1_1_buffer_packed.html#a3161f7d1ca4a5aa6705dea4efc0a58a8">getShadowCopy()</a>, MEMCATEGORY_GEOMETRY ) before calling this function. </p>
<p>This will also not automatically upload the shadow data to the GPU. The user must call upload or use a staging buffer themselves to achieve this. </p>

</div>
</div>
<a id="a1f35a4a63b023187026b9abc1c897a71" name="a1f35a4a63b023187026b9abc1c897a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f35a4a63b023187026b9abc1c897a71">&#9670;&#160;</a></span>advanceFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::BufferPacked::advanceFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1map.html">map</a>. Do NOT call this function more than once per frame, or if you've called <a class="el" href="struct_ogre_1_1map.html">map</a>( <a class="el" href="class_ogre_1_1_buffer_packed.html#a1f35a4a63b023187026b9abc1c897a71">advanceFrame</a> = true ) </dd></dl>

</div>
</div>
<a id="a98dad93c786c6f00fca12a631d05e9fd" name="a98dad93c786c6f00fca12a631d05e9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dad93c786c6f00fca12a631d05e9fd">&#9670;&#160;</a></span>bindBufferAllRenderStages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::MetalUavBufferPacked::bindBufferAllRenderStages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e02c2a04eea583c906fdb707782c76b" name="a1e02c2a04eea583c906fdb707782c76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e02c2a04eea583c906fdb707782c76b">&#9670;&#160;</a></span>bindBufferCS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::MetalUavBufferPacked::bindBufferCS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the texture buffer to the given slot in the Vertex/Pixel/Geometry/Hull/Domain/Compute Shader. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Not all RS API separate by shader stage. For best compatibility, don't assign two different buffers at the same slot for different stages (just leave the slot empty on the stages you don't use). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot to asign this constant buffer. In D3D11 it's called 'slot'. In GLSL it's called it's called 'binding' </td></tr>
    <tr><td class="paramname">offset</td><td>0-based offset. It is possible to bind a region of the buffer. Offset needs to be aligned. You can query the RS capabilities for the alignment, however 256 bytes is the maximum allowed alignment per the OpenGL specification, making it a safe bet to hardcode. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>Size in bytes to bind the tex buffer. When zero, binds from offset until the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_uav_buffer_packed.html#a17d822d95c872bc9c98ec03c997d8926">Ogre::UavBufferPacked</a>.</p>

</div>
</div>
<a id="a293f67717c593f402f7739e5b7d244e0" name="a293f67717c593f402f7739e5b7d244e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293f67717c593f402f7739e5b7d244e0">&#9670;&#160;</a></span>bindBufferPS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::MetalUavBufferPacked::bindBufferPS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06adc5b3c40e5bc23950b479b8820adf" name="a06adc5b3c40e5bc23950b479b8820adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06adc5b3c40e5bc23950b479b8820adf">&#9670;&#160;</a></span>bindBufferVS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::MetalUavBufferPacked::bindBufferVS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sizeBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab081334829993c5fcd4302777807cd9d" name="ab081334829993c5fcd4302777807cd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab081334829993c5fcd4302777807cd9d">&#9670;&#160;</a></span>destroyAllTexBufferViews()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::UavBufferPacked::destroyAllTexBufferViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_uav_buffer_packed.html#a8da16a38736fc02b3a8f5f773e751f7c" title="Frees memory from a view created by getAsTexBufferView Does nothing if a view of the given pixel form...">destroyTexBufferView</a>, this one does it on all the creates views. </dd></dl>

</div>
</div>
<a id="a8da16a38736fc02b3a8f5f773e751f7c" name="a8da16a38736fc02b3a8f5f773e751f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da16a38736fc02b3a8f5f773e751f7c">&#9670;&#160;</a></span>destroyTexBufferView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::UavBufferPacked::destroyTexBufferView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees memory from a view created by getAsTexBufferView Does nothing if a view of the given pixel format did not exist. </p>

</div>
</div>
<a id="a23a512da35a9771487c49d7d24652b3a" name="a23a512da35a9771487c49d7d24652b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a512da35a9771487c49d7d24652b3a">&#9670;&#160;</a></span>getAsTexBufferView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> * Ogre::UavBufferPacked::getAsTexBufferView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_ogre_1_1_tex_buffer_packed.html" title="Represents Texture buffers (also known as tbuffers in D3D11)">TexBufferPacked</a> for binding to the GPU as a texture w/ read-only access. </p>
<p>Buffer must've been created with BB_FLAG_TEX. </p><dl class="section remark"><dt>Remarks</dt><dd>Don't try to use readRequest or map the returned pointer. All major operations except binding to the shader should be done through the <a class="el" href="class_ogre_1_1_uav_buffer_packed.html" title="Represents UAV buffers (also known as SSBOs in OpenGL) Uav buffers are supported in DX10/DX10....">UavBufferPacked</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>If this function was already called, it will return the same pointer as the last time (though performs an O(N) search), otherwise returns a new pointer </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_ogre_1_1_tex_buffer_packed.html" title="Represents Texture buffers (also known as tbuffers in D3D11)">TexBufferPacked</a> to be used to bind to the different stages. Do not destroy this buffer via <a class="el" href="class_ogre_1_1_vao_manager.html#a6241229a8f3c895dcd49e7d0e8dfe545" title="Destroys the given texture buffer created with createTexBuffer.">VaoManager::destroyTexBuffer</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_uav_buffer_packed.html#a8da16a38736fc02b3a8f5f773e751f7c" title="Frees memory from a view created by getAsTexBufferView Does nothing if a view of the given pixel form...">destroyTexBufferView</a> </dd></dl>

</div>
</div>
<a id="a29ff95c6bebe87dcfe2d43a02cc0ba6c" name="a29ff95c6bebe87dcfe2d43a02cc0ba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ff95c6bebe87dcfe2d43a02cc0ba6c">&#9670;&#160;</a></span>getBufferInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_buffer_interface.html">BufferInterface</a> * Ogre::BufferPacked::getBufferInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a856e7d7f45915efd5289793462befc2b" name="a856e7d7f45915efd5289793462befc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856e7d7f45915efd5289793462befc2b">&#9670;&#160;</a></span>getBufferPackedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="namespace_ogre.html#ab66e67b60d5f40dacf69ea55b82868ab">BufferPackedTypes</a> Ogre::UavBufferPacked::getBufferPackedType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Useful to query which one is the derived class. </p>

<p>Implements <a class="el" href="class_ogre_1_1_buffer_packed.html#aeca00d5d686b4f9d9e1f17d932dd3815">Ogre::BufferPacked</a>.</p>

<p class="reference">References <a class="el" href="namespace_ogre.html#ab66e67b60d5f40dacf69ea55b82868aba752cb1fc6d1a04cbfde834d5101c81e9">Ogre::BP_TYPE_UAV</a>.</p>

</div>
</div>
<a id="a50080eb729acd0c995606d512d5633c9" name="a50080eb729acd0c995606d512d5633c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50080eb729acd0c995606d512d5633c9">&#9670;&#160;</a></span>getBufferType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> Ogre::BufferPacked::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af98ad9606c188cc815fc647a21f20498" name="af98ad9606c188cc815fc647a21f20498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98ad9606c188cc815fc647a21f20498">&#9670;&#160;</a></span>getBytesPerElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">size_t</a> Ogre::BufferPacked::getBytesPerElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a542b46fc7a7cf5fe524cfc7b4b389ba9" name="a542b46fc7a7cf5fe524cfc7b4b389ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542b46fc7a7cf5fe524cfc7b4b389ba9">&#9670;&#160;</a></span>getMappingState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a447e51d7625af79716667cebcfa6da57">MappingState</a> Ogre::BufferPacked::getMappingState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mapping state. </p>
<p>Note that if you call map with MS_PERSISTENT_INCOHERENT or MS_PERSISTENT_COHERENT, then call unmap( UO_KEEP_PERSISTENT ); the returned value will still be MS_PERSISTENT_INCOHERENT/_COHERENT when persistent mapping is supported. This differs from isCurrentlyMapped </p>

</div>
</div>
<a id="a69984ccd67bf7c801cc33dd20780b581" name="a69984ccd67bf7c801cc33dd20780b581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69984ccd67bf7c801cc33dd20780b581">&#9670;&#160;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">size_t</a> Ogre::BufferPacked::getNumElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3161f7d1ca4a5aa6705dea4efc0a58a8" name="a3161f7d1ca4a5aa6705dea4efc0a58a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3161f7d1ca4a5aa6705dea4efc0a58a8">&#9670;&#160;</a></span>getShadowCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">void</a> * Ogre::BufferPacked::getShadowCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a155f9b4ef9bc20239691a869d4daa08d" name="a155f9b4ef9bc20239691a869d4daa08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155f9b4ef9bc20239691a869d4daa08d">&#9670;&#160;</a></span>getTotalSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">size_t</a> Ogre::BufferPacked::getTotalSizeBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac7d5a7fc76d5e3086620800003e55b5" name="aac7d5a7fc76d5e3086620800003e55b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7d5a7fc76d5e3086620800003e55b5">&#9670;&#160;</a></span>isCurrentlyMapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">bool</a> Ogre::BufferPacked::isCurrentlyMapped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the buffer is currently mapped. </p>
<p>If you've persistently mapped the buffer and then called unmap( UO_KEEP_PERSISTENT ); this function will return false; which differs from getMappingState's behavior. </p>

</div>
</div>
<a id="a24a2ccddbb2fc851304ae81eb78243ed" name="a24a2ccddbb2fc851304ae81eb78243ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a2ccddbb2fc851304ae81eb78243ed">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> *<a class="el" href="_ogre_platform_8h.html#a59a62dcc672b5775f3bd2a8d08bb60a4">RESTRICT_ALIAS_RETURN</a> Ogre::BufferPacked::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>elementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>elementCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">bool</a>&#160;</td>
          <td class="paramname"><em>bAdvanceFrame</em> = <code><a class="el" href="struct_ogre_1_1map.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the specified region to a pointer the CPU can access. </p>
<p>Only dynamic buffers can use this function. The region [elementStart; elementStart + elementCount) will be mapped. </p><dl class="section remark"><dt>Remarks</dt><dd>You can only map once per frame, regardless of parameters (except for advanceFrame). map( 0, 1 ) followed by map( 1, 1 ); is invalid. If you plan modifying elements 0 and 1; you should call map( 0, 2 ) </dd></dl>
<dl class="section user"><dt></dt><dd>Note that even if you use persistent mapping, you still need to call </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a73e02f6b2fa2c16340c1a9359926b481" title="Unmaps or flushes the region mapped with.">unmap</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementStart</td><td>Start of the region to be mapped, in elements. Normally you want this to be 0. </td></tr>
    <tr><td class="paramname">elementCount</td><td>Length of the region to map, in elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a69984ccd67bf7c801cc33dd20780b581">getNumElements</a> to <a class="el" href="struct_ogre_1_1map.html">map</a> the whole range. Can't be 0. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bAdvanceFrame</td><td>When true, the Buffer will be usable after unmapping it (or earlier if persistent mapped). However you won't be able to call map() again until the next frame. Calling this with false allows to call map multiple times. However ater calling unmap, you must call advanceFrame. THIS IS ONLY FOR VERY ADVANCED USERS. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded" name="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&#160;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792" name="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&#160;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144" name="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&#160;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c" name="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&#160;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d" name="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&#160;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">delete</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f1a983f9e2dfddee802c47bb0b1ca9" name="ad1f1a983f9e2dfddee802c47bb0b1ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f1a983f9e2dfddee802c47bb0b1ca9">&#9670;&#160;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab422c67a2c8844f410fe822a357cba3b" name="ab422c67a2c8844f410fe822a357cba3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422c67a2c8844f410fe822a357cba3b">&#9670;&#160;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="a63fc6bdc2eb6aeac24898a77ec5e2023" name="a63fc6bdc2eb6aeac24898a77ec5e2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc6bdc2eb6aeac24898a77ec5e2023">&#9670;&#160;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="adce32528577d71b228692df906ecd17c" name="adce32528577d71b228692df906ecd17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce32528577d71b228692df906ecd17c">&#9670;&#160;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed1464ac3de21ff20db8f9f1f8608dc7" name="aed1464ac3de21ff20db8f9f1f8608dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1464ac3de21ff20db8f9f1f8608dc7">&#9670;&#160;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="struct_ogre_1_1map.html">class</a> <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="struct_ogre_1_1map.html">Alloc</a> &gt;::operator <a class="el" href="struct_ogre_1_1map.html">new</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">char</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="a80c6682bd4adc315782091679d230cee" name="a80c6682bd4adc315782091679d230cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c6682bd4adc315782091679d230cee">&#9670;&#160;</a></span>readRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aef9bfd2a5567613e99bc8d7eae1c1bf9">AsyncTicketPtr</a> Ogre::BufferPacked::readRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>elementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Async data read request. </p>
<p>A ticket will be returned. Once the async transfer finishes, you can use the ticket to read the data from CPU. @See <a class="el" href="class_ogre_1_1_async_ticket.html" title="In Ogre 2.0 data structures, reading data from GPU back to CPU is asynchronous.">AsyncTicket</a> </p>

</div>
</div>
<a id="aba157f97e7a2c5d08ddda393aeb028f8" name="aba157f97e7a2c5d08ddda393aeb028f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba157f97e7a2c5d08ddda393aeb028f8">&#9670;&#160;</a></span>regressFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::BufferPacked::regressFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the opposite of. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a1f35a4a63b023187026b9abc1c897a71">advanceFrame</a>. Only call this after having called <a class="el" href="class_ogre_1_1_buffer_packed.html#a1f35a4a63b023187026b9abc1c897a71">advanceFrame</a>. i.e. restore the buffer to the state it was before calling <a class="el" href="class_ogre_1_1_buffer_packed.html#a1f35a4a63b023187026b9abc1c897a71">advanceFrame</a>. </dd></dl>

</div>
</div>
<a id="a73e02f6b2fa2c16340c1a9359926b481" name="a73e02f6b2fa2c16340c1a9359926b481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e02f6b2fa2c16340c1a9359926b481">&#9670;&#160;</a></span>unmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::BufferPacked::unmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a118de288d2577e6d95183777f40e57c7">UnmapOptions</a>&#160;</td>
          <td class="paramname"><em>unmapOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>flushStartElem</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>flushSizeElem</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps or flushes the region mapped with. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1map.html">map</a>. Alternatively, you can flush a smaller region (i.e. you didn't know which regions you were to update when mapping, but now that you're done, you know). The region being flushed is [flushStart; flushStart + flushSize) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unmapOption</td><td>When using persistent mapping, UO_KEEP_PERSISTENT will keep the map alive; but you will have to call map again to use it. This requirement allows <a class="el" href="namespace_ogre.html">Ogre</a> to:<ol type="1">
<li>Synchronize if needed (avoid mapping a region that is still in use)</li>
<li>Emulate persistent mapping on Hardware/Drivers that don't support it. </li>
</ol>
</td></tr>
    <tr><td class="paramname">flushStartElem</td><td>In elements, 0-based index (based on the mapped region) on where to start flushing from. Default is 0. </td></tr>
    <tr><td class="paramname">flushSizeElem</td><td>The length of the flushing region, which can't be bigger than 'elementCount' passed to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_ogre_1_1map.html">map</a>. When this value is 0, we flush until the end of the buffer starting from flushStartElem </dd></dl>

</div>
</div>
<a id="a0c6fb3d387685e50e2b5069164b95e6b" name="a0c6fb3d387685e50e2b5069164b95e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6fb3d387685e50e2b5069164b95e6b">&#9670;&#160;</a></span>upload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1map.html">virtual</a> <a class="el" href="struct_ogre_1_1map.html">void</a> Ogre::BufferPacked::upload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">const</a> <a class="el" href="struct_ogre_1_1map.html">void</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>elementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1map.html">size_t</a>&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the provided data to the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to transfer to the GPU. Caller is responsible for freeing the pointer. "data" starts at offset zero. i.e. dst[elementStart * mBytesPerElement] = data[0]; </td></tr>
    <tr><td class="paramname">elementStart</td><td>The start region, usually zero. </td></tr>
    <tr><td class="paramname">elementCount</td><td>Size, in number of elements, of data. Must be less than @getNumElements - elementStart </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_metal_uav_buffer_packed_8h.html">OgreMetalUavBufferPacked.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_metal_uav_buffer_packed.html">MetalUavBufferPacked</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
