<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::GL3PlusTextureGpuHeadlessWindow Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;2.2</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::GL3PlusTextureGpuHeadlessWindow Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreGL3PlusTextureGpuWindow.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::GL3PlusTextureGpuHeadlessWindow:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window__inherit__graph.svg" width="350" height="362"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea69a0f09b68e4510558bf2ac54d2d93" id="r_aea69a0f09b68e4510558bf2ac54d2d93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#aea69a0f09b68e4510558bf2ac54d2d93">GL3PlusTextureGpuHeadlessWindow</a> (<a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, <a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *textureManager, <a class="el" href="class_ogre_1_1_g_l3_plus_context.html">GL3PlusContext</a> *context, <a class="el" href="class_ogre_1_1_window.html">Window</a> *window)</td></tr>
<tr class="separator:aea69a0f09b68e4510558bf2ac54d2d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcb586f80e932e0d9db13040bb0ad5a" id="r_abfcb586f80e932e0d9db13040bb0ad5a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#abfcb586f80e932e0d9db13040bb0ad5a">~GL3PlusTextureGpuHeadlessWindow</a> ()</td></tr>
<tr class="separator:abfcb586f80e932e0d9db13040bb0ad5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad623ee0c97e95e276074d3cfd64c374c" id="r_ad623ee0c97e95e276074d3cfd64c374c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#ad623ee0c97e95e276074d3cfd64c374c">_addPendingResidencyChanges</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> value)</td></tr>
<tr class="separator:ad623ee0c97e95e276074d3cfd64c374c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920a04e161ec1e48a00daf425263d5fa" id="r_a920a04e161ec1e48a00daf425263d5fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a920a04e161ec1e48a00daf425263d5fa">_autogenerateMipmaps</a> (void)</td></tr>
<tr class="memdesc:a920a04e161ec1e48a00daf425263d5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the API to let the HW autogenerate mipmaps.  <br /></td></tr>
<tr class="separator:a920a04e161ec1e48a00daf425263d5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb11dd2fac1160eaa5ae7ea0d8165581" id="r_aeb11dd2fac1160eaa5ae7ea0d8165581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aeb11dd2fac1160eaa5ae7ea0d8165581">_getSysRamCopy</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="separator:aeb11dd2fac1160eaa5ae7ea0d8165581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e1fcc0e8d7a092a55c79ace4564a4a" id="r_a47e1fcc0e8d7a092a55c79ace4564a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a47e1fcc0e8d7a092a55c79ace4564a4a">_getSysRamCopyAsBox</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="separator:a47e1fcc0e8d7a092a55c79ace4564a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7046d90f92e6a950d6d803892ee4b09" id="r_af7046d90f92e6a950d6d803892ee4b09"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af7046d90f92e6a950d6d803892ee4b09">_getSysRamCopyBytesPerImage</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="memdesc:af7046d90f92e6a950d6d803892ee4b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: Returns non-zero even if there is no system ram copy.  <br /></td></tr>
<tr class="separator:af7046d90f92e6a950d6d803892ee4b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6061da5422410802a10d2e97e9ab46f0" id="r_a6061da5422410802a10d2e97e9ab46f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a6061da5422410802a10d2e97e9ab46f0">_getSysRamCopyBytesPerRow</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="memdesc:a6061da5422410802a10d2e97e9ab46f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: Returns non-zero even if there is no system ram copy.  <br /></td></tr>
<tr class="separator:a6061da5422410802a10d2e97e9ab46f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431961218d3f34e166358323e10320c0" id="r_a431961218d3f34e166358323e10320c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a431961218d3f34e166358323e10320c0">_isDataReadyImpl</a> (void) const</td></tr>
<tr class="memdesc:a431961218d3f34e166358323e10320c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <br /></td></tr>
<tr class="separator:a431961218d3f34e166358323e10320c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b879c519f45ccb57f91bc45a221f3e" id="r_ad3b879c519f45ccb57f91bc45a221f3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad3b879c519f45ccb57f91bc45a221f3e">_isManualTextureFlagPresent</a> (void) const</td></tr>
<tr class="separator:ad3b879c519f45ccb57f91bc45a221f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df37fcb72b47849df985a18828f2e97" id="r_a0df37fcb72b47849df985a18828f2e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a0df37fcb72b47849df985a18828f2e97">_notifySysRamDownloadIsReady</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *sysRamPtr, bool resyncOnly)</td></tr>
<tr class="memdesc:a0df37fcb72b47849df985a18828f2e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not call directly.  <br /></td></tr>
<tr class="separator:a0df37fcb72b47849df985a18828f2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7204ba757b6d4086b08474888be7369b" id="r_a7204ba757b6d4086b08474888be7369b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#a7204ba757b6d4086b08474888be7369b">_notifyTextureSlotChanged</a> (const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *newPool, <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> slice)</td></tr>
<tr class="separator:a7204ba757b6d4086b08474888be7369b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4c74e16ccbdaf8bf82c04a0f7ea2d6" id="r_aed4c74e16ccbdaf8bf82c04a0f7ea2d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aed4c74e16ccbdaf8bf82c04a0f7ea2d6">_resetTextureManager</a> (void)</td></tr>
<tr class="separator:aed4c74e16ccbdaf8bf82c04a0f7ea2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebb419ba824d0128f437bbe20cc81f9" id="r_aeebb419ba824d0128f437bbe20cc81f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aeebb419ba824d0128f437bbe20cc81f9">_resolveTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *resolveTexture)</td></tr>
<tr class="memdesc:aeebb419ba824d0128f437bbe20cc81f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately resolves this texture to the resolveTexture argument.  <br /></td></tr>
<tr class="separator:aeebb419ba824d0128f437bbe20cc81f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6f53b830403f10c121ad44c925ee0d" id="r_a8d6f53b830403f10c121ad44c925ee0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a8d6f53b830403f10c121ad44c925ee0d">_setDepthBufferDefaults</a> (<a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> depthBufferPoolId, bool preferDepthTexture, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> desiredDepthBufferFormat)</td></tr>
<tr class="memdesc:a8d6f53b830403f10c121ad44c925ee0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These 3 values are used as defaults for the compositor to use, but they may be explicitly overriden by a <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a>.  <br /></td></tr>
<tr class="separator:a8d6f53b830403f10c121ad44c925ee0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ccef279ef9251c5a4b40bfaf7b9e05" id="r_a56ccef279ef9251c5a4b40bfaf7b9e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a56ccef279ef9251c5a4b40bfaf7b9e05">_setNextResidencyStatus</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency)</td></tr>
<tr class="separator:a56ccef279ef9251c5a4b40bfaf7b9e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4044404f7783aea108e986336caaedf6" id="r_a4044404f7783aea108e986336caaedf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4044404f7783aea108e986336caaedf6">_setSampleDescription</a> (<a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> desc, <a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> validatedSampleDesc)</td></tr>
<tr class="memdesc:a4044404f7783aea108e986336caaedf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <br /></td></tr>
<tr class="separator:a4044404f7783aea108e986336caaedf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae641939cec4a57193dab3fc88921b7ae" id="r_ae641939cec4a57193dab3fc88921b7ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae641939cec4a57193dab3fc88921b7ae">_setSourceType</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> type)</td></tr>
<tr class="separator:ae641939cec4a57193dab3fc88921b7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e910251ab52c86bf2dd902c60c8c0a" id="r_a17e910251ab52c86bf2dd902c60c8c0a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a17e910251ab52c86bf2dd902c60c8c0a">_setToDisplayDummyTexture</a> (void)</td></tr>
<tr class="separator:a17e910251ab52c86bf2dd902c60c8c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81e2a8d0caf9096dbab0723bab2b894" id="r_aa81e2a8d0caf9096dbab0723bab2b894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa81e2a8d0caf9096dbab0723bab2b894">_syncGpuResidentToSystemRam</a> (void)</td></tr>
<tr class="memdesc:aa81e2a8d0caf9096dbab0723bab2b894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces downloading data from GPU to CPU, usually because the data on GPU changed and we're in strategy AlwaysKeepSystemRamCopy.  <br /></td></tr>
<tr class="separator:aa81e2a8d0caf9096dbab0723bab2b894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f9670da9031ec138caf8b3e910b37e" id="r_a85f9670da9031ec138caf8b3e910b37e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a85f9670da9031ec138caf8b3e910b37e">_transitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> newResidency, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *sysRamCopy, bool autoDeleteSysRamCopy=true)</td></tr>
<tr class="memdesc:a85f9670da9031ec138caf8b3e910b37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function may be called manually (if user is manually managing a texture) or automatically (e.g.  <br /></td></tr>
<tr class="separator:a85f9670da9031ec138caf8b3e910b37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6dd0d57c28fe017e8a83877bea0c5f" id="r_a1b6dd0d57c28fe017e8a83877bea0c5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1b6dd0d57c28fe017e8a83877bea0c5f">addListener</a> (<a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *listener)</td></tr>
<tr class="separator:a1b6dd0d57c28fe017e8a83877bea0c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ea3e542d7ef9c1e223d12b99d24d0b" id="r_a00ea3e542d7ef9c1e223d12b99d24d0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a00ea3e542d7ef9c1e223d12b99d24d0b">allowsAutoMipmaps</a> (void) const</td></tr>
<tr class="separator:a00ea3e542d7ef9c1e223d12b99d24d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b8aace07a416886cc0f871b32f078c" id="r_a50b8aace07a416886cc0f871b32f078c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a50b8aace07a416886cc0f871b32f078c">copyContentsToMemory</a> (<a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> src, <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> dst, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> dstFormat, bool automaticResolve=true)</td></tr>
<tr class="memdesc:a50b8aace07a416886cc0f871b32f078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current contents of the render target to the memory.  <br /></td></tr>
<tr class="separator:a50b8aace07a416886cc0f871b32f078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1403e76b6775c08d2cb7b0c7d1398d" id="r_a1a1403e76b6775c08d2cb7b0c7d1398d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1a1403e76b6775c08d2cb7b0c7d1398d">copyParametersFrom</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *src)</td></tr>
<tr class="separator:a1a1403e76b6775c08d2cb7b0c7d1398d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bcd8a0e429ba08f5aca693b6504126" id="r_a95bcd8a0e429ba08f5aca693b6504126"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a95bcd8a0e429ba08f5aca693b6504126">copyTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *dst, const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;dstBox, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> dstMipLevel, const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;srcBox, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> srcMipLevel, bool keepResolvedTexSynced=true)</td></tr>
<tr class="separator:a95bcd8a0e429ba08f5aca693b6504126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512cc522becaa23ca6d0189da2a99f5a" id="r_a512cc522becaa23ca6d0189da2a99f5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#a512cc522becaa23ca6d0189da2a99f5a">getCustomAttribute</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, void *pData)</td></tr>
<tr class="separator:a512cc522becaa23ca6d0189da2a99f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fc34cf0b95593aa41df1370f5da312" id="r_a72fc34cf0b95593aa41df1370f5da312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a72fc34cf0b95593aa41df1370f5da312">getDepth</a> (void) const</td></tr>
<tr class="memdesc:a72fc34cf0b95593aa41df1370f5da312"><td class="mdescLeft">&#160;</td><td class="mdescRight">For TypeCube &amp; TypeCubeArray, this value returns 1.  <br /></td></tr>
<tr class="separator:a72fc34cf0b95593aa41df1370f5da312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a804ee415094f7a8350b351cd7adea" id="r_a96a804ee415094f7a8350b351cd7adea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a96a804ee415094f7a8350b351cd7adea">getDepthBufferPoolId</a> (void) const</td></tr>
<tr class="separator:a96a804ee415094f7a8350b351cd7adea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df44c12f039dfb40a60f6aacc94495" id="r_a06df44c12f039dfb40a60f6aacc94495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a06df44c12f039dfb40a60f6aacc94495">getDepthOrSlices</a> (void) const</td></tr>
<tr class="separator:a06df44c12f039dfb40a60f6aacc94495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a72f255c8c54a6cf81feda5512a6796" id="r_a8a72f255c8c54a6cf81feda5512a6796"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a8a72f255c8c54a6cf81feda5512a6796">getDesiredDepthBufferFormat</a> (void) const</td></tr>
<tr class="separator:a8a72f255c8c54a6cf81feda5512a6796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93baf8152625edecb31e20bac225ed96" id="r_a93baf8152625edecb31e20bac225ed96"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a93baf8152625edecb31e20bac225ed96">getDisplayTextureName</a> (void) const</td></tr>
<tr class="memdesc:a93baf8152625edecb31e20bac225ed96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GLuid of the texture that is being displayed.  <br /></td></tr>
<tr class="separator:a93baf8152625edecb31e20bac225ed96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714b2b71f5443736c7c0ac2a97753c02" id="r_a714b2b71f5443736c7c0ac2a97753c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a714b2b71f5443736c7c0ac2a97753c02">getEmptyBox</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> mipLevel)</td></tr>
<tr class="separator:a714b2b71f5443736c7c0ac2a97753c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030fd6e8824a9b23948bdfce7f0a1211" id="r_a030fd6e8824a9b23948bdfce7f0a1211"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a030fd6e8824a9b23948bdfce7f0a1211">getFinalTextureName</a> (void) const</td></tr>
<tr class="memdesc:a030fd6e8824a9b23948bdfce7f0a1211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns the internal handle that belongs to this texture.  <br /></td></tr>
<tr class="separator:a030fd6e8824a9b23948bdfce7f0a1211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c0a87d81a1166e3239c247c1f66677" id="r_a59c0a87d81a1166e3239c247c1f66677"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a59c0a87d81a1166e3239c247c1f66677">getGlTextureTarget</a> (void) const</td></tr>
<tr class="memdesc:a59c0a87d81a1166e3239c247c1f66677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns GL_TEXTURE_2D / GL_TEXTURE_2D_ARRAY / etc.  <br /></td></tr>
<tr class="separator:a59c0a87d81a1166e3239c247c1f66677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4766a70699416dd6dc2a51ad28307a19" id="r_a4766a70699416dd6dc2a51ad28307a19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a4766a70699416dd6dc2a51ad28307a19">getGpuPageOutStrategy</a> (void) const</td></tr>
<tr class="separator:a4766a70699416dd6dc2a51ad28307a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7556d2e92eb39b9f465d25bd811c5c22" id="r_a7556d2e92eb39b9f465d25bd811c5c22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a7556d2e92eb39b9f465d25bd811c5c22">getHeight</a> (void) const</td></tr>
<tr class="separator:a7556d2e92eb39b9f465d25bd811c5c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7261ed5e880bbe376162a666d0ebea3" id="r_ac7261ed5e880bbe376162a666d0ebea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ac7261ed5e880bbe376162a666d0ebea3">getInternalSliceStart</a> (void) const</td></tr>
<tr class="separator:ac7261ed5e880bbe376162a666d0ebea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4ea058e8a05f5d1949fe952ad00063" id="r_a4d4ea058e8a05f5d1949fe952ad00063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4d4ea058e8a05f5d1949fe952ad00063">getInternalTextureType</a> (void) const</td></tr>
<tr class="separator:a4d4ea058e8a05f5d1949fe952ad00063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e063590ddf3677c87852e3107b4e45" id="r_a37e063590ddf3677c87852e3107b4e45"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> * &gt;::type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a37e063590ddf3677c87852e3107b4e45">getListeners</a> (void) const</td></tr>
<tr class="separator:a37e063590ddf3677c87852e3107b4e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee1b547e1be5bfafae466ca0b374ba" id="r_a5aee1b547e1be5bfafae466ca0b374ba"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a5aee1b547e1be5bfafae466ca0b374ba">getMsaaFramebufferName</a> (void) const</td></tr>
<tr class="memdesc:a5aee1b547e1be5bfafae466ca0b374ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">If MSAA &gt; 1u and <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434ad873b427a39b3c3aabac9ae445f192f4" title="MSAA rendering is an antialiasing technique.">TextureFlags::MsaaExplicitResolve</a> is not set, this returns the handle to the temporary MSAA renderbuffer used for rendering, which will later be resolved into the resolve texture.  <br /></td></tr>
<tr class="separator:a5aee1b547e1be5bfafae466ca0b374ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a698f48957f6d466fbddcbf2e80becd" id="r_a4a698f48957f6d466fbddcbf2e80becd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a4a698f48957f6d466fbddcbf2e80becd">getName</a> (void) const</td></tr>
<tr class="separator:a4a698f48957f6d466fbddcbf2e80becd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a10073f63d8fb559374f9e7c6585ae5" id="r_a4a10073f63d8fb559374f9e7c6585ae5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4a10073f63d8fb559374f9e7c6585ae5">getNameStr</a> (void) const</td></tr>
<tr class="memdesc:a4a10073f63d8fb559374f9e7c6585ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: This returns the alias name of the texture.  <br /></td></tr>
<tr class="separator:a4a10073f63d8fb559374f9e7c6585ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107372aa3256baf8a80484b7f2412dd6" id="r_a107372aa3256baf8a80484b7f2412dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a107372aa3256baf8a80484b7f2412dd6">getNextResidencyStatus</a> (void) const</td></tr>
<tr class="memdesc:a107372aa3256baf8a80484b7f2412dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus()</a> != <a class="el" href="class_ogre_1_1_gpu_resource.html#a107372aa3256baf8a80484b7f2412dd6" title="When getResidencyStatus() != getNextResidencyStatus(), residency changes happen in the main thread,...">getNextResidencyStatus()</a>, residency changes happen in the main thread, while some preparation may be happening in the background.  <br /></td></tr>
<tr class="separator:a107372aa3256baf8a80484b7f2412dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbda8603b2d42d666a9aea7113e290d" id="r_a5dbda8603b2d42d666a9aea7113e290d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a5dbda8603b2d42d666a9aea7113e290d">getNumMipmaps</a> (void) const</td></tr>
<tr class="separator:a5dbda8603b2d42d666a9aea7113e290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dd6a8c7c23f1dc98a9ec150bdf16e1" id="r_a78dd6a8c7c23f1dc98a9ec150bdf16e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a78dd6a8c7c23f1dc98a9ec150bdf16e1">getNumSlices</a> (void) const</td></tr>
<tr class="memdesc:a78dd6a8c7c23f1dc98a9ec150bdf16e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For TypeCube this value returns 6.  <br /></td></tr>
<tr class="separator:a78dd6a8c7c23f1dc98a9ec150bdf16e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f960e2ffea97ad43308c23ce1efb4b1" id="r_a1f960e2ffea97ad43308c23ce1efb4b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a1f960e2ffea97ad43308c23ce1efb4b1">getPendingResidencyChanges</a> (void) const</td></tr>
<tr class="memdesc:a1f960e2ffea97ad43308c23ce1efb4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of pending residency changes.  <br /></td></tr>
<tr class="separator:a1f960e2ffea97ad43308c23ce1efb4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a6949bdace3ca3e22d9cdb8cc77411" id="r_a65a6949bdace3ca3e22d9cdb8cc77411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a65a6949bdace3ca3e22d9cdb8cc77411">getPixelFormat</a> (void) const</td></tr>
<tr class="separator:a65a6949bdace3ca3e22d9cdb8cc77411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089625f3d76ac5040973e36e3ae2c72d" id="r_a089625f3d76ac5040973e36e3ae2c72d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a089625f3d76ac5040973e36e3ae2c72d">getPreferDepthTexture</a> (void) const</td></tr>
<tr class="separator:a089625f3d76ac5040973e36e3ae2c72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e2b3a27c5827b5f063fa6669f8e161" id="r_a03e2b3a27c5827b5f063fa6669f8e161"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a03e2b3a27c5827b5f063fa6669f8e161">getRealResourceNameStr</a> (void) const</td></tr>
<tr class="memdesc:a03e2b3a27c5827b5f063fa6669f8e161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real name (e.g. disk in file) of the resource.  <br /></td></tr>
<tr class="separator:a03e2b3a27c5827b5f063fa6669f8e161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c6e78baed76ebbde12a2061b35ab16" id="r_a57c6e78baed76ebbde12a2061b35ab16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a57c6e78baed76ebbde12a2061b35ab16">getRequestedSampleDescription</a> (void) const</td></tr>
<tr class="memdesc:a57c6e78baed76ebbde12a2061b35ab16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns original requested sample description, i.e. the raw input to setSampleDescription.  <br /></td></tr>
<tr class="separator:a57c6e78baed76ebbde12a2061b35ab16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab133cc1245bb5648652e4369d9497b" id="r_aeab133cc1245bb5648652e4369d9497b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus</a> (void) const</td></tr>
<tr class="separator:aeab133cc1245bb5648652e4369d9497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be2b0daaad98d2140ca22efc6685684" id="r_a9be2b0daaad98d2140ca22efc6685684"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9be2b0daaad98d2140ca22efc6685684">getResourceGroupStr</a> (void) const</td></tr>
<tr class="separator:a9be2b0daaad98d2140ca22efc6685684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e45ab2f1617d1d51c45f687d9ebee8c" id="r_a2e45ab2f1617d1d51c45f687d9ebee8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a2e45ab2f1617d1d51c45f687d9ebee8c">getSampleDescription</a> (void) const</td></tr>
<tr class="memdesc:a2e45ab2f1617d1d51c45f687d9ebee8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns effective sample description supported by the API.  <br /></td></tr>
<tr class="separator:a2e45ab2f1617d1d51c45f687d9ebee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad718ff4ec85f52e36ef2772d9b150c2" id="r_aad718ff4ec85f52e36ef2772d9b150c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aad718ff4ec85f52e36ef2772d9b150c2">getSettingsDesc</a> (void) const</td></tr>
<tr class="separator:aad718ff4ec85f52e36ef2772d9b150c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c0f33134c2401b0e711506c8055623" id="r_a96c0f33134c2401b0e711506c8055623"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a96c0f33134c2401b0e711506c8055623">getSizeBytes</a> (void) const</td></tr>
<tr class="memdesc:a96c0f33134c2401b0e711506c8055623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total size in bytes used in GPU by this texture (not by its pool) including mipmaps.  <br /></td></tr>
<tr class="separator:a96c0f33134c2401b0e711506c8055623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88170d5ed9c9d2dc6e886217aaf1f6a5" id="r_a88170d5ed9c9d2dc6e886217aaf1f6a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a88170d5ed9c9d2dc6e886217aaf1f6a5">getSourceType</a> (void) const</td></tr>
<tr class="memdesc:a88170d5ed9c9d2dc6e886217aaf1f6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This setting is for where the texture is created, e.g.    <br /></td></tr>
<tr class="separator:a88170d5ed9c9d2dc6e886217aaf1f6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d30ea54e791fd18489ad3cd28fe9b6" id="r_ac2d30ea54e791fd18489ad3cd28fe9b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#ac2d30ea54e791fd18489ad3cd28fe9b6">getSubsampleLocations</a> (vector&lt; <a class="el" href="class_ogre_1_1_vector2.html">Vector2</a> &gt;::type locations)</td></tr>
<tr class="memdesc:ac2d30ea54e791fd18489ad3cd28fe9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MSAA subsample locations.  <br /></td></tr>
<tr class="separator:ac2d30ea54e791fd18489ad3cd28fe9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392c0d59b4956c9a361e82514cba0427" id="r_a392c0d59b4956c9a361e82514cba0427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a392c0d59b4956c9a361e82514cba0427">getTextureManager</a> (void) const</td></tr>
<tr class="separator:a392c0d59b4956c9a361e82514cba0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cba290939fe64d8d12c514d79e9fc4" id="r_aa5cba290939fe64d8d12c514d79e9fc4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa5cba290939fe64d8d12c514d79e9fc4">getTexturePool</a> (void) const</td></tr>
<tr class="separator:aa5cba290939fe64d8d12c514d79e9fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78663647804665d50f8e0ec251845ff3" id="r_a78663647804665d50f8e0ec251845ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a78663647804665d50f8e0ec251845ff3">getTexturePoolId</a> (void) const</td></tr>
<tr class="separator:a78663647804665d50f8e0ec251845ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6906f8bdd2c820cc47b60b7d494d147" id="r_ab6906f8bdd2c820cc47b60b7d494d147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ab6906f8bdd2c820cc47b60b7d494d147">getTextureType</a> (void) const</td></tr>
<tr class="separator:ab6906f8bdd2c820cc47b60b7d494d147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1858af3588de15e9da271d22fe9d5c1" id="r_ad1858af3588de15e9da271d22fe9d5c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad1858af3588de15e9da271d22fe9d5c1">getWidth</a> (void) const</td></tr>
<tr class="separator:ad1858af3588de15e9da271d22fe9d5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab038b4f32feeaa739a8cff7397e8809d" id="r_ab038b4f32feeaa739a8cff7397e8809d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ab038b4f32feeaa739a8cff7397e8809d">hasAutomaticBatching</a> (void) const</td></tr>
<tr class="separator:ab038b4f32feeaa739a8cff7397e8809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de8595b73e911c15ce9e8066926380d" id="r_a4de8595b73e911c15ce9e8066926380d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4de8595b73e911c15ce9e8066926380d">hasAutoMipmapAuto</a> (void) const</td></tr>
<tr class="separator:a4de8595b73e911c15ce9e8066926380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af943f8d1fd87f457fb4633058d696470" id="r_af943f8d1fd87f457fb4633058d696470"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af943f8d1fd87f457fb4633058d696470">hasEquivalentParameters</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *other) const</td></tr>
<tr class="separator:af943f8d1fd87f457fb4633058d696470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c2ce1e86de183dd2e2eff87da180a5" id="r_aa3c2ce1e86de183dd2e2eff87da180a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa3c2ce1e86de183dd2e2eff87da180a5">hasMsaaExplicitResolves</a> (void) const</td></tr>
<tr class="separator:aa3c2ce1e86de183dd2e2eff87da180a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74eec57c1978002c8db51e606c2178ed" id="r_a74eec57c1978002c8db51e606c2178ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a74eec57c1978002c8db51e606c2178ed">isDataReady</a> (void)</td></tr>
<tr class="memdesc:a74eec57c1978002c8db51e606c2178ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this texture is fully ready to be used for displaying.  <br /></td></tr>
<tr class="separator:a74eec57c1978002c8db51e606c2178ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afd94abec3a7a91c656188fc6d7cdf5" id="r_a2afd94abec3a7a91c656188fc6d7cdf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a2afd94abec3a7a91c656188fc6d7cdf5">isManualTexture</a> (void) const</td></tr>
<tr class="separator:a2afd94abec3a7a91c656188fc6d7cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c32548e36eee7661d2da4c58f09f80" id="r_a23c32548e36eee7661d2da4c58f09f80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a23c32548e36eee7661d2da4c58f09f80">isMetadataReady</a> (void) const</td></tr>
<tr class="memdesc:a23c32548e36eee7661d2da4c58f09f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is threadsafe to call this function from main thread.  <br /></td></tr>
<tr class="separator:a23c32548e36eee7661d2da4c58f09f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebc3bec47d599f4d0f7a9cde67bd4d3" id="r_a4ebc3bec47d599f4d0f7a9cde67bd4d3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4ebc3bec47d599f4d0f7a9cde67bd4d3">isMsaaPatternSupported</a> (<a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0f">MsaaPatterns::MsaaPatterns</a> pattern)</td></tr>
<tr class="separator:a4ebc3bec47d599f4d0f7a9cde67bd4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccfb3ab941842233e28a216e337e28e" id="r_a0ccfb3ab941842233e28a216e337e28e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a0ccfb3ab941842233e28a216e337e28e">isMultisample</a> (void) const</td></tr>
<tr class="separator:a0ccfb3ab941842233e28a216e337e28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81e9a755ba2b500f911c02b1df1893a" id="r_ab81e9a755ba2b500f911c02b1df1893a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#ab81e9a755ba2b500f911c02b1df1893a">isOpenGLRenderWindow</a> (void) const</td></tr>
<tr class="memdesc:ab81e9a755ba2b500f911c02b1df1893a"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL RenderWindows are a bit specific:  <br /></td></tr>
<tr class="separator:ab81e9a755ba2b500f911c02b1df1893a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6576323b0cf05a3efbf46f9ab5d6e1e" id="r_ae6576323b0cf05a3efbf46f9ab5d6e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae6576323b0cf05a3efbf46f9ab5d6e1e">isPoolOwner</a> (void) const</td></tr>
<tr class="separator:ae6576323b0cf05a3efbf46f9ab5d6e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359fd32c4f8c31cdd4db4baf72c1b70c" id="r_a359fd32c4f8c31cdd4db4baf72c1b70c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a359fd32c4f8c31cdd4db4baf72c1b70c">isReinterpretable</a> (void) const</td></tr>
<tr class="separator:a359fd32c4f8c31cdd4db4baf72c1b70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0edfcf7c6354c686d2ff580e7a5011" id="r_a4c0edfcf7c6354c686d2ff580e7a5011"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4c0edfcf7c6354c686d2ff580e7a5011">isRenderToTexture</a> (void) const</td></tr>
<tr class="separator:a4c0edfcf7c6354c686d2ff580e7a5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c236009b4074f43621c21db5ff6ef4" id="r_aa0c236009b4074f43621c21db5ff6ef4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa0c236009b4074f43621c21db5ff6ef4">isRenderWindowSpecific</a> (void) const</td></tr>
<tr class="separator:aa0c236009b4074f43621c21db5ff6ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529bc39128cc173557a2742b7278c400" id="r_a529bc39128cc173557a2742b7278c400"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a529bc39128cc173557a2742b7278c400">isTexture</a> (void) const</td></tr>
<tr class="separator:a529bc39128cc173557a2742b7278c400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdde6ea96205d73550d17a18bf4653a4" id="r_acdde6ea96205d73550d17a18bf4653a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#acdde6ea96205d73550d17a18bf4653a4">isUav</a> (void) const</td></tr>
<tr class="separator:acdde6ea96205d73550d17a18bf4653a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52acdc930dff7ae7f455256822d9520d" id="r_a52acdc930dff7ae7f455256822d9520d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a52acdc930dff7ae7f455256822d9520d">notifyAllListenersTextureChanged</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> reason, void *extraData=0)</td></tr>
<tr class="separator:a52acdc930dff7ae7f455256822d9520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe802beaa684f0f1a42ff4294fe7712b" id="r_afe802beaa684f0f1a42ff4294fe7712b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#afe802beaa684f0f1a42ff4294fe7712b">notifyDataIsReady</a> (void)</td></tr>
<tr class="memdesc:afe802beaa684f0f1a42ff4294fe7712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies it is safe to use the real data. Everything has been uploaded.  <br /></td></tr>
<tr class="separator:afe802beaa684f0f1a42ff4294fe7712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded" id="r_a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792" id="r_acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144" id="r_a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c" id="r_a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d" id="r_a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f1a983f9e2dfddee802c47bb0b1ca9" id="r_ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ad1f1a983f9e2dfddee802c47bb0b1ca9">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422c67a2c8844f410fe822a357cba3b" id="r_ab422c67a2c8844f410fe822a357cba3b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab422c67a2c8844f410fe822a357cba3b">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:ab422c67a2c8844f410fe822a357cba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <br /></td></tr>
<tr class="separator:ab422c67a2c8844f410fe822a357cba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc6bdc2eb6aeac24898a77ec5e2023" id="r_a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a63fc6bdc2eb6aeac24898a77ec5e2023">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <br /></td></tr>
<tr class="separator:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce32528577d71b228692df906ecd17c" id="r_adce32528577d71b228692df906ecd17c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#adce32528577d71b228692df906ecd17c">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:adce32528577d71b228692df906ecd17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1464ac3de21ff20db8f9f1f8608dc7" id="r_aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#aed1464ac3de21ff20db8f9f1f8608dc7">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <br /></td></tr>
<tr class="separator:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6b84b89e2080bb7103d4778641d86e" id="r_a2e6b84b89e2080bb7103d4778641d86e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a2e6b84b89e2080bb7103d4778641d86e">prefersLoadingFromFileAsSRGB</a> (void) const</td></tr>
<tr class="separator:a2e6b84b89e2080bb7103d4778641d86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e0ad601752b91f2851c88f9ed49869" id="r_ae3e0ad601752b91f2851c88f9ed49869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae3e0ad601752b91f2851c88f9ed49869">removeListener</a> (<a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *listener)</td></tr>
<tr class="separator:ae3e0ad601752b91f2851c88f9ed49869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db88cd9e4286f47a56fe7f507cd5c1b" id="r_a3db88cd9e4286f47a56fe7f507cd5c1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3db88cd9e4286f47a56fe7f507cd5c1b">requiresTextureFlipping</a> (void) const</td></tr>
<tr class="separator:a3db88cd9e4286f47a56fe7f507cd5c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9034d26bf967a6a9ab6a03f3f2a75a88" id="r_a9034d26bf967a6a9ab6a03f3f2a75a88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9034d26bf967a6a9ab6a03f3f2a75a88">scheduleTransitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image=0, bool autoDeleteImage=true)</td></tr>
<tr class="memdesc:a9034d26bf967a6a9ab6a03f3f2a75a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as unsafeScheduleTransitionTo, but first checks if we're already in the residency state we want to go to, or if it has already been scheduled; thus it can be called multiple times.  <br /></td></tr>
<tr class="separator:a9034d26bf967a6a9ab6a03f3f2a75a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae40391d39c8feae00acaf25839c6f9" id="r_a6ae40391d39c8feae00acaf25839c6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a6ae40391d39c8feae00acaf25839c6f9">setNumMipmaps</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numMipmaps)</td></tr>
<tr class="separator:a6ae40391d39c8feae00acaf25839c6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dfe2523d8e5647e79caaf28c296d4e" id="r_a54dfe2523d8e5647e79caaf28c296d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a54dfe2523d8e5647e79caaf28c296d4e">setPixelFormat</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat)</td></tr>
<tr class="memdesc:a54dfe2523d8e5647e79caaf28c296d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel format.  <br /></td></tr>
<tr class="separator:a54dfe2523d8e5647e79caaf28c296d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e22c90559d13385d75dc19970806d" id="r_af79e22c90559d13385d75dc19970806d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af79e22c90559d13385d75dc19970806d">setResolution</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> width, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> height, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> depthOrSlices=1u)</td></tr>
<tr class="separator:af79e22c90559d13385d75dc19970806d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ee4d088c32b3e9efeb4d2fec5cad3e" id="r_aa2ee4d088c32b3e9efeb4d2fec5cad3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa2ee4d088c32b3e9efeb4d2fec5cad3e">setSampleDescription</a> (<a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> desc)</td></tr>
<tr class="separator:aa2ee4d088c32b3e9efeb4d2fec5cad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bd23c2116dc08afcaa8dc1b8d2384e" id="r_a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a78bd23c2116dc08afcaa8dc1b8d2384e">setTexturePoolId</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> poolId)</td></tr>
<tr class="memdesc:a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> with automatic batching will be merged with other textures into the same pool as one big 2D Array texture behind the scenes.  <br /></td></tr>
<tr class="separator:a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78fb144ef8847a9369db46ade4cf568" id="r_ad78fb144ef8847a9369db46ade4cf568"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#ad78fb144ef8847a9369db46ade4cf568">setTextureType</a> (<a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType)</td></tr>
<tr class="separator:ad78fb144ef8847a9369db46ade4cf568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd2fb8a2ce598268c8813f5f230ddd8" id="r_a3bd2fb8a2ce598268c8813f5f230ddd8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3bd2fb8a2ce598268c8813f5f230ddd8">supportsAsDepthBufferFor</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *colourTarget) const</td></tr>
<tr class="separator:a3bd2fb8a2ce598268c8813f5f230ddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f76858facbfe1833178af802576cd33" id="r_a5f76858facbfe1833178af802576cd33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#a5f76858facbfe1833178af802576cd33">swapBuffers</a> (void)</td></tr>
<tr class="memdesc:a5f76858facbfe1833178af802576cd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only valid for <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> classes.  <br /></td></tr>
<tr class="separator:a5f76858facbfe1833178af802576cd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3efd161b3ec98e3a405cf3167b7d022" id="r_aa3efd161b3ec98e3a405cf3167b7d022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa3efd161b3ec98e3a405cf3167b7d022">unsafeScheduleTransitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image=0, bool autoDeleteImage=true)</td></tr>
<tr class="memdesc:aa3efd161b3ec98e3a405cf3167b7d022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules an async transition in residency.  <br /></td></tr>
<tr class="separator:aa3efd161b3ec98e3a405cf3167b7d022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc608f61167b7b737a4129cd2b85f5f4" id="r_adc608f61167b7b737a4129cd2b85f5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#adc608f61167b7b737a4129cd2b85f5f4">waitForData</a> (void)</td></tr>
<tr class="memdesc:adc608f61167b7b737a4129cd2b85f5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks main thread until data is ready.  <br /></td></tr>
<tr class="separator:adc608f61167b7b737a4129cd2b85f5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6740006ae83f39c4aeb83f300b67f6b2" id="r_a6740006ae83f39c4aeb83f300b67f6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a6740006ae83f39c4aeb83f300b67f6b2">waitForMetadata</a> (void)</td></tr>
<tr class="memdesc:a6740006ae83f39c4aeb83f300b67f6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks main thread until metadata is ready.  <br /></td></tr>
<tr class="separator:a6740006ae83f39c4aeb83f300b67f6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af042e9ab52c07776f154ee077330f592" id="r_af042e9ab52c07776f154ee077330f592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af042e9ab52c07776f154ee077330f592">writeContentsToFile</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> minMip, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> maxMip, bool automaticResolve=true)</td></tr>
<tr class="memdesc:af042e9ab52c07776f154ee077330f592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current contents of the render target to the named file.  <br /></td></tr>
<tr class="separator:af042e9ab52c07776f154ee077330f592"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3ed2bdf11740fd262b9311a33e33f935" id="r_a3ed2bdf11740fd262b9311a33e33f935"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3ed2bdf11740fd262b9311a33e33f935">msFinalTextureBuffer</a></td></tr>
<tr class="separator:a3ed2bdf11740fd262b9311a33e33f935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43888e98f84f5c9eb9ded14dd0deb34d" id="r_a43888e98f84f5c9eb9ded14dd0deb34d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a43888e98f84f5c9eb9ded14dd0deb34d">msMsaaTextureBuffer</a></td></tr>
<tr class="separator:a43888e98f84f5c9eb9ded14dd0deb34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea69a0f09b68e4510558bf2ac54d2d93" name="aea69a0f09b68e4510558bf2ac54d2d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea69a0f09b68e4510558bf2ac54d2d93">&#9670;&#160;</a></span>GL3PlusTextureGpuHeadlessWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::GL3PlusTextureGpuHeadlessWindow::GL3PlusTextureGpuHeadlessWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *&#160;</td>
          <td class="paramname"><em>textureManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_g_l3_plus_context.html">GL3PlusContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_window.html">Window</a> *&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfcb586f80e932e0d9db13040bb0ad5a" name="abfcb586f80e932e0d9db13040bb0ad5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcb586f80e932e0d9db13040bb0ad5a">&#9670;&#160;</a></span>~GL3PlusTextureGpuHeadlessWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::GL3PlusTextureGpuHeadlessWindow::~GL3PlusTextureGpuHeadlessWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad623ee0c97e95e276074d3cfd64c374c" name="ad623ee0c97e95e276074d3cfd64c374c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad623ee0c97e95e276074d3cfd64c374c">&#9670;&#160;</a></span>_addPendingResidencyChanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::GpuResource::_addPendingResidencyChanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a920a04e161ec1e48a00daf425263d5fa" name="a920a04e161ec1e48a00daf425263d5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920a04e161ec1e48a00daf425263d5fa">&#9670;&#160;</a></span>_autogenerateMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpu::_autogenerateMipmaps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the API to let the HW autogenerate mipmaps. </p>
<p>Assumes the <a class="el" href="class_ogre_1_1_texture_gpu.html#a00ea3e542d7ef9c1e223d12b99d24d0b">allowsAutoMipmaps()</a> == true and <a class="el" href="class_ogre_1_1_texture_gpu.html#a4c0edfcf7c6354c686d2ff580e7a5011">isRenderToTexture()</a> == true </p>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#acdd960c1ef12b4992c365592fe95a9e5">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="aeb11dd2fac1160eaa5ae7ea0d8165581" name="aeb11dd2fac1160eaa5ae7ea0d8165581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb11dd2fac1160eaa5ae7ea0d8165581">&#9670;&#160;</a></span>_getSysRamCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> * Ogre::TextureGpu::_getSysRamCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47e1fcc0e8d7a092a55c79ace4564a4a" name="a47e1fcc0e8d7a092a55c79ace4564a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e1fcc0e8d7a092a55c79ace4564a4a">&#9670;&#160;</a></span>_getSysRamCopyAsBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> Ogre::TextureGpu::_getSysRamCopyAsBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7046d90f92e6a950d6d803892ee4b09" name="af7046d90f92e6a950d6d803892ee4b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7046d90f92e6a950d6d803892ee4b09">&#9670;&#160;</a></span>_getSysRamCopyBytesPerImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::TextureGpu::_getSysRamCopyBytesPerImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note: Returns non-zero even if there is no system ram copy. </p>

</div>
</div>
<a id="a6061da5422410802a10d2e97e9ab46f0" name="a6061da5422410802a10d2e97e9ab46f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6061da5422410802a10d2e97e9ab46f0">&#9670;&#160;</a></span>_getSysRamCopyBytesPerRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::TextureGpu::_getSysRamCopyBytesPerRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note: Returns non-zero even if there is no system ram copy. </p>

</div>
</div>
<a id="a431961218d3f34e166358323e10320c0" name="a431961218d3f34e166358323e10320c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431961218d3f34e166358323e10320c0">&#9670;&#160;</a></span>_isDataReadyImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::GL3PlusTextureGpu::_isDataReadyImpl </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use. </p>
<p>Do not call directly.</p>
<p>This function is the same isDataReady except it ignores pending residency changes, which is important when <a class="el" href="class_ogre_1_1_texture_gpu_manager.html" title="This class manages all textures (i.e.">TextureGpuManager</a> needs to know this information but the <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> is transitioning (thus mPendingResidencyChanges is in an inconsistent state) </p>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#a5b54c7062cd7a87bd0c726de248c0bde">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#aa22c78f8059cef488c425928308afca7">Ogre::GL3PlusTextureGpuWindow</a>.</p>

</div>
</div>
<a id="ad3b879c519f45ccb57f91bc45a221f3e" name="ad3b879c519f45ccb57f91bc45a221f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b879c519f45ccb57f91bc45a221f3e">&#9670;&#160;</a></span>_isManualTextureFlagPresent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::_isManualTextureFlagPresent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0df37fcb72b47849df985a18828f2e97" name="a0df37fcb72b47849df985a18828f2e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df37fcb72b47849df985a18828f2e97">&#9670;&#160;</a></span>_notifySysRamDownloadIsReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_notifySysRamDownloadIsReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *&#160;</td>
          <td class="paramname"><em>sysRamPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resyncOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do not call directly. </p>
<p>Will change mResidencyStatus from <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> to <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a96b255b9535992cc830591ed916d15f3" title="Texture is on System RAM.">GpuResidency::OnSystemRam</a> </p>

</div>
</div>
<a id="a7204ba757b6d4086b08474888be7369b" name="a7204ba757b6d4086b08474888be7369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7204ba757b6d4086b08474888be7369b">&#9670;&#160;</a></span>_notifyTextureSlotChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpuHeadlessWindow::_notifyTextureSlotChanged </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *&#160;</td>
          <td class="paramname"><em>newPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#ae7872e21340e360c58fa62f35b306a64">Ogre::GL3PlusTextureGpu</a>.</p>

</div>
</div>
<a id="aed4c74e16ccbdaf8bf82c04a0f7ea2d6" name="aed4c74e16ccbdaf8bf82c04a0f7ea2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4c74e16ccbdaf8bf82c04a0f7ea2d6">&#9670;&#160;</a></span>_resetTextureManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_resetTextureManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeebb419ba824d0128f437bbe20cc81f9" name="aeebb419ba824d0128f437bbe20cc81f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebb419ba824d0128f437bbe20cc81f9">&#9670;&#160;</a></span>_resolveTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_resolveTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>resolveTexture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immediately resolves this texture to the resolveTexture argument. </p>
<p>Source must be MSAA texture, destination must be non-MSAA. </p><dl class="section remark"><dt>Remarks</dt><dd>This function may be slow on some APIs and should only be used when required, for example, to capture the screen from an explicit MSAA target and save it to disk only on user demand. If you need to call this often (like once per frame or more), then consider setting a Compositor with CompositorNode::mLocalRtvs::resolveTextureName set so that the compositor automatically resolves the texture every frame as efficiently as possible. </dd></dl>

</div>
</div>
<a id="a8d6f53b830403f10c121ad44c925ee0d" name="a8d6f53b830403f10c121ad44c925ee0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6f53b830403f10c121ad44c925ee0d">&#9670;&#160;</a></span>_setDepthBufferDefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpuRenderTarget::_setDepthBufferDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>depthBufferPoolId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preferDepthTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>desiredDepthBufferFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These 3 values are used as defaults for the compositor to use, but they may be explicitly overriden by a <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a>. </p>
<p>Particularly required when passing the textures between nodes as input and output (since only the <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> pointer is passed, and thus this information is lost) </p><dl class="section remark"><dt>Remarks</dt><dd>Changing these settings won't take immediate effect because they're only used when creating the compositor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthBufferPoolId</td><td>Sets the pool ID this <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> should query from. Default value is POOL_DEFAULT. Set to POOL_NO_DEPTH to avoid using a <a class="el" href="class_ogre_1_1_depth_buffer.html" title="An abstract class that contains a depth/stencil buffer.">DepthBuffer</a> (or manually controlling it) </td></tr>
    <tr><td class="paramname">preferDepthTexture</td><td>Whether this RT should be attached to a depth texture, or a regular depth buffer. On older GPUs, preferring depth textures may result in certain depth precisions to not be available (or use integer precision instead of floating point, etc). True to use depth textures. False otherwise (default). </td></tr>
    <tr><td class="paramname">desiredDepthBufferFormat</td><td><a class="el" href="namespace_ogre.html">Ogre</a> will try to honour this request, but if it's not supported, you may get lower precision. All formats will try to fallback to PF_D24_UNORM_S8_UINT if not supported. Must be one of the following: PFG_D24_UNORM_S8_UINT PFG_D16_UNORM PFG_D32_FLOAT PFG_D32_FLOAT_X24_S8_UINT </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#a4c626ccabbd6c853ee1490358b9ca490">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a56ccef279ef9251c5a4b40bfaf7b9e05" name="a56ccef279ef9251c5a4b40bfaf7b9e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ccef279ef9251c5a4b40bfaf7b9e05">&#9670;&#160;</a></span>_setNextResidencyStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::GpuResource::_setNextResidencyStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>nextResidency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4044404f7783aea108e986336caaedf6" name="a4044404f7783aea108e986336caaedf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4044404f7783aea108e986336caaedf6">&#9670;&#160;</a></span>_setSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_setSampleDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>validatedSampleDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use. </p>

</div>
</div>
<a id="ae641939cec4a57193dab3fc88921b7ae" name="ae641939cec4a57193dab3fc88921b7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae641939cec4a57193dab3fc88921b7ae">&#9670;&#160;</a></span>_setSourceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_setSourceType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17e910251ab52c86bf2dd902c60c8c0a" name="a17e910251ab52c86bf2dd902c60c8c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e910251ab52c86bf2dd902c60c8c0a">&#9670;&#160;</a></span>_setToDisplayDummyTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpu::_setToDisplayDummyTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#a360fe72891b1109edbe1469f4b30f027">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#a2d5633fbd7367e3db7999fe1a1fb15a1">Ogre::GL3PlusTextureGpuWindow</a>.</p>

</div>
</div>
<a id="aa81e2a8d0caf9096dbab0723bab2b894" name="aa81e2a8d0caf9096dbab0723bab2b894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81e2a8d0caf9096dbab0723bab2b894">&#9670;&#160;</a></span>_syncGpuResidentToSystemRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_syncGpuResidentToSystemRam </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces downloading data from GPU to CPU, usually because the data on GPU changed and we're in strategy AlwaysKeepSystemRamCopy. </p>
<p>May stall. </p>

</div>
</div>
<a id="a85f9670da9031ec138caf8b3e910b37e" name="a85f9670da9031ec138caf8b3e910b37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f9670da9031ec138caf8b3e910b37e">&#9670;&#160;</a></span>_transitionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_transitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>newResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> *&#160;</td>
          <td class="paramname"><em>sysRamCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteSysRamCopy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function may be called manually (if user is manually managing a texture) or automatically (e.g. </p>
<p>loading from file, or automatic batching is enabled) Once you call this function, you're no longer in OnStorage mode; and will transition to either OnSystemRam or Resident depending on whether auto batching is enabled. </p><dl class="section remark"><dt>Remarks</dt><dd>Do NOT call this function yourself if you've created this function with AutomaticBatching as <a class="el" href="namespace_ogre.html">Ogre</a> will call this, from a worker thread!</dd></dl>
<p>Make sure you're done using mSysRamCopy before calling this function, as we may free that pointer (unless autoDeleteSysRamCopyOnResident = false).</p>
<p>If you're calling _transitionTo yourself (i.e. you're not using scheduleTransitionTo) then you'll need to call _setNextResidencyStatus too, so that both getResidencyStatus and getNextResidencyStatus agree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysRamCopy</td><td>System RAM copy that backs this GPU data. May be null. Must've been allocated with <a class="el" href="group___memory.html#gafd7ddaef10ac9ea1ffbd18902167b9a2" title="Allocate a block of raw memory aligned to SIMD boundaries, and indicate the category of usage.">OGRE_MALLOC_SIMD( size, MEMCATEGORY_RESOURCE )</a>; We will deallocate it. MUST respect _getSysRamCopyBytesPerRow &amp; _getSysRamCopyBytesPerImage. If in doubt, use <a class="el" href="class_ogre_1_1_pixel_format_gpu_utils.html#aee2ade90d769c187b8192e0a234c5f17">PixelFormatGpuUtils::getSizeBytes</a> with rowAlignment = 4u;</td></tr>
  </table>
  </dd>
</dl>
<p>This param must be nullptr or equal to get_getSysRamCopy when going from Resident to OnSystemRam and strategy is not AlwaysKeepSystemRamCopy; as we will async download the content from the GPU. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoDeleteSysRamCopy</td><td>When true, we free mSysRamCopy as we should. When false, caller is responsible for deleting this pointer else it will leak! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6dd0d57c28fe017e8a83877bea0c5f" name="a1b6dd0d57c28fe017e8a83877bea0c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6dd0d57c28fe017e8a83877bea0c5f">&#9670;&#160;</a></span>addListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::addListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00ea3e542d7ef9c1e223d12b99d24d0b" name="a00ea3e542d7ef9c1e223d12b99d24d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ea3e542d7ef9c1e223d12b99d24d0b">&#9670;&#160;</a></span>allowsAutoMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::allowsAutoMipmaps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50b8aace07a416886cc0f871b32f078c" name="a50b8aace07a416886cc0f871b32f078c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b8aace07a416886cc0f871b32f078c">&#9670;&#160;</a></span>copyContentsToMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::copyContentsToMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>dstFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automaticResolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the current contents of the render target to the memory. </p>

</div>
</div>
<a id="a1a1403e76b6775c08d2cb7b0c7d1398d" name="a1a1403e76b6775c08d2cb7b0c7d1398d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1403e76b6775c08d2cb7b0c7d1398d">&#9670;&#160;</a></span>copyParametersFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::copyParametersFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95bcd8a0e429ba08f5aca693b6504126" name="a95bcd8a0e429ba08f5aca693b6504126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bcd8a0e429ba08f5aca693b6504126">&#9670;&#160;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpu::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>dstMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>srcMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepResolvedTexSynced</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td></td></tr>
    <tr><td class="paramname">dstBox</td><td></td></tr>
    <tr><td class="paramname">dstMipLevel</td><td></td></tr>
    <tr><td class="paramname">srcBox</td><td></td></tr>
    <tr><td class="paramname">srcMipLevel</td><td></td></tr>
    <tr><td class="paramname">keepResolvedTexSynced</td><td>When true, if dst is an MSAA texture and is implicitly resolved (i.e. dst-&gt;<a class="el" href="class_ogre_1_1_texture_gpu.html#aa3c2ce1e86de183dd2e2eff87da180a5">hasMsaaExplicitResolves()</a> == false); the resolved texture is also kept up to date.</td></tr>
  </table>
  </dd>
</dl>
<p>Typically the reason to set this to false is if you plane on rendering more stuff to dst texture and then resolve. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#a9bc79af9475a1d7350cd783e85707ee4">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a512cc522becaa23ca6d0189da2a99f5a" name="a512cc522becaa23ca6d0189da2a99f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512cc522becaa23ca6d0189da2a99f5a">&#9670;&#160;</a></span>getCustomAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpuHeadlessWindow::getCustomAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a9cf89e55f18c75154a841da462e9606c">Ogre::GL3PlusTextureGpu</a>.</p>

</div>
</div>
<a id="a72fc34cf0b95593aa41df1370f5da312" name="a72fc34cf0b95593aa41df1370f5da312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fc34cf0b95593aa41df1370f5da312">&#9670;&#160;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getDepth </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For TypeCube &amp; TypeCubeArray, this value returns 1. </p>

</div>
</div>
<a id="a96a804ee415094f7a8350b351cd7adea" name="a96a804ee415094f7a8350b351cd7adea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a804ee415094f7a8350b351cd7adea">&#9670;&#160;</a></span>getDepthBufferPoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::GL3PlusTextureGpuRenderTarget::getDepthBufferPoolId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#ad9e5b1428a5fc4fdfaca35292509c716">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a06df44c12f039dfb40a60f6aacc94495" name="a06df44c12f039dfb40a60f6aacc94495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df44c12f039dfb40a60f6aacc94495">&#9670;&#160;</a></span>getDepthOrSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getDepthOrSlices </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a72f255c8c54a6cf81feda5512a6796" name="a8a72f255c8c54a6cf81feda5512a6796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a72f255c8c54a6cf81feda5512a6796">&#9670;&#160;</a></span>getDesiredDepthBufferFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::GL3PlusTextureGpuRenderTarget::getDesiredDepthBufferFormat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#a9e98f7545f8b2fd4d92dd412fa5ac270">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a93baf8152625edecb31e20bac225ed96" name="a93baf8152625edecb31e20bac225ed96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93baf8152625edecb31e20bac225ed96">&#9670;&#160;</a></span>getDisplayTextureName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint Ogre::GL3PlusTextureGpu::getDisplayTextureName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the GLuid of the texture that is being displayed. </p>
<p>While the texture is being loaded (i.e. data is not ready), we will display a dummy white texture. Once notifyDataIsReady, getDisplayTextureName should be the same as getFinalTextureName. In other words, getDisplayTextureName may change its returned value based on the texture's status </p>

</div>
</div>
<a id="a714b2b71f5443736c7c0ac2a97753c02" name="a714b2b71f5443736c7c0ac2a97753c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714b2b71f5443736c7c0ac2a97753c02">&#9670;&#160;</a></span>getEmptyBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> Ogre::TextureGpu::getEmptyBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a030fd6e8824a9b23948bdfce7f0a1211" name="a030fd6e8824a9b23948bdfce7f0a1211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030fd6e8824a9b23948bdfce7f0a1211">&#9670;&#160;</a></span>getFinalTextureName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint Ogre::GL3PlusTextureGpu::getFinalTextureName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Always returns the internal handle that belongs to this texture. </p>
<p>Note that for <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434a2f298fbaec7db976ba6616430b1f52a3" title="When not present: The Texture is exactly the type requested (e.g.">TextureFlags::AutomaticBatching</a> textures, this will be the handle of a 2D Array texture pool.</p>
<p>If the texture has MSAA enabled, this returns the handle to the resolve texture, not the MSAA one.</p>
<p>If <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434ad873b427a39b3c3aabac9ae445f192f4" title="MSAA rendering is an antialiasing technique.">TextureFlags::MsaaExplicitResolve</a> is set, it returns the handle to the MSAA texture, since there is no resolve texture. </p>

</div>
</div>
<a id="a59c0a87d81a1166e3239c247c1f66677" name="a59c0a87d81a1166e3239c247c1f66677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c0a87d81a1166e3239c247c1f66677">&#9670;&#160;</a></span>getGlTextureTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum Ogre::GL3PlusTextureGpu::getGlTextureTarget </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns GL_TEXTURE_2D / GL_TEXTURE_2D_ARRAY / etc. </p>

</div>
</div>
<a id="a4766a70699416dd6dc2a51ad28307a19" name="a4766a70699416dd6dc2a51ad28307a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4766a70699416dd6dc2a51ad28307a19">&#9670;&#160;</a></span>getGpuPageOutStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> Ogre::GpuResource::getGpuPageOutStrategy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7556d2e92eb39b9f465d25bd811c5c22" name="a7556d2e92eb39b9f465d25bd811c5c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7556d2e92eb39b9f465d25bd811c5c22">&#9670;&#160;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getHeight </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7261ed5e880bbe376162a666d0ebea3" name="ac7261ed5e880bbe376162a666d0ebea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7261ed5e880bbe376162a666d0ebea3">&#9670;&#160;</a></span>getInternalSliceStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getInternalSliceStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d4ea058e8a05f5d1949fe952ad00063" name="a4d4ea058e8a05f5d1949fe952ad00063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4ea058e8a05f5d1949fe952ad00063">&#9670;&#160;</a></span>getInternalTextureType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> Ogre::TextureGpu::getInternalTextureType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37e063590ddf3677c87852e3107b4e45" name="a37e063590ddf3677c87852e3107b4e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e063590ddf3677c87852e3107b4e45">&#9670;&#160;</a></span>getListeners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> * &gt;::type &amp; Ogre::TextureGpu::getListeners </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5aee1b547e1be5bfafae466ca0b374ba" name="a5aee1b547e1be5bfafae466ca0b374ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aee1b547e1be5bfafae466ca0b374ba">&#9670;&#160;</a></span>getMsaaFramebufferName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint Ogre::GL3PlusTextureGpu::getMsaaFramebufferName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If MSAA &gt; 1u and <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434ad873b427a39b3c3aabac9ae445f192f4" title="MSAA rendering is an antialiasing technique.">TextureFlags::MsaaExplicitResolve</a> is not set, this returns the handle to the temporary MSAA renderbuffer used for rendering, which will later be resolved into the resolve texture. </p>
<p>Otherwise it returns null. </p>

</div>
</div>
<a id="a4a698f48957f6d466fbddcbf2e80becd" name="a4a698f48957f6d466fbddcbf2e80becd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a698f48957f6d466fbddcbf2e80becd">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::GpuResource::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a10073f63d8fb559374f9e7c6585ae5" name="a4a10073f63d8fb559374f9e7c6585ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a10073f63d8fb559374f9e7c6585ae5">&#9670;&#160;</a></span>getNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getNameStr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note: This returns the alias name of the texture. </p>
<p>See <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a24f8cd49c0990fb532306a1569b58f33">TextureGpuManager::createOrRetrieveTexture</a> </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_gpu_resource.html#a757b15607dab2d7259d829e9a76b3e65">Ogre::GpuResource</a>.</p>

</div>
</div>
<a id="a107372aa3256baf8a80484b7f2412dd6" name="a107372aa3256baf8a80484b7f2412dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107372aa3256baf8a80484b7f2412dd6">&#9670;&#160;</a></span>getNextResidencyStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> Ogre::GpuResource::getNextResidencyStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When <a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus()</a> != <a class="el" href="class_ogre_1_1_gpu_resource.html#a107372aa3256baf8a80484b7f2412dd6" title="When getResidencyStatus() != getNextResidencyStatus(), residency changes happen in the main thread,...">getNextResidencyStatus()</a>, residency changes happen in the main thread, while some preparation may be happening in the background. </p>
<p>For example when a texture is not resident but getNextResidencyStatus says it will, a background thread is loading the texture file from disk, but the actual transition won't happen until the main thread changes it. You can call texture-&gt;<a class="el" href="class_ogre_1_1_texture_gpu.html#adc608f61167b7b737a4129cd2b85f5f4" title="Blocks main thread until data is ready.">waitForData()</a> which will stall, as the main thread will be communicating back and forth with the background to see if it's ready; and when it is, the main thread will perform the transition inside waitForData</p>
<p>Likewise, if that texture is resident but will soon not be, it is still legal to access its contents as long as you access them from the main thread before that main thread changes the residency. This gives you a strong serialization guarantee, but be careful with async tickets such as AsyncTextureTickets:</p>
<p>If you call <a class="el" href="class_ogre_1_1_async_texture_ticket.html" title="In Ogre 2.2 reading data from GPU back to CPU is asynchronous.">AsyncTextureTicket</a> *asyncTicket = textureManager-&gt;createAsyncTextureTicket( ... ); assert( texture-&gt;<a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus()</a> == <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> ); ... do something else that calls <a class="el" href="namespace_ogre.html">Ogre</a> functionality ... assert( texture-&gt;<a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus()</a> == <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> ); asyncTicket-&gt;download( texture, mip, true ); Then the second assert may trigger because that "do something else" ended up calling a function inside <a class="el" href="namespace_ogre.html">Ogre</a> that finalized the transition. Once you've called download and the resource was still Resident, you are safe that your data integrity will be kept. </p><dl class="section remark"><dt>Remarks</dt><dd>Beware of the ABA problem. If the following transitions are scheduled: OnStorage -&gt; Resident -&gt; OnStorage Then both getResidencyStatus &amp; getNextResidencyStatus will return OnStorage. Use <a class="el" href="class_ogre_1_1_gpu_resource.html#a1f960e2ffea97ad43308c23ce1efb4b1" title="Returns the number of pending residency changes.">GpuResource::getPendingResidencyChanges</a> to fix the ABA problem. </dd></dl>

</div>
</div>
<a id="a5dbda8603b2d42d666a9aea7113e290d" name="a5dbda8603b2d42d666a9aea7113e290d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbda8603b2d42d666a9aea7113e290d">&#9670;&#160;</a></span>getNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::TextureGpu::getNumMipmaps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78dd6a8c7c23f1dc98a9ec150bdf16e1" name="a78dd6a8c7c23f1dc98a9ec150bdf16e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dd6a8c7c23f1dc98a9ec150bdf16e1">&#9670;&#160;</a></span>getNumSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getNumSlices </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For TypeCube this value returns 6. </p>
<p>For TypeCubeArray, value returns numSlices * 6u. </p>

</div>
</div>
<a id="a1f960e2ffea97ad43308c23ce1efb4b1" name="a1f960e2ffea97ad43308c23ce1efb4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f960e2ffea97ad43308c23ce1efb4b1">&#9670;&#160;</a></span>getPendingResidencyChanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::GpuResource::getPendingResidencyChanges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of pending residency changes. </p>
<p>Residency changes may not be immediate and thus be delayed (e.g. see <a class="el" href="class_ogre_1_1_texture_gpu.html#a9034d26bf967a6a9ab6a03f3f2a75a88" title="Same as unsafeScheduleTransitionTo, but first checks if we&#39;re already in the residency state we want ...">TextureGpu::scheduleTransitionTo</a>).</p>
<p>When this value is 0 it implies that mResidencyStatus == mNextResidencyStatus </p>

</div>
</div>
<a id="a65a6949bdace3ca3e22d9cdb8cc77411" name="a65a6949bdace3ca3e22d9cdb8cc77411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a6949bdace3ca3e22d9cdb8cc77411">&#9670;&#160;</a></span>getPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::TextureGpu::getPixelFormat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a089625f3d76ac5040973e36e3ae2c72d" name="a089625f3d76ac5040973e36e3ae2c72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089625f3d76ac5040973e36e3ae2c72d">&#9670;&#160;</a></span>getPreferDepthTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::GL3PlusTextureGpuRenderTarget::getPreferDepthTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#adaef49d04083efa37638502be9ece306">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a03e2b3a27c5827b5f063fa6669f8e161" name="a03e2b3a27c5827b5f063fa6669f8e161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e2b3a27c5827b5f063fa6669f8e161">&#9670;&#160;</a></span>getRealResourceNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getRealResourceNameStr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the real name (e.g. disk in file) of the resource. </p>

</div>
</div>
<a id="a57c6e78baed76ebbde12a2061b35ab16" name="a57c6e78baed76ebbde12a2061b35ab16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c6e78baed76ebbde12a2061b35ab16">&#9670;&#160;</a></span>getRequestedSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> Ogre::TextureGpu::getRequestedSampleDescription </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns original requested sample description, i.e. the raw input to setSampleDescription. </p>

</div>
</div>
<a id="aeab133cc1245bb5648652e4369d9497b" name="aeab133cc1245bb5648652e4369d9497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab133cc1245bb5648652e4369d9497b">&#9670;&#160;</a></span>getResidencyStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> Ogre::GpuResource::getResidencyStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9be2b0daaad98d2140ca22efc6685684" name="a9be2b0daaad98d2140ca22efc6685684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be2b0daaad98d2140ca22efc6685684">&#9670;&#160;</a></span>getResourceGroupStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getResourceGroupStr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e45ab2f1617d1d51c45f687d9ebee8c" name="a2e45ab2f1617d1d51c45f687d9ebee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e45ab2f1617d1d51c45f687d9ebee8c">&#9670;&#160;</a></span>getSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> Ogre::TextureGpu::getSampleDescription </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns effective sample description supported by the API. </p>
<p>Note it's only useful after having transitioned to resident. </p>

</div>
</div>
<a id="aad718ff4ec85f52e36ef2772d9b150c2" name="aad718ff4ec85f52e36ef2772d9b150c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad718ff4ec85f52e36ef2772d9b150c2">&#9670;&#160;</a></span>getSettingsDesc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getSettingsDesc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c0f33134c2401b0e711506c8055623" name="a96c0f33134c2401b0e711506c8055623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c0f33134c2401b0e711506c8055623">&#9670;&#160;</a></span>getSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::TextureGpu::getSizeBytes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns total size in bytes used in GPU by this texture (not by its pool) including mipmaps. </p>

</div>
</div>
<a id="a88170d5ed9c9d2dc6e886217aaf1f6a5" name="a88170d5ed9c9d2dc6e886217aaf1f6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88170d5ed9c9d2dc6e886217aaf1f6a5">&#9670;&#160;</a></span>getSourceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::TextureGpu::getSourceType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This setting is for where the texture is created, e.g.   </p>
<p>its a compositor texture, a shadow texture or standard texture loaded for a mesh etc...</p>
<p>This value is merely for statistical tracking purposes</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_ogre_1_1_texture_source_type.html#a487889f4cfc926c4eaaf01e2f4e68c5a">TextureSourceType::TextureSourceType</a>   </dd></dl>

</div>
</div>
<a id="ac2d30ea54e791fd18489ad3cd28fe9b6" name="ac2d30ea54e791fd18489ad3cd28fe9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d30ea54e791fd18489ad3cd28fe9b6">&#9670;&#160;</a></span>getSubsampleLocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpu::getSubsampleLocations </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_ogre_1_1_vector2.html">Vector2</a> &gt;::type&#160;</td>
          <td class="paramname"><em>locations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the MSAA subsample locations. </p>
<p>mSampleDescription.pattern must not be <a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0fae9213e03f8cab27c1f90e1981b2ab623" title="Let the GPU decide.">MsaaPatterns::Undefined</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locations</td><td>Outputs an array with the locations for each subsample. Values are in range [-1; 1] </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#a1a458af605a3aa67117fe267ac453c17">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#a13609621515188959fde2257be92ac4b">Ogre::GL3PlusTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a392c0d59b4956c9a361e82514cba0427" name="a392c0d59b4956c9a361e82514cba0427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392c0d59b4956c9a361e82514cba0427">&#9670;&#160;</a></span>getTextureManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> * Ogre::TextureGpu::getTextureManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5cba290939fe64d8d12c514d79e9fc4" name="aa5cba290939fe64d8d12c514d79e9fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cba290939fe64d8d12c514d79e9fc4">&#9670;&#160;</a></span>getTexturePool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> * Ogre::TextureGpu::getTexturePool </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78663647804665d50f8e0ec251845ff3" name="a78663647804665d50f8e0ec251845ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78663647804665d50f8e0ec251845ff3">&#9670;&#160;</a></span>getTexturePoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getTexturePoolId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6906f8bdd2c820cc47b60b7d494d147" name="ab6906f8bdd2c820cc47b60b7d494d147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6906f8bdd2c820cc47b60b7d494d147">&#9670;&#160;</a></span>getTextureType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> Ogre::TextureGpu::getTextureType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1858af3588de15e9da271d22fe9d5c1" name="ad1858af3588de15e9da271d22fe9d5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1858af3588de15e9da271d22fe9d5c1">&#9670;&#160;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::TextureGpu::getWidth </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab038b4f32feeaa739a8cff7397e8809d" name="ab038b4f32feeaa739a8cff7397e8809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab038b4f32feeaa739a8cff7397e8809d">&#9670;&#160;</a></span>hasAutomaticBatching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasAutomaticBatching </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4de8595b73e911c15ce9e8066926380d" name="a4de8595b73e911c15ce9e8066926380d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de8595b73e911c15ce9e8066926380d">&#9670;&#160;</a></span>hasAutoMipmapAuto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasAutoMipmapAuto </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af943f8d1fd87f457fb4633058d696470" name="af943f8d1fd87f457fb4633058d696470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af943f8d1fd87f457fb4633058d696470">&#9670;&#160;</a></span>hasEquivalentParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasEquivalentParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3c2ce1e86de183dd2e2eff87da180a5" name="aa3c2ce1e86de183dd2e2eff87da180a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c2ce1e86de183dd2e2eff87da180a5">&#9670;&#160;</a></span>hasMsaaExplicitResolves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasMsaaExplicitResolves </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74eec57c1978002c8db51e606c2178ed" name="a74eec57c1978002c8db51e606c2178ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74eec57c1978002c8db51e606c2178ed">&#9670;&#160;</a></span>isDataReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isDataReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this texture is fully ready to be used for displaying. </p>
<p>IMPORTANT: Always returns true if getResidencyStatus != <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> and there are no pending residency transitions.</p>
<p>Returns false while there are pending residency status</p>
<p>If this is true, then isMetadataReady is also true. See isMetadataReady. </p>

</div>
</div>
<a id="a2afd94abec3a7a91c656188fc6d7cdf5" name="a2afd94abec3a7a91c656188fc6d7cdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afd94abec3a7a91c656188fc6d7cdf5">&#9670;&#160;</a></span>isManualTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isManualTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23c32548e36eee7661d2da4c58f09f80" name="a23c32548e36eee7661d2da4c58f09f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c32548e36eee7661d2da4c58f09f80">&#9670;&#160;</a></span>isMetadataReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isMetadataReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It is threadsafe to call this function from main thread. </p>
<p>If this returns false, then the following functions are not threadsafe: Setters must not be called, and getters may change from a worker thread: setResolution getWidth, getHeight, getDepth, getDepthOrSlices, getNumSlices set/getPixelFormat set/getNumMipmaps set/getTextureType getTexturePool Note that this function may return true but the worker thread may still be uploading to this texture. Use isDataReady to see if the worker thread is fully done with this texture.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Function for querying/waiting for data and metadata to be ready are for blocking the main thread when a worker thread is loading the texture from file or a listener (i.e. isManualTexture returns false) otherwise you don't need to call these functions. </dd></dl>

</div>
</div>
<a id="a4ebc3bec47d599f4d0f7a9cde67bd4d3" name="a4ebc3bec47d599f4d0f7a9cde67bd4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebc3bec47d599f4d0f7a9cde67bd4d3">&#9670;&#160;</a></span>isMsaaPatternSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::isMsaaPatternSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0f">MsaaPatterns::MsaaPatterns</a>&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#ad0bb22af342ab460495997988c2a6cf9">Ogre::D3D11TextureGpu</a>.</p>

</div>
</div>
<a id="a0ccfb3ab941842233e28a216e337e28e" name="a0ccfb3ab941842233e28a216e337e28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccfb3ab941842233e28a216e337e28e">&#9670;&#160;</a></span>isMultisample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isMultisample </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab81e9a755ba2b500f911c02b1df1893a" name="ab81e9a755ba2b500f911c02b1df1893a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81e9a755ba2b500f911c02b1df1893a">&#9670;&#160;</a></span>isOpenGLRenderWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::GL3PlusTextureGpuHeadlessWindow::isOpenGLRenderWindow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OpenGL RenderWindows are a bit specific: </p>
<ul>
<li>Their origins are upside down. Which means we need to flip Y.</li>
<li>They can access resolved contents of MSAA even if hasMsaaExplicitResolves = true</li>
<li>Headless windows return false since internally they're FBOs. However isRenderWindowSpecific will return true </li>
</ul>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#a31a1ba96b03d3bab1a3c5943d03531fc">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="ae6576323b0cf05a3efbf46f9ab5d6e1e" name="ae6576323b0cf05a3efbf46f9ab5d6e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6576323b0cf05a3efbf46f9ab5d6e1e">&#9670;&#160;</a></span>isPoolOwner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isPoolOwner </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a359fd32c4f8c31cdd4db4baf72c1b70c" name="a359fd32c4f8c31cdd4db4baf72c1b70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359fd32c4f8c31cdd4db4baf72c1b70c">&#9670;&#160;</a></span>isReinterpretable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isReinterpretable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c0edfcf7c6354c686d2ff580e7a5011" name="a4c0edfcf7c6354c686d2ff580e7a5011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0edfcf7c6354c686d2ff580e7a5011">&#9670;&#160;</a></span>isRenderToTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isRenderToTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0c236009b4074f43621c21db5ff6ef4" name="aa0c236009b4074f43621c21db5ff6ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c236009b4074f43621c21db5ff6ef4">&#9670;&#160;</a></span>isRenderWindowSpecific()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isRenderWindowSpecific </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a529bc39128cc173557a2742b7278c400" name="a529bc39128cc173557a2742b7278c400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529bc39128cc173557a2742b7278c400">&#9670;&#160;</a></span>isTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdde6ea96205d73550d17a18bf4653a4" name="acdde6ea96205d73550d17a18bf4653a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdde6ea96205d73550d17a18bf4653a4">&#9670;&#160;</a></span>isUav()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isUav </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52acdc930dff7ae7f455256822d9520d" name="a52acdc930dff7ae7f455256822d9520d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52acdc930dff7ae7f455256822d9520d">&#9670;&#160;</a></span>notifyAllListenersTextureChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::notifyAllListenersTextureChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extraData</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe802beaa684f0f1a42ff4294fe7712b" name="afe802beaa684f0f1a42ff4294fe7712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe802beaa684f0f1a42ff4294fe7712b">&#9670;&#160;</a></span>notifyDataIsReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpu::notifyDataIsReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies it is safe to use the real data. Everything has been uploaded. </p>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#abe10b3ea1bc20e616134af7b7f567446">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#ab8963d9948825e033beec03c8428dc7c">Ogre::GL3PlusTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded" name="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&#160;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792" name="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&#160;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144" name="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&#160;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c" name="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&#160;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d" name="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&#160;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f1a983f9e2dfddee802c47bb0b1ca9" name="ad1f1a983f9e2dfddee802c47bb0b1ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f1a983f9e2dfddee802c47bb0b1ca9">&#9670;&#160;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab422c67a2c8844f410fe822a357cba3b" name="ab422c67a2c8844f410fe822a357cba3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422c67a2c8844f410fe822a357cba3b">&#9670;&#160;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="a63fc6bdc2eb6aeac24898a77ec5e2023" name="a63fc6bdc2eb6aeac24898a77ec5e2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc6bdc2eb6aeac24898a77ec5e2023">&#9670;&#160;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="adce32528577d71b228692df906ecd17c" name="adce32528577d71b228692df906ecd17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce32528577d71b228692df906ecd17c">&#9670;&#160;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed1464ac3de21ff20db8f9f1f8608dc7" name="aed1464ac3de21ff20db8f9f1f8608dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1464ac3de21ff20db8f9f1f8608dc7">&#9670;&#160;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="a2e6b84b89e2080bb7103d4778641d86e" name="a2e6b84b89e2080bb7103d4778641d86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6b84b89e2080bb7103d4778641d86e">&#9670;&#160;</a></span>prefersLoadingFromFileAsSRGB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::prefersLoadingFromFileAsSRGB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3e0ad601752b91f2851c88f9ed49869" name="ae3e0ad601752b91f2851c88f9ed49869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e0ad601752b91f2851c88f9ed49869">&#9670;&#160;</a></span>removeListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::removeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3db88cd9e4286f47a56fe7f507cd5c1b" name="a3db88cd9e4286f47a56fe7f507cd5c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db88cd9e4286f47a56fe7f507cd5c1b">&#9670;&#160;</a></span>requiresTextureFlipping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::requiresTextureFlipping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9034d26bf967a6a9ab6a03f3f2a75a88" name="a9034d26bf967a6a9ab6a03f3f2a75a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9034d26bf967a6a9ab6a03f3f2a75a88">&#9670;&#160;</a></span>scheduleTransitionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::scheduleTransitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>nextResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as unsafeScheduleTransitionTo, but first checks if we're already in the residency state we want to go to, or if it has already been scheduled; thus it can be called multiple times. </p>

</div>
</div>
<a id="a6ae40391d39c8feae00acaf25839c6f9" name="a6ae40391d39c8feae00acaf25839c6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae40391d39c8feae00acaf25839c6f9">&#9670;&#160;</a></span>setNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setNumMipmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54dfe2523d8e5647e79caaf28c296d4e" name="a54dfe2523d8e5647e79caaf28c296d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dfe2523d8e5647e79caaf28c296d4e">&#9670;&#160;</a></span>setPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setPixelFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pixel format. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="class_ogre_1_1_texture_gpu.html#a2e6b84b89e2080bb7103d4778641d86e">prefersLoadingFromFileAsSRGB()</a> returns true, the format may not be fully honoured (as we'll use the equivalent _SRGB variation). </dd></dl>

</div>
</div>
<a id="af79e22c90559d13385d75dc19970806d" name="af79e22c90559d13385d75dc19970806d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79e22c90559d13385d75dc19970806d">&#9670;&#160;</a></span>setResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2ee4d088c32b3e9efeb4d2fec5cad3e" name="aa2ee4d088c32b3e9efeb4d2fec5cad3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ee4d088c32b3e9efeb4d2fec5cad3e">&#9670;&#160;</a></span>setSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setSampleDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78bd23c2116dc08afcaa8dc1b8d2384e" name="a78bd23c2116dc08afcaa8dc1b8d2384e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bd23c2116dc08afcaa8dc1b8d2384e">&#9670;&#160;</a></span>setTexturePoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setTexturePoolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> with automatic batching will be merged with other textures into the same pool as one big 2D Array texture behind the scenes. </p>
<p>For two textures to be placed in the same pool (assuming it's not full) the following must match: Width, Height, PixelFormat, number of mipmaps, poolID</p>
<p><a class="el" href="class_ogre_1_1_pool.html" title="Template class describing a simple pool of items.">Pool</a> ID is an arbitrary value with no actual meaning. This is ID allows you to prevent certain textures from being group together. For example, you may want all textures from Level 0 to be grouped together while Level 1 gets grouped together in a different pool</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434a2f298fbaec7db976ba6616430b1f52a3" title="When not present: The Texture is exactly the type requested (e.g.">TextureFlags::AutomaticBatching</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a6e96132817c27bfae1c0374e98d20dfc" title="Reserves and preallocates a pool with the given parameters Returns the master texture that owns the p...">TextureGpuManager::reservePoolId</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value cannot be changed while the texture is resident (i.e. because it has already been assigned to a pool) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolId</td><td>Arbitrary value. Default value is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad78fb144ef8847a9369db46ade4cf568" name="ad78fb144ef8847a9369db46ade4cf568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78fb144ef8847a9369db46ade4cf568">&#9670;&#160;</a></span>setTextureType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpuHeadlessWindow::setTextureType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#aa307d3e0905e7de18587dcb30c0b65e2">Ogre::GL3PlusTextureGpu</a>.</p>

</div>
</div>
<a id="a3bd2fb8a2ce598268c8813f5f230ddd8" name="a3bd2fb8a2ce598268c8813f5f230ddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd2fb8a2ce598268c8813f5f230ddd8">&#9670;&#160;</a></span>supportsAsDepthBufferFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::supportsAsDepthBufferFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>colourTarget</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f76858facbfe1833178af802576cd33" name="a5f76858facbfe1833178af802576cd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f76858facbfe1833178af802576cd33">&#9670;&#160;</a></span>swapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusTextureGpuHeadlessWindow::swapBuffers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only valid for <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> classes. </p>
<p>TODO: This may be moved to a different class. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#ac707e8be721a47fb23a628003b1ade1f">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="aa3efd161b3ec98e3a405cf3167b7d022" name="aa3efd161b3ec98e3a405cf3167b7d022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3efd161b3ec98e3a405cf3167b7d022">&#9670;&#160;</a></span>unsafeScheduleTransitionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::unsafeScheduleTransitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>nextResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules an async transition in residency. </p>
<p>If transitioning from OnStorage to Resident, it will read from file (ResourceGroup was set in createTexture) If transitioning from OnSystemRam to Resident, it will read from the pointer it has. Multiple transitions can be stack together. </p><dl class="section remark"><dt>Remarks</dt><dd>If you're not loading from file (i.e. you're creating it programatically), call _transitionTo &amp; _setNextResidencyStatus directly. Once you've called scheduleTransitionTo at least once, calling _transitionTo is very dangerous, as there are race conditions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_gpu.html#a9034d26bf967a6a9ab6a03f3f2a75a88" title="Same as unsafeScheduleTransitionTo, but first checks if we&#39;re already in the residency state we want ...">TextureGpu::scheduleTransitionTo</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nextResidency</td><td>The residency to change to. </td></tr>
    <tr><td class="paramname">image</td><td>Pointer to image if you want to load the texture from memory instead of loading it from file or a listener. Pointer must be null if this is a manual texture. Pointer must NOT be a stack variable nor be deleted immediately. The actual loading is postponed until the request reaches the worker thread. That means the image pointer is safe to delete once you receive the <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257" title="This Reason is called when TextureGpu::notifyDataIsReady is called.">TextureGpuListener::Reason::ReadyForRendering</a> message. </td></tr>
    <tr><td class="paramname">autoDeleteImage</td><td>Whether we should call "delete image" once we're done using the image. Otherwise you must listen for <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257" title="This Reason is called when TextureGpu::notifyDataIsReady is called.">TextureGpuListener::ReadyForRendering</a> message to know when we're done using the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc608f61167b7b737a4129cd2b85f5f4" name="adc608f61167b7b737a4129cd2b85f5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc608f61167b7b737a4129cd2b85f5f4">&#9670;&#160;</a></span>waitForData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::waitForData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks main thread until data is ready. </p>
<p>Afterwards isDataReady should return true. If it doesn't, then there was a problem loading the texture. See isMetadataReady remarks. </p>

</div>
</div>
<a id="a6740006ae83f39c4aeb83f300b67f6b2" name="a6740006ae83f39c4aeb83f300b67f6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6740006ae83f39c4aeb83f300b67f6b2">&#9670;&#160;</a></span>waitForMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::waitForMetadata </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks main thread until metadata is ready. </p>
<p>Afterwards isMetadataReady should return true. If it doesn't, then there was a problem loading the texture. See isMetadataReady remarks. </p>

</div>
</div>
<a id="af042e9ab52c07776f154ee077330f592" name="af042e9ab52c07776f154ee077330f592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af042e9ab52c07776f154ee077330f592">&#9670;&#160;</a></span>writeContentsToFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::writeContentsToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>minMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>maxMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automaticResolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the current contents of the render target to the named file. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3ed2bdf11740fd262b9311a33e33f935" name="a3ed2bdf11740fd262b9311a33e33f935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed2bdf11740fd262b9311a33e33f935">&#9670;&#160;</a></span>msFinalTextureBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::TextureGpu::msFinalTextureBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43888e98f84f5c9eb9ded14dd0deb34d" name="a43888e98f84f5c9eb9ded14dd0deb34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43888e98f84f5c9eb9ded14dd0deb34d">&#9670;&#160;</a></span>msMsaaTextureBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::TextureGpu::msMsaaTextureBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_g_l3_plus_texture_gpu_window_8h.html">OgreGL3PlusTextureGpuWindow.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html">GL3PlusTextureGpuHeadlessWindow</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
