<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::GL3PlusVaoManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.3</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_g_l3_plus_vao_manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_g_l3_plus_vao_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::GL3PlusVaoManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreGL3PlusVaoManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::GL3PlusVaoManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_g_l3_plus_vao_manager__inherit__graph.svg" width="191" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_g_l3_plus_vao_manager_1_1_block.html">Block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_g_l3_plus_vao_manager_1_1_stride_changer.html">StrideChanger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acf63571a368c427ffdcfb1897ec5f041"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="struct_ogre_1_1_g_l3_plus_vao_manager_1_1_block.html">Block</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#acf63571a368c427ffdcfb1897ec5f041">BlockVec</a></td></tr>
<tr class="separator:acf63571a368c427ffdcfb1897ec5f041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a984ae987b00e95b35198131a4e9a6b"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="struct_ogre_1_1_vao_manager_1_1_memory_stats_entry.html">MemoryStatsEntry</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a8a984ae987b00e95b35198131a4e9a6b">MemoryStatsEntryVec</a></td></tr>
<tr class="separator:a8a984ae987b00e95b35198131a4e9a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c5a9e410625780fcc610f3243be960"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="struct_ogre_1_1_g_l3_plus_vao_manager_1_1_stride_changer.html">StrideChanger</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a79c5a9e410625780fcc610f3243be960">StrideChangerVec</a></td></tr>
<tr class="separator:a79c5a9e410625780fcc610f3243be960"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ceaf6e928e2079f263dab39e7d8d6a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a4ceaf6e928e2079f263dab39e7d8d6a6">GL3PlusVaoManager</a> (bool <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#aadc4d558e3a0893cb21661c05f74b463">supportsArbBufferStorage</a>, bool emulateTexBuffers, bool <a class="el" href="class_ogre_1_1_vao_manager.html#afce1736c1c28af8657aaf863d366240f">supportsIndirectBuffers</a>, bool _supportsBaseInstance, bool supportsSsbo, const <a class="el" href="group___general.html#ga442a408f658c0cbfbe3e404e91a0fcc5">NameValuePairList</a> *params)</td></tr>
<tr class="separator:a4ceaf6e928e2079f263dab39e7d8d6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add095b8663546d8520f8cc9c0d92c90c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#add095b8663546d8520f8cc9c0d92c90c">~GL3PlusVaoManager</a> ()</td></tr>
<tr class="separator:add095b8663546d8520f8cc9c0d92c90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad255ed9aad893f120f6a29e172052ccd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ad255ed9aad893f120f6a29e172052ccd">_beginFrame</a> (void)</td></tr>
<tr class="separator:ad255ed9aad893f120f6a29e172052ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2c223f495c035085ffa2b7323bce82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a4c2c223f495c035085ffa2b7323bce82">_getDynamicBufferCurrentFrameNoWait</a> (void) const</td></tr>
<tr class="separator:a4c2c223f495c035085ffa2b7323bce82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374058250675bac30bfb5b03c26b5eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a374058250675bac30bfb5b03c26b5eb7">_notifyStagingBufferEnteredZeroRef</a> (<a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *stagingBuffer)</td></tr>
<tr class="separator:a374058250675bac30bfb5b03c26b5eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2545e4ce03ff536e3d505e4669cc91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ace2545e4ce03ff536e3d505e4669cc91">_notifyStagingBufferLeftZeroRef</a> (<a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *stagingBuffer)</td></tr>
<tr class="separator:ace2545e4ce03ff536e3d505e4669cc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a803fbce3bc62ad1bc5a0632bf69da7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a6a803fbce3bc62ad1bc5a0632bf69da7">_update</a> (void)</td></tr>
<tr class="separator:a6a803fbce3bc62ad1bc5a0632bf69da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f85d710473526ee0985c4def94dcb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#ae7f85d710473526ee0985c4def94dcb5">bindDrawId</a> (void)</td></tr>
<tr class="memdesc:ae7f85d710473526ee0985c4def94dcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the Draw ID to the currently bound vertex array object.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#ae7f85d710473526ee0985c4def94dcb5">More...</a><br /></td></tr>
<tr class="separator:ae7f85d710473526ee0985c4def94dcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2479c58ace6ff748d17cc0f65091d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#acfe2479c58ace6ff748d17cc0f65091d">cleanupEmptyPools</a> (void)</td></tr>
<tr class="memdesc:acfe2479c58ace6ff748d17cc0f65091d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees GPU memory if there are empty, unused pools.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#acfe2479c58ace6ff748d17cc0f65091d">More...</a><br /></td></tr>
<tr class="separator:acfe2479c58ace6ff748d17cc0f65091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530db71d0308ab9ad62b1243be3196ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aef9bfd2a5567613e99bc8d7eae1c1bf9">AsyncTicketPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a530db71d0308ab9ad62b1243be3196ff">createAsyncTicket</a> (<a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *creator, <a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *stagingBuffer, size_t elementStart, size_t elementCount)</td></tr>
<tr class="separator:a530db71d0308ab9ad62b1243be3196ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952ab60d93451fc2ea18e14bbc31c309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a952ab60d93451fc2ea18e14bbc31c309">createConstBuffer</a> (size_t sizeBytes, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a952ab60d93451fc2ea18e14bbc31c309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an constant buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a952ab60d93451fc2ea18e14bbc31c309">More...</a><br /></td></tr>
<tr class="separator:a952ab60d93451fc2ea18e14bbc31c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f791867304e682175612237b3bfd470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a0f791867304e682175612237b3bfd470">createIndexBuffer</a> (<a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexBufferPacked::IndexType</a> indexType, size_t numIndices, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a0f791867304e682175612237b3bfd470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an index buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a0f791867304e682175612237b3bfd470">More...</a><br /></td></tr>
<tr class="separator:a0f791867304e682175612237b3bfd470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ec74188530974bc3c28f3d1ab2982f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_indirect_buffer_packed.html">IndirectBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ad5ec74188530974bc3c28f3d1ab2982f">createIndirectBuffer</a> (size_t sizeBytes, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:ad5ec74188530974bc3c28f3d1ab2982f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an indirect buffer.  <a href="class_ogre_1_1_vao_manager.html#ad5ec74188530974bc3c28f3d1ab2982f">More...</a><br /></td></tr>
<tr class="separator:ad5ec74188530974bc3c28f3d1ab2982f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167879924fcc223de12f276c61be0c88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_multi_source_vertex_buffer_pool.html">MultiSourceVertexBufferPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a167879924fcc223de12f276c61be0c88">createMultiSourceVertexBufferPool</a> (const <a class="el" href="namespace_ogre.html#abdf543378d3741e0b20039e582e55a16">VertexElement2VecVec</a> &amp;vertexElementsBySource, size_t maxNumVertices, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType)</td></tr>
<tr class="separator:a167879924fcc223de12f276c61be0c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f95d947d7dae2068089fe00a03eb37d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html">ReadOnlyBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a9f95d947d7dae2068089fe00a03eb37d">createReadOnlyBuffer</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat, size_t sizeBytes, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a9f95d947d7dae2068089fe00a03eb37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a read-only buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a9f95d947d7dae2068089fe00a03eb37d">More...</a><br /></td></tr>
<tr class="separator:a9f95d947d7dae2068089fe00a03eb37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8851d90bc61865477947731455440b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a4e8851d90bc61865477947731455440b">createStagingBuffer</a> (size_t sizeBytes, bool forUpload)</td></tr>
<tr class="memdesc:a4e8851d90bc61865477947731455440b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new staging buffer and adds it to the pool.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#a4e8851d90bc61865477947731455440b">More...</a><br /></td></tr>
<tr class="separator:a4e8851d90bc61865477947731455440b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe72cf8783a9d2438c978550a68366f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_g_l3_plus_staging_texture.html">GL3PlusStagingTexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#afe72cf8783a9d2438c978550a68366f5">createStagingTexture</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> formatFamily, size_t sizeBytes)</td></tr>
<tr class="memdesc:afe72cf8783a9d2438c978550a68366f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See GL3PlusTextureGpuManager::createStagingTextureImpl.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#afe72cf8783a9d2438c978550a68366f5">More...</a><br /></td></tr>
<tr class="separator:afe72cf8783a9d2438c978550a68366f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15deceadb9ee88de12fd801464e4b09b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a15deceadb9ee88de12fd801464e4b09b">createTexBuffer</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat, size_t sizeBytes, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a15deceadb9ee88de12fd801464e4b09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an constant buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a15deceadb9ee88de12fd801464e4b09b">More...</a><br /></td></tr>
<tr class="separator:a15deceadb9ee88de12fd801464e4b09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6001313fdecc1491daa683595fdb5018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a6001313fdecc1491daa683595fdb5018">createUavBuffer</a> (size_t numElements, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> bytesPerElement, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> bindFlags, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a6001313fdecc1491daa683595fdb5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an UAV buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a6001313fdecc1491daa683595fdb5018">More...</a><br /></td></tr>
<tr class="separator:a6001313fdecc1491daa683595fdb5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76927e1aaf3cdd9dfddcf4f7bbb0a48a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_vertex_array_object.html">VertexArrayObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a76927e1aaf3cdd9dfddcf4f7bbb0a48a">createVertexArrayObject</a> (const <a class="el" href="namespace_ogre.html#a0a4ccde77034efa918c66e561958949a">VertexBufferPackedVec</a> &amp;vertexBuffers, <a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *indexBuffer, <a class="el" href="group___general.html#ga0ef99399e9e670e7bb69dc373968a666">OperationType</a> opType)</td></tr>
<tr class="memdesc:a76927e1aaf3cdd9dfddcf4f7bbb0a48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="struct_ogre_1_1_vertex_array_object.html" title="Vertex array objects (Vaos) are immutable objects that describe a combination of vertex buffers and i...">VertexArrayObject</a> that binds all the vertex buffers with their respective declarations, and the index buffers.  <a href="class_ogre_1_1_vao_manager.html#a76927e1aaf3cdd9dfddcf4f7bbb0a48a">More...</a><br /></td></tr>
<tr class="separator:a76927e1aaf3cdd9dfddcf4f7bbb0a48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163fd24c8a7f2c33595bb7fe94e97cf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vertex_buffer_packed.html">VertexBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3">createVertexBuffer</a> (const <a class="el" href="namespace_ogre.html#a03b06afe794fcbba8e2d2172892a80f6">VertexElement2Vec</a> &amp;vertexElements, size_t numVertices, <a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a> bufferType, void *initialData, bool keepAsShadow)</td></tr>
<tr class="memdesc:a163fd24c8a7f2c33595bb7fe94e97cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vertex buffer based on the given parameters.  <a href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3">More...</a><br /></td></tr>
<tr class="separator:a163fd24c8a7f2c33595bb7fe94e97cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204c8055903cea82fe38e6a9fbc62f6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a204c8055903cea82fe38e6a9fbc62f6d">deleteStagingBuffers</a> ()</td></tr>
<tr class="separator:a204c8055903cea82fe38e6a9fbc62f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f5147151805c3d294ae200683d76bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a51f5147151805c3d294ae200683d76bb">destroyConstBuffer</a> (<a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *constBuffer)</td></tr>
<tr class="memdesc:a51f5147151805c3d294ae200683d76bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given constant buffer created with createConstBuffer.  <a href="class_ogre_1_1_vao_manager.html#a51f5147151805c3d294ae200683d76bb">More...</a><br /></td></tr>
<tr class="separator:a51f5147151805c3d294ae200683d76bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c53b84b4c6ba27fdcbf57a08d4b044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a04c53b84b4c6ba27fdcbf57a08d4b044">destroyIndexBuffer</a> (<a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *indexBuffer)</td></tr>
<tr class="memdesc:a04c53b84b4c6ba27fdcbf57a08d4b044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given index buffer created with createIndexBuffer.  <a href="class_ogre_1_1_vao_manager.html#a04c53b84b4c6ba27fdcbf57a08d4b044">More...</a><br /></td></tr>
<tr class="separator:a04c53b84b4c6ba27fdcbf57a08d4b044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7e88128e2496523ab0ca8e35634879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a4e7e88128e2496523ab0ca8e35634879">destroyIndirectBuffer</a> (<a class="el" href="class_ogre_1_1_indirect_buffer_packed.html">IndirectBufferPacked</a> *indirectBuffer)</td></tr>
<tr class="memdesc:a4e7e88128e2496523ab0ca8e35634879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given indirect buffer created with createIndirectBuffer.  <a href="class_ogre_1_1_vao_manager.html#a4e7e88128e2496523ab0ca8e35634879">More...</a><br /></td></tr>
<tr class="separator:a4e7e88128e2496523ab0ca8e35634879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703bff2ff022184c4f40da6ecb9a19ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a703bff2ff022184c4f40da6ecb9a19ee">destroyReadOnlyBuffer</a> (<a class="el" href="class_ogre_1_1_read_only_buffer_packed.html">ReadOnlyBufferPacked</a> *readOnlyBuffer)</td></tr>
<tr class="memdesc:a703bff2ff022184c4f40da6ecb9a19ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given texture buffer created with createReadOnlyBuffer.  <a href="class_ogre_1_1_vao_manager.html#a703bff2ff022184c4f40da6ecb9a19ee">More...</a><br /></td></tr>
<tr class="separator:a703bff2ff022184c4f40da6ecb9a19ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79c19ee474881cbf8f49600395c27ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#aa79c19ee474881cbf8f49600395c27ca">destroyStagingTexture</a> (<a class="el" href="class_ogre_1_1_g_l3_plus_staging_texture.html">GL3PlusStagingTexture</a> *stagingTexture)</td></tr>
<tr class="memdesc:aa79c19ee474881cbf8f49600395c27ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Important: Does not delete the stagingTexture.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#aa79c19ee474881cbf8f49600395c27ca">More...</a><br /></td></tr>
<tr class="separator:aa79c19ee474881cbf8f49600395c27ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6241229a8f3c895dcd49e7d0e8dfe545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a6241229a8f3c895dcd49e7d0e8dfe545">destroyTexBuffer</a> (<a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *texBuffer)</td></tr>
<tr class="memdesc:a6241229a8f3c895dcd49e7d0e8dfe545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given texture buffer created with createTexBuffer.  <a href="class_ogre_1_1_vao_manager.html#a6241229a8f3c895dcd49e7d0e8dfe545">More...</a><br /></td></tr>
<tr class="separator:a6241229a8f3c895dcd49e7d0e8dfe545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f235ad527a20a7c20b9daae8dc18ff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a0f235ad527a20a7c20b9daae8dc18ff7">destroyUavBuffer</a> (<a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *uavBuffer)</td></tr>
<tr class="memdesc:a0f235ad527a20a7c20b9daae8dc18ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given UAV buffer created with createUavBuffer.  <a href="class_ogre_1_1_vao_manager.html#a0f235ad527a20a7c20b9daae8dc18ff7">More...</a><br /></td></tr>
<tr class="separator:a0f235ad527a20a7c20b9daae8dc18ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d56b87f51c489bdc2df07d1ce040512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a4d56b87f51c489bdc2df07d1ce040512">destroyVertexArrayObject</a> (<a class="el" href="struct_ogre_1_1_vertex_array_object.html">VertexArrayObject</a> *vao)</td></tr>
<tr class="memdesc:a4d56b87f51c489bdc2df07d1ce040512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the input pointer.  <a href="class_ogre_1_1_vao_manager.html#a4d56b87f51c489bdc2df07d1ce040512">More...</a><br /></td></tr>
<tr class="separator:a4d56b87f51c489bdc2df07d1ce040512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dce3c8cb8c7d08ff77e6c4776fed1f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a1dce3c8cb8c7d08ff77e6c4776fed1f4">destroyVertexBuffer</a> (<a class="el" href="class_ogre_1_1_vertex_buffer_packed.html">VertexBufferPacked</a> *vertexBuffer)</td></tr>
<tr class="memdesc:a1dce3c8cb8c7d08ff77e6c4776fed1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given vertex buffer created with createVertexBuffer.  <a href="class_ogre_1_1_vao_manager.html#a1dce3c8cb8c7d08ff77e6c4776fed1f4">More...</a><br /></td></tr>
<tr class="separator:a1dce3c8cb8c7d08ff77e6c4776fed1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a00e866aebffe5114767ce1fc81bea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a4a00e866aebffe5114767ce1fc81bea8">getConstBufferAlignment</a> (void) const</td></tr>
<tr class="separator:a4a00e866aebffe5114767ce1fc81bea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6613f84365a386b9a50fed61a96cfc7a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a6613f84365a386b9a50fed61a96cfc7a">getConstBufferMaxSize</a> (void) const</td></tr>
<tr class="separator:a6613f84365a386b9a50fed61a96cfc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb22409286339939dc6d49e44a8f3683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#adb22409286339939dc6d49e44a8f3683">getDefaultStagingBufferLifetime</a> (void) const</td></tr>
<tr class="separator:adb22409286339939dc6d49e44a8f3683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5388b5890025a724a42f4469363bb267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a5388b5890025a724a42f4469363bb267">getDefaultStagingBufferUnfencedTime</a> (void) const</td></tr>
<tr class="separator:a5388b5890025a724a42f4469363bb267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b609165fb053afe550711546254e230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a9b609165fb053afe550711546254e230">getDynamicBufferMultiplier</a> (void) const</td></tr>
<tr class="separator:a9b609165fb053afe550711546254e230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab528ecee92f02772be5dc8329c0e1e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ab528ecee92f02772be5dc8329c0e1e1b">getFrameCount</a> (void)</td></tr>
<tr class="separator:ab528ecee92f02772be5dc8329c0e1e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5140b54e5640aa8b8b931a6c14d1e4c2"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a5140b54e5640aa8b8b931a6c14d1e4c2">getMaxVertexAttribs</a> (void) const</td></tr>
<tr class="separator:a5140b54e5640aa8b8b931a6c14d1e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70811386532e1aa7ad5600165a4013a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a70811386532e1aa7ad5600165a4013a6">getMemoryStats</a> (<a class="el" href="class_ogre_1_1_vao_manager.html#a8a984ae987b00e95b35198131a4e9a6b">MemoryStatsEntryVec</a> &amp;outStats, size_t &amp;outCapacityBytes, size_t &amp;outFreeBytes, <a class="el" href="class_ogre_1_1_log.html">Log</a> *log) const</td></tr>
<tr class="memdesc:a70811386532e1aa7ad5600165a4013a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves memory stats about our GPU pools being managed.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#a70811386532e1aa7ad5600165a4013a6">More...</a><br /></td></tr>
<tr class="separator:a70811386532e1aa7ad5600165a4013a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ea50dfdfc83e13bae02da290647884"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ae8ea50dfdfc83e13bae02da290647884">getReadOnlyBufferMaxSize</a> (void) const</td></tr>
<tr class="separator:ae8ea50dfdfc83e13bae02da290647884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755b7f61f17c568f32a6708c4d4cb986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a755b7f61f17c568f32a6708c4d4cb986">getStagingBuffer</a> (size_t minSizeBytes, bool forUpload)</td></tr>
<tr class="memdesc:a755b7f61f17c568f32a6708c4d4cb986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a staging buffer for use.  <a href="class_ogre_1_1_vao_manager.html#a755b7f61f17c568f32a6708c4d4cb986">More...</a><br /></td></tr>
<tr class="separator:a755b7f61f17c568f32a6708c4d4cb986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4856f0420c296824372ce64825cbfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a6c4856f0420c296824372ce64825cbfd">getTexBufferAlignment</a> (void) const</td></tr>
<tr class="separator:a6c4856f0420c296824372ce64825cbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0feae113e7a1003d76b3640c51d243"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a2d0feae113e7a1003d76b3640c51d243">getTexBufferMaxSize</a> (void) const</td></tr>
<tr class="separator:a2d0feae113e7a1003d76b3640c51d243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68920b89d7ab929fc78d2013ef419bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_timer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a68920b89d7ab929fc78d2013ef419bbe">getTimer</a> (void)</td></tr>
<tr class="separator:a68920b89d7ab929fc78d2013ef419bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50170e8b31bd91edd07b36c3fb6678f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a50170e8b31bd91edd07b36c3fb6678f7">getUavBufferAlignment</a> (void) const</td></tr>
<tr class="separator:a50170e8b31bd91edd07b36c3fb6678f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94298022c4ca57ca88a9440c223af4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#ae94298022c4ca57ca88a9440c223af4c">getUavBufferMaxSize</a> (void) const</td></tr>
<tr class="separator:ae94298022c4ca57ca88a9440c223af4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ef161fc8e37d2217cd10c849005a16"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a82ef161fc8e37d2217cd10c849005a16">isFrameFinished</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> frameCount)</td></tr>
<tr class="memdesc:a82ef161fc8e37d2217cd10c849005a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_vao_manager.html#a48589a1d12b10aa89082ebca7a9c524d" title="If this returns true, then waitForSpecificFrameToFinish is guaranteed to return immediately.">VaoManager::isFrameFinished</a>.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#a82ef161fc8e37d2217cd10c849005a16">More...</a><br /></td></tr>
<tr class="separator:a82ef161fc8e37d2217cd10c849005a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bef9b46aa4eb7100cab724b4b0811a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a62bef9b46aa4eb7100cab724b4b0811a">readOnlyIsTexBuffer</a> (void) const</td></tr>
<tr class="memdesc:a62bef9b46aa4eb7100cab724b4b0811a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When true, <a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> behaves like <a class="el" href="class_ogre_1_1_tex_buffer_packed.html" title="Represents Texture buffers (also known as tbuffers in D3D11)">TexBufferPacked</a>, i.e.  <a href="class_ogre_1_1_vao_manager.html#a62bef9b46aa4eb7100cab724b4b0811a">More...</a><br /></td></tr>
<tr class="separator:a62bef9b46aa4eb7100cab724b4b0811a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445b8e5486e061745af43d1831f60eb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a445b8e5486e061745af43d1831f60eb6">setDefaultStagingBufferlifetime</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> lifetime, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> unfencedTime)</td></tr>
<tr class="memdesc:a445b8e5486e061745af43d1831f60eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default time for staging buffers.  <a href="class_ogre_1_1_vao_manager.html#a445b8e5486e061745af43d1831f60eb6">More...</a><br /></td></tr>
<tr class="separator:a445b8e5486e061745af43d1831f60eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc4d558e3a0893cb21661c05f74b463"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#aadc4d558e3a0893cb21661c05f74b463">supportsArbBufferStorage</a> (void) const</td></tr>
<tr class="separator:aadc4d558e3a0893cb21661c05f74b463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9d6f2ebaa70d64fc171dd886ae218d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a7d9d6f2ebaa70d64fc171dd886ae218d">supportsBaseInstance</a> (void) const</td></tr>
<tr class="separator:a7d9d6f2ebaa70d64fc171dd886ae218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce1736c1c28af8657aaf863d366240f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#afce1736c1c28af8657aaf863d366240f">supportsIndirectBuffers</a> (void) const</td></tr>
<tr class="memdesc:afce1736c1c28af8657aaf863d366240f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When false, <a class="el" href="class_ogre_1_1_indirect_buffer_packed.html" title="Represents Indirect buffers for storing draw call commands.">IndirectBufferPacked</a> will emulate the mapping behavior, and we need to use the emulated calls in <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>.  <a href="class_ogre_1_1_vao_manager.html#afce1736c1c28af8657aaf863d366240f">More...</a><br /></td></tr>
<tr class="separator:afce1736c1c28af8657aaf863d366240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1945aa252817231abb52b12d4d5399a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a1945aa252817231abb52b12d4d5399a3">supportsPersistentMapping</a> (void) const</td></tr>
<tr class="separator:a1945aa252817231abb52b12d4d5399a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cfc17aa6d593fa1c6ef272e2ee9ad9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a00cfc17aa6d593fa1c6ef272e2ee9ad9">waitForSpecificFrameToFinish</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> frameCount)</td></tr>
<tr class="memdesc:a00cfc17aa6d593fa1c6ef272e2ee9ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_vao_manager.html#af029f21d9a83ae3024e36695a3f554f7" title="Waits for a specific frame to be ready.">VaoManager::waitForSpecificFrameToFinish</a>.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#a00cfc17aa6d593fa1c6ef272e2ee9ad9">More...</a><br /></td></tr>
<tr class="separator:a00cfc17aa6d593fa1c6ef272e2ee9ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0260436ff6254a7f977f308148fa964"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#ad0260436ff6254a7f977f308148fa964">waitForTailFrameToFinish</a> (void)</td></tr>
<tr class="memdesc:ad0260436ff6254a7f977f308148fa964"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_ogre_1_1_vao_manager.html#a1b746e3cfc05da2d1fded8949f27b0e4" title="Returns the current frame # (which wraps to 0 every mDynamicBufferMultiplier times).">VaoManager::waitForTailFrameToFinish</a>.  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#ad0260436ff6254a7f977f308148fa964">More...</a><br /></td></tr>
<tr class="separator:ad0260436ff6254a7f977f308148fa964"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a222d4e40df5eb53ab0b050e37aca7b89"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vao_manager.html#a222d4e40df5eb53ab0b050e37aca7b89">calculateVertexSize</a> (const <a class="el" href="namespace_ogre.html#a03b06afe794fcbba8e2d2172892a80f6">VertexElement2Vec</a> &amp;vertexElements)</td></tr>
<tr class="memdesc:a222d4e40df5eb53ab0b050e37aca7b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a single vertex buffer source with the given declaration, in bytes.  <a href="class_ogre_1_1_vao_manager.html#a222d4e40df5eb53ab0b050e37aca7b89">More...</a><br /></td></tr>
<tr class="separator:a222d4e40df5eb53ab0b050e37aca7b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdfac5014aab294b0c75ae452919bbd"><td class="memItemLeft" align="right" valign="top">static GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a2cdfac5014aab294b0c75ae452919bbd">getAttributeIndexFor</a> (<a class="el" href="namespace_ogre.html#a0a62b3f2ede8992ff365bb013a8bc00d">VertexElementSemantic</a> semantic)</td></tr>
<tr class="separator:a2cdfac5014aab294b0c75ae452919bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb5d4187c15479363e1cf47a7b21844"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#addb5d4187c15479363e1cf47a7b21844">mergeContiguousBlocks</a> (BlockVec::iterator blockToMerge, <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#acf63571a368c427ffdcfb1897ec5f041">BlockVec</a> &amp;blocks)</td></tr>
<tr class="separator:addb5d4187c15479363e1cf47a7b21844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9232ad54fd466bddf3d3983c50da76"><td class="memItemLeft" align="right" valign="top">static GLsync&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a7b9232ad54fd466bddf3d3983c50da76">waitFor</a> (GLsync fenceName)</td></tr>
<tr class="memdesc:a7b9232ad54fd466bddf3d3983c50da76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will stall undefinitely until GPU finishes (signals the sync object).  <a href="class_ogre_1_1_g_l3_plus_vao_manager.html#a7b9232ad54fd466bddf3d3983c50da76">More...</a><br /></td></tr>
<tr class="separator:a7b9232ad54fd466bddf3d3983c50da76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acf63571a368c427ffdcfb1897ec5f041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf63571a368c427ffdcfb1897ec5f041">&#9670;&nbsp;</a></span>BlockVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="struct_ogre_1_1_g_l3_plus_vao_manager_1_1_block.html">Block</a>&gt;::type <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#acf63571a368c427ffdcfb1897ec5f041">Ogre::GL3PlusVaoManager::BlockVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a984ae987b00e95b35198131a4e9a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a984ae987b00e95b35198131a4e9a6b">&#9670;&nbsp;</a></span>MemoryStatsEntryVec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="struct_ogre_1_1_vao_manager_1_1_memory_stats_entry.html">MemoryStatsEntry</a>&gt;::type <a class="el" href="class_ogre_1_1_vao_manager.html#a8a984ae987b00e95b35198131a4e9a6b">Ogre::VaoManager::MemoryStatsEntryVec</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79c5a9e410625780fcc610f3243be960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c5a9e410625780fcc610f3243be960">&#9670;&nbsp;</a></span>StrideChangerVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="struct_ogre_1_1_g_l3_plus_vao_manager_1_1_stride_changer.html">StrideChanger</a>&gt;::type <a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#a79c5a9e410625780fcc610f3243be960">Ogre::GL3PlusVaoManager::StrideChangerVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4ceaf6e928e2079f263dab39e7d8d6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceaf6e928e2079f263dab39e7d8d6a6">&#9670;&nbsp;</a></span>GL3PlusVaoManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::GL3PlusVaoManager::GL3PlusVaoManager </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supportsArbBufferStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emulateTexBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supportsIndirectBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_supportsBaseInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supportsSsbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___general.html#ga442a408f658c0cbfbe3e404e91a0fcc5">NameValuePairList</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add095b8663546d8520f8cc9c0d92c90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add095b8663546d8520f8cc9c0d92c90c">&#9670;&nbsp;</a></span>~GL3PlusVaoManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::GL3PlusVaoManager::~GL3PlusVaoManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad255ed9aad893f120f6a29e172052ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad255ed9aad893f120f6a29e172052ccd">&#9670;&nbsp;</a></span>_beginFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VaoManager::_beginFrame </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_vao_manager.html#a67f9ba423c008c11341ad9b1bb3921dc">Ogre::D3D11VaoManager</a>.</p>

</div>
</div>
<a id="a4c2c223f495c035085ffa2b7323bce82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2c223f495c035085ffa2b7323bce82">&#9670;&nbsp;</a></span>_getDynamicBufferCurrentFrameNoWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::VaoManager::_getDynamicBufferCurrentFrameNoWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a374058250675bac30bfb5b03c26b5eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374058250675bac30bfb5b03c26b5eb7">&#9670;&nbsp;</a></span>_notifyStagingBufferEnteredZeroRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::_notifyStagingBufferEnteredZeroRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td>
          <td class="paramname"><em>stagingBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2545e4ce03ff536e3d505e4669cc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2545e4ce03ff536e3d505e4669cc91">&#9670;&nbsp;</a></span>_notifyStagingBufferLeftZeroRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::_notifyStagingBufferLeftZeroRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td>
          <td class="paramname"><em>stagingBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a803fbce3bc62ad1bc5a0632bf69da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a803fbce3bc62ad1bc5a0632bf69da7">&#9670;&nbsp;</a></span>_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusVaoManager::_update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_vao_manager.html#aeef5f194f9a38bfb4aedc768f0cd87f3">Ogre::VaoManager</a>.</p>

</div>
</div>
<a id="ae7f85d710473526ee0985c4def94dcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f85d710473526ee0985c4def94dcb5">&#9670;&nbsp;</a></span>bindDrawId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::GL3PlusVaoManager::bindDrawId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the Draw ID to the currently bound vertex array object. </p>

</div>
</div>
<a id="a222d4e40df5eb53ab0b050e37aca7b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222d4e40df5eb53ab0b050e37aca7b89">&#9670;&nbsp;</a></span>calculateVertexSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::calculateVertexSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a03b06afe794fcbba8e2d2172892a80f6">VertexElement2Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of a single vertex buffer source with the given declaration, in bytes. </p>

</div>
</div>
<a id="acfe2479c58ace6ff748d17cc0f65091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2479c58ace6ff748d17cc0f65091d">&#9670;&nbsp;</a></span>cleanupEmptyPools()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusVaoManager::cleanupEmptyPools </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees GPU memory if there are empty, unused pools. </p>

<p>Implements <a class="el" href="class_ogre_1_1_vao_manager.html#a53583222c18f1e56eccf4adbffe0eb53">Ogre::VaoManager</a>.</p>

</div>
</div>
<a id="a530db71d0308ab9ad62b1243be3196ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530db71d0308ab9ad62b1243be3196ff">&#9670;&nbsp;</a></span>createAsyncTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aef9bfd2a5567613e99bc8d7eae1c1bf9">AsyncTicketPtr</a> Ogre::GL3PlusVaoManager::createAsyncTicket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a> *&#160;</td>
          <td class="paramname"><em>stagingBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_ogre_1_1_vao_manager.html#a0b7cb641e18e9489cfa9bf868fd30985">Ogre::VaoManager</a>.</p>

</div>
</div>
<a id="a952ab60d93451fc2ea18e14bbc31c309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952ab60d93451fc2ea18e14bbc31c309">&#9670;&nbsp;</a></span>createConstBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a>* Ogre::VaoManager::createConstBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an constant buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. (depends on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>, on D3D11 we're forced to give its own buffer) </p><dl class="section remark"><dt>Remarks</dt><dd>@See createVertexBuffer for the remaining parameters not documented here. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the given constant buffer. API restrictions may apply. To stay safe keep it multiple of 16, don't request more than 64kb per buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired const buffer pointer </dd></dl>

</div>
</div>
<a id="a0f791867304e682175612237b3bfd470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f791867304e682175612237b3bfd470">&#9670;&nbsp;</a></span>createIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a>* Ogre::VaoManager::createIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexBufferPacked::IndexType</a>&#160;</td>
          <td class="paramname"><em>indexType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an index buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. </p><dl class="section remark"><dt>Remarks</dt><dd>@See createVertexBuffer for the remaining parameters not documented here. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexType</td><td>Whether this Index Buffer should be 16-bit (recommended) or 32-bit </td></tr>
    <tr><td class="paramname">numIndices</td><td>The number of indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired index buffer pointer </dd></dl>

</div>
</div>
<a id="ad5ec74188530974bc3c28f3d1ab2982f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ec74188530974bc3c28f3d1ab2982f">&#9670;&nbsp;</a></span>createIndirectBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_indirect_buffer_packed.html">IndirectBufferPacked</a>* Ogre::VaoManager::createIndirectBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an indirect buffer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>@See createVertexBuffer for the remaining parameters not documented here. </dd></dl>

</div>
</div>
<a id="a167879924fcc223de12f276c61be0c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167879924fcc223de12f276c61be0c88">&#9670;&nbsp;</a></span>createMultiSourceVertexBufferPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_multi_source_vertex_buffer_pool.html">MultiSourceVertexBufferPool</a>* Ogre::VaoManager::createMultiSourceVertexBufferPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#abdf543378d3741e0b20039e582e55a16">VertexElement2VecVec</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexElementsBySource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxNumVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f95d947d7dae2068089fe00a03eb37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f95d947d7dae2068089fe00a03eb37d">&#9670;&nbsp;</a></span>createReadOnlyBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html">ReadOnlyBufferPacked</a>* Ogre::VaoManager::createReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a read-only buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. (depends on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>, on D3D11 we're forced to give its own buffer) </p><dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="class_ogre_1_1_vao_manager.html#a163fd24c8a7f2c33595bb7fe94e97cf3" title="Creates a vertex buffer based on the given parameters.">VaoManager::createVertexBuffer</a> for the remaining parameters not documented here. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pixel format for the texture buffer. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the given constant buffer. API restrictions may apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired read-only buffer pointer </dd></dl>

</div>
</div>
<a id="a4e8851d90bc61865477947731455440b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8851d90bc61865477947731455440b">&#9670;&nbsp;</a></span>createStagingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a>* Ogre::GL3PlusVaoManager::createStagingBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forUpload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new staging buffer and adds it to the pool. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_vao_manager.html#a755b7f61f17c568f32a6708c4d4cb986" title="Retrieves a staging buffer for use.">getStagingBuffer</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The returned buffer starts with a reference count of 1. You should decrease it when you're done using it. </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_vao_manager.html#ae9f1ac357be2baf213594f302d8c90d8">Ogre::VaoManager</a>.</p>

</div>
</div>
<a id="afe72cf8783a9d2438c978550a68366f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe72cf8783a9d2438c978550a68366f5">&#9670;&nbsp;</a></span>createStagingTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_g_l3_plus_staging_texture.html">GL3PlusStagingTexture</a>* Ogre::GL3PlusVaoManager::createStagingTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>formatFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See GL3PlusTextureGpuManager::createStagingTextureImpl. </p>
<p><a class="el" href="class_ogre_1_1_texture_manager.html" title="Class for loading &amp; managing textures.">TextureManager</a> delegates to the <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> because behind the scenes, in GL StagingTextures are just a buffer with CPU access. However we won't track them, so it's the <a class="el" href="class_ogre_1_1_texture_manager.html" title="Class for loading &amp; managing textures.">TextureManager</a>'s job to call destroyStagingTexture before the <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> gets deleted. This case is more of an exception because of D3D11. </p>

</div>
</div>
<a id="a15deceadb9ee88de12fd801464e4b09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15deceadb9ee88de12fd801464e4b09b">&#9670;&nbsp;</a></span>createTexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a>* Ogre::VaoManager::createTexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an constant buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. (depends on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>, on D3D11 we're forced to give its own buffer) </p><dl class="section remark"><dt>Remarks</dt><dd>@See createVertexBuffer for the remaining parameters not documented here. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pixel format for the texture buffer. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the given constant buffer. API restrictions may apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired texture buffer pointer </dd></dl>

</div>
</div>
<a id="a6001313fdecc1491daa683595fdb5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6001313fdecc1491daa683595fdb5018">&#9670;&nbsp;</a></span>createUavBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a>* Ogre::VaoManager::createUavBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>bytesPerElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>bindFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an UAV buffer based on the given parameters. </p>
<p>Behind the scenes, the buffer is actually part of much larger buffer, in order to reduce bindings at runtime. (depends on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>, on D3D11 we're forced to give its own buffer) </p><dl class="section remark"><dt>Remarks</dt><dd>@See createVertexBuffer for the remaining parameters not documented here. There is no BufferType option as the only available one is BT_DEFAULT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the given constant buffer. API restrictions may apply. </td></tr>
    <tr><td class="paramname">bindFlags</td><td>A combination of BufferBindFlags. BB_FLAG_UAV is implicit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired UAV buffer pointer </dd></dl>

</div>
</div>
<a id="a76927e1aaf3cdd9dfddcf4f7bbb0a48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76927e1aaf3cdd9dfddcf4f7bbb0a48a">&#9670;&nbsp;</a></span>createVertexArrayObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_vertex_array_object.html">VertexArrayObject</a>* Ogre::VaoManager::createVertexArrayObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a0a4ccde77034efa918c66e561958949a">VertexBufferPackedVec</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga0ef99399e9e670e7bb69dc373968a666">OperationType</a>&#160;</td>
          <td class="paramname"><em>opType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="struct_ogre_1_1_vertex_array_object.html" title="Vertex array objects (Vaos) are immutable objects that describe a combination of vertex buffers and i...">VertexArrayObject</a> that binds all the vertex buffers with their respective declarations, and the index buffers. </p>
<p>The returned value is immutable and thus cannot be modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffers</td><td>An array of vertex buffers to be bound to the vertex array object. </td></tr>
    <tr><td class="paramname">indexBuffer</td><td>The index buffer to be bound. </td></tr>
    <tr><td class="paramname">opType</td><td>Type of operation. Cannot be changed later. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ogre_1_1_vertex_array_object.html" title="Vertex array objects (Vaos) are immutable objects that describe a combination of vertex buffers and i...">VertexArrayObject</a> that can be rendered. </dd></dl>

</div>
</div>
<a id="a163fd24c8a7f2c33595bb7fe94e97cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163fd24c8a7f2c33595bb7fe94e97cf3">&#9670;&nbsp;</a></span>createVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vertex_buffer_packed.html">VertexBufferPacked</a>* Ogre::VaoManager::createVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a03b06afe794fcbba8e2d2172892a80f6">VertexElement2Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a579e6aa73b3f580b1227a5c80991dbc9">BufferType</a>&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAsShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vertex buffer based on the given parameters. </p>
<p>Behind the scenes, the vertex buffer is part of much larger vertex buffer, in order to reduce bindings at runtime. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexElements</td><td>A list of element bindings for this vertex buffer. Once created, changing VertexElements is not possible, you'll have to create another Vertex Buffer. </td></tr>
    <tr><td class="paramname">numVertices</td><td>The number of vertices for this vertex </td></tr>
    <tr><td class="paramname">bufferType</td><td>The type of buffer for this vertex buffer. @See BufferType::BT_DYNAMIC special case. </td></tr>
    <tr><td class="paramname">initialData</td><td>Initial data the buffer will hold upon creation. Can be null (i.e. you plan to upload later). Cannot be null when bufferType is BT_IMMUTABLE. Must have enough room to prevent an overflow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_buffer_packed.html#a50d8ee96245a8ac3dd7066eebf1f202d" title="Generic constructor.">BufferPacked::BufferPacked</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepAsShadow</td><td>Whether to keep the pointer "initialData" as a shadow copy of the contents. @See <a class="el" href="class_ogre_1_1_buffer_packed.html#a50d8ee96245a8ac3dd7066eebf1f202d" title="Generic constructor.">BufferPacked::BufferPacked</a> regarding on who is responsible for freeing this pointer and what happens if an exception was raised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired vertex buffer pointer </dd></dl>

</div>
</div>
<a id="a204c8055903cea82fe38e6a9fbc62f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204c8055903cea82fe38e6a9fbc62f6d">&#9670;&nbsp;</a></span>deleteStagingBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::deleteStagingBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51f5147151805c3d294ae200683d76bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f5147151805c3d294ae200683d76bb">&#9670;&nbsp;</a></span>destroyConstBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyConstBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>constBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the given constant buffer created with createConstBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constBuffer</td><td>Constant Buffer created with createConstBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04c53b84b4c6ba27fdcbf57a08d4b044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c53b84b4c6ba27fdcbf57a08d4b044">&#9670;&nbsp;</a></span>destroyIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_index_buffer_packed.html">IndexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>indexBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the given index buffer created with createIndexBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexBuffer</td><td>Index Buffer created with createIndexBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e7e88128e2496523ab0ca8e35634879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7e88128e2496523ab0ca8e35634879">&#9670;&nbsp;</a></span>destroyIndirectBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyIndirectBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_indirect_buffer_packed.html">IndirectBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>indirectBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the given indirect buffer created with createIndirectBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indirectBuffer</td><td>Indirect Buffer created with createIndirectBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a703bff2ff022184c4f40da6ecb9a19ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703bff2ff022184c4f40da6ecb9a19ee">&#9670;&nbsp;</a></span>destroyReadOnlyBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html">ReadOnlyBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>readOnlyBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the given texture buffer created with createReadOnlyBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readOnlyBuffer</td><td><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> created with createReadOnlyBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa79c19ee474881cbf8f49600395c27ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79c19ee474881cbf8f49600395c27ca">&#9670;&nbsp;</a></span>destroyStagingTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::GL3PlusVaoManager::destroyStagingTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_g_l3_plus_staging_texture.html">GL3PlusStagingTexture</a> *&#160;</td>
          <td class="paramname"><em>stagingTexture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Important: Does not delete the stagingTexture. </p>
<p>The <a class="el" href="class_ogre_1_1_texture_manager.html" title="Class for loading &amp; managing textures.">TextureManager</a> should do that. Caller is also responsible for ensuring it is safe to destroy stagingTexture (i.e. no hazards). </p>

</div>
</div>
<a id="a6241229a8f3c895dcd49e7d0e8dfe545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6241229a8f3c895dcd49e7d0e8dfe545">&#9670;&nbsp;</a></span>destroyTexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyTexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>texBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the given texture buffer created with createTexBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constBuffer</td><td><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> Buffer created with createTexBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f235ad527a20a7c20b9daae8dc18ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f235ad527a20a7c20b9daae8dc18ff7">&#9670;&nbsp;</a></span>destroyUavBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyUavBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>uavBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the given UAV buffer created with createUavBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constBuffer</td><td>Uav Buffer created with createUavBuffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d56b87f51c489bdc2df07d1ce040512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d56b87f51c489bdc2df07d1ce040512">&#9670;&nbsp;</a></span>destroyVertexArrayObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyVertexArrayObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_vertex_array_object.html">VertexArrayObject</a> *&#160;</td>
          <td class="paramname"><em>vao</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the input pointer. </p>
<p>After this call, it's no longer valid </p><dl class="section remark"><dt>Remarks</dt><dd>API memory may or may not be released since VertexArrayObjects may internally share the same API constructs. </dd></dl>
<dl class="section user"><dt></dt><dd>The vertex &amp; index buffers associated with this vao are not destroyed by this function. </dd></dl>

</div>
</div>
<a id="a1dce3c8cb8c7d08ff77e6c4776fed1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dce3c8cb8c7d08ff77e6c4776fed1f4">&#9670;&nbsp;</a></span>destroyVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::destroyVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vertex_buffer_packed.html">VertexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the given vertex buffer created with createVertexBuffer. </p>
<p>NOTE: Vertex Buffers created by a <a class="el" href="class_ogre_1_1_multi_source_vertex_buffer_pool.html" title="Vertex Array Objects do not need to change when: The same (internal) vertex buffer is still bound.">MultiSourceVertexBufferPool</a> must be freed by the pool that created it, don't use this function for those. </p><dl class="section remark"><dt>Remarks</dt><dd>Performs an O(N) lookup. Where N is the number of created vertex buffers </dd></dl>

</div>
</div>
<a id="a2cdfac5014aab294b0c75ae452919bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdfac5014aab294b0c75ae452919bbd">&#9670;&nbsp;</a></span>getAttributeIndexFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GLuint Ogre::GL3PlusVaoManager::getAttributeIndexFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a0a62b3f2ede8992ff365bb013a8bc00d">VertexElementSemantic</a>&#160;</td>
          <td class="paramname"><em>semantic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a00e866aebffe5114767ce1fc81bea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a00e866aebffe5114767ce1fc81bea8">&#9670;&nbsp;</a></span>getConstBufferAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getConstBufferAlignment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6613f84365a386b9a50fed61a96cfc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6613f84365a386b9a50fed61a96cfc7a">&#9670;&nbsp;</a></span>getConstBufferMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VaoManager::getConstBufferMaxSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb22409286339939dc6d49e44a8f3683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb22409286339939dc6d49e44a8f3683">&#9670;&nbsp;</a></span>getDefaultStagingBufferLifetime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getDefaultStagingBufferLifetime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5388b5890025a724a42f4469363bb267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5388b5890025a724a42f4469363bb267">&#9670;&nbsp;</a></span>getDefaultStagingBufferUnfencedTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getDefaultStagingBufferUnfencedTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b609165fb053afe550711546254e230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b609165fb053afe550711546254e230">&#9670;&nbsp;</a></span>getDynamicBufferMultiplier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::VaoManager::getDynamicBufferMultiplier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab528ecee92f02772be5dc8329c0e1e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab528ecee92f02772be5dc8329c0e1e1b">&#9670;&nbsp;</a></span>getFrameCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getFrameCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5140b54e5640aa8b8b931a6c14d1e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5140b54e5640aa8b8b931a6c14d1e4c2">&#9670;&nbsp;</a></span>getMaxVertexAttribs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLint Ogre::GL3PlusVaoManager::getMaxVertexAttribs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70811386532e1aa7ad5600165a4013a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70811386532e1aa7ad5600165a4013a6">&#9670;&nbsp;</a></span>getMemoryStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusVaoManager::getMemoryStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html#a8a984ae987b00e95b35198131a4e9a6b">MemoryStatsEntryVec</a> &amp;&#160;</td>
          <td class="paramname"><em>outStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outCapacityBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outFreeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_log.html">Log</a> *&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves memory stats about our GPU pools being managed. </p>
<p>The output in the <a class="el" href="class_ogre_1_1_log.html">Log</a> will be csv data that resembles the following: <a class="el" href="class_ogre_1_1_pool.html" title="Template class describing a simple pool of items.">Pool</a> Type Offset Bytes <a class="el" href="class_ogre_1_1_pool.html" title="Template class describing a simple pool of items.">Pool</a> Capacity CPU_INACCESSIBLE 0 148128 67108864 CPU_INACCESSIBLE 200000 1024 67108864 CPU_ACCESSIBLE_PERSISTENT 0 1152 16777216</p>
<p>These are the chunks of memory currently in use. If there are multiple entries belonging to the same pool, that means the memory has been fragmented.</p>
<p>The actual output may vary depending on the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. </p><dl class="section remark"><dt>Remarks</dt><dd>Worst case scenario this function has O(N^2) complexity where N is the number of free blocks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStats</td><td>Detailed information about each entry. </td></tr>
    <tr><td class="paramname">outCapacityBytes</td><td>Total capacity i.e. total used VRAM in GPU. </td></tr>
    <tr><td class="paramname">outFreeBytes</td><td>Total free memory available for consumption. </td></tr>
    <tr><td class="paramname">log</td><td>Optional to dump all information to a CSV file. Nullptr to avoid dumping. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_vao_manager.html#ab35499fd8188bd81807454a5c8de836c">Ogre::VaoManager</a>.</p>

</div>
</div>
<a id="ae8ea50dfdfc83e13bae02da290647884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ea50dfdfc83e13bae02da290647884">&#9670;&nbsp;</a></span>getReadOnlyBufferMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VaoManager::getReadOnlyBufferMaxSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a755b7f61f17c568f32a6708c4d4cb986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755b7f61f17c568f32a6708c4d4cb986">&#9670;&nbsp;</a></span>getStagingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_staging_buffer.html">StagingBuffer</a>* Ogre::VaoManager::getStagingBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forUpload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a staging buffer for use. </p>
<p>We'll search for existing ones that can hold minSizeBytes. We first prioritize those that won't cause a stall at all. Then those that will cause a partial stall, and otherwise return one that will cause full stall. If we can't find any existing buffer that can hold the requested number bytes, we'll create a new one. </p><dl class="section remark"><dt>Remarks</dt><dd>Calling this function causes the reference count of the returned pointer to be increased. You should decrease the reference count after you're done with the returned pointer. @See <a class="el" href="class_ogre_1_1_staging_buffer.html#a29313389dacd812a8d238df458f9e979" title="Decreases the reference count by one.">StagingBuffer::removeReferenceCount</a> regarding ref. counting. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeBytes</td><td>Minimum size, in bytes, of the staging buffer. The returned buffer may be bigger. </td></tr>
    <tr><td class="paramname">forUpload</td><td>True if it should be used to upload data to GPU, false to download. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The staging buffer. </dd></dl>

</div>
</div>
<a id="a6c4856f0420c296824372ce64825cbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4856f0420c296824372ce64825cbfd">&#9670;&nbsp;</a></span>getTexBufferAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getTexBufferAlignment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d0feae113e7a1003d76b3640c51d243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0feae113e7a1003d76b3640c51d243">&#9670;&nbsp;</a></span>getTexBufferMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VaoManager::getTexBufferMaxSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68920b89d7ab929fc78d2013ef419bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68920b89d7ab929fc78d2013ef419bbe">&#9670;&nbsp;</a></span>getTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_timer.html">Timer</a>* Ogre::VaoManager::getTimer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50170e8b31bd91edd07b36c3fb6678f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50170e8b31bd91edd07b36c3fb6678f7">&#9670;&nbsp;</a></span>getUavBufferAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::VaoManager::getUavBufferAlignment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae94298022c4ca57ca88a9440c223af4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94298022c4ca57ca88a9440c223af4c">&#9670;&nbsp;</a></span>getUavBufferMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::VaoManager::getUavBufferMaxSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82ef161fc8e37d2217cd10c849005a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ef161fc8e37d2217cd10c849005a16">&#9670;&nbsp;</a></span>isFrameFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::GL3PlusVaoManager::isFrameFinished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>frameCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_vao_manager.html#a48589a1d12b10aa89082ebca7a9c524d" title="If this returns true, then waitForSpecificFrameToFinish is guaranteed to return immediately.">VaoManager::isFrameFinished</a>. </p>

<p>Implements <a class="el" href="class_ogre_1_1_vao_manager.html#a48589a1d12b10aa89082ebca7a9c524d">Ogre::VaoManager</a>.</p>

</div>
</div>
<a id="addb5d4187c15479363e1cf47a7b21844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb5d4187c15479363e1cf47a7b21844">&#9670;&nbsp;</a></span>mergeContiguousBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::GL3PlusVaoManager::mergeContiguousBlocks </td>
          <td>(</td>
          <td class="paramtype">BlockVec::iterator&#160;</td>
          <td class="paramname"><em>blockToMerge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html#acf63571a368c427ffdcfb1897ec5f041">BlockVec</a> &amp;&#160;</td>
          <td class="paramname"><em>blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>StagingBuffer::mergeContiguousBlocks </dd></dl>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bdf968b7b9af8a5239a27da73d5711">&#9670;&nbsp;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421b197ca3a38da17e2eb1531a645fa2">&#9670;&nbsp;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="ab78a921e54419be677839cdf15d1f0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78a921e54419be677839cdf15d1f0b8">&#9670;&nbsp;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="afa2943846ba6a2b5824a12857139cf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2943846ba6a2b5824a12857139cf5e">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4be37baef81876985aa1071ad5acc6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be37baef81876985aa1071ad5acc6dd">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="a62bef9b46aa4eb7100cab724b4b0811a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bef9b46aa4eb7100cab724b4b0811a">&#9670;&nbsp;</a></span>readOnlyIsTexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VaoManager::readOnlyIsTexBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When true, <a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> behaves like <a class="el" href="class_ogre_1_1_tex_buffer_packed.html" title="Represents Texture buffers (also known as tbuffers in D3D11)">TexBufferPacked</a>, i.e. </p>
<p>assigned to texture buffer slots.</p>
<p>When false, <a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> behaves like <a class="el" href="class_ogre_1_1_uav_buffer_packed.html" title="Represents UAV buffers (also known as SSBOs in OpenGL) Uav buffers are supported in DX10/DX10....">UavBufferPacked</a> i.e. assigned to UAV buffer slots. Except D3D11, which still uses texture buffer slots when false but chooses StructuredBuffer over Buffer </p>

</div>
</div>
<a id="a445b8e5486e061745af43d1831f60eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445b8e5486e061745af43d1831f60eb6">&#9670;&nbsp;</a></span>setDefaultStagingBufferlifetime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VaoManager::setDefaultStagingBufferlifetime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>lifetime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>unfencedTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default time for staging buffers. </p>
<p>Staging buffers are recycled/reused. When their reference count reaches 0, this <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> will begin to track how long since the last time they've reached ref count 0. When the time threshold is met, the staging buffer gets removed. </p><dl class="section remark"><dt>Remarks</dt><dd>See getStagingBuffer </dd></dl>
<dl class="section user"><dt></dt><dd>Small explanation on <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> lifetime management (so you can make sense on what we're doing here):</dd></dl>
<p>StagingBuffers may produce "pops" when created (due to API/driver stalls) so we reuse them. We keep track of how long StagingBuffers have been remained unused, and delete old ones. The intention is to be able to recycle old buffers, while getting rid of the excess if a sudden spike happened. That's what the lifetime threshold controls.</p>
<p>We also have the "unfenced threshold". This controls something very different. StagingBuffers usages need fences to check whether we're done using the buffer. But we don't issue a fence every time you do something with them, because that could result in a lot of fences (i.e. imagine you do a 1000 uploads of 16 bytes each, in succession, we shouldn't do 1000 fences); so we fence when certain upload/download thresholds are met (i.e. you've uploaded 1MB of data). So if you've uploaded 750kb so far, no fence will be issued. But if you upload 300kb more, we will fence. But what happens if you've only uploaded 750kb and then nothing more for the last 10 minutes? Since we haven't fenced, and now you need to upload a lot more, we don't know if those 750kb are done uploading because we never fenced it. It probably ended 10 minutes ago, but we won't know. We would have to fence now and perform a full stall waiting for that fence. To solve this edge case, we fence whenever X time has elapsed without fencing (and only if there's data that remains unfenced of course). That's what the unfenced threshold is for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lifetime</td><td>Time in milliseconds. The default is 5 minutes. A staging buffer that remained at zero ref. count for lifetime milliseconds will be destroyed. </td></tr>
    <tr><td class="paramname">unfencedTime</td><td>For efficiency reasons (API overhead), some staging buffers implementations will not track all hazards on fences. A staging buffer that remained at zero ref. count for unfencedTime milliseconds will be told to clean their hazards, creating the missing appropiate fences. unfencedTime can't be higher than lifetime. unfencedTime should not be too far away from lifetime, and not too soon either, to maximize the chances of no stalls when we finally destroy it and avoid excessive API overhead in keeping fences alive. The default is 4 minutes 59 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadc4d558e3a0893cb21661c05f74b463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc4d558e3a0893cb21661c05f74b463">&#9670;&nbsp;</a></span>supportsArbBufferStorage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::GL3PlusVaoManager::supportsArbBufferStorage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d9d6f2ebaa70d64fc171dd886ae218d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9d6f2ebaa70d64fc171dd886ae218d">&#9670;&nbsp;</a></span>supportsBaseInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VaoManager::supportsBaseInstance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afce1736c1c28af8657aaf863d366240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce1736c1c28af8657aaf863d366240f">&#9670;&nbsp;</a></span>supportsIndirectBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VaoManager::supportsIndirectBuffers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When false, <a class="el" href="class_ogre_1_1_indirect_buffer_packed.html" title="Represents Indirect buffers for storing draw call commands.">IndirectBufferPacked</a> will emulate the mapping behavior, and we need to use the emulated calls in <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. </p>

</div>
</div>
<a id="a1945aa252817231abb52b12d4d5399a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1945aa252817231abb52b12d4d5399a3">&#9670;&nbsp;</a></span>supportsPersistentMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::VaoManager::supportsPersistentMapping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b9232ad54fd466bddf3d3983c50da76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9232ad54fd466bddf3d3983c50da76">&#9670;&nbsp;</a></span>waitFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GLsync Ogre::GL3PlusVaoManager::waitFor </td>
          <td>(</td>
          <td class="paramtype">GLsync&#160;</td>
          <td class="paramname"><em>fenceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will stall undefinitely until GPU finishes (signals the sync object). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fenceName</td><td>Sync object to wait for. Will be deleted on success. On failure, throws an exception and fenceName will not be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null ptr on success. Should throw on failure, but if this function for some strange reason doesn't throw, it is programmed to return 'fenceName' </dd></dl>

</div>
</div>
<a id="a00cfc17aa6d593fa1c6ef272e2ee9ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cfc17aa6d593fa1c6ef272e2ee9ad9">&#9670;&nbsp;</a></span>waitForSpecificFrameToFinish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::GL3PlusVaoManager::waitForSpecificFrameToFinish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>frameCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_vao_manager.html#af029f21d9a83ae3024e36695a3f554f7" title="Waits for a specific frame to be ready.">VaoManager::waitForSpecificFrameToFinish</a>. </p>

<p>Implements <a class="el" href="class_ogre_1_1_vao_manager.html#af029f21d9a83ae3024e36695a3f554f7">Ogre::VaoManager</a>.</p>

</div>
</div>
<a id="ad0260436ff6254a7f977f308148fa964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0260436ff6254a7f977f308148fa964">&#9670;&nbsp;</a></span>waitForTailFrameToFinish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::GL3PlusVaoManager::waitForTailFrameToFinish </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_ogre_1_1_vao_manager.html#a1b746e3cfc05da2d1fded8949f27b0e4" title="Returns the current frame # (which wraps to 0 every mDynamicBufferMultiplier times).">VaoManager::waitForTailFrameToFinish</a>. </p>

<p>Implements <a class="el" href="class_ogre_1_1_vao_manager.html#a1b746e3cfc05da2d1fded8949f27b0e4">Ogre::VaoManager</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_g_l3_plus_vao_manager_8h.html">OgreGL3PlusVaoManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_g_l3_plus_vao_manager.html">GL3PlusVaoManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
