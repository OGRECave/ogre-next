<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::VulkanTextureGpu Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.3</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_vulkan_texture_gpu.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1_vulkan_texture_gpu-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::VulkanTextureGpu Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreVulkanTextureGpu.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::VulkanTextureGpu:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_vulkan_texture_gpu__inherit__graph.svg" width="352" height="426"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a167b312bc2c967169dcf31643eb621f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a167b312bc2c967169dcf31643eb621f2">VulkanTextureGpu</a> (<a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, <a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *textureManager)</td></tr>
<tr class="separator:a167b312bc2c967169dcf31643eb621f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9bc54b12f379d3beb5ed6f61b750cf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a4d9bc54b12f379d3beb5ed6f61b750cf">~VulkanTextureGpu</a> ()</td></tr>
<tr class="separator:a4d9bc54b12f379d3beb5ed6f61b750cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad623ee0c97e95e276074d3cfd64c374c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#ad623ee0c97e95e276074d3cfd64c374c">_addPendingResidencyChanges</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> value)</td></tr>
<tr class="separator:ad623ee0c97e95e276074d3cfd64c374c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7688bdd3bad5ad0f08bc5024e6431c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a2e7688bdd3bad5ad0f08bc5024e6431c">_autogenerateMipmaps</a> (<a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a> transitionMode=<a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a>)</td></tr>
<tr class="memdesc:a2e7688bdd3bad5ad0f08bc5024e6431c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the API to let the HW autogenerate mipmaps.  <a href="class_ogre_1_1_vulkan_texture_gpu.html#a2e7688bdd3bad5ad0f08bc5024e6431c">More...</a><br /></td></tr>
<tr class="separator:a2e7688bdd3bad5ad0f08bc5024e6431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335f8053b320bab94073cd0359da9f15"><td class="memItemLeft" align="right" valign="top">VkImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a335f8053b320bab94073cd0359da9f15">_createView</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> mipLevel, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> numMipmaps, <a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a> arraySlice, bool cubemapsAs2DArrays, bool forUav, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> numSlices=0u, VkImage imageOverride=0) const</td></tr>
<tr class="separator:a335f8053b320bab94073cd0359da9f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7828b4d590c12aa357cf23938a69373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ac7828b4d590c12aa357cf23938a69373">_getSysRamCopy</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> mipLevel)</td></tr>
<tr class="separator:ac7828b4d590c12aa357cf23938a69373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e1fcc0e8d7a092a55c79ace4564a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a47e1fcc0e8d7a092a55c79ace4564a4a">_getSysRamCopyAsBox</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> mipLevel)</td></tr>
<tr class="separator:a47e1fcc0e8d7a092a55c79ace4564a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7046d90f92e6a950d6d803892ee4b09"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af7046d90f92e6a950d6d803892ee4b09">_getSysRamCopyBytesPerImage</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> mipLevel)</td></tr>
<tr class="memdesc:af7046d90f92e6a950d6d803892ee4b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: Returns non-zero even if there is no system ram copy.  <a href="class_ogre_1_1_texture_gpu.html#af7046d90f92e6a950d6d803892ee4b09">More...</a><br /></td></tr>
<tr class="separator:af7046d90f92e6a950d6d803892ee4b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6061da5422410802a10d2e97e9ab46f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a6061da5422410802a10d2e97e9ab46f0">_getSysRamCopyBytesPerRow</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> mipLevel)</td></tr>
<tr class="memdesc:a6061da5422410802a10d2e97e9ab46f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: Returns non-zero even if there is no system ram copy.  <a href="class_ogre_1_1_texture_gpu.html#a6061da5422410802a10d2e97e9ab46f0">More...</a><br /></td></tr>
<tr class="separator:a6061da5422410802a10d2e97e9ab46f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ec1d9dcbea3a1937c7b0d000fd47e6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a44ec1d9dcbea3a1937c7b0d000fd47e6">_isDataReadyImpl</a> (void) const</td></tr>
<tr class="memdesc:a44ec1d9dcbea3a1937c7b0d000fd47e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <a href="class_ogre_1_1_vulkan_texture_gpu.html#a44ec1d9dcbea3a1937c7b0d000fd47e6">More...</a><br /></td></tr>
<tr class="separator:a44ec1d9dcbea3a1937c7b0d000fd47e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b879c519f45ccb57f91bc45a221f3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad3b879c519f45ccb57f91bc45a221f3e">_isManualTextureFlagPresent</a> (void) const</td></tr>
<tr class="separator:ad3b879c519f45ccb57f91bc45a221f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df37fcb72b47849df985a18828f2e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a0df37fcb72b47849df985a18828f2e97">_notifySysRamDownloadIsReady</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> *sysRamPtr, bool resyncOnly)</td></tr>
<tr class="memdesc:a0df37fcb72b47849df985a18828f2e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not call directly.  <a href="class_ogre_1_1_texture_gpu.html#a0df37fcb72b47849df985a18828f2e97">More...</a><br /></td></tr>
<tr class="separator:a0df37fcb72b47849df985a18828f2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6f481187459e2436a6499d9be5fbc4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a9b6f481187459e2436a6499d9be5fbc4">_notifyTextureSlotChanged</a> (const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *newPool, <a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a> slice)</td></tr>
<tr class="separator:a9b6f481187459e2436a6499d9be5fbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4c74e16ccbdaf8bf82c04a0f7ea2d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aed4c74e16ccbdaf8bf82c04a0f7ea2d6">_resetTextureManager</a> (void)</td></tr>
<tr class="separator:aed4c74e16ccbdaf8bf82c04a0f7ea2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebb419ba824d0128f437bbe20cc81f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aeebb419ba824d0128f437bbe20cc81f9">_resolveTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *resolveTexture)</td></tr>
<tr class="memdesc:aeebb419ba824d0128f437bbe20cc81f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately resolves this texture to the resolveTexture argument.  <a href="class_ogre_1_1_texture_gpu.html#aeebb419ba824d0128f437bbe20cc81f9">More...</a><br /></td></tr>
<tr class="separator:aeebb419ba824d0128f437bbe20cc81f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c626ccabbd6c853ee1490358b9ca490"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4c626ccabbd6c853ee1490358b9ca490">_setDepthBufferDefaults</a> (<a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a> depthBufferPoolId, bool preferDepthTexture, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> desiredDepthBufferFormat)</td></tr>
<tr class="memdesc:a4c626ccabbd6c853ee1490358b9ca490"><td class="mdescLeft">&#160;</td><td class="mdescRight">These 3 values are used as defaults for the compositor to use, but they may be explicitly overriden by a <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a>.  <a href="class_ogre_1_1_texture_gpu.html#a4c626ccabbd6c853ee1490358b9ca490">More...</a><br /></td></tr>
<tr class="separator:a4c626ccabbd6c853ee1490358b9ca490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0259d623d9baa835e8bec9aec09ec417"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a0259d623d9baa835e8bec9aec09ec417">_setNextLayout</a> (<a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> layout)</td></tr>
<tr class="memdesc:a0259d623d9baa835e8bec9aec09ec417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the layout the texture should be transitioned to after the next copy operation (once the copy encoder gets closed)  <a href="class_ogre_1_1_vulkan_texture_gpu.html#a0259d623d9baa835e8bec9aec09ec417">More...</a><br /></td></tr>
<tr class="separator:a0259d623d9baa835e8bec9aec09ec417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ccef279ef9251c5a4b40bfaf7b9e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a56ccef279ef9251c5a4b40bfaf7b9e05">_setNextResidencyStatus</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency)</td></tr>
<tr class="separator:a56ccef279ef9251c5a4b40bfaf7b9e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4044404f7783aea108e986336caaedf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4044404f7783aea108e986336caaedf6">_setSampleDescription</a> (<a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> desc, <a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> validatedSampleDesc)</td></tr>
<tr class="memdesc:a4044404f7783aea108e986336caaedf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use.  <a href="class_ogre_1_1_texture_gpu.html#a4044404f7783aea108e986336caaedf6">More...</a><br /></td></tr>
<tr class="separator:a4044404f7783aea108e986336caaedf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae641939cec4a57193dab3fc88921b7ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae641939cec4a57193dab3fc88921b7ae">_setSourceType</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> type)</td></tr>
<tr class="separator:ae641939cec4a57193dab3fc88921b7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d66e0da4416467fd2ba38a045f04c24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a9d66e0da4416467fd2ba38a045f04c24">_setToDisplayDummyTexture</a> (void)</td></tr>
<tr class="separator:a9d66e0da4416467fd2ba38a045f04c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81e2a8d0caf9096dbab0723bab2b894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa81e2a8d0caf9096dbab0723bab2b894">_syncGpuResidentToSystemRam</a> (void)</td></tr>
<tr class="memdesc:aa81e2a8d0caf9096dbab0723bab2b894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces downloading data from GPU to CPU, usually because the data on GPU changed and we're in strategy AlwaysKeepSystemRamCopy.  <a href="class_ogre_1_1_texture_gpu.html#aa81e2a8d0caf9096dbab0723bab2b894">More...</a><br /></td></tr>
<tr class="separator:aa81e2a8d0caf9096dbab0723bab2b894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f9670da9031ec138caf8b3e910b37e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a85f9670da9031ec138caf8b3e910b37e">_transitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> newResidency, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> *sysRamCopy, bool autoDeleteSysRamCopy=true)</td></tr>
<tr class="memdesc:a85f9670da9031ec138caf8b3e910b37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function may be called manually (if user is manually managing a texture) or automatically (e.g.  <a href="class_ogre_1_1_texture_gpu.html#a85f9670da9031ec138caf8b3e910b37e">More...</a><br /></td></tr>
<tr class="separator:a85f9670da9031ec138caf8b3e910b37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6dd0d57c28fe017e8a83877bea0c5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1b6dd0d57c28fe017e8a83877bea0c5f">addListener</a> (<a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *listener)</td></tr>
<tr class="separator:a1b6dd0d57c28fe017e8a83877bea0c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ea3e542d7ef9c1e223d12b99d24d0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a00ea3e542d7ef9c1e223d12b99d24d0b">allowsAutoMipmaps</a> (void) const</td></tr>
<tr class="separator:a00ea3e542d7ef9c1e223d12b99d24d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b8aace07a416886cc0f871b32f078c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a50b8aace07a416886cc0f871b32f078c">copyContentsToMemory</a> (<a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> src, <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> dst, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> dstFormat, bool automaticResolve=true)</td></tr>
<tr class="memdesc:a50b8aace07a416886cc0f871b32f078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current contents of the render target to the memory.  <a href="class_ogre_1_1_texture_gpu.html#a50b8aace07a416886cc0f871b32f078c">More...</a><br /></td></tr>
<tr class="separator:a50b8aace07a416886cc0f871b32f078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1403e76b6775c08d2cb7b0c7d1398d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1a1403e76b6775c08d2cb7b0c7d1398d">copyParametersFrom</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *src)</td></tr>
<tr class="separator:a1a1403e76b6775c08d2cb7b0c7d1398d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f103b82bfa80046c870fb64b3a18b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a94f103b82bfa80046c870fb64b3a18b5">copyTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *dst, const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;dstBox, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> dstMipLevel, const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;srcBox, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> srcMipLevel, bool keepResolvedTexSynced=true, <a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a> srcTransitionMode=<a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a>, <a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a> dstTransitionMode=<a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a>)</td></tr>
<tr class="separator:a94f103b82bfa80046c870fb64b3a18b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0ceb6e5461235a993f1b6982984133"><td class="memItemLeft" align="right" valign="top">VkImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a0b0ceb6e5461235a993f1b6982984133">createView</a> (const <a class="el" href="struct_ogre_1_1_descriptor_set_texture2_1_1_texture_slot.html">DescriptorSetTexture2::TextureSlot</a> &amp;texSlot, bool bUseCache=true) const</td></tr>
<tr class="separator:a0b0ceb6e5461235a993f1b6982984133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ee652beefe440f678067bcc3e04aaa"><td class="memItemLeft" align="right" valign="top">VkImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#aa9ee652beefe440f678067bcc3e04aaa">createView</a> (<a class="el" href="struct_ogre_1_1_descriptor_set_uav_1_1_texture_slot.html">DescriptorSetUav::TextureSlot</a> texSlot, bool bUseCache=true)</td></tr>
<tr class="separator:aa9ee652beefe440f678067bcc3e04aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c9d08dad106bb9eabfbb589a47d1eb"><td class="memItemLeft" align="right" valign="top">VkImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#af3c9d08dad106bb9eabfbb589a47d1eb">createView</a> (void) const</td></tr>
<tr class="separator:af3c9d08dad106bb9eabfbb589a47d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ae217889a61a5f3db96ab2fdf44851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a84ae217889a61a5f3db96ab2fdf44851">destroyView</a> (<a class="el" href="struct_ogre_1_1_descriptor_set_texture2_1_1_texture_slot.html">DescriptorSetTexture2::TextureSlot</a> texSlot, VkImageView imageView)</td></tr>
<tr class="separator:a84ae217889a61a5f3db96ab2fdf44851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c8efd9d4f9ddbdae952872f81534b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a06c8efd9d4f9ddbdae952872f81534b8">destroyView</a> (<a class="el" href="struct_ogre_1_1_descriptor_set_uav_1_1_texture_slot.html">DescriptorSetUav::TextureSlot</a> texSlot, VkImageView imageView)</td></tr>
<tr class="separator:a06c8efd9d4f9ddbdae952872f81534b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e93138a97ffb507ace65e342a356aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#ae4e93138a97ffb507ace65e342a356aa">destroyView</a> (VkImageView imageView)</td></tr>
<tr class="separator:ae4e93138a97ffb507ace65e342a356aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0253f67a1ff8ee7ec6ee4e98a3a9773a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a0253f67a1ff8ee7ec6ee4e98a3a9773a">getCurrentLayout</a> (void) const</td></tr>
<tr class="separator:a0253f67a1ff8ee7ec6ee4e98a3a9773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecbe86d69c49a223a92070acbd309fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aaecbe86d69c49a223a92070acbd309fc">getCustomAttribute</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, void *pData)</td></tr>
<tr class="separator:aaecbe86d69c49a223a92070acbd309fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624cabb524d4fc589803108d79fea2df"><td class="memItemLeft" align="right" valign="top">VkImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a624cabb524d4fc589803108d79fea2df">getDefaultDisplaySrv</a> (void) const</td></tr>
<tr class="separator:a624cabb524d4fc589803108d79fea2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472f6a92131325af1a8f5ba2b78b86eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a472f6a92131325af1a8f5ba2b78b86eb">getDefaultLayout</a> (bool bIgnoreDiscardableFlag=false) const</td></tr>
<tr class="separator:a472f6a92131325af1a8f5ba2b78b86eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fc34cf0b95593aa41df1370f5da312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a72fc34cf0b95593aa41df1370f5da312">getDepth</a> (void) const</td></tr>
<tr class="memdesc:a72fc34cf0b95593aa41df1370f5da312"><td class="mdescLeft">&#160;</td><td class="mdescRight">For TypeCube &amp; TypeCubeArray, this value returns 1.  <a href="class_ogre_1_1_texture_gpu.html#a72fc34cf0b95593aa41df1370f5da312">More...</a><br /></td></tr>
<tr class="separator:a72fc34cf0b95593aa41df1370f5da312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e5b1428a5fc4fdfaca35292509c716"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad9e5b1428a5fc4fdfaca35292509c716">getDepthBufferPoolId</a> (void) const</td></tr>
<tr class="separator:ad9e5b1428a5fc4fdfaca35292509c716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df44c12f039dfb40a60f6aacc94495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a06df44c12f039dfb40a60f6aacc94495">getDepthOrSlices</a> (void) const</td></tr>
<tr class="separator:a06df44c12f039dfb40a60f6aacc94495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e98f7545f8b2fd4d92dd412fa5ac270"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9e98f7545f8b2fd4d92dd412fa5ac270">getDesiredDepthBufferFormat</a> (void) const</td></tr>
<tr class="separator:a9e98f7545f8b2fd4d92dd412fa5ac270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb2223272d9736f93dd8a255d41b925"><td class="memItemLeft" align="right" valign="top">VkImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#afbb2223272d9736f93dd8a255d41b925">getDisplayTextureName</a> (void) const</td></tr>
<tr class="separator:afbb2223272d9736f93dd8a255d41b925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714b2b71f5443736c7c0ac2a97753c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a714b2b71f5443736c7c0ac2a97753c02">getEmptyBox</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> mipLevel)</td></tr>
<tr class="separator:a714b2b71f5443736c7c0ac2a97753c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ab4a439e06b33cba80b1af7afd01c2"><td class="memItemLeft" align="right" valign="top">VkImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a80ab4a439e06b33cba80b1af7afd01c2">getFinalTextureName</a> (void) const</td></tr>
<tr class="separator:a80ab4a439e06b33cba80b1af7afd01c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51481d31eb97e679497f16452c9732b8"><td class="memItemLeft" align="right" valign="top">VkImageSubresourceRange&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a51481d31eb97e679497f16452c9732b8">getFullSubresourceRange</a> (void) const</td></tr>
<tr class="separator:a51481d31eb97e679497f16452c9732b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4766a70699416dd6dc2a51ad28307a19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a4766a70699416dd6dc2a51ad28307a19">getGpuPageOutStrategy</a> (void) const</td></tr>
<tr class="separator:a4766a70699416dd6dc2a51ad28307a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7556d2e92eb39b9f465d25bd811c5c22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a7556d2e92eb39b9f465d25bd811c5c22">getHeight</a> (void) const</td></tr>
<tr class="separator:a7556d2e92eb39b9f465d25bd811c5c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829c17e22a5acd6ec583c3d2520db784"><td class="memItemLeft" align="right" valign="top">VkImageMemoryBarrier&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a829c17e22a5acd6ec583c3d2520db784">getImageMemoryBarrier</a> (void) const</td></tr>
<tr class="memdesc:a829c17e22a5acd6ec583c3d2520db784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a fresh VkImageMemoryBarrier filled with common data.  <a href="class_ogre_1_1_vulkan_texture_gpu.html#a829c17e22a5acd6ec583c3d2520db784">More...</a><br /></td></tr>
<tr class="separator:a829c17e22a5acd6ec583c3d2520db784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e85ec353d2f79da71c96ad69b4048a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af3e85ec353d2f79da71c96ad69b4048a">getInternalHeight</a> (void) const</td></tr>
<tr class="memdesc:af3e85ec353d2f79da71c96ad69b4048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real API height accounting for <a class="el" href="class_ogre_1_1_texture_gpu.html#ae9039d0b1ef9d873aea7440407b37cb2">TextureGpu::getOrientationMode</a>. See getInternalWidth.  <a href="class_ogre_1_1_texture_gpu.html#af3e85ec353d2f79da71c96ad69b4048a">More...</a><br /></td></tr>
<tr class="separator:af3e85ec353d2f79da71c96ad69b4048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7261ed5e880bbe376162a666d0ebea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ac7261ed5e880bbe376162a666d0ebea3">getInternalSliceStart</a> (void) const</td></tr>
<tr class="separator:ac7261ed5e880bbe376162a666d0ebea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4ea058e8a05f5d1949fe952ad00063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4d4ea058e8a05f5d1949fe952ad00063">getInternalTextureType</a> (void) const</td></tr>
<tr class="separator:a4d4ea058e8a05f5d1949fe952ad00063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb90b45a1ccbcc0e499d2dcfabbaa3a1"><td class="memItemLeft" align="right" valign="top">VkImageViewType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#abb90b45a1ccbcc0e499d2dcfabbaa3a1">getInternalVulkanTextureViewType</a> (void) const</td></tr>
<tr class="separator:abb90b45a1ccbcc0e499d2dcfabbaa3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb35caa0639bfa59b095295a73ab6c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a7bb35caa0639bfa59b095295a73ab6c0">getInternalWidth</a> (void) const</td></tr>
<tr class="memdesc:a7bb35caa0639bfa59b095295a73ab6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real API width accounting for <a class="el" href="class_ogre_1_1_texture_gpu.html#ae9039d0b1ef9d873aea7440407b37cb2">TextureGpu::getOrientationMode</a> If orientation mode is 90° or 270° then getInternalWidth returns the height and getInternalHeight returns the width.  <a href="class_ogre_1_1_texture_gpu.html#a7bb35caa0639bfa59b095295a73ab6c0">More...</a><br /></td></tr>
<tr class="separator:a7bb35caa0639bfa59b095295a73ab6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1321d0a1c2967d76381c06c5e513f57b"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> * &gt;::type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a1321d0a1c2967d76381c06c5e513f57b">getListeners</a> (void) const</td></tr>
<tr class="separator:a1321d0a1c2967d76381c06c5e513f57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49970f083f11bcf5026aa23184ad112"><td class="memItemLeft" align="right" valign="top">VkImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#ab49970f083f11bcf5026aa23184ad112">getMsaaFramebufferName</a> (void) const</td></tr>
<tr class="separator:ab49970f083f11bcf5026aa23184ad112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a698f48957f6d466fbddcbf2e80becd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a4a698f48957f6d466fbddcbf2e80becd">getName</a> (void) const</td></tr>
<tr class="separator:a4a698f48957f6d466fbddcbf2e80becd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a10073f63d8fb559374f9e7c6585ae5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4a10073f63d8fb559374f9e7c6585ae5">getNameStr</a> (void) const</td></tr>
<tr class="memdesc:a4a10073f63d8fb559374f9e7c6585ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: This returns the alias name of the texture.  <a href="class_ogre_1_1_texture_gpu.html#a4a10073f63d8fb559374f9e7c6585ae5">More...</a><br /></td></tr>
<tr class="separator:a4a10073f63d8fb559374f9e7c6585ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107372aa3256baf8a80484b7f2412dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a107372aa3256baf8a80484b7f2412dd6">getNextResidencyStatus</a> (void) const</td></tr>
<tr class="memdesc:a107372aa3256baf8a80484b7f2412dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus()</a> != <a class="el" href="class_ogre_1_1_gpu_resource.html#a107372aa3256baf8a80484b7f2412dd6" title="When getResidencyStatus() != getNextResidencyStatus(), residency changes happen in the main thread,...">getNextResidencyStatus()</a>, residency changes happen in the main thread, while some preparation may be happening in the background.  <a href="class_ogre_1_1_gpu_resource.html#a107372aa3256baf8a80484b7f2412dd6">More...</a><br /></td></tr>
<tr class="separator:a107372aa3256baf8a80484b7f2412dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbda8603b2d42d666a9aea7113e290d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a5dbda8603b2d42d666a9aea7113e290d">getNumMipmaps</a> (void) const</td></tr>
<tr class="separator:a5dbda8603b2d42d666a9aea7113e290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dd6a8c7c23f1dc98a9ec150bdf16e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a78dd6a8c7c23f1dc98a9ec150bdf16e1">getNumSlices</a> (void) const</td></tr>
<tr class="memdesc:a78dd6a8c7c23f1dc98a9ec150bdf16e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For TypeCube this value returns 6.  <a href="class_ogre_1_1_texture_gpu.html#a78dd6a8c7c23f1dc98a9ec150bdf16e1">More...</a><br /></td></tr>
<tr class="separator:a78dd6a8c7c23f1dc98a9ec150bdf16e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9039d0b1ef9d873aea7440407b37cb2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae9039d0b1ef9d873aea7440407b37cb2">getOrientationMode</a> (void) const</td></tr>
<tr class="separator:ae9039d0b1ef9d873aea7440407b37cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f960e2ffea97ad43308c23ce1efb4b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#a1f960e2ffea97ad43308c23ce1efb4b1">getPendingResidencyChanges</a> (void) const</td></tr>
<tr class="memdesc:a1f960e2ffea97ad43308c23ce1efb4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of pending residency changes.  <a href="class_ogre_1_1_gpu_resource.html#a1f960e2ffea97ad43308c23ce1efb4b1">More...</a><br /></td></tr>
<tr class="separator:a1f960e2ffea97ad43308c23ce1efb4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a6949bdace3ca3e22d9cdb8cc77411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a65a6949bdace3ca3e22d9cdb8cc77411">getPixelFormat</a> (void) const</td></tr>
<tr class="separator:a65a6949bdace3ca3e22d9cdb8cc77411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaef49d04083efa37638502be9ece306"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#adaef49d04083efa37638502be9ece306">getPreferDepthTexture</a> (void) const</td></tr>
<tr class="separator:adaef49d04083efa37638502be9ece306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e2b3a27c5827b5f063fa6669f8e161"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a03e2b3a27c5827b5f063fa6669f8e161">getRealResourceNameStr</a> (void) const</td></tr>
<tr class="memdesc:a03e2b3a27c5827b5f063fa6669f8e161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real name (e.g. disk in file) of the resource.  <a href="class_ogre_1_1_texture_gpu.html#a03e2b3a27c5827b5f063fa6669f8e161">More...</a><br /></td></tr>
<tr class="separator:a03e2b3a27c5827b5f063fa6669f8e161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c6e78baed76ebbde12a2061b35ab16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a57c6e78baed76ebbde12a2061b35ab16">getRequestedSampleDescription</a> (void) const</td></tr>
<tr class="memdesc:a57c6e78baed76ebbde12a2061b35ab16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns original requested sample description, i.e. the raw input to setSampleDescription.  <a href="class_ogre_1_1_texture_gpu.html#a57c6e78baed76ebbde12a2061b35ab16">More...</a><br /></td></tr>
<tr class="separator:a57c6e78baed76ebbde12a2061b35ab16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab133cc1245bb5648652e4369d9497b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus</a> (void) const</td></tr>
<tr class="separator:aeab133cc1245bb5648652e4369d9497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be2b0daaad98d2140ca22efc6685684"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9be2b0daaad98d2140ca22efc6685684">getResourceGroupStr</a> (void) const</td></tr>
<tr class="separator:a9be2b0daaad98d2140ca22efc6685684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e45ab2f1617d1d51c45f687d9ebee8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a2e45ab2f1617d1d51c45f687d9ebee8c">getSampleDescription</a> (void) const</td></tr>
<tr class="memdesc:a2e45ab2f1617d1d51c45f687d9ebee8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns effective sample description supported by the API.  <a href="class_ogre_1_1_texture_gpu.html#a2e45ab2f1617d1d51c45f687d9ebee8c">More...</a><br /></td></tr>
<tr class="separator:a2e45ab2f1617d1d51c45f687d9ebee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad718ff4ec85f52e36ef2772d9b150c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aad718ff4ec85f52e36ef2772d9b150c2">getSettingsDesc</a> (void) const</td></tr>
<tr class="separator:aad718ff4ec85f52e36ef2772d9b150c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c0f33134c2401b0e711506c8055623"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a96c0f33134c2401b0e711506c8055623">getSizeBytes</a> (void) const</td></tr>
<tr class="memdesc:a96c0f33134c2401b0e711506c8055623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total size in bytes used in GPU by this texture (not by its pool) including mipmaps.  <a href="class_ogre_1_1_texture_gpu.html#a96c0f33134c2401b0e711506c8055623">More...</a><br /></td></tr>
<tr class="separator:a96c0f33134c2401b0e711506c8055623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88170d5ed9c9d2dc6e886217aaf1f6a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a88170d5ed9c9d2dc6e886217aaf1f6a5">getSourceType</a> (void) const</td></tr>
<tr class="separator:a88170d5ed9c9d2dc6e886217aaf1f6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3807d6ff756bce380e88709ceff3fc6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a3807d6ff756bce380e88709ceff3fc6b">getSubsampleLocations</a> (vector&lt; <a class="el" href="class_ogre_1_1_vector2.html">Vector2</a> &gt;::type locations)</td></tr>
<tr class="memdesc:a3807d6ff756bce380e88709ceff3fc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MSAA subsample locations.  <a href="class_ogre_1_1_vulkan_texture_gpu.html#a3807d6ff756bce380e88709ceff3fc6b">More...</a><br /></td></tr>
<tr class="separator:a3807d6ff756bce380e88709ceff3fc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e8a7c83b8295de9925a974f0121cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae3e8a7c83b8295de9925a974f0121cdc">getTextureManager</a> (void) const</td></tr>
<tr class="separator:ae3e8a7c83b8295de9925a974f0121cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fc814096fcf30c53fa116b5458ce1c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a68fc814096fcf30c53fa116b5458ce1c">getTexturePool</a> (void) const</td></tr>
<tr class="separator:a68fc814096fcf30c53fa116b5458ce1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78663647804665d50f8e0ec251845ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a78663647804665d50f8e0ec251845ff3">getTexturePoolId</a> (void) const</td></tr>
<tr class="separator:a78663647804665d50f8e0ec251845ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6906f8bdd2c820cc47b60b7d494d147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ab6906f8bdd2c820cc47b60b7d494d147">getTextureType</a> (void) const</td></tr>
<tr class="separator:ab6906f8bdd2c820cc47b60b7d494d147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21571655f9b2ee623e7fa528c2847490"><td class="memItemLeft" align="right" valign="top">VkImageType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a21571655f9b2ee623e7fa528c2847490">getVulkanTextureType</a> (void) const</td></tr>
<tr class="separator:a21571655f9b2ee623e7fa528c2847490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1858af3588de15e9da271d22fe9d5c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ad1858af3588de15e9da271d22fe9d5c1">getWidth</a> (void) const</td></tr>
<tr class="separator:ad1858af3588de15e9da271d22fe9d5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f64aa578e0615d892b1b706a9cbb134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a2f64aa578e0615d892b1b706a9cbb134">getWorkaroundedPixelFormat</a> (const <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat) const</td></tr>
<tr class="separator:a2f64aa578e0615d892b1b706a9cbb134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab038b4f32feeaa739a8cff7397e8809d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ab038b4f32feeaa739a8cff7397e8809d">hasAutomaticBatching</a> (void) const</td></tr>
<tr class="separator:ab038b4f32feeaa739a8cff7397e8809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de8595b73e911c15ce9e8066926380d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4de8595b73e911c15ce9e8066926380d">hasAutoMipmapAuto</a> (void) const</td></tr>
<tr class="separator:a4de8595b73e911c15ce9e8066926380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af943f8d1fd87f457fb4633058d696470"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af943f8d1fd87f457fb4633058d696470">hasEquivalentParameters</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *other) const</td></tr>
<tr class="separator:af943f8d1fd87f457fb4633058d696470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c2ce1e86de183dd2e2eff87da180a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa3c2ce1e86de183dd2e2eff87da180a5">hasMsaaExplicitResolves</a> (void) const</td></tr>
<tr class="separator:aa3c2ce1e86de183dd2e2eff87da180a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa844386b35f2cb71fee2f61304cb0d8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa844386b35f2cb71fee2f61304cb0d8d">isDataReady</a> (void) const</td></tr>
<tr class="memdesc:aa844386b35f2cb71fee2f61304cb0d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this texture is fully ready to be used for displaying.  <a href="class_ogre_1_1_texture_gpu.html#aa844386b35f2cb71fee2f61304cb0d8d">More...</a><br /></td></tr>
<tr class="separator:aa844386b35f2cb71fee2f61304cb0d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace88832ef330c2b560127ca2386c87de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ace88832ef330c2b560127ca2386c87de">isDiscardableContent</a> (void) const</td></tr>
<tr class="separator:ace88832ef330c2b560127ca2386c87de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afd94abec3a7a91c656188fc6d7cdf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a2afd94abec3a7a91c656188fc6d7cdf5">isManualTexture</a> (void) const</td></tr>
<tr class="separator:a2afd94abec3a7a91c656188fc6d7cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c32548e36eee7661d2da4c58f09f80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a23c32548e36eee7661d2da4c58f09f80">isMetadataReady</a> (void) const</td></tr>
<tr class="memdesc:a23c32548e36eee7661d2da4c58f09f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is threadsafe to call this function from main thread.  <a href="class_ogre_1_1_texture_gpu.html#a23c32548e36eee7661d2da4c58f09f80">More...</a><br /></td></tr>
<tr class="separator:a23c32548e36eee7661d2da4c58f09f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebc3bec47d599f4d0f7a9cde67bd4d3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4ebc3bec47d599f4d0f7a9cde67bd4d3">isMsaaPatternSupported</a> (<a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0f">MsaaPatterns::MsaaPatterns</a> pattern)</td></tr>
<tr class="separator:a4ebc3bec47d599f4d0f7a9cde67bd4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccfb3ab941842233e28a216e337e28e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a0ccfb3ab941842233e28a216e337e28e">isMultisample</a> (void) const</td></tr>
<tr class="separator:a0ccfb3ab941842233e28a216e337e28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a1ba96b03d3bab1a3c5943d03531fc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a31a1ba96b03d3bab1a3c5943d03531fc">isOpenGLRenderWindow</a> (void) const</td></tr>
<tr class="memdesc:a31a1ba96b03d3bab1a3c5943d03531fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL RenderWindows are a bit specific:  <a href="class_ogre_1_1_texture_gpu.html#a31a1ba96b03d3bab1a3c5943d03531fc">More...</a><br /></td></tr>
<tr class="separator:a31a1ba96b03d3bab1a3c5943d03531fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6576323b0cf05a3efbf46f9ab5d6e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae6576323b0cf05a3efbf46f9ab5d6e1e">isPoolOwner</a> (void) const</td></tr>
<tr class="separator:ae6576323b0cf05a3efbf46f9ab5d6e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359fd32c4f8c31cdd4db4baf72c1b70c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a359fd32c4f8c31cdd4db4baf72c1b70c">isReinterpretable</a> (void) const</td></tr>
<tr class="separator:a359fd32c4f8c31cdd4db4baf72c1b70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0edfcf7c6354c686d2ff580e7a5011"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a4c0edfcf7c6354c686d2ff580e7a5011">isRenderToTexture</a> (void) const</td></tr>
<tr class="separator:a4c0edfcf7c6354c686d2ff580e7a5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c236009b4074f43621c21db5ff6ef4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa0c236009b4074f43621c21db5ff6ef4">isRenderWindowSpecific</a> (void) const</td></tr>
<tr class="separator:aa0c236009b4074f43621c21db5ff6ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529bc39128cc173557a2742b7278c400"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a529bc39128cc173557a2742b7278c400">isTexture</a> (void) const</td></tr>
<tr class="separator:a529bc39128cc173557a2742b7278c400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9078e54f74753c91de4a74462bdff406"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9078e54f74753c91de4a74462bdff406">isTextureGpu</a> (void) const</td></tr>
<tr class="separator:a9078e54f74753c91de4a74462bdff406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdde6ea96205d73550d17a18bf4653a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#acdde6ea96205d73550d17a18bf4653a4">isUav</a> (void) const</td></tr>
<tr class="separator:acdde6ea96205d73550d17a18bf4653a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52acdc930dff7ae7f455256822d9520d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a52acdc930dff7ae7f455256822d9520d">notifyAllListenersTextureChanged</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> reason, void *extraData=0)</td></tr>
<tr class="separator:a52acdc930dff7ae7f455256822d9520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46d4abec459668fcc9d19af2ef76ae5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#ac46d4abec459668fcc9d19af2ef76ae5">notifyDataIsReady</a> (void)</td></tr>
<tr class="memdesc:ac46d4abec459668fcc9d19af2ef76ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies it is safe to use the real data. Everything has been uploaded.  <a href="class_ogre_1_1_vulkan_texture_gpu.html#ac46d4abec459668fcc9d19af2ef76ae5">More...</a><br /></td></tr>
<tr class="separator:ac46d4abec459668fcc9d19af2ef76ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6b84b89e2080bb7103d4778641d86e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a2e6b84b89e2080bb7103d4778641d86e">prefersLoadingFromFileAsSRGB</a> (void) const</td></tr>
<tr class="separator:a2e6b84b89e2080bb7103d4778641d86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e0ad601752b91f2851c88f9ed49869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ae3e0ad601752b91f2851c88f9ed49869">removeListener</a> (<a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *listener)</td></tr>
<tr class="separator:ae3e0ad601752b91f2851c88f9ed49869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db88cd9e4286f47a56fe7f507cd5c1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3db88cd9e4286f47a56fe7f507cd5c1b">requiresTextureFlipping</a> (void) const</td></tr>
<tr class="separator:a3db88cd9e4286f47a56fe7f507cd5c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0729d200bede23e29f5a88f0b9dcb3f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a0729d200bede23e29f5a88f0b9dcb3f6">scheduleReupload</a> (<a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image=0, bool autoDeleteImage=true)</td></tr>
<tr class="memdesc:a0729d200bede23e29f5a88f0b9dcb3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are times where you want to reload a texture again (e.g.  <a href="class_ogre_1_1_texture_gpu.html#a0729d200bede23e29f5a88f0b9dcb3f6">More...</a><br /></td></tr>
<tr class="separator:a0729d200bede23e29f5a88f0b9dcb3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9034d26bf967a6a9ab6a03f3f2a75a88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a9034d26bf967a6a9ab6a03f3f2a75a88">scheduleTransitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image=0, bool autoDeleteImage=true)</td></tr>
<tr class="memdesc:a9034d26bf967a6a9ab6a03f3f2a75a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as unsafeScheduleTransitionTo, but first checks if we're already in the residency state we want to go to, or if it has already been scheduled; thus it can be called multiple times.  <a href="class_ogre_1_1_texture_gpu.html#a9034d26bf967a6a9ab6a03f3f2a75a88">More...</a><br /></td></tr>
<tr class="separator:a9034d26bf967a6a9ab6a03f3f2a75a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae40391d39c8feae00acaf25839c6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a6ae40391d39c8feae00acaf25839c6f9">setNumMipmaps</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> numMipmaps)</td></tr>
<tr class="separator:a6ae40391d39c8feae00acaf25839c6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3866a77dfd74f1b70fdd31f42382c544"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3866a77dfd74f1b70fdd31f42382c544">setOrientationMode</a> (<a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a> orientationMode)</td></tr>
<tr class="memdesc:a3866a77dfd74f1b70fdd31f42382c544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given orientation.  <a href="class_ogre_1_1_texture_gpu.html#a3866a77dfd74f1b70fdd31f42382c544">More...</a><br /></td></tr>
<tr class="separator:a3866a77dfd74f1b70fdd31f42382c544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dfe2523d8e5647e79caaf28c296d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a54dfe2523d8e5647e79caaf28c296d4e">setPixelFormat</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat)</td></tr>
<tr class="memdesc:a54dfe2523d8e5647e79caaf28c296d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel format.  <a href="class_ogre_1_1_texture_gpu.html#a54dfe2523d8e5647e79caaf28c296d4e">More...</a><br /></td></tr>
<tr class="separator:a54dfe2523d8e5647e79caaf28c296d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e22c90559d13385d75dc19970806d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af79e22c90559d13385d75dc19970806d">setResolution</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> depthOrSlices=1u)</td></tr>
<tr class="separator:af79e22c90559d13385d75dc19970806d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ee4d088c32b3e9efeb4d2fec5cad3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa2ee4d088c32b3e9efeb4d2fec5cad3e">setSampleDescription</a> (<a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> desc)</td></tr>
<tr class="separator:aa2ee4d088c32b3e9efeb4d2fec5cad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a78bd23c2116dc08afcaa8dc1b8d2384e">setTexturePoolId</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId)</td></tr>
<tr class="memdesc:a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> with automatic batching will be merged with other textures into the same pool as one big 2D Array texture behind the scenes.  <a href="class_ogre_1_1_texture_gpu.html#a78bd23c2116dc08afcaa8dc1b8d2384e">More...</a><br /></td></tr>
<tr class="separator:a78bd23c2116dc08afcaa8dc1b8d2384e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cafdfd7801b925a8a220535aadc44b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#a96cafdfd7801b925a8a220535aadc44b">setTextureType</a> (<a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType)</td></tr>
<tr class="separator:a96cafdfd7801b925a8a220535aadc44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd2fb8a2ce598268c8813f5f230ddd8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3bd2fb8a2ce598268c8813f5f230ddd8">supportsAsDepthBufferFor</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *colourTarget) const</td></tr>
<tr class="separator:a3bd2fb8a2ce598268c8813f5f230ddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac707e8be721a47fb23a628003b1ade1f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#ac707e8be721a47fb23a628003b1ade1f">swapBuffers</a> (void)</td></tr>
<tr class="memdesc:ac707e8be721a47fb23a628003b1ade1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only valid for <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> classes.  <a href="class_ogre_1_1_texture_gpu.html#ac707e8be721a47fb23a628003b1ade1f">More...</a><br /></td></tr>
<tr class="separator:ac707e8be721a47fb23a628003b1ade1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3efd161b3ec98e3a405cf3167b7d022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#aa3efd161b3ec98e3a405cf3167b7d022">unsafeScheduleTransitionTo</a> (<a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> nextResidency, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image=0, bool autoDeleteImage=true)</td></tr>
<tr class="memdesc:aa3efd161b3ec98e3a405cf3167b7d022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules an async transition in residency.  <a href="class_ogre_1_1_texture_gpu.html#aa3efd161b3ec98e3a405cf3167b7d022">More...</a><br /></td></tr>
<tr class="separator:aa3efd161b3ec98e3a405cf3167b7d022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc608f61167b7b737a4129cd2b85f5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#adc608f61167b7b737a4129cd2b85f5f4">waitForData</a> (void)</td></tr>
<tr class="memdesc:adc608f61167b7b737a4129cd2b85f5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks main thread until data is ready.  <a href="class_ogre_1_1_texture_gpu.html#adc608f61167b7b737a4129cd2b85f5f4">More...</a><br /></td></tr>
<tr class="separator:adc608f61167b7b737a4129cd2b85f5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6740006ae83f39c4aeb83f300b67f6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a6740006ae83f39c4aeb83f300b67f6b2">waitForMetadata</a> (void)</td></tr>
<tr class="memdesc:a6740006ae83f39c4aeb83f300b67f6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks main thread until metadata is ready.  <a href="class_ogre_1_1_texture_gpu.html#a6740006ae83f39c4aeb83f300b67f6b2">More...</a><br /></td></tr>
<tr class="separator:a6740006ae83f39c4aeb83f300b67f6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af042e9ab52c07776f154ee077330f592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#af042e9ab52c07776f154ee077330f592">writeContentsToFile</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> minMip, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> maxMip, bool automaticResolve=true)</td></tr>
<tr class="memdesc:af042e9ab52c07776f154ee077330f592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current contents of the render target to the named file.  <a href="class_ogre_1_1_texture_gpu.html#af042e9ab52c07776f154ee077330f592">More...</a><br /></td></tr>
<tr class="separator:af042e9ab52c07776f154ee077330f592"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae48b5ec410564e91ffd7ac70252674c3"><td class="memItemLeft" align="right" valign="top">VkImageLayout&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#ae48b5ec410564e91ffd7ac70252674c3">mCurrLayout</a></td></tr>
<tr class="memdesc:ae48b5ec410564e91ffd7ac70252674c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current layout we're in. Including any internal stuff.  <a href="class_ogre_1_1_vulkan_texture_gpu.html#ae48b5ec410564e91ffd7ac70252674c3">More...</a><br /></td></tr>
<tr class="separator:ae48b5ec410564e91ffd7ac70252674c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2706154db19568bbb4ddf600ffa6309"><td class="memItemLeft" align="right" valign="top">VkImageLayout&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html#aa2706154db19568bbb4ddf600ffa6309">mNextLayout</a></td></tr>
<tr class="memdesc:aa2706154db19568bbb4ddf600ffa6309"><td class="mdescLeft">&#160;</td><td class="mdescRight">The layout we're expected to be when rendering or doing compute, rather than when doing internal stuff (e.g.  <a href="class_ogre_1_1_vulkan_texture_gpu.html#aa2706154db19568bbb4ddf600ffa6309">More...</a><br /></td></tr>
<tr class="separator:aa2706154db19568bbb4ddf600ffa6309"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8ec57ce0ef0c682416c3a6b6d13a095a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a8ec57ce0ef0c682416c3a6b6d13a095a">msDefaultOrientationMode</a></td></tr>
<tr class="memdesc:a8ec57ce0ef0c682416c3a6b6d13a095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PUBLIC VARIABLE.  <a href="class_ogre_1_1_texture_gpu.html#a8ec57ce0ef0c682416c3a6b6d13a095a">More...</a><br /></td></tr>
<tr class="separator:a8ec57ce0ef0c682416c3a6b6d13a095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed2bdf11740fd262b9311a33e33f935"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a3ed2bdf11740fd262b9311a33e33f935">msFinalTextureBuffer</a></td></tr>
<tr class="separator:a3ed2bdf11740fd262b9311a33e33f935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43888e98f84f5c9eb9ded14dd0deb34d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu.html#a43888e98f84f5c9eb9ded14dd0deb34d">msMsaaTextureBuffer</a></td></tr>
<tr class="separator:a43888e98f84f5c9eb9ded14dd0deb34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a167b312bc2c967169dcf31643eb621f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167b312bc2c967169dcf31643eb621f2">&#9670;&nbsp;</a></span>VulkanTextureGpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::VulkanTextureGpu::VulkanTextureGpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a> *&#160;</td>
          <td class="paramname"><em>textureManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d9bc54b12f379d3beb5ed6f61b750cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9bc54b12f379d3beb5ed6f61b750cf">&#9670;&nbsp;</a></span>~VulkanTextureGpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::VulkanTextureGpu::~VulkanTextureGpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad623ee0c97e95e276074d3cfd64c374c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad623ee0c97e95e276074d3cfd64c374c">&#9670;&nbsp;</a></span>_addPendingResidencyChanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::GpuResource::_addPendingResidencyChanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e7688bdd3bad5ad0f08bc5024e6431c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7688bdd3bad5ad0f08bc5024e6431c">&#9670;&nbsp;</a></span>_autogenerateMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VulkanTextureGpu::_autogenerateMipmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a>&#160;</td>
          <td class="paramname"><em>transitionMode</em> = <code><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the API to let the HW autogenerate mipmaps. </p>
<p>Assumes <a class="el" href="class_ogre_1_1_texture_gpu.html#a00ea3e542d7ef9c1e223d12b99d24d0b">allowsAutoMipmaps()</a> == true and <a class="el" href="class_ogre_1_1_texture_gpu.html#a4c0edfcf7c6354c686d2ff580e7a5011">isRenderToTexture()</a> == true </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitionMode</td><td>See <a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a" title="Copy Encoder Transition modes to be used by TextureGpu::copyTo and TextureGpu::_autogenerateMipmaps.">CopyEncTransitionMode::CopyEncTransitionMode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#a9591cec393bcb06deda9b5f94a040fc5">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a335f8053b320bab94073cd0359da9f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335f8053b320bab94073cd0359da9f15">&#9670;&nbsp;</a></span>_createView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageView Ogre::VulkanTextureGpu::_createView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a>&#160;</td>
          <td class="paramname"><em>arraySlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cubemapsAs2DArrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forUav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>numSlices</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>imageOverride</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7828b4d590c12aa357cf23938a69373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7828b4d590c12aa357cf23938a69373">&#9670;&nbsp;</a></span>_getSysRamCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>* Ogre::TextureGpu::_getSysRamCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47e1fcc0e8d7a092a55c79ace4564a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e1fcc0e8d7a092a55c79ace4564a4a">&#9670;&nbsp;</a></span>_getSysRamCopyAsBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> Ogre::TextureGpu::_getSysRamCopyAsBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7046d90f92e6a950d6d803892ee4b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7046d90f92e6a950d6d803892ee4b09">&#9670;&nbsp;</a></span>_getSysRamCopyBytesPerImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::TextureGpu::_getSysRamCopyBytesPerImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note: Returns non-zero even if there is no system ram copy. </p>

</div>
</div>
<a id="a6061da5422410802a10d2e97e9ab46f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6061da5422410802a10d2e97e9ab46f0">&#9670;&nbsp;</a></span>_getSysRamCopyBytesPerRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::TextureGpu::_getSysRamCopyBytesPerRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note: Returns non-zero even if there is no system ram copy. </p>

</div>
</div>
<a id="a44ec1d9dcbea3a1937c7b0d000fd47e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ec1d9dcbea3a1937c7b0d000fd47e6">&#9670;&nbsp;</a></span>_isDataReadyImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::VulkanTextureGpu::_isDataReadyImpl </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use. </p>
<p>Do not call directly.</p>
<p>This function is the same isDataReady except it ignores pending residency changes, which is important when <a class="el" href="class_ogre_1_1_texture_gpu_manager.html" title="This class manages all textures (i.e.">TextureGpuManager</a> needs to know this information but the <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> is transitioning (thus mPendingResidencyChanges is in an inconsistent state) </p>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#a5b54c7062cd7a87bd0c726de248c0bde">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a8143270ab5936e1c7814453923578182">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="ad3b879c519f45ccb57f91bc45a221f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b879c519f45ccb57f91bc45a221f3e">&#9670;&nbsp;</a></span>_isManualTextureFlagPresent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::_isManualTextureFlagPresent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0df37fcb72b47849df985a18828f2e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df37fcb72b47849df985a18828f2e97">&#9670;&nbsp;</a></span>_notifySysRamDownloadIsReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_notifySysRamDownloadIsReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> *&#160;</td>
          <td class="paramname"><em>sysRamPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resyncOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do not call directly. </p>
<p>Will change mResidencyStatus from <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> to <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a96b255b9535992cc830591ed916d15f3" title="Texture is on System RAM.">GpuResidency::OnSystemRam</a> </p>

</div>
</div>
<a id="a9b6f481187459e2436a6499d9be5fbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6f481187459e2436a6499d9be5fbc4">&#9670;&nbsp;</a></span>_notifyTextureSlotChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VulkanTextureGpu::_notifyTextureSlotChanged </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a> *&#160;</td>
          <td class="paramname"><em>newPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a>&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#a3cae191a32588efad29844e71bdf40be">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#aaa490ee3ea4694933380dc41d345f73c">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="aed4c74e16ccbdaf8bf82c04a0f7ea2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4c74e16ccbdaf8bf82c04a0f7ea2d6">&#9670;&nbsp;</a></span>_resetTextureManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_resetTextureManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeebb419ba824d0128f437bbe20cc81f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebb419ba824d0128f437bbe20cc81f9">&#9670;&nbsp;</a></span>_resolveTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_resolveTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>resolveTexture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immediately resolves this texture to the resolveTexture argument. </p>
<p>Source must be MSAA texture, destination must be non-MSAA. </p><dl class="section remark"><dt>Remarks</dt><dd>This function may be slow on some APIs and should only be used when required, for example, to capture the screen from an explicit MSAA target and save it to disk only on user demand. If you need to call this often (like once per frame or more), then consider setting a Compositor with CompositorNode::mLocalRtvs::resolveTextureName set so that the compositor automatically resolves the texture every frame as efficiently as possible. </dd></dl>

</div>
</div>
<a id="a4c626ccabbd6c853ee1490358b9ca490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c626ccabbd6c853ee1490358b9ca490">&#9670;&nbsp;</a></span>_setDepthBufferDefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::_setDepthBufferDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a>&#160;</td>
          <td class="paramname"><em>depthBufferPoolId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preferDepthTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>desiredDepthBufferFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These 3 values are used as defaults for the compositor to use, but they may be explicitly overriden by a <a class="el" href="class_ogre_1_1_render_pass_descriptor.html">RenderPassDescriptor</a>. </p>
<p>Particularly required when passing the textures between nodes as input and output (since only the <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> pointer is passed, and thus this information is lost) </p><dl class="section remark"><dt>Remarks</dt><dd>Changing these settings won't take immediate effect because they're only used when creating the compositor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthBufferPoolId</td><td>Sets the pool ID this <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> should query from. Default value is POOL_DEFAULT. Set to POOL_NO_DEPTH to avoid using a <a class="el" href="class_ogre_1_1_depth_buffer.html" title="An abstract class that contains a depth/stencil buffer.">DepthBuffer</a> (or manually controlling it) </td></tr>
    <tr><td class="paramname">preferDepthTexture</td><td>Whether this RT should be attached to a depth texture, or a regular depth buffer. On older GPUs, preferring depth textures may result in certain depth precisions to not be available (or use integer precision instead of floating point, etc). True to use depth textures. False otherwise (default). </td></tr>
    <tr><td class="paramname">desiredDepthBufferFormat</td><td><a class="el" href="namespace_ogre.html">Ogre</a> will try to honour this request, but if it's not supported, you may get lower precision. All formats will try to fallback to PF_D24_UNORM_S8_UINT if not supported. Must be one of the following: PFG_D24_UNORM_S8_UINT PFG_D16_UNORM PFG_D32_FLOAT PFG_D32_FLOAT_X24_S8_UINT </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#a0eb01d9f122d8f370cba66d52f6e2f3b">Ogre::VulkanTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_render_target.html#a92022fd9a36232324a897f145ee75338">Ogre::NULLTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#a7a9d5617ccd447a3d3d0385e3f94f835">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a8d6f53b830403f10c121ad44c925ee0d">Ogre::GL3PlusTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#a7544586c6b3d81749f4139360bc50de4">Ogre::D3D11TextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a0259d623d9baa835e8bec9aec09ec417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0259d623d9baa835e8bec9aec09ec417">&#9670;&nbsp;</a></span>_setNextLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VulkanTextureGpu::_setNextLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the layout the texture should be transitioned to after the next copy operation (once the copy encoder gets closed) </p>
<p>This is specific to Vulkan &amp; D3D12 </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#a7345e4a1d69f94657945067273376684">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a56ccef279ef9251c5a4b40bfaf7b9e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ccef279ef9251c5a4b40bfaf7b9e05">&#9670;&nbsp;</a></span>_setNextResidencyStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::GpuResource::_setNextResidencyStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>nextResidency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4044404f7783aea108e986336caaedf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4044404f7783aea108e986336caaedf6">&#9670;&nbsp;</a></span>_setSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_setSampleDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>validatedSampleDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use. </p>

</div>
</div>
<a id="ae641939cec4a57193dab3fc88921b7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae641939cec4a57193dab3fc88921b7ae">&#9670;&nbsp;</a></span>_setSourceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_setSourceType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d66e0da4416467fd2ba38a045f04c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d66e0da4416467fd2ba38a045f04c24">&#9670;&nbsp;</a></span>_setToDisplayDummyTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VulkanTextureGpu::_setToDisplayDummyTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#a360fe72891b1109edbe1469f4b30f027">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a1625322de34336fb90c89c070913a696">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="aa81e2a8d0caf9096dbab0723bab2b894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81e2a8d0caf9096dbab0723bab2b894">&#9670;&nbsp;</a></span>_syncGpuResidentToSystemRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_syncGpuResidentToSystemRam </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces downloading data from GPU to CPU, usually because the data on GPU changed and we're in strategy AlwaysKeepSystemRamCopy. </p>
<p>May stall. </p>

</div>
</div>
<a id="a85f9670da9031ec138caf8b3e910b37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f9670da9031ec138caf8b3e910b37e">&#9670;&nbsp;</a></span>_transitionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::_transitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>newResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> *&#160;</td>
          <td class="paramname"><em>sysRamCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteSysRamCopy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function may be called manually (if user is manually managing a texture) or automatically (e.g. </p>
<p>loading from file, or automatic batching is enabled) Once you call this function, you're no longer in OnStorage mode; and will transition to either OnSystemRam or Resident depending on whether auto batching is enabled. </p><dl class="section remark"><dt>Remarks</dt><dd>Do NOT call this function yourself if you've created this function with AutomaticBatching as <a class="el" href="namespace_ogre.html">Ogre</a> will call this, from a worker thread!</dd></dl>
<p>Make sure you're done using mSysRamCopy before calling this function, as we may free that pointer (unless autoDeleteSysRamCopyOnResident = false).</p>
<p>If you're calling _transitionTo yourself (i.e. you're not using scheduleTransitionTo) then you'll need to call _setNextResidencyStatus too, so that both getResidencyStatus and getNextResidencyStatus agree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysRamCopy</td><td>System RAM copy that backs this GPU data. May be null. Must've been allocated with <a class="el" href="group___memory.html#gafd7ddaef10ac9ea1ffbd18902167b9a2" title="Allocate a block of raw memory aligned to SIMD boundaries, and indicate the category of usage.">OGRE_MALLOC_SIMD( size, MEMCATEGORY_RESOURCE )</a>; We will deallocate it. MUST respect _getSysRamCopyBytesPerRow &amp; _getSysRamCopyBytesPerImage. If in doubt, use <a class="el" href="class_ogre_1_1_pixel_format_gpu_utils.html#aee2ade90d769c187b8192e0a234c5f17">PixelFormatGpuUtils::getSizeBytes</a> with rowAlignment = 4u;</td></tr>
  </table>
  </dd>
</dl>
<p>This param must be nullptr or equal to get_getSysRamCopy when going from Resident to OnSystemRam and strategy is not AlwaysKeepSystemRamCopy; as we will async download the content from the GPU. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoDeleteSysRamCopy</td><td>When true, we free mSysRamCopy as we should. When false, caller is responsible for deleting this pointer else it will leak! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6dd0d57c28fe017e8a83877bea0c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6dd0d57c28fe017e8a83877bea0c5f">&#9670;&nbsp;</a></span>addListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::addListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00ea3e542d7ef9c1e223d12b99d24d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ea3e542d7ef9c1e223d12b99d24d0b">&#9670;&nbsp;</a></span>allowsAutoMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::allowsAutoMipmaps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50b8aace07a416886cc0f871b32f078c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b8aace07a416886cc0f871b32f078c">&#9670;&nbsp;</a></span>copyContentsToMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::copyContentsToMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>dstFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automaticResolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the current contents of the render target to the memory. </p>

</div>
</div>
<a id="a1a1403e76b6775c08d2cb7b0c7d1398d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1403e76b6775c08d2cb7b0c7d1398d">&#9670;&nbsp;</a></span>copyParametersFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::copyParametersFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94f103b82bfa80046c870fb64b3a18b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f103b82bfa80046c870fb64b3a18b5">&#9670;&nbsp;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VulkanTextureGpu::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>dstMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>srcMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepResolvedTexSynced</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a>&#160;</td>
          <td class="paramname"><em>srcTransitionMode</em> = <code><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697a">CopyEncTransitionMode::CopyEncTransitionMode</a>&#160;</td>
          <td class="paramname"><em>dstTransitionMode</em> = <code><a class="el" href="namespace_ogre_1_1_copy_enc_transition_mode.html#a88628e41c3e6b360f8b1653a1fc6697aafa04688137f25d1b66e3e5c9b6429172">CopyEncTransitionMode::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td></td></tr>
    <tr><td class="paramname">dstBox</td><td></td></tr>
    <tr><td class="paramname">dstMipLevel</td><td></td></tr>
    <tr><td class="paramname">srcBox</td><td></td></tr>
    <tr><td class="paramname">srcMipLevel</td><td></td></tr>
    <tr><td class="paramname">keepResolvedTexSynced</td><td>When true, if dst is an MSAA texture and is implicitly resolved (i.e. dst-&gt;<a class="el" href="class_ogre_1_1_texture_gpu.html#aa3c2ce1e86de183dd2e2eff87da180a5">hasMsaaExplicitResolves()</a> == false); the resolved texture is also kept up to date.</td></tr>
  </table>
  </dd>
</dl>
<p>Typically the reason to set this to false is if you plane on rendering more stuff to dst texture and then resolve. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcTransitionMode</td><td>Transition mode for 'this' </td></tr>
    <tr><td class="paramname">dstTransitionMode</td><td>Transition mode for 'dst' </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#a18f60db95a5d6b1681b34aae96d98c4c">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="a0b0ceb6e5461235a993f1b6982984133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0ceb6e5461235a993f1b6982984133">&#9670;&nbsp;</a></span>createView() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageView Ogre::VulkanTextureGpu::createView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_descriptor_set_texture2_1_1_texture_slot.html">DescriptorSetTexture2::TextureSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>texSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseCache</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9ee652beefe440f678067bcc3e04aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ee652beefe440f678067bcc3e04aaa">&#9670;&nbsp;</a></span>createView() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageView Ogre::VulkanTextureGpu::createView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_descriptor_set_uav_1_1_texture_slot.html">DescriptorSetUav::TextureSlot</a>&#160;</td>
          <td class="paramname"><em>texSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseCache</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3c9d08dad106bb9eabfbb589a47d1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c9d08dad106bb9eabfbb589a47d1eb">&#9670;&nbsp;</a></span>createView() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageView Ogre::VulkanTextureGpu::createView </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84ae217889a61a5f3db96ab2fdf44851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ae217889a61a5f3db96ab2fdf44851">&#9670;&nbsp;</a></span>destroyView() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VulkanTextureGpu::destroyView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_descriptor_set_texture2_1_1_texture_slot.html">DescriptorSetTexture2::TextureSlot</a>&#160;</td>
          <td class="paramname"><em>texSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageView&#160;</td>
          <td class="paramname"><em>imageView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06c8efd9d4f9ddbdae952872f81534b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c8efd9d4f9ddbdae952872f81534b8">&#9670;&nbsp;</a></span>destroyView() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VulkanTextureGpu::destroyView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_descriptor_set_uav_1_1_texture_slot.html">DescriptorSetUav::TextureSlot</a>&#160;</td>
          <td class="paramname"><em>texSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageView&#160;</td>
          <td class="paramname"><em>imageView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4e93138a97ffb507ace65e342a356aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e93138a97ffb507ace65e342a356aa">&#9670;&nbsp;</a></span>destroyView() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::VulkanTextureGpu::destroyView </td>
          <td>(</td>
          <td class="paramtype">VkImageView&#160;</td>
          <td class="paramname"><em>imageView</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0253f67a1ff8ee7ec6ee4e98a3a9773a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0253f67a1ff8ee7ec6ee4e98a3a9773a">&#9670;&nbsp;</a></span>getCurrentLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> Ogre::VulkanTextureGpu::getCurrentLayout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#acc59aec11b770b8fc317dea50313d052">Ogre::TextureGpu</a>.</p>

</div>
</div>
<a id="aaecbe86d69c49a223a92070acbd309fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecbe86d69c49a223a92070acbd309fc">&#9670;&nbsp;</a></span>getCustomAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::getCustomAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a4f981756a34b86387f5a745d7f1a181d">Ogre::VulkanTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#ab2695e8f4f208b95547ccf1dcd93837f">Ogre::MetalTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#a512cc522becaa23ca6d0189da2a99f5a">Ogre::GL3PlusTextureGpuHeadlessWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#adae1ce0fb5460b2097d702562f9e2c89">Ogre::GL3PlusTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu.html#a9cf89e55f18c75154a841da462e9606c">Ogre::GL3PlusTextureGpu</a>, <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#a55f2f486a1dfd3ab07fdf927c51f84ea">Ogre::D3D11TextureGpuWindow</a>, and <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#a1f897bb3028c54f77c26a153176b5392">Ogre::D3D11TextureGpu</a>.</p>

</div>
</div>
<a id="a624cabb524d4fc589803108d79fea2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624cabb524d4fc589803108d79fea2df">&#9670;&nbsp;</a></span>getDefaultDisplaySrv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkImageView Ogre::VulkanTextureGpu::getDefaultDisplaySrv </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a472f6a92131325af1a8f5ba2b78b86eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472f6a92131325af1a8f5ba2b78b86eb">&#9670;&nbsp;</a></span>getDefaultLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> Ogre::TextureGpu::getDefaultLayout </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoreDiscardableFlag</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72fc34cf0b95593aa41df1370f5da312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fc34cf0b95593aa41df1370f5da312">&#9670;&nbsp;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getDepth </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For TypeCube &amp; TypeCubeArray, this value returns 1. </p>

</div>
</div>
<a id="ad9e5b1428a5fc4fdfaca35292509c716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e5b1428a5fc4fdfaca35292509c716">&#9670;&nbsp;</a></span>getDepthBufferPoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a> Ogre::TextureGpu::getDepthBufferPoolId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#ae6b89b32a070f07e401f85660418e2e6">Ogre::VulkanTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_render_target.html#a096a1aa3086614e8e1782159378ebbea">Ogre::NULLTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#ac66494237857ec1982d7eb15d3e1b67d">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a96a804ee415094f7a8350b351cd7adea">Ogre::GL3PlusTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#aa6b80203230f0e8efaac82109bfb938f">Ogre::D3D11TextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a06df44c12f039dfb40a60f6aacc94495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df44c12f039dfb40a60f6aacc94495">&#9670;&nbsp;</a></span>getDepthOrSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getDepthOrSlices </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e98f7545f8b2fd4d92dd412fa5ac270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e98f7545f8b2fd4d92dd412fa5ac270">&#9670;&nbsp;</a></span>getDesiredDepthBufferFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::TextureGpu::getDesiredDepthBufferFormat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#ad2cc3c7247cc6fae4756328694c17ac8">Ogre::VulkanTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_render_target.html#ad4924a674088729c46ae3e36f40fe4ab">Ogre::NULLTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#abcf5995181ba29cd8ed6940d1e52ebcd">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a8a72f255c8c54a6cf81feda5512a6796">Ogre::GL3PlusTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#a749c5446b213fb9b1195ffd6bc1fd655">Ogre::D3D11TextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="afbb2223272d9736f93dd8a255d41b925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb2223272d9736f93dd8a255d41b925">&#9670;&nbsp;</a></span>getDisplayTextureName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkImage Ogre::VulkanTextureGpu::getDisplayTextureName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a714b2b71f5443736c7c0ac2a97753c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714b2b71f5443736c7c0ac2a97753c02">&#9670;&nbsp;</a></span>getEmptyBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_texture_box.html">TextureBox</a> Ogre::TextureGpu::getEmptyBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>mipLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80ab4a439e06b33cba80b1af7afd01c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ab4a439e06b33cba80b1af7afd01c2">&#9670;&nbsp;</a></span>getFinalTextureName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkImage Ogre::VulkanTextureGpu::getFinalTextureName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51481d31eb97e679497f16452c9732b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51481d31eb97e679497f16452c9732b8">&#9670;&nbsp;</a></span>getFullSubresourceRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageSubresourceRange Ogre::VulkanTextureGpu::getFullSubresourceRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4766a70699416dd6dc2a51ad28307a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4766a70699416dd6dc2a51ad28307a19">&#9670;&nbsp;</a></span>getGpuPageOutStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> Ogre::GpuResource::getGpuPageOutStrategy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7556d2e92eb39b9f465d25bd811c5c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7556d2e92eb39b9f465d25bd811c5c22">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getHeight </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a829c17e22a5acd6ec583c3d2520db784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829c17e22a5acd6ec583c3d2520db784">&#9670;&nbsp;</a></span>getImageMemoryBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageMemoryBarrier Ogre::VulkanTextureGpu::getImageMemoryBarrier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a fresh VkImageMemoryBarrier filled with common data. </p>
<p>srcAccessMask, dstAccessMask, oldLayout and newLayout must be filled by caller </p>

</div>
</div>
<a id="af3e85ec353d2f79da71c96ad69b4048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e85ec353d2f79da71c96ad69b4048a">&#9670;&nbsp;</a></span>getInternalHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getInternalHeight </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Real API height accounting for <a class="el" href="class_ogre_1_1_texture_gpu.html#ae9039d0b1ef9d873aea7440407b37cb2">TextureGpu::getOrientationMode</a>. See getInternalWidth. </p>

</div>
</div>
<a id="ac7261ed5e880bbe376162a666d0ebea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7261ed5e880bbe376162a666d0ebea3">&#9670;&nbsp;</a></span>getInternalSliceStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getInternalSliceStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d4ea058e8a05f5d1949fe952ad00063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4ea058e8a05f5d1949fe952ad00063">&#9670;&nbsp;</a></span>getInternalTextureType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> Ogre::TextureGpu::getInternalTextureType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb90b45a1ccbcc0e499d2dcfabbaa3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb90b45a1ccbcc0e499d2dcfabbaa3a1">&#9670;&nbsp;</a></span>getInternalVulkanTextureViewType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageViewType Ogre::VulkanTextureGpu::getInternalVulkanTextureViewType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bb35caa0639bfa59b095295a73ab6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb35caa0639bfa59b095295a73ab6c0">&#9670;&nbsp;</a></span>getInternalWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getInternalWidth </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Real API width accounting for <a class="el" href="class_ogre_1_1_texture_gpu.html#ae9039d0b1ef9d873aea7440407b37cb2">TextureGpu::getOrientationMode</a> If orientation mode is 90° or 270° then getInternalWidth returns the height and getInternalHeight returns the width. </p>

</div>
</div>
<a id="a1321d0a1c2967d76381c06c5e513f57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1321d0a1c2967d76381c06c5e513f57b">&#9670;&nbsp;</a></span>getListeners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a>*&gt;::type&amp; Ogre::TextureGpu::getListeners </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab49970f083f11bcf5026aa23184ad112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49970f083f11bcf5026aa23184ad112">&#9670;&nbsp;</a></span>getMsaaFramebufferName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkImage Ogre::VulkanTextureGpu::getMsaaFramebufferName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a698f48957f6d466fbddcbf2e80becd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a698f48957f6d466fbddcbf2e80becd">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::GpuResource::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a10073f63d8fb559374f9e7c6585ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a10073f63d8fb559374f9e7c6585ae5">&#9670;&nbsp;</a></span>getNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getNameStr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note: This returns the alias name of the texture. </p>
<p>See <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a6c611147ab065038c4727b75dffdac65">TextureGpuManager::createOrRetrieveTexture</a> </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_gpu_resource.html#a757b15607dab2d7259d829e9a76b3e65">Ogre::GpuResource</a>.</p>

</div>
</div>
<a id="a107372aa3256baf8a80484b7f2412dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107372aa3256baf8a80484b7f2412dd6">&#9670;&nbsp;</a></span>getNextResidencyStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> Ogre::GpuResource::getNextResidencyStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When <a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus()</a> != <a class="el" href="class_ogre_1_1_gpu_resource.html#a107372aa3256baf8a80484b7f2412dd6" title="When getResidencyStatus() != getNextResidencyStatus(), residency changes happen in the main thread,...">getNextResidencyStatus()</a>, residency changes happen in the main thread, while some preparation may be happening in the background. </p>
<p>For example when a texture is not resident but getNextResidencyStatus says it will, a background thread is loading the texture file from disk, but the actual transition won't happen until the main thread changes it. You can call texture-&gt;<a class="el" href="class_ogre_1_1_texture_gpu.html#adc608f61167b7b737a4129cd2b85f5f4" title="Blocks main thread until data is ready.">waitForData()</a> which will stall, as the main thread will be communicating back and forth with the background to see if it's ready; and when it is, the main thread will perform the transition inside waitForData</p>
<p>Likewise, if that texture is resident but will soon not be, it is still legal to access its contents as long as you access them from the main thread before that main thread changes the residency. This gives you a strong serialization guarantee, but be careful with async tickets such as AsyncTextureTickets:</p>
<p>If you call <a class="el" href="class_ogre_1_1_async_texture_ticket.html" title="In Ogre 2.2 reading data from GPU back to CPU is asynchronous.">AsyncTextureTicket</a> *asyncTicket = textureManager-&gt;createAsyncTextureTicket( ... ); assert( texture-&gt;<a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus()</a> == <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> ); ... do something else that calls <a class="el" href="namespace_ogre.html">Ogre</a> functionality ... assert( texture-&gt;<a class="el" href="class_ogre_1_1_gpu_resource.html#aeab133cc1245bb5648652e4369d9497b">getResidencyStatus()</a> == <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> ); asyncTicket-&gt;download( texture, mip, true ); Then the second assert may trigger because that "do something else" ended up calling a function inside <a class="el" href="namespace_ogre.html">Ogre</a> that finalized the transition. Once you've called download and the resource was still Resident, you are safe that your data integrity will be kept. </p><dl class="section remark"><dt>Remarks</dt><dd>Beware of the ABA problem. If the following transitions are scheduled: OnStorage -&gt; Resident -&gt; OnStorage Then both getResidencyStatus &amp; getNextResidencyStatus will return OnStorage. Use <a class="el" href="class_ogre_1_1_gpu_resource.html#a1f960e2ffea97ad43308c23ce1efb4b1" title="Returns the number of pending residency changes.">GpuResource::getPendingResidencyChanges</a> to fix the ABA problem. </dd></dl>

</div>
</div>
<a id="a5dbda8603b2d42d666a9aea7113e290d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbda8603b2d42d666a9aea7113e290d">&#9670;&nbsp;</a></span>getNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::TextureGpu::getNumMipmaps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78dd6a8c7c23f1dc98a9ec150bdf16e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dd6a8c7c23f1dc98a9ec150bdf16e1">&#9670;&nbsp;</a></span>getNumSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getNumSlices </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For TypeCube this value returns 6. </p>
<p>For TypeCubeArray, value returns numSlices * 6u. </p>

</div>
</div>
<a id="ae9039d0b1ef9d873aea7440407b37cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9039d0b1ef9d873aea7440407b37cb2">&#9670;&nbsp;</a></span>getOrientationMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a> Ogre::TextureGpu::getOrientationMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#ab4bba2899ce07abed908958763bba352">Ogre::VulkanTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#abe4809a1316cb8a86907767c1a071cf9">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#aae3f1a124f5b281d774f907a4d002516">Ogre::GL3PlusTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#a643c574230246059f119b0f115eae8de">Ogre::D3D11TextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a1f960e2ffea97ad43308c23ce1efb4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f960e2ffea97ad43308c23ce1efb4b1">&#9670;&nbsp;</a></span>getPendingResidencyChanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::GpuResource::getPendingResidencyChanges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of pending residency changes. </p>
<p>Residency changes may not be immediate and thus be delayed (e.g. see <a class="el" href="class_ogre_1_1_texture_gpu.html#a9034d26bf967a6a9ab6a03f3f2a75a88" title="Same as unsafeScheduleTransitionTo, but first checks if we&#39;re already in the residency state we want ...">TextureGpu::scheduleTransitionTo</a>).</p>
<p>When this value is 0 it implies that mResidencyStatus == mNextResidencyStatus </p>

</div>
</div>
<a id="a65a6949bdace3ca3e22d9cdb8cc77411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a6949bdace3ca3e22d9cdb8cc77411">&#9670;&nbsp;</a></span>getPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::TextureGpu::getPixelFormat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adaef49d04083efa37638502be9ece306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaef49d04083efa37638502be9ece306">&#9670;&nbsp;</a></span>getPreferDepthTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::getPreferDepthTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#adc5ca38a637d00963bae287d015f5fdd">Ogre::VulkanTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_render_target.html#ac49f4467b459958063d827e7e28a1908">Ogre::NULLTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#a85721c905f77da38ffb9970f751b0eba">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#a089625f3d76ac5040973e36e3ae2c72d">Ogre::GL3PlusTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#afe886084dabc338b0705ce3d792fe0d6">Ogre::D3D11TextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a03e2b3a27c5827b5f063fa6669f8e161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e2b3a27c5827b5f063fa6669f8e161">&#9670;&nbsp;</a></span>getRealResourceNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getRealResourceNameStr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the real name (e.g. disk in file) of the resource. </p>

</div>
</div>
<a id="a57c6e78baed76ebbde12a2061b35ab16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c6e78baed76ebbde12a2061b35ab16">&#9670;&nbsp;</a></span>getRequestedSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> Ogre::TextureGpu::getRequestedSampleDescription </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns original requested sample description, i.e. the raw input to setSampleDescription. </p>

</div>
</div>
<a id="aeab133cc1245bb5648652e4369d9497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab133cc1245bb5648652e4369d9497b">&#9670;&nbsp;</a></span>getResidencyStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> Ogre::GpuResource::getResidencyStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9be2b0daaad98d2140ca22efc6685684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be2b0daaad98d2140ca22efc6685684">&#9670;&nbsp;</a></span>getResourceGroupStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getResourceGroupStr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e45ab2f1617d1d51c45f687d9ebee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e45ab2f1617d1d51c45f687d9ebee8c">&#9670;&nbsp;</a></span>getSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a> Ogre::TextureGpu::getSampleDescription </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns effective sample description supported by the API. </p>
<p>Note it's only useful after having transitioned to resident. </p>

</div>
</div>
<a id="aad718ff4ec85f52e36ef2772d9b150c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad718ff4ec85f52e36ef2772d9b150c2">&#9670;&nbsp;</a></span>getSettingsDesc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::TextureGpu::getSettingsDesc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c0f33134c2401b0e711506c8055623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c0f33134c2401b0e711506c8055623">&#9670;&nbsp;</a></span>getSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::TextureGpu::getSizeBytes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns total size in bytes used in GPU by this texture (not by its pool) including mipmaps. </p>

</div>
</div>
<a id="a88170d5ed9c9d2dc6e886217aaf1f6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88170d5ed9c9d2dc6e886217aaf1f6a5">&#9670;&nbsp;</a></span>getSourceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::TextureGpu::getSourceType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a3807d6ff756bce380e88709ceff3fc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3807d6ff756bce380e88709ceff3fc6b">&#9670;&nbsp;</a></span>getSubsampleLocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VulkanTextureGpu::getSubsampleLocations </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_ogre_1_1_vector2.html">Vector2</a> &gt;::type&#160;</td>
          <td class="paramname"><em>locations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the MSAA subsample locations. </p>
<p>mSampleDescription.pattern must not be <a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0fae9213e03f8cab27c1f90e1981b2ab623" title="Let the GPU decide.">MsaaPatterns::Undefined</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locations</td><td>Outputs an array with the locations for each subsample. Values are in range [-1; 1] </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#a1a458af605a3aa67117fe267ac453c17">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a26c43a33fd8c126c64f49cefae13aa18">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="ae3e8a7c83b8295de9925a974f0121cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e8a7c83b8295de9925a974f0121cdc">&#9670;&nbsp;</a></span>getTextureManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html">TextureGpuManager</a>* Ogre::TextureGpu::getTextureManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68fc814096fcf30c53fa116b5458ce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fc814096fcf30c53fa116b5458ce1c">&#9670;&nbsp;</a></span>getTexturePool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_texture_pool.html">TexturePool</a>* Ogre::TextureGpu::getTexturePool </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78663647804665d50f8e0ec251845ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78663647804665d50f8e0ec251845ff3">&#9670;&nbsp;</a></span>getTexturePoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getTexturePoolId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6906f8bdd2c820cc47b60b7d494d147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6906f8bdd2c820cc47b60b7d494d147">&#9670;&nbsp;</a></span>getTextureType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> Ogre::TextureGpu::getTextureType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21571655f9b2ee623e7fa528c2847490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21571655f9b2ee623e7fa528c2847490">&#9670;&nbsp;</a></span>getVulkanTextureType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageType Ogre::VulkanTextureGpu::getVulkanTextureType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1858af3588de15e9da271d22fe9d5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1858af3588de15e9da271d22fe9d5c1">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::TextureGpu::getWidth </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f64aa578e0615d892b1b706a9cbb134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f64aa578e0615d892b1b706a9cbb134">&#9670;&nbsp;</a></span>getWorkaroundedPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> Ogre::VulkanTextureGpu::getWorkaroundedPixelFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab038b4f32feeaa739a8cff7397e8809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab038b4f32feeaa739a8cff7397e8809d">&#9670;&nbsp;</a></span>hasAutomaticBatching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasAutomaticBatching </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4de8595b73e911c15ce9e8066926380d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de8595b73e911c15ce9e8066926380d">&#9670;&nbsp;</a></span>hasAutoMipmapAuto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasAutoMipmapAuto </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af943f8d1fd87f457fb4633058d696470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af943f8d1fd87f457fb4633058d696470">&#9670;&nbsp;</a></span>hasEquivalentParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasEquivalentParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3c2ce1e86de183dd2e2eff87da180a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c2ce1e86de183dd2e2eff87da180a5">&#9670;&nbsp;</a></span>hasMsaaExplicitResolves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::hasMsaaExplicitResolves </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa844386b35f2cb71fee2f61304cb0d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa844386b35f2cb71fee2f61304cb0d8d">&#9670;&nbsp;</a></span>isDataReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isDataReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this texture is fully ready to be used for displaying. </p>
<p>IMPORTANT: Always returns true if getResidencyStatus != <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2" title="VRAM and other GPU resources have been allocated for this resource.">GpuResidency::Resident</a> and there are no pending residency transitions.</p>
<p>Returns false while there are pending residency status</p>
<p>If this is true, then isMetadataReady is also true. See isMetadataReady. </p>

</div>
</div>
<a id="ace88832ef330c2b560127ca2386c87de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace88832ef330c2b560127ca2386c87de">&#9670;&nbsp;</a></span>isDiscardableContent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isDiscardableContent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2afd94abec3a7a91c656188fc6d7cdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afd94abec3a7a91c656188fc6d7cdf5">&#9670;&nbsp;</a></span>isManualTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isManualTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23c32548e36eee7661d2da4c58f09f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c32548e36eee7661d2da4c58f09f80">&#9670;&nbsp;</a></span>isMetadataReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isMetadataReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It is threadsafe to call this function from main thread. </p>
<p>If this returns false, then the following functions are not threadsafe: Setters must not be called, and getters may change from a worker thread: setResolution getWidth, getHeight, getDepth, getDepthOrSlices, getNumSlices set/getPixelFormat set/getNumMipmaps set/getTextureType getTexturePool Note that this function may return true but the worker thread may still be uploading to this texture. Use isDataReady to see if the worker thread is fully done with this texture.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Function for querying/waiting for data and metadata to be ready are for blocking the main thread when a worker thread is loading the texture from file or a listener (i.e. isManualTexture returns false) otherwise you don't need to call these functions. </dd></dl>

</div>
</div>
<a id="a4ebc3bec47d599f4d0f7a9cde67bd4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebc3bec47d599f4d0f7a9cde67bd4d3">&#9670;&nbsp;</a></span>isMsaaPatternSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::isMsaaPatternSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_msaa_patterns.html#a54095ce17b1cbaa8972173d9ea950f0f">MsaaPatterns::MsaaPatterns</a>&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu.html#ad0bb22af342ab460495997988c2a6cf9">Ogre::D3D11TextureGpu</a>.</p>

</div>
</div>
<a id="a0ccfb3ab941842233e28a216e337e28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccfb3ab941842233e28a216e337e28e">&#9670;&nbsp;</a></span>isMultisample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isMultisample </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31a1ba96b03d3bab1a3c5943d03531fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a1ba96b03d3bab1a3c5943d03531fc">&#9670;&nbsp;</a></span>isOpenGLRenderWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::isOpenGLRenderWindow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OpenGL RenderWindows are a bit specific: </p>
<ul>
<li>Their origins are upside down. Which means we need to flip Y.</li>
<li>They can access resolved contents of MSAA even if hasMsaaExplicitResolves = true</li>
<li>Headless windows return false since internally they're FBOs. However isRenderWindowSpecific will return true </li>
</ul>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a8f0edacbcb6b52f7db50913446ffbee8">Ogre::VulkanTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#ab81e9a755ba2b500f911c02b1df1893a">Ogre::GL3PlusTextureGpuHeadlessWindow</a>, and <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#a465589165bc3c4ac818aab46631a0433">Ogre::GL3PlusTextureGpuWindow</a>.</p>

</div>
</div>
<a id="ae6576323b0cf05a3efbf46f9ab5d6e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6576323b0cf05a3efbf46f9ab5d6e1e">&#9670;&nbsp;</a></span>isPoolOwner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isPoolOwner </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a359fd32c4f8c31cdd4db4baf72c1b70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359fd32c4f8c31cdd4db4baf72c1b70c">&#9670;&nbsp;</a></span>isReinterpretable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isReinterpretable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c0edfcf7c6354c686d2ff580e7a5011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0edfcf7c6354c686d2ff580e7a5011">&#9670;&nbsp;</a></span>isRenderToTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isRenderToTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0c236009b4074f43621c21db5ff6ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c236009b4074f43621c21db5ff6ef4">&#9670;&nbsp;</a></span>isRenderWindowSpecific()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isRenderWindowSpecific </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a529bc39128cc173557a2742b7278c400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529bc39128cc173557a2742b7278c400">&#9670;&nbsp;</a></span>isTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isTexture </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9078e54f74753c91de4a74462bdff406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9078e54f74753c91de4a74462bdff406">&#9670;&nbsp;</a></span>isTextureGpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::isTextureGpu </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="struct_ogre_1_1_gpu_tracked_resource.html#a3d389b0aae18bb6dcb82af84c93b77de">Ogre::GpuTrackedResource</a>.</p>

</div>
</div>
<a id="acdde6ea96205d73550d17a18bf4653a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdde6ea96205d73550d17a18bf4653a4">&#9670;&nbsp;</a></span>isUav()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::isUav </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52acdc930dff7ae7f455256822d9520d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52acdc930dff7ae7f455256822d9520d">&#9670;&nbsp;</a></span>notifyAllListenersTextureChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::notifyAllListenersTextureChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extraData</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac46d4abec459668fcc9d19af2ef76ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46d4abec459668fcc9d19af2ef76ae5">&#9670;&nbsp;</a></span>notifyDataIsReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VulkanTextureGpu::notifyDataIsReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies it is safe to use the real data. Everything has been uploaded. </p>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu.html#abe10b3ea1bc20e616134af7b7f567446">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a7f1e918ec5e6d01c51a6e851b20a9ab8">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bdf968b7b9af8a5239a27da73d5711">&#9670;&nbsp;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421b197ca3a38da17e2eb1531a645fa2">&#9670;&nbsp;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="ab78a921e54419be677839cdf15d1f0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78a921e54419be677839cdf15d1f0b8">&#9670;&nbsp;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="afa2943846ba6a2b5824a12857139cf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2943846ba6a2b5824a12857139cf5e">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4be37baef81876985aa1071ad5acc6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be37baef81876985aa1071ad5acc6dd">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="a2e6b84b89e2080bb7103d4778641d86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6b84b89e2080bb7103d4778641d86e">&#9670;&nbsp;</a></span>prefersLoadingFromFileAsSRGB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::prefersLoadingFromFileAsSRGB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3e0ad601752b91f2851c88f9ed49869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e0ad601752b91f2851c88f9ed49869">&#9670;&nbsp;</a></span>removeListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::removeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html">TextureGpuListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3db88cd9e4286f47a56fe7f507cd5c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db88cd9e4286f47a56fe7f507cd5c1b">&#9670;&nbsp;</a></span>requiresTextureFlipping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpu::requiresTextureFlipping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0729d200bede23e29f5a88f0b9dcb3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0729d200bede23e29f5a88f0b9dcb3f6">&#9670;&nbsp;</a></span>scheduleReupload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::scheduleReupload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There are times where you want to reload a texture again (e.g. </p>
<p>file on disk changed, uploading a new <a class="el" href="class_ogre_1_1_image2.html" title="Class representing an image file.">Image2</a>, etc) without visual disruption.</p>
<p>e.g. if you were to call: </p><div class="fragment"><div class="line">tex-&gt;scheduleTransitionTo( <a class="code" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98ad60acc99d4bcd4898f280cbf6d8ef1dc">GpuResidency::OnStorage</a> );</div>
<div class="line">tex-&gt;scheduleTransitionTo( <a class="code" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">GpuResidency::Resident</a>, ... );</div>
<div class="ttc" id="anamespace_ogre_1_1_gpu_residency_html_a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2"><div class="ttname"><a href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98a268f91accb452d1707dd83b5aeb72aa2">Ogre::GpuResidency::Resident</a></div><div class="ttdeci">@ Resident</div><div class="ttdoc">VRAM and other GPU resources have been allocated for this resource.</div><div class="ttdef"><b>Definition:</b> OgreGpuResource.h:65</div></div>
<div class="ttc" id="anamespace_ogre_1_1_gpu_residency_html_a2dee9b512fd45f8d010e8e18e25ebd98ad60acc99d4bcd4898f280cbf6d8ef1dc"><div class="ttname"><a href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98ad60acc99d4bcd4898f280cbf6d8ef1dc">Ogre::GpuResidency::OnStorage</a></div><div class="ttdeci">@ OnStorage</div><div class="ttdoc">Texture is on storage (i.e.</div><div class="ttdef"><b>Definition:</b> OgreGpuResource.h:48</div></div>
</div><!-- fragment --><p>you'll achieve the same result, however the texture becomes immediately unavailable causing a few frames were all the user sees is a blank texture until it is fully reloaded.</p>
<p>This routine allows for an in-place hot-reload, where the old texture is swapped for the new one once it's done loading.</p>
<p>This is also faster because DescriptorTextureSets don't change</p>
<dl class="section remark"><dt>Remarks</dt><dd><ol type="1">
<li>Assumes the last queued transition to perform is into Resident or OnSystemRam</li>
<li><a class="el" href="class_visual.html">Visual</a> hitches are unavoidable if metadata changes (e.g. new texture is of different pixel format, different number of mipmaps, resolution, etc) If that's the case, it is faster to transition to OnStorage, remove the metadata entry from cache, then to Resident again</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>See <a class="el" href="class_ogre_1_1_texture_gpu.html#aa3efd161b3ec98e3a405cf3167b7d022" title="Schedules an async transition in residency.">TextureGpu::unsafeScheduleTransitionTo</a> </td></tr>
    <tr><td class="paramname">autoDeleteImage</td><td>Same <a class="el" href="class_ogre_1_1_texture_gpu.html#aa3efd161b3ec98e3a405cf3167b7d022" title="Schedules an async transition in residency.">TextureGpu::unsafeScheduleTransitionTo</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9034d26bf967a6a9ab6a03f3f2a75a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9034d26bf967a6a9ab6a03f3f2a75a88">&#9670;&nbsp;</a></span>scheduleTransitionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::scheduleTransitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>nextResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as unsafeScheduleTransitionTo, but first checks if we're already in the residency state we want to go to, or if it has already been scheduled; thus it can be called multiple times. </p>

</div>
</div>
<a id="a6ae40391d39c8feae00acaf25839c6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae40391d39c8feae00acaf25839c6f9">&#9670;&nbsp;</a></span>setNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setNumMipmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3866a77dfd74f1b70fdd31f42382c544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3866a77dfd74f1b70fdd31f42382c544">&#9670;&nbsp;</a></span>setOrientationMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::setOrientationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a>&#160;</td>
          <td class="paramname"><em>orientationMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given orientation. </p>
<p>'this' must be a <a class="el" href="class_ogre_1_1_render_texture.html" title="This class represents a RenderTarget that renders to a Texture.">RenderTexture</a> If <a class="el" href="namespace_ogre.html">Ogre</a> wasn't build with OGRE_CONFIG_ENABLE_VIEWPORT_ORIENTATIONMODE, calls to this function will not stick (i.e. getOrientationMode always returns the same value)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_gpu.html#a8ec57ce0ef0c682416c3a6b6d13a095a" title="PUBLIC VARIABLE.">TextureGpu::msDefaultOrientationMode</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_texture_gpu.html#a7bb35caa0639bfa59b095295a73ab6c0" title="Real API width accounting for TextureGpu::getOrientationMode If orientation mode is 90° or 270° then ...">TextureGpu::getInternalWidth</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_texture_gpu.html#af3e85ec353d2f79da71c96ad69b4048a" title="Real API height accounting for TextureGpu::getOrientationMode. See getInternalWidth.">TextureGpu::getInternalHeight</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Must be OnStorage.</dd></dl>
<p>If OrientationMode == OR_DEGREE_90 or OR_DEGREE_270, the internal resolution if flipped. i.e. swap( width, height ). This is important if you need to perform copyTo operations or AsyncTextureTickets</p>
<p>This setting has only been tested with Vulkan and is likely to malfunction with the other APIs if set to anything other than OR_DEGREE_0 </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_render_target.html#ab6c7ba7f441548b407cc1487749d6a64">Ogre::VulkanTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_render_target.html#a7b24c28e837f20f9d848f643d606b780">Ogre::MetalTextureGpuRenderTarget</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_render_target.html#acb742aad6d436ce9f4aeeb535fb1bc6a">Ogre::GL3PlusTextureGpuRenderTarget</a>, and <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_render_target.html#ae5f9574abd474e92f8f20da4145e157f">Ogre::D3D11TextureGpuRenderTarget</a>.</p>

</div>
</div>
<a id="a54dfe2523d8e5647e79caaf28c296d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dfe2523d8e5647e79caaf28c296d4e">&#9670;&nbsp;</a></span>setPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setPixelFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pixel format. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="class_ogre_1_1_texture_gpu.html#a2e6b84b89e2080bb7103d4778641d86e">prefersLoadingFromFileAsSRGB()</a> returns true, the format may not be fully honoured (as we'll use the equivalent _SRGB variation). </dd></dl>

</div>
</div>
<a id="af79e22c90559d13385d75dc19970806d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79e22c90559d13385d75dc19970806d">&#9670;&nbsp;</a></span>setResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2ee4d088c32b3e9efeb4d2fec5cad3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ee4d088c32b3e9efeb4d2fec5cad3e">&#9670;&nbsp;</a></span>setSampleDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setSampleDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_sample_description.html">SampleDescription</a>&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78bd23c2116dc08afcaa8dc1b8d2384e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bd23c2116dc08afcaa8dc1b8d2384e">&#9670;&nbsp;</a></span>setTexturePoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::setTexturePoolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> with automatic batching will be merged with other textures into the same pool as one big 2D Array texture behind the scenes. </p>
<p>For two textures to be placed in the same pool (assuming it's not full) the following must match: Width, Height, PixelFormat, number of mipmaps, poolID</p>
<p><a class="el" href="class_ogre_1_1_pool.html" title="Template class describing a simple pool of items.">Pool</a> ID is an arbitrary value with no actual meaning. This is ID allows you to prevent certain textures from being group together. For example, you may want all textures from Level 0 to be grouped together while Level 1 gets grouped together in a different pool</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434a2f298fbaec7db976ba6616430b1f52a3" title="When not present: The Texture is exactly the type requested (e.g.">TextureFlags::AutomaticBatching</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a09d2107487d758a1fb49591bff242ae1" title="Reserves and preallocates a pool with the given parameters Returns the master texture that owns the p...">TextureGpuManager::reservePoolId</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value cannot be changed while the texture is resident (i.e. because it has already been assigned to a pool) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolId</td><td>Arbitrary value. Default value is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96cafdfd7801b925a8a220535aadc44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cafdfd7801b925a8a220535aadc44b">&#9670;&nbsp;</a></span>setTextureType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::VulkanTextureGpu::setTextureType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_texture_gpu.html#aeadb4961ae1af0313cbd253bd32285dd">Ogre::TextureGpu</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#a00970cb74f079f5dff4d4183002a3039">Ogre::VulkanTextureGpuWindow</a>.</p>

</div>
</div>
<a id="a3bd2fb8a2ce598268c8813f5f230ddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd2fb8a2ce598268c8813f5f230ddd8">&#9670;&nbsp;</a></span>supportsAsDepthBufferFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpu::supportsAsDepthBufferFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>colourTarget</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac707e8be721a47fb23a628003b1ade1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac707e8be721a47fb23a628003b1ade1f">&#9670;&nbsp;</a></span>swapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpu::swapBuffers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only valid for <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> classes. </p>
<p>TODO: This may be moved to a different class. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_window.html#ad0bd6c9d882c9b291c841a8b6d06efb6">Ogre::VulkanTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_metal_texture_gpu_window.html#a4a76d8af2faf043bc6bff7fcb46d2d2f">Ogre::MetalTextureGpuWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_headless_window.html#a5f76858facbfe1833178af802576cd33">Ogre::GL3PlusTextureGpuHeadlessWindow</a>, <a class="el" href="class_ogre_1_1_g_l3_plus_texture_gpu_window.html#a798d74df2205998cd76478c0e09f2d46">Ogre::GL3PlusTextureGpuWindow</a>, and <a class="el" href="class_ogre_1_1_d3_d11_texture_gpu_window.html#a8791b4406aa0830cc3a46b6cd66d2895">Ogre::D3D11TextureGpuWindow</a>.</p>

</div>
</div>
<a id="aa3efd161b3ec98e3a405cf3167b7d022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3efd161b3ec98e3a405cf3167b7d022">&#9670;&nbsp;</a></span>unsafeScheduleTransitionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::unsafeScheduleTransitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>nextResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules an async transition in residency. </p>
<p>If transitioning from OnStorage to Resident, it will read from file (ResourceGroup was set in createTexture) If transitioning from OnSystemRam to Resident, it will read from the pointer it has. Multiple transitions can be stack together. </p><dl class="section remark"><dt>Remarks</dt><dd>If you're not loading from file (i.e. you're creating it programatically), call _transitionTo &amp; _setNextResidencyStatus directly. Once you've called scheduleTransitionTo at least once, calling _transitionTo is very dangerous, as there are race conditions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_gpu.html#a9034d26bf967a6a9ab6a03f3f2a75a88" title="Same as unsafeScheduleTransitionTo, but first checks if we&#39;re already in the residency state we want ...">TextureGpu::scheduleTransitionTo</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nextResidency</td><td>The residency to change to. </td></tr>
    <tr><td class="paramname">image</td><td>Pointer to image if you want to load the texture from memory instead of loading it from file or a listener. Pointer must be null if this is a manual texture. Pointer must NOT be a stack variable nor be deleted immediately. The actual loading is postponed until the request reaches the worker thread. That means the image pointer is safe to delete once you receive the TextureGpuListener::Reason::ReadyForRendering message. </td></tr>
    <tr><td class="paramname">autoDeleteImage</td><td>Whether we should call "delete image" once we're done using the image. Otherwise you must listen for <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257" title="This Reason is called when TextureGpu::notifyDataIsReady is called.">TextureGpuListener::ReadyForRendering</a> message to know when we're done using the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc608f61167b7b737a4129cd2b85f5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc608f61167b7b737a4129cd2b85f5f4">&#9670;&nbsp;</a></span>waitForData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::waitForData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks main thread until data is ready. </p>
<p>Afterwards isDataReady should return true. If it doesn't, then there was a problem loading the texture. See isMetadataReady remarks.</p>
<p>Q: What's the penalty for calling this function?</p>
<p>A: We need to wait for the worker thread to finish all previous textures until it processes this one. The manager only has broad resolution so it may be also possible that we even have to wait the worker thread to process a few textures that came <em>after</em> this one too.</p>
<p>Thus the cost can be anywhere from "very little" to "a lot" depending on the order in which other textures have been loaded.</p>
<p>The real cost is that you lose valuable ability to hide loading times. If you must call this function, you can mitigate the problem: </p><pre class="fragment">1. All textures you need to wait for, load them *first* together, then
   call TextureGpuManager::waitForStreamingCompletion (preferred) or
   this function. Then proceed to load the rest of the textures.
2. If you can't do the above, call this function as late as possible 
</pre> 
</div>
</div>
<a id="a6740006ae83f39c4aeb83f300b67f6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6740006ae83f39c4aeb83f300b67f6b2">&#9670;&nbsp;</a></span>waitForMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::waitForMetadata </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks main thread until metadata is ready. </p>
<p>Afterwards isMetadataReady should return true. If it doesn't, then there was a problem loading the texture. See isMetadataReady remarks. </p>

</div>
</div>
<a id="af042e9ab52c07776f154ee077330f592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af042e9ab52c07776f154ee077330f592">&#9670;&nbsp;</a></span>writeContentsToFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpu::writeContentsToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>minMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>maxMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automaticResolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the current contents of the render target to the named file. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae48b5ec410564e91ffd7ac70252674c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48b5ec410564e91ffd7ac70252674c3">&#9670;&nbsp;</a></span>mCurrLayout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageLayout Ogre::VulkanTextureGpu::mCurrLayout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current layout we're in. Including any internal stuff. </p>

</div>
</div>
<a id="aa2706154db19568bbb4ddf600ffa6309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2706154db19568bbb4ddf600ffa6309">&#9670;&nbsp;</a></span>mNextLayout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageLayout Ogre::VulkanTextureGpu::mNextLayout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The layout we're expected to be when rendering or doing compute, rather than when doing internal stuff (e.g. </p>
<p>this variable won't contain VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, because that origins from C++ operations and are not expected by the compositor)</p>
<p>When mCurrLayout != mNextLayout, it means that there is already a layout transition that will be happening to achieve mCurrLayout = mNextLayout </p>

</div>
</div>
<a id="a8ec57ce0ef0c682416c3a6b6d13a095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec57ce0ef0c682416c3a6b6d13a095a">&#9670;&nbsp;</a></span>msDefaultOrientationMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga86b4672dfa02cea53b10a52bd6344305">OrientationMode</a> Ogre::TextureGpu::msDefaultOrientationMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PUBLIC VARIABLE. </p>
<p>This variable can be altered directly.</p>
<p>Changes are reflected immediately for new TextureGpus. Existing TextureGpus won't be affected </p>

</div>
</div>
<a id="a3ed2bdf11740fd262b9311a33e33f935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed2bdf11740fd262b9311a33e33f935">&#9670;&nbsp;</a></span>msFinalTextureBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::TextureGpu::msFinalTextureBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43888e98f84f5c9eb9ded14dd0deb34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43888e98f84f5c9eb9ded14dd0deb34d">&#9670;&nbsp;</a></span>msMsaaTextureBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::TextureGpu::msMsaaTextureBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_vulkan_texture_gpu_8h.html">OgreVulkanTextureGpu.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_vulkan_texture_gpu.html">VulkanTextureGpu</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
