
//#include "SyntaxHighlightingMisc.h"
@property( parallax_correct_cubemaps )

@piece( DeclCubemapProbeStruct )
struct CubemapProbe
{
	float4 row0_centerX;
	float4 row1_centerY;
	float4 row2_centerZ;
	float4 halfSize;
	float4 cubemapPosLS;
	float4 cubemapPosVS;
};
@end

@piece( DeclParallaxLocalCorrect )
/** Parallax Correct a reflection dir based on an OBB (Oriented Bounding Box) from a cubemap probe.
\param reflDir
	Reflection dir, in view space.
\param pos
	Position of the object where the reflection is going to reflect, in local space.
	Use toProbeLocalSpace to conver to LS.
\param probe
	Cubemap's probe
\return
	Parallax-Corrected reflection dir, IN LOCAL SPACE (local to probe's).
	Unlike the inputs, this vector is LEFT HANDED.

	The w component contains the distance from pos to intersection walking across reflDir
*/
INLINE float4 localCorrect( float3 reflDir, float3 posLS, CubemapProbe probe )
{
	float3 probeShapeHalfSize	= probe.halfSize.xyz;
	float3x3 viewSpaceToProbeLocal = buildFloat3x3( probe.row0_centerX.xyz,
													probe.row1_centerY.xyz,
													probe.row2_centerZ.xyz );
	float3 reflDirLS = mul( reflDir, viewSpaceToProbeLocal );

	//Find the ray intersection with box plane
	float3 invReflDirLS = float3( 1.0, 1.0, 1.0 ) / reflDirLS;
	float3 intersectAtMinPlane = ( -probeShapeHalfSize - posLS ) * invReflDirLS;
	float3 intersectAtMaxPlane = (  probeShapeHalfSize - posLS ) * invReflDirLS;
	//Get the largest intersection values (we are not intersted in negative values)
	float3 largestIntersect = max( intersectAtMaxPlane.xyz, intersectAtMinPlane.xyz );
	//Get the closest of all solutions
	float distance = min( min( largestIntersect.x, largestIntersect.y ), largestIntersect.z );
	//Get the intersection position
	float3 intersectPositionLS = posLS.xyz + reflDirLS.xyz * distance;
	//Get corrected vector
	float3 localCorrectedVec = intersectPositionLS.xyz - probe.cubemapPosLS.xyz;

	//Make it left-handed.
	localCorrectedVec.z = -localCorrectedVec.z;
	return float4( localCorrectedVec, distance );
}

/** Converts a position from view space to probe's local space.
\param pos
	Position of the object where the reflection is going to reflect, in view space
\return
	Position in local space.
*/
@property( syntax == metal )inline @end float3 toProbeLocalSpace( float3 pos, CubemapProbe probe )
{
	float3 probeShapeCenterVS = float3( probe.row0_centerX.w,
										probe.row1_centerY.w,
										probe.row2_centerZ.w );

	float3x3 viewSpaceToProbeLocal = float3x3( probe.row0_centerX.xyz,
											   probe.row1_centerY.xyz,
											   probe.row2_centerZ.xyz );
	float3 posLS = pos - probeShapeCenterVS;

	@property( syntax == hlsl )
		posLS = mul( viewSpaceToProbeLocal, posLS );
	@end @property( syntax != hlsl )
		posLS = posLS * viewSpaceToProbeLocal;
	@end

	return posLS;
}

/// Returns true if position (in local space) is inside the probe. False otherwise
@property( syntax == metal )inline @end bool isInsideProbe( float3 posLS, CubemapProbe probe )
{
	return !( abs( posLS.x ) > probe.halfSize.x ||
			  abs( posLS.y ) > probe.halfSize.y ||
			  abs( posLS.z ) > probe.halfSize.z );
}

/// Returns value in range (-inf; 1].
/// 1 means being at the center of the probe.
/// 0 means being at the edge of the probe
/// <0 means position is outside the probe.
@property( syntax == metal )inline @end half getProbeFade( half3 posLS, CubemapProbe probe )
{
	half3 vDiff = ( half3_c( probe.halfSize.xyz ) - abs( posLS.xyz ) ) / half3_c( probe.halfSize.xyz );
	return min( min( vDiff.x, vDiff.y ), vDiff.z );
}

INLINE half getProbeNDF( half3 posLS, half3 probeToAreaCenterOffsetLS,
						 half3 innerRange, half3 outerRange )
{
	half3 areaPosLS = posLS.xyz - probeToAreaCenterOffsetLS.xyz;
	//half3 areaPosLS = posLS.xyz - half3_c( 0, 0, -5 );
	half3 dist = abs( areaPosLS.xyz );
	//1e-6f avoids division by zero.
	half3 ndf = (dist - innerRange) / (outerRange - innerRange + _h( 1e-6f ));

	return max3( ndf.x, ndf.y, ndf.z );
}

@end /// DeclParallaxLocalCorrect
@end /// parallax_correct_cubemaps
