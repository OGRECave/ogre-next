// The mapping below is a quadratic fit for log2(perceptualRoughness)+iblRoughnessOneLevel when
// iblRoughnessOneLevel is 4. We found empirically that this mapping works very well for
// a 256 cubemap with 5 levels used. But also scales well for other iblRoughnessOneLevel values.
@piece( envSpecularRoughness ) pixelData.perceptualRoughness * midf_c( passBuf.envMapNumMipmaps ) * ( _h( 2.0 ) - pixelData.perceptualRoughness ) @end
@piece( envSpecularRoughnessClearCoat ) pixelData.clearCoatPerceptualRoughness * midf_c( passBuf.envMapNumMipmaps ) * ( _h( 2.0 ) - pixelData.clearCoatPerceptualRoughness ) @end

@piece( DefaultHeaderPS )
	// START UNIFORM DECLARATION
	@property( !hlms_shadowcaster || alpha_test || hlms_alpha_hash )
		@property( !hlms_shadowcaster )
			@insertpiece( PassStructDecl )
		@end
		@insertpiece( MaterialStructDecl )
		@insertpiece( InstanceStructDecl )
		@insertpiece( AtmosphereNprSkyStructDecl )
	@end
	@insertpiece( custom_ps_uniformStructDeclaration )
	// END UNIFORM DECLARATION

	@property( !fresnel_scalar )
		#define float_fresnel midf
		#define float_fresnel_c( x ) midf_c( x )
		#define make_float_fresnel( x ) midf_c( x )
	@else
		#define float_fresnel midf3
		#define float_fresnel_c( x ) midf3_c( x )
		#define make_float_fresnel( x ) midf3_c( x, x, x )
	@end

	@insertpiece( DeclReverseDepthMacros )

	@property( syntax == metal )
		#define PASSBUF_ARG_DECL , constant PassBuffer &passBuf
		#define PASSBUF_ARG , passBuf
	@else
		#define PASSBUF_ARG_DECL
		#define PASSBUF_ARG
	@end

	@property( hlms_enable_cubemaps_auto )
		@insertpiece( UnpackHelpers )
	@end

	struct PixelData
	{
		@property( !hlms_shadowcaster )
			midf3 normal;
			@property( normal_map )
				midf3 geomNormal;
			@else
				#define geomNormal normal
			@end
			@property( detail_triplanar )
				midf3 worldSpaceNormal;
			@end
			midf4	diffuse;
			midf3	specular;

			@property( clear_coat )
				midf clearCoat;
				midf clearCoatPerceptualRoughness;
				midf clearCoatRoughness;
			@end

			midf	perceptualRoughness;
			midf	roughness;
			float_fresnel	F0;

			@property( needs_view_dir )
				midf3	viewDir;
				midf	NdotV;
			@end

			@property( needs_refl_dir )
				midf3 reflDir;
				@property( needs_env_brdf )
					midf3 envColourS;
					midf3 envColourD;

					@property( clear_coat )
						midf3 clearCoatEnvColourS;
					@end
				@end
			@end
		@else
			midf4 diffuse; //We only use the .w component, Alpha
		@end

		@insertpiece( custom_ps_pixelData )
	};

	#define SampleDetailWeightMap( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx )
	@foreach( detail_maps_diffuse, n )
		@property( detail_map@n )#define SampleDetailCol@n( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx )@end
	@end
	@property( diffuse_map )
		#define SampleDiffuse( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx ) @property( diffuse_map_grayscale ).rrra@end
	@end
	@property( specular_map )
		#define SampleSpecular( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx )
	@end
	@property( roughness_map )
		#define SampleRoughness( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx )
	@end
	@property( emissive_map )
		#define SampleEmissive( tex, sampler, uv, arrayIdx ) OGRE_SampleArray2DF16( tex, sampler, uv, arrayIdx ) @property( emissive_map_grayscale ).rrr@end
	@end
	@property( use_envprobe_map )
		@property( syntax == metal )
			#define SampleEnvProbe( tex, sampler, uv, lod ) OGRE_SampleLevelF16( tex, sampler, float3( uv ), lod )
		@else
			#define SampleEnvProbe( tex, sampler, uv, lod ) OGRE_SampleLevelF16( tex, sampler, uv, lod )
		@end
	@end

	@property( hlms_lights_spot_textured )
		@insertpiece( DeclQuat_zAxis )
		INLINE float3 qmul( float4 q, float3 v )
		{
			return v + 2.0 * cross( cross( v, q.xyz ) + q.w * v, q.xyz );
		}
	@end

	@property( normal_map_tex || detail_maps_normal )
		INLINE midf3 reconstructZfromTSNormal( midf2 tsNormal2 )
		{
			midf3 tsNormal;
			tsNormal.xy = tsNormal2.xy;
			tsNormal.z	= sqrt( max( _h(0.0f), _h(1.0f) - tsNormal.x * tsNormal.x - tsNormal.y * tsNormal.y ) );
			return tsNormal.xyz;
		}

		@property( normal_sampling_format == normal_rg_snorm )
			//Normal texture must be in UV8/RG8_SNORM or BC5S format!
			#define getTSNormal( normalMap, samplerState, uv, normalIdx ) reconstructZfromTSNormal( OGRE_SampleArray2DF16( normalMap, samplerState, uv, normalIdx ).xy )
		@end
		@property( normal_sampling_format == normal_rg_unorm )
			//Normal texture must be in RG8_UNORM or similar format!
			#define getTSNormal( normalMap, samplerState, uv, normalIdx ) reconstructZfromTSNormal( OGRE_SampleArray2DF16( normalMap, samplerState, uv, normalIdx ).xy * 2.0 - 1.0 )
		@end
		@property( normal_sampling_format == normal_bc3_unorm )
			//Normal texture must be in BC3 or similar format!
			#define getTSNormal( normalMap, samplerState, uv, normalIdx ) reconstructZfromTSNormal( OGRE_SampleArray2DF16( normalMap, samplerState, uv, normalIdx ).yw * 2.0 - 1.0 )
		@end
		@property( normal_sampling_format == normal_la )
			//Normal texture must be in LA format!
			#define getTSNormal( normalMap, samplerState, uv, normalIdx ) reconstructZfromTSNormal( OGRE_SampleArray2DF16( normalMap, samplerState, uv, normalIdx ).xw * 2.0 - 1.0 )
		@end
	@end

	@property( obb_restraint_approx || obb_restraint_ltc )
		/// Returns value in range [-inf; 1]
		/// Values <= 0 means 'pos' is outside the obb
		midf getObbRestraintFade( @property( syntax == metal )constant@end  float4 obbRestraint[3],
								  float3 pos, float3 obbFadeFactors )
		{
			float3 obbDistToBounds;
			obbDistToBounds.x = dot( obbRestraint[0].xyzw, float4( pos.xyz, 1.0 ) );
			obbDistToBounds.y = dot( obbRestraint[1].xyzw, float4( pos.xyz, 1.0 ) );
			obbDistToBounds.z = dot( obbRestraint[2].xyzw, float4( pos.xyz, 1.0 ) );
			//Until this point, obbDistToBounds in range [-1;1] means we're inside the OBB.
			obbDistToBounds = abs( obbDistToBounds );

			float3 obbFade = (1.0 - obbDistToBounds) * obbFadeFactors;
			return min( midf_c( min3( obbFade.x, obbFade.y, obbFade.z ) ), _h( 1.0 ) );
		}
	@end

	@property( (hlms_normal || hlms_qtangent) && !hlms_prepass && needs_view_dir )
		@insertpiece( DeclClearCoatFuncs )

		@insertpiece( DeclareBRDF )
		@insertpiece( DeclareBRDF_InstantRadiosity )
		@insertpiece( DeclareBRDF_AreaLightApprox )
	@end

	@insertpiece( DeclVctFuncs )
	@insertpiece( DeclIrradianceFieldFuncs )
	@insertpiece( DeclRefractionsFuncs )
	@insertpiece( DeclIrradianceSH )
	@insertpiece( DeclLightProfilesTextureFuncs )
	@insertpiece( DeclAlphaHashFuncs )
@end


//-----------------------------------------------------------------------------
//		BODY CODE
//-----------------------------------------------------------------------------

@piece( LoadMaterial )
	@property( !lower_gpu_overhead )
		@property( syntax != metal )
            ushort materialId	= worldMaterialIdx[inPs.drawId].x & 0x1FFu;
            #define material materialArray[materialId]
		@else
			#define material materialArray[inPs.materialId]
		@end
	@else
		#define material materialArray[0]
	@end
@end

@piece( UnpackTextureIndices0 )
	@property( syntax == metal )
		@property( diffuse_map )		ushort texIndex_diffuseIdx			= material.diffuseIdx;@end
		@property( detail_weight_map )	ushort texIndex_weightMapIdx		= material.weightMapIdx;@end
		@property( detail_map0 )		ushort texIndex_detailMapIdx0		= material.detailMapIdx0;@end
		@property( detail_map1 )		ushort texIndex_detailMapIdx1		= material.detailMapIdx1;@end
		@property( detail_map2 )		ushort texIndex_detailMapIdx2		= material.detailMapIdx2;@end
		@property( detail_map3 )		ushort texIndex_detailMapIdx3		= material.detailMapIdx3;@end
	@else
		@property( diffuse_map )		ushort texIndex_diffuseIdx			= material.indices0_3.x & 0x0000FFFFu;@end
		@property( detail_weight_map )	ushort texIndex_weightMapIdx		= material.indices0_3.z & 0x0000FFFFu;@end
		@property( detail_map0 )		ushort texIndex_detailMapIdx0		= material.indices0_3.z >> 16u;@end
		@property( detail_map1 )		ushort texIndex_detailMapIdx1		= material.indices0_3.w & 0x0000FFFFu;@end
		@property( detail_map2 )		ushort texIndex_detailMapIdx2		= material.indices0_3.w >> 16u;@end
		@property( detail_map3 )		ushort texIndex_detailMapIdx3		= material.indices4_7.x & 0x0000FFFFu;@end
	@end
@end
@piece( UnpackTextureIndices1 )
	@property( syntax == metal )
		@property( normal_map_tex )		ushort texIndex_normalIdx			= material.normalIdx;@end
		@property( specular_map )		ushort texIndex_specularIdx			= material.specularIdx;@end
		@property( roughness_map )		ushort texIndex_roughnessIdx		= material.roughnessIdx;@end
		@property( detail_map_nm0 )		ushort texIndex_detailNormMapIdx0	= material.detailNormMapIdx0;@end
		@property( detail_map_nm1 )		ushort texIndex_detailNormMapIdx1	= material.detailNormMapIdx1;@end
		@property( detail_map_nm2 )		ushort texIndex_detailNormMapIdx2	= material.detailNormMapIdx2;@end
		@property( detail_map_nm3 )		ushort texIndex_detailNormMapIdx3	= material.detailNormMapIdx3;@end
		@property( emissive_map )		ushort texIndex_emissiveMapIdx		= material.emissiveMapIdx;@end
		@property( use_envprobe_map )	ushort texIndex_envMapIdx			= material.envMapIdx;@end
	@else
		@property( normal_map_tex )		ushort texIndex_normalIdx			= material.indices0_3.x >> 16u;@end
		@property( specular_map )		ushort texIndex_specularIdx			= material.indices0_3.y & 0x0000FFFFu;@end
		@property( roughness_map )		ushort texIndex_roughnessIdx		= material.indices0_3.y >> 16u;@end
		@property( detail_map_nm0 )		ushort texIndex_detailNormMapIdx0	= material.indices4_7.x >> 16u;@end
		@property( detail_map_nm1 )		ushort texIndex_detailNormMapIdx1	= material.indices4_7.y & 0x0000FFFFu;@end
		@property( detail_map_nm2 )		ushort texIndex_detailNormMapIdx2	= material.indices4_7.y >> 16u;@end
		@property( detail_map_nm3 )		ushort texIndex_detailNormMapIdx3	= material.indices4_7.z & 0x0000FFFFu;@end
		@property( emissive_map )		ushort texIndex_emissiveMapIdx		= material.indices4_7.z >> 16u;@end
		@property( use_envprobe_map )	ushort texIndex_envMapIdx			= material.indices4_7.w & 0x0000FFFFu;@end
	@end
@end

@piece( LoadDetailWeights )
	@property( detail_maps_diffuse || detail_maps_normal )
		//Prepare weight map for the detail maps.
		@property( detail_weight_map )
			midf4 detailWeights = SampleDetailWeightMap( textureMaps@value(detail_weight_map_idx),
														  samplerState@value(detail_weight_map_sampler),
														  UV_DETAIL_WEIGHT( inPs.uv@value(uv_detail_weight).xy ),
														  texIndex_weightMapIdx );
			@property( detail_weights )detailWeights *= midf4_c( material.cDetailWeights );@end
		@else
			@property( detail_weights )
				midf4 detailWeights = midf4_c( material.cDetailWeights );
			@else
				midf4 detailWeights = midf4_c( 1.0, 1.0, 1.0, 1.0 );
			@end
		@end
	@end
@end

@piece( SampleDetailMaps )
	/// Sample detail maps and weight them against the weight map in the next foreach loop.
	@foreach( detail_maps_diffuse, n )
		@property( detail_map@n )
			midf4 detailCol@n = SampleDetailCol@n@property( detail_triplanar_diffuse )Triplanar@end ( textureMaps@value(detail_map@n_idx),
													samplerState@value(detail_map@n_sampler),
													UV_DETAIL@n( @property( detail_triplanar )GetTriplanarUVTp( inPs.worldPos, pixelData.worldSpaceNormal )@else inPs.uv@value(uv_detail@n).xy@end @insertpiece( offsetDetail@n ) ),
                                                    texIndex_detailMapIdx@n );
			detailWeights.@insertpiece(detail_swizzle@n) *= detailCol@n.w;
			detailCol@n.w = detailWeights.@insertpiece(detail_swizzle@n);
		@end
	@end
@end

@piece( SampleDiffuseMap )
	/// DIFFUSE MAP
	@property( diffuse_map )
		pixelData.diffuse = SampleDiffuse( textureMaps@value( diffuse_map_idx ),
										   samplerState@value(diffuse_map_sampler),
										   UV_DIFFUSE( inPs.uv@value(uv_diffuse).xy ),
										   texIndex_diffuseIdx );
	@else
		/// If there are no diffuse maps, we must initialize it to some value.
		pixelData.diffuse.xyzw = midf4_c( material.bgDiffuse.xyzw );
	@end

	/// Blend the detail diffuse maps with the main diffuse.
	@foreach( detail_maps_diffuse, n )
		@insertpiece( blend_mode_idx@n ) @add( t, 1 ) @end

	/// Apply the material's diffuse over the textures
	pixelData.diffuse.xyz *= midf3_c( material.kD.xyz );
	@property( transparent_mode || hlms_screen_space_refractions )
		pixelData.diffuse.xyz *= (pixelData.diffuse.w * pixelData.diffuse.w);
	@end

	@property( alpha_test && (!alpha_test_shadow_caster_only || hlms_shadowcaster) )
		if( material.kD.w @insertpiece( alpha_test_cmp_func ) pixelData.diffuse.w )
			discard;
	@end
@end

@piece( SampleSpecularMap )
	/// SPECUlAR MAP
	pixelData.specular.xyz = midf3_c( material.kS.xyz );
	@property( !metallic_workflow )
		pixelData.F0 = float_fresnel_c( material.F0.@insertpiece( FresnelSwizzle ) );
		@property( specular_map && !fresnel_workflow )
			pixelData.specular.xyz *= SampleSpecular( textureMaps@value( specular_map_idx ),
													  samplerState@value(specular_map_sampler),
													  UV_SPECULAR( inPs.uv@value(uv_specular).xy ),
													  texIndex_specularIdx ).xyz;
		@end
		@property( specular_map && fresnel_workflow )
			pixelData.F0 *= SampleSpecular( textureMaps@value( specular_map_idx ),
											samplerState@value(specular_map_sampler),
											UV_SPECULAR( inPs.uv@value(uv_specular).xy ),
											texIndex_specularIdx ).@insertpiece( FresnelSwizzle );
		@end
	@else
		midf metalness = midf_c( material.F0.x );
		@property( specular_map )
			metalness *= SampleSpecular( textureMaps@value( specular_map_idx ),
										 samplerState@value(specular_map_sampler),
										 UV_SPECULAR( inPs.uv@value(uv_specular).xy ),
										 texIndex_specularIdx ).x;
		@end
		pixelData.F0 = lerp( make_float_fresnel( 0.04f ), pixelData.diffuse.xyz * _h( 3.14159f ), metalness );
		pixelData.diffuse.xyz = pixelData.diffuse.xyz - pixelData.diffuse.xyz * metalness;
		@property( hlms_alphablend || hlms_screen_space_refractions )
			pixelData.F0 *= midf_c( material.F0.w ); ///Should this be done for non-metallic as well???
		@end
	@end
	@property( transparent_mode || hlms_screen_space_refractions )
		pixelData.F0 *= pixelData.diffuse.w;
	@end
@end

@piece( SampleRoughnessMap )
	/// ROUGHNESS MAP
	pixelData.perceptualRoughness = midf_c( material.kS.w );
	@property( roughness_map )
		pixelData.perceptualRoughness *=
			SampleRoughness( textureMaps@value( roughness_map_idx ),
							 samplerState@value( roughness_map_sampler ),
							 UV_ROUGHNESS( inPs.uv@value(uv_roughness).xy ),
							 texIndex_roughnessIdx ).x;
	@end

@property( clear_coat )
	// This is a hack but it will do: the base layer must be at least as rough
	// as the clear coat layer to take into account possible diffusion by the
	// top layer
	pixelData.perceptualRoughness = lerp(pixelData.perceptualRoughness,
										 max(pixelData.perceptualRoughness, pixelData.clearCoatPerceptualRoughness),
										 pixelData.clearCoat);
@end

	@property( perceptual_roughness )
		pixelData.roughness = max( pixelData.perceptualRoughness * pixelData.perceptualRoughness, _h( 0.001f ) );
	@else
		pixelData.roughness = max( pixelData.perceptualRoughness, _h( 0.001f ) );
	@end
@end

@property( two_sided_lighting )
	@property( hlms_forwardplus_flipY )
		@piece( two_sided_flip_normal )* (gl_FrontFacing ? -1.0 : 1.0)@end
	@else
		@piece( two_sided_flip_normal )* (gl_FrontFacing ? 1.0 : -1.0)@end
	@end
@end
@piece( LoadGeomNormalData )
	// Geometric normal
	pixelData.geomNormal = normalize( inPs.normal ) @insertpiece( two_sided_flip_normal );
@end
@piece( LoadNormalData )
	@property( normal_map )
		//Normal mapping.
		pixelData.geomNormal = normalize( inPs.normal ) @insertpiece( two_sided_flip_normal );
		midf3 vTangent		= normalize( inPs.tangent );

		@property( hlms_qtangent || hlms_tangent4 )
			@piece( tbnApplyReflection ) * inPs.biNormalReflection@end
		@end

		//Get the TBN matrix
		midf3 vBinormal	= normalize( cross( pixelData.geomNormal, vTangent )@insertpiece( tbnApplyReflection ) );
		midf3x3 TBN		= buildMidf3x3( vTangent, vBinormal, pixelData.geomNormal );

		@property( normal_map_tex )
			pixelData.normal = getTSNormal( textureMaps@value( normal_map_tex_idx ),
											samplerState@value( normal_map_tex_sampler ),
											UV_NORMAL( inPs.uv@value(uv_normal).xy ),
											texIndex_normalIdx );
		@else
			pixelData.normal = midf3_c( 0.0, 0.0, 1.0 );
		@end
		@property( normal_weight_tex )
			// Apply the weight to the main normal map
			pixelData.normal = lerp( midf3_c( 0.0, 0.0, 1.0 ), pixelData.normal, normalMapWeight );
		@end
	@end
@end

@piece( SampleAndApplyDetailNormalMaps )
	/// If there is no normal map, the first iteration must
	/// initialize pixelData.normal instead of try to merge with it.
	@property( normal_map_tex )
		@piece( detail_nm_op_sum )+=@end
		@piece( detail_nm_op_mul )*=@end
	@else
		@piece( detail_nm_op_sum )=@end
		@piece( detail_nm_op_mul )=@end
	@end

	@property( detail_maps_normal )
	   @foreach( 4, n )
		   @property( normal_weight_detail@n )
			   @piece( detail@n_nm_weight_mul ) * midf_c( material.normalWeights.@insertpiece( detail_swizzle@n ) )@end
		   @end
	   @end
	@end

	@foreach( detail_maps_normal, n )
		@piece( SampleDetailMapNm@n )getTSNormal( textureMaps@value(detail_map_nm@n_idx),
												  samplerState@value(detail_map_nm@n_sampler),
												  UV_DETAIL_NM@n( @property( detail_triplanar )GetTriplanarUVTp( inPs.worldPos, pixelData.worldSpaceNormal )@else inPs.uv@value(uv_detail_nm@n).xy@end @insertpiece( offsetDetail@n ) ),
												  texIndex_detailNormMapIdx@n ) * detailWeights.@insertpiece(detail_swizzle@n) @insertpiece( detail@n_nm_weight_mul )@end
	@end

	/// Blend the detail normal maps with the main normal.
	@foreach( second_valid_detail_map_nm, n, first_valid_detail_map_nm )
		float3 vDetail = @insertpiece( SampleDetailMapNm@n );
		pixelData.normal.xy	@insertpiece( detail_nm_op_sum ) vDetail.xy;
		pixelData.normal.z	@insertpiece( detail_nm_op_mul ) vDetail.z + 1.0 - detailWeights.@insertpiece(detail_swizzle@n) @insertpiece( detail@n_nm_weight_mul );
	@end
	@foreach( detail_maps_normal, n, second_valid_detail_map_nm )
		@property( detail_map_nm@n )
			vDetail = @insertpiece( SampleDetailMapNm@n );
			pixelData.normal.xy	+= vDetail.xy;
			pixelData.normal.z	*= vDetail.z + 1.0 - detailWeights.@insertpiece(detail_swizzle@n) @insertpiece( detail@n_nm_weight_mul );
		@end
	@end
@end

@piece( LightingHeader )
	//Everything's in Camera space
	@property( needs_view_dir )
		@property( !hlms_instanced_stereo )
			pixelData.viewDir	= midf3_c( normalize( -inPs.pos ) );
		@else
			if( gl_FragCoord.x > passBuf.rightEyePixelStartX )
				pixelData.viewDir = midf3_c( normalize( -inPs.pos + passBuf.leftToRightView.xyz ) );
			else
				pixelData.viewDir = midf3_c( normalize( -inPs.pos ) );
		@end
		pixelData.NdotV		= saturate( dot( pixelData.normal, pixelData.viewDir ) );
	@end

	@property( !ambient_fixed || vct_num_probes )
		midf3 finalColour = midf3_c(0, 0, 0);
	@else
		midf3 finalColour = midf3_c( passBuf.ambientUpperHemi.xyz ) * pixelData.diffuse.xyz;
	@end

	@property( hlms_static_branch_shadow_map_lights || hlms_lights_point || hlms_lights_spot || hlms_lights_area_approx || hlms_lights_area_ltc )
		float3 lightDir;
		float fDistance;
		midf3 tmpColour;
		midf spotCosAngle;
	@end

	@property( hlms_static_branch_shadow_map_lights )
		const float2 shadowmap_uv_min[@value(hlms_num_shadow_map_lights)] =
			OGRE_ARRAY_START( float2 )
					hlms_shadowmap0_uv_min
					@foreach( hlms_num_shadow_map_lights, n, 1 )
					, hlms_shadowmap@n_uv_min@end
			OGRE_ARRAY_END;
		const float2 shadowmap_uv_max[@value(hlms_num_shadow_map_lights)] =
			OGRE_ARRAY_START( float2 )
				hlms_shadowmap0_uv_max
				@foreach( hlms_num_shadow_map_lights, n, 1 )
				, hlms_shadowmap@n_uv_max@end
			OGRE_ARRAY_END;
		const float2 shadowmap_uv_length[@value(hlms_num_shadow_map_lights)] =
			OGRE_ARRAY_START( float2 )
				hlms_shadowmap0_uv_length
				@foreach( hlms_num_shadow_map_lights, n, 1 )
				, hlms_shadowmap@n_uv_length@end
			OGRE_ARRAY_END;
	@end

	@property( needs_refl_dir )
		pixelData.reflDir = _h( 2.0 ) * dot( pixelData.viewDir, pixelData.normal ) * pixelData.normal -
							pixelData.viewDir;
	@end

	@insertpiece( DoAmbientHeader )
@end

@piece( DoDirectionalLights )
	@property( hlms_lights_directional )
		@insertpiece( ObjLightMaskCmp )
			finalColour += BRDF( midf3_c( light0Buf.lights[0].position.xyz ),
								 midf3_c( light0Buf.lights[0].diffuse.xyz ),
								 midf3_c( light0Buf.lights[0].specular ), pixelData PASSBUF_ARG ) @insertpiece( DarkenWithShadowFirstLight );
	@end
	@foreach( hlms_lights_directional, n, 1 )
		@insertpiece( ObjLightMaskCmp )
			finalColour += BRDF( midf3_c( light0Buf.lights[@n].position.xyz ),
								 midf3_c( light0Buf.lights[@n].diffuse.xyz ),
								 midf3_c( light0Buf.lights[@n].specular ), pixelData PASSBUF_ARG )@insertpiece( DarkenWithShadow );@end

	@property( !hlms_static_branch_lights )
		@foreach( hlms_lights_directional_non_caster, n, hlms_lights_directional )
			@insertpiece( ObjLightMaskCmp )
				finalColour += BRDF( midf3_c( light0Buf.lights[@n].position.xyz ),
									 midf3_c( light0Buf.lights[@n].diffuse.xyz ),
									 midf3_c( light0Buf.lights[@n].specular ), pixelData PASSBUF_ARG );@end
	@else
		for( int n=0; n<floatBitsToInt( light0Buf.numNonCasterDirectionalLights ); ++n )
		{
			int i = @value( hlms_lights_directional ) + n;
			@insertpiece( ObjLightMaskCmpNonCasterLoop )
				finalColour += BRDF( midf3_c( light0Buf.lights[i].position.xyz ),
									 midf3_c( light0Buf.lights[i].diffuse.xyz ),
									 midf3_c( light0Buf.lights[i].specular ), pixelData PASSBUF_ARG );
		}
		/// Increase fineMaskLightIdx to keep it working with spot/point lights
		@insertpiece( ObjLightMaskCmpNonCasterLoopEnd )
	@end
@end

//Point lights
@piece( DoPointLights )
@property( hlms_static_branch_shadow_map_lights )
	int cur_shadow_map = @value(CurrentShadowMap);
	int light_idx = @value(hlms_lights_directional_non_caster);
	const int sm_point_lights_num = floatBitsToInt( passBuf.numShadowMapPointLights );
	const int sm_point_lights_end = light_idx + sm_point_lights_num;
	for( ; light_idx<sm_point_lights_end; light_idx++ )
	{
		lightDir = light0Buf.lights[light_idx].position.xyz - inPs.pos;
		fDistance= length( lightDir );
		if( fDistance <= light0Buf.lights[light_idx].attenuation.x @insertpiece( andObjLightMaskCmp_light_idx ) )
		{
			lightDir *= 1.0 / fDistance;
			tmpColour = BRDF( midf3_c( lightDir ), midf3_c( light0Buf.lights[light_idx].diffuse.xyz ),
							  midf3_c( light0Buf.lights[light_idx].specular ),
							  pixelData PASSBUF_ARG )@insertpiece( DarkenWithShadowPoint_cur_shadow_map );
			midf atten = midf_c( 1.0 / (0.5 + (light0Buf.lights[light_idx].attenuation.y + light0Buf.lights[light_idx].attenuation.z * fDistance) * fDistance ) );
			finalColour += tmpColour * atten;
		}
		cur_shadow_map++;
	}
@else
	@foreach( hlms_lights_point, n, hlms_lights_directional_non_caster )
		lightDir = light0Buf.lights[@n].position.xyz - inPs.pos;
		fDistance= length( lightDir );
		if( fDistance <= light0Buf.lights[@n].attenuation.x @insertpiece( andObjLightMaskCmp ) )
		{
			lightDir *= 1.0 / fDistance;
			tmpColour = BRDF( midf3_c( lightDir ), midf3_c( light0Buf.lights[@n].diffuse.xyz ),
							  midf3_c( light0Buf.lights[@n].specular ),
							  pixelData PASSBUF_ARG )@insertpiece( DarkenWithShadowPoint );
			midf atten = midf_c( 1.0 / (0.5 + (light0Buf.lights[@n].attenuation.y + light0Buf.lights[@n].attenuation.z * fDistance) * fDistance ) );
			finalColour += tmpColour * atten;
		}
	@end
@end
@end

//Spot lights
//spotParams[@value(spot_params)].x = 1.0 / cos( InnerAngle ) - cos( OuterAngle )
//spotParams[@value(spot_params)].y = cos( OuterAngle / 2 )
//spotParams[@value(spot_params)].z = falloff
@piece( DoSpotLights )
@property( hlms_static_branch_shadow_map_lights )
	const int sm_spot_lights_num = floatBitsToInt( passBuf.numShadowMapSpotLights );
	const int sm_spot_lights_end = light_idx + sm_spot_lights_num;
	for( ; light_idx<sm_spot_lights_end; light_idx++ )
	{
		lightDir = light0Buf.lights[light_idx].position.xyz - inPs.pos;
		fDistance= length( lightDir );
		lightDir *= 1.0 / fDistance;
		spotCosAngle = dot( midf3_c( -lightDir ), midf3_c( light0Buf.lights[light_idx].spotDirection.xyz ) );
		if( fDistance <= light0Buf.lights[light_idx].attenuation.x && spotCosAngle >= light0Buf.lights[light_idx].spotParams.y @insertpiece( andObjLightMaskCmp_light_idx ) )
		{
			midf spotAtten = saturate( (spotCosAngle - midf_c( light0Buf.lights[light_idx].spotParams.y )) * midf_c( light0Buf.lights[light_idx].spotParams.x ) );
			spotAtten = pow( spotAtten, midf_c( light0Buf.lights[light_idx].spotParams.z ) );

			@property( light_profiles_texture )
				spotAtten *= getPhotometricAttenuation( spotCosAngle,
														light0Buf.lights[light_idx].lightTexProfileIdx
														OGRE_PHOTOMETRIC_ARG );
			@end

			tmpColour = BRDF( midf3_c( lightDir ), midf3_c( light0Buf.lights[light_idx].diffuse.xyz ),
							  midf3_c( light0Buf.lights[light_idx].specular ),
							  pixelData PASSBUF_ARG )@insertpiece( DarkenWithShadow_cur_shadow_map );
			midf atten = midf_c( 1.0 / (0.5 + (light0Buf.lights[light_idx].attenuation.y + light0Buf.lights[light_idx].attenuation.z * fDistance) * fDistance ) );
			finalColour += tmpColour * (atten * spotAtten);
		}
		cur_shadow_map++;
	}
@else
	@foreach( hlms_lights_spot, n, hlms_lights_point )
		lightDir = light0Buf.lights[@n].position.xyz - inPs.pos;
		fDistance= length( lightDir );
		lightDir *= 1.0 / fDistance;
		@property( !hlms_lights_spot_textured )
			spotCosAngle = dot( midf3_c( -lightDir ), midf3_c( light0Buf.lights[@n].spotDirection.xyz ) );
		@else
			spotCosAngle = dot( midf3_c( -lightDir ), zAxis( midf4_c( light0Buf.lights[@n].spotQuaternion ) ) );
		@end
		if( fDistance <= light0Buf.lights[@n].attenuation.x && spotCosAngle >= light0Buf.lights[@n].spotParams.y @insertpiece( andObjLightMaskCmp ) )
		{
			@property( hlms_lights_spot_textured )
				float3 posInLightSpace = qmul( spotQuaternion[@value(spot_params)], inPs.pos );
				midf spotAtten = texture( texSpotLight, normalize( posInLightSpace ).xy ).x; //TODO
			@else
				midf spotAtten = saturate( (spotCosAngle - midf_c( light0Buf.lights[@n].spotParams.y )) * midf_c( light0Buf.lights[@n].spotParams.x ) );
				spotAtten = pow( spotAtten, midf_c( light0Buf.lights[@n].spotParams.z ) );
			@end

			@property( light_profiles_texture )
				spotAtten *= getPhotometricAttenuation( spotCosAngle,
														light0Buf.lights[@n].lightTexProfileIdx
														OGRE_PHOTOMETRIC_ARG );
			@end

			tmpColour = BRDF( midf3_c( lightDir ), midf3_c( light0Buf.lights[@n].diffuse.xyz ),
							  midf3_c( light0Buf.lights[@n].specular ),
							  pixelData PASSBUF_ARG )@insertpiece( DarkenWithShadow );
			midf atten = midf_c( 1.0 / (0.5 + (light0Buf.lights[@n].attenuation.y + light0Buf.lights[@n].attenuation.z * fDistance) * fDistance ) );
			finalColour += tmpColour * (atten * spotAtten);
		}
	@end
@end
@end

@piece( DoEmissiveLight )
	@property( emissive_map || emissive_constant )
		///Emissive is not part of PixelData because emissive can just be accumulated to finalColour
		@property( emissive_map )
			midf3 emissiveCol = SampleEmissive( textureMaps@value( emissive_map_idx ),
												samplerState@value(emissive_map_sampler),
												UV_EMISSIVE( inPs.uv@value(uv_emissive).xy ),
												texIndex_emissiveMapIdx ).xyz;
			@property( emissive_constant )
				emissiveCol *= midf3_c( material.emissive.xyz );
			@end
			@property( emissive_as_lightmap )
				emissiveCol *= pixelData.diffuse.xyz;
			@end
			finalColour += emissiveCol;
		@else
			finalColour += midf3_c( material.emissive.xyz );
		@end
	@end
@end

@piece( CubemapManualPcc )
	midf3 posInProbSpace = midf3_c( toProbeLocalSpace( inPs.pos, @insertpiece( pccProbeSource ) ) );
	midf probeFade = getProbeFade( posInProbSpace, @insertpiece( pccProbeSource ) );
@property( vct_num_probes )
	if( probeFade > _h( 0 ) && (pixelData.roughness < _h( 1.0f ) || vctSpecular.w == 0) )
@else
	if( probeFade > _h( 0 ) )
@end
	{
		probeFade = saturate( probeFade * _h( 200.0 ) );
		@property( vct_num_probes )
			midf4 reflDirLS_dist = localCorrect( pixelData.reflDir, posInProbSpace, @insertpiece( pccProbeSource ) );
			midf3 reflDirLS = reflDirLS_dist.xyz;
		@else
			midf3 reflDirLS = localCorrect( pixelData.reflDir, posInProbSpace, @insertpiece( pccProbeSource ) ).xyz;
		@end
		midf3 nNormalLS = localCorrect( pixelData.normal, posInProbSpace, @insertpiece( pccProbeSource ) ).xyz;
		midf4 envS = SampleEnvProbe( texEnvProbeMap, samplerState@value(envMapRegSampler),
									 reflDirLS, @insertpiece( envSpecularRoughness ) );
		@property( envmap_scale )
			envS.xyz *= midf3_c( passBuf.ambientUpperHemi.w );
		@end
		@property( cubemaps_as_diffuse_gi )
			midf3 envD = SampleEnvProbe( texEnvProbeMap, samplerState@value(envMapRegSampler),
										 nNormalLS, 11.0 ).xyz @insertpiece( ApplyEnvMapScale );
			envD.xyz *= probeFade;
		@end

		envS.xyz *= probeFade;

		@property( clear_coat )
			midf3 clearCoatEnvS = SampleEnvProbe( texEnvProbeMap, samplerState@value( envMapRegSampler ),
												  reflDirLS,
												  @insertpiece( envSpecularRoughnessClearCoat ) ).xyz @insertpiece( ApplyEnvMapScale );
			clearCoatEnvS *= probeFade;
		@end

		@property( vct_num_probes )
			float vctLerp = getPccVctBlendWeight( inPs.pos, pixelData.reflDir, reflDirLS_dist.w,
												  pixelData.roughness,
												  @insertpiece( pccProbeSource ).cubemapPosVS.xyz,
												  vctSpecPosVS, vctSpecular.w,
												  passBuf.pccVctMinDistance,
												  passBuf.invPccVctInvDistance,
												  envS.w );

			pixelData.envColourS = lerp( envS.xyz, pixelData.envColourS, vctLerp );
			@property( cubemaps_as_diffuse_gi )
				pixelData.envColourD += vctSpecular.w > 0 ? midf3_c( 0, 0, 0 ) : envD;
			@end

			@property( clear_coat )
				pixelData.clearCoatEnvColourS = lerp( clearCoatEnvS, pixelData.clearCoatEnvColourS, vctLerp );
			@end
		@else
			pixelData.envColourS += envS.xyz;
			@property( cubemaps_as_diffuse_gi )
				pixelData.envColourD += envD;
			@end

			@property( clear_coat )
				pixelData.clearCoatEnvColourS += clearCoatEnvS;
			@end
		@end
	}
@end

@piece( CubemapGlobal )
	pixelData.envColourS += SampleEnvProbe( texEnvProbeMap, samplerState@value(envMapRegSampler),
											mul( pixelData.reflDir, midf3x3_c( passBuf.invViewMatCubemap ) ),
											@insertpiece( envSpecularRoughness ) ).xyz @insertpiece( ApplyEnvMapScale );
	@property( cubemaps_as_diffuse_gi )
		pixelData.envColourD += SampleEnvProbe( texEnvProbeMap, samplerState@value(envMapRegSampler),
												mul( pixelData.normal, midf3x3_c( passBuf.invViewMatCubemap ) ),
												11.0 ).xyz @insertpiece( ApplyEnvMapScale );
	@end

	@property( clear_coat )
		pixelData.clearCoatEnvColourS += SampleEnvProbe( texEnvProbeMap, samplerState@value( envMapRegSampler ),
														 mul( pixelData.reflDir, midf3x3_c( passBuf.invViewMatCubemap ) ),
														 @insertpiece( envSpecularRoughnessClearCoat ) ).xyz @insertpiece( ApplyEnvMapScale );
	@end
@end

@piece( ProcessAlpha )
	@property( hlms_alphablend || hlms_alpha_to_coverage || hlms_alpha_hash )
		@property( use_texture_alpha )
			float finalAlpha = midf_c( material.F0.w ) * pixelData.diffuse.w;
		@else
			float finalAlpha = midf_c( material.F0.w );
		@end

		@property( hlms_alpha_hash )
			@property( hlms_alpha_to_coverage )
				finalAlpha = AlphaHashReject( finalAlpha, inPs.uv0.xy ALPHA_HASHING_ARG );
			@else
				if( AlphaHashReject( finalAlpha, inPs.uv0.xy ALPHA_HASHING_ARG ) )
					discard;
			@end
		@end
	@else
		midf finalAlpha = _h( 1.0f );
	@end
@end

@property( !hlms_shadowcaster )
@piece( DefaultBodyPS )
	@property( hlms_emulate_clip_distances && hlms_global_clip_planes && hlms_pso_clip_distances && syntax == glslvk )
		@foreach( hlms_pso_clip_distances, n )
			if( inPs.clipDistance@n < 0.0 )
				discard;
		@end
	@end

	@property( hlms_screen_pos_uv )
		float2 screenPosUv = gl_FragCoord.xy * passBuf.invWindowRes.xy;
	@end
	@property( hlms_screen_pos_int )
		rshort2 iFragCoord =
			rshort2( gl_FragCoord.x,
					 @property( !hlms_forwardplus_flipY && syntax == glsl )passBuf.windowResolution.y - @end
					 gl_FragCoord.y );
	@end

	@property( hlms_normal || hlms_qtangent )
		PixelData pixelData;

		@insertpiece( LoadMaterial )
		@insertpiece( UnpackTextureIndices0 )
		@insertpiece( UnpackTextureIndices1 )
		@insertpiece( DeclareObjLightMask )
		@insertpiece( custom_ps_posMaterialLoad )

		@insertpiece( LoadDetailWeights )

		@insertpiece( SampleDetailMaps )

		@property( !hlms_prepass || alpha_test || hlms_alpha_hash )
			@insertpiece( SampleDiffuseMap )
		@end

		@insertpiece( SampleSpecularMap )
		@insertpiece( LoadClearCoat )
		@insertpiece( SampleRoughnessMap )

@property( hlms_bake_lighting_only )
		pixelData.diffuse.xyz	= float3( 1.0f, 1.0f, 1.0f );
		pixelData.specular.xyz	= float3( 0.0f, 0.0f, 0.0f );
@end

		@property( !hlms_use_prepass )
			@insertpiece( LoadGeomNormalData )
		@end

		@insertpiece( forwardPlusDoDecals )

		@property( !hlms_use_prepass )
			@insertpiece( LoadNormalData )
			@insertpiece( SampleAndApplyDetailNormalMaps )

			@insertpiece( custom_ps_posSampleNormal )

			@insertpiece( forwardPlusApplyDecalsNormal )

			@property( normal_map )
				pixelData.normal = normalize( mul( TBN, pixelData.normal ) );
			@end

			@insertpiece( DoDirectionalShadowMaps )

		@end @property( hlms_use_prepass )
			@property( hlms_use_prepass_msaa )
				//SV_Coverage/gl_SampleMaskIn is always before depth & stencil tests,
				//so we need to perform the test ourselves
				//See http://www.yosoygames.com.ar/wp/2017/02/beware-of-sv_coverage/
				uint sampleMask = uint( gl_SampleMaskIn0 );
				float msaaDepth;
				uint subsampleDepthMask;
				float pixelDepthZ;
				float pixelDepthW;
				float2 pixelDepthZW;
				float pixelDepth;
				int intPixelDepth;
				int intMsaaDepth;
				//Unfortunately there are precision errors, so we allow some ulp errors.
				//200 & 5 are arbitrary, but were empirically found to be very good values.
				int ulpError = int( lerp( 200.0, 5.0, gl_FragCoord.z ) );
				@foreach( hlms_use_prepass_msaa, n )
					pixelDepthZW = interpolateAtSample( inPs.zwDepth, @n );
					pixelDepthZ = pixelDepthZW.x;
					pixelDepthW = pixelDepthZW.y;
					pixelDepth = pixelDepthZ / pixelDepthW;
					msaaDepth = OGRE_Load2DMS( gBuf_depthTexture, iFragCoord.xy, @n ).x;
					intPixelDepth = floatBitsToInt( pixelDepth );
					intMsaaDepth = floatBitsToInt( msaaDepth );
					subsampleDepthMask = (abs( intPixelDepth - intMsaaDepth ) <= ulpError) ? 0xffffffffu : ~(1u << @nu);
					//subsampleDepthMask = int( (pixelDepth <= msaaDepth) ? 0xffffffffu : ~(1u << @nu) );
					sampleMask &= subsampleDepthMask;
				@end

				sampleMask = sampleMask == 0u ? 1u : sampleMask;

				int gBufSubsample = int( findLSB( sampleMask ) );

				pixelData.normal = normalize( OGRE_Load2DMSF16( gBuf_normals, iFragCoord, gBufSubsample ).xyz * _h( 2.0 ) - _h( 1.0 ) );
				midf2 shadowRoughness = OGRE_Load2DMSF16( gBuf_shadowRoughness, iFragCoord, gBufSubsample ).xy;
			@else
				pixelData.normal = normalize( OGRE_Load2DF16( gBuf_normals, iFragCoord, 0 ).xyz * _h( 2.0 ) - _h( 1.0 ) );
				midf2 shadowRoughness = OGRE_Load2DF16( gBuf_shadowRoughness, iFragCoord, 0 ).xy;
			@end

			midf fShadow = shadowRoughness.x;

			@property( roughness_map )
				pixelData.roughness = shadowRoughness.y * _h( 0.98 ) + _h( 0.02 );
			@end
		@end

		@property( !hlms_prepass )
			@insertpiece( LightingHeader )

			@insertpiece( custom_ps_preLights )

			@property( !custom_disable_directional_lights )
				@insertpiece( DoDirectionalLights )
			@end

			@insertpiece( DoPointLights )
			@insertpiece( DoSpotLights )

			@insertpiece( DoAreaApproxLights )
			@insertpiece( DoAreaLtcLights )

			@insertpiece( forward3dLighting )

			@property( needs_env_brdf )
				pixelData.envColourS = midf3_c( 0, 0, 0 );
				pixelData.envColourD = midf3_c( 0, 0, 0 );

				@property( clear_coat )
					pixelData.clearCoatEnvColourS = midf3_c( 0, 0, 0 );
				@end
			@end

			@insertpiece( applyVoxelConeTracing )
			@insertpiece( applyIrradianceField )

			@insertpiece( forwardPlusDoCubemaps )
			@insertpiece( applyIrradianceVolumes )

			@insertpiece( DoEmissiveLight )

			@property( use_envprobe_map )
				@property( use_parallax_correct_cubemaps && !hlms_enable_cubemaps_auto )
					@insertpiece( CubemapManualPcc )
				@end @property( !use_parallax_correct_cubemaps )
					@insertpiece( CubemapGlobal )
				@end
			@end

			@property( hlms_use_ssr )
				//TODO: SSR pass should be able to combine global & local cubemap.
				float4 ssrReflection = OGRE_Load2D( ssrTexture, iFragCoord, 0 ).xyzw;
				@property( use_envprobe_map )
					pixelData.envColourS = lerp( pixelData.envColourS.xyz, ssrReflection.xyz, ssrReflection.w );
				@else
					pixelData.envColourS += ssrReflection.xyz * ssrReflection.w;
				@end
			@end

			@insertpiece( DoPlanarReflectionsPS )

			@insertpiece( DoAmbientLighting )

			@property( needs_env_brdf )
				@insertpiece( BRDF_EnvMap )
			@end

			@insertpiece( applyRefractions )

			@property( hlms_fog )
				const float distToCamera = length( inPs.pos.xyz );
				const midf luminance = dot( finalColour.xyz,
											midf3_c( _h( 0.212655 ), _h( 0.715158 ), _h( 0.072187 ) ) );
				const midf lumFogWeight = max( exp2( atmoSettings.fogBreakFalloff * luminance +
													 atmoSettings.fogBreakMinBrightness ),
											   _h( 0.0 ) );
				midf fogWeight = midf_c( exp2( -distToCamera * atmoSettings.fogDensity ) );
				fogWeight = lerp( _h( 1.0 ), fogWeight, lumFogWeight );
				finalColour.xyz = lerp( inPs.fog.xyz, finalColour.xyz, fogWeight );
			@end
		@end ///!hlms_prepass

	@end ///!hlms_normal || hlms_qtangent

	@property( !hlms_render_depth_only )
		@property( !hlms_prepass )
			@property( hlms_normal || hlms_qtangent )
				@property( !hw_gamma_write )
					//Linear to Gamma space
					outPs_colour0.xyz	= sqrt( finalColour );
				@else
					outPs_colour0.xyz	= finalColour;
				@end

				@insertpiece( ProcessAlpha )
				outPs_colour0.w = finalAlpha;

				@property( debug_pssm_splits )
					outPs_colour0.xyz = lerp( outPs_colour0.xyz, debugPssmSplit.xyz, _h( 0.2f ) );
				@end				
				@property( hlms_gen_normals_gbuffer )
					outPs_normals = midf4_c( pixelData.normal * _h( 0.5 ) + _h( 0.5 ), 1.0 );
				@end
			@else
				outPs_colour0 = midf4_c( 1.0, 1.0, 1.0, 1.0 );
				@property( hlms_gen_normals_gbuffer )
					outPs_normals = midf4_c( 0.5, 0.5, 1.0, 1.0 );
				@end
			@end
		@else
			outPs_normals = midf4_c( pixelData.normal * _h( 0.5 ) + _h( 0.5 ), 1.0 );
			@property( hlms_pssm_splits )
				outPs_shadowRoughness	= midf2_c( fShadow, (pixelData.roughness - 0.02) * 1.02040816 );
			@end @property( !hlms_pssm_splits )
				outPs_shadowRoughness	= midf2_c( 1.0, (pixelData.roughness - 0.02) * 1.02040816 );
			@end
		@end
	@else /// hlms_render_depth_only
		@insertpiece( ProcessAlpha )
	@end
@end ///DefaultBodyPS
@else ///!hlms_shadowcaster

@piece( DefaultBodyPS )
	@property( alpha_test || hlms_alpha_hash )
		PixelData pixelData;
		@insertpiece( LoadMaterial )
		@insertpiece( UnpackTextureIndices0 )
		@insertpiece( LoadDetailWeights )
		@insertpiece( SampleDetailMaps )
		@insertpiece( SampleDiffuseMap )
	@end
	@insertpiece( DoShadowCastPS )
	@property( hlms_alpha_hash )
		@insertpiece( ProcessAlpha )
	@end
@end

@end
