// NPR = Non-Physically-based Rendering Atmo

//#include "SyntaxHighlightingMisc.h"

// @property( atmosky_npr )

// @piece( DeclAtmosphereNprSkyFuncs )

// See https://en.wikipedia.org/wiki/Rayleigh_distribution
// It's inspired, not fully based.
//
// The formula also gives us the nice property that for inputs
// where absorption is in range [0; 1] the output i also in range [0; 1]
float3 getSkyRayleighAbsorption( float3 vDir, const float density )
{
	float3 absorption = -density * vDir;
	absorption = exp2( absorption ) * 2.0f;
	return absorption;
}

float3 pow3( float3 v, float e )
{
	return float3( pow( v.x, e ), pow( v.y, e ), pow( v.z, e ) );
}

// @endpiece

// @piece( DoAtmosphereNprSky )
// clang-format off
#define p_densityCoeff			atmoSettings.densityCoeff
#define p_lightDensity			atmoSettings.lightDensity
#define p_sunHeight				atmoSettings.sunHeight
#define p_sunHeightWeight		atmoSettings.sunHeightWeight
#define p_skyLightAbsorption	atmoSettings.skyLightAbsorption.xyz
#define p_sunAbsorption			atmoSettings.sunAbsorption.xyz
#define p_cameraDisplacement	atmoSettings.cameraDisplacement
#define p_mieAbsorption			atmoSettings.packedParams1.xyz
#define p_finalMultiplier		atmoSettings.packedParams1.w
#define p_sunDir				atmoSettings.packedParams2.xyz
#define p_borderLimit			atmoSettings.packedParams2.w
#define p_skyColour				atmoSettings.packedParams3.xyz
#define p_densityDiffusion		atmoSettings.packedParams3.w
// clang-format on

const float3 cameraPos = float3( atmoSettings.skyLightAbsorption.w, atmoSettings.sunAbsorption.w,
								 atmoSettings.cameraDisplacement.w );
float3 cameraDir = worldPos.xyz - cameraPos;
float distToCamera = length( cameraDir );
float3 atmoCameraDir = cameraDir * ( 1.0f / distToCamera );

const float LdotV = max( dot( atmoCameraDir, p_sunDir ), 0.0f );

atmoCameraDir.y += p_densityDiffusion * 0.075f * ( 1.0f - atmoCameraDir.y ) * ( 1.0f - atmoCameraDir.y );
atmoCameraDir += p_cameraDisplacement.xyz;
atmoCameraDir = normalize( atmoCameraDir );

atmoCameraDir.y = max( atmoCameraDir.y, p_borderLimit );
atmoCameraDir.y = atmoCameraDir.y * 0.9f + 0.1f;
atmoCameraDir = normalize( atmoCameraDir );

const float LdotV360 = dot( atmoCameraDir, p_sunDir ) * 0.5f + 0.5f;

// ptDensity gets smaller as sunHeight gets bigger
// ptDensity gets smaller as atmoCameraDir.y gets bigger
const float ptDensity =
	p_densityCoeff / pow( max( atmoCameraDir.y / ( 1.0f - p_sunHeight ), 0.0035f ), p_densityDiffusion );

const float antiMie = max( p_sunHeightWeight, 0.08f );

const float3 skyAbsorption = getSkyRayleighAbsorption( p_skyColour, ptDensity );
// const float3 skyColourGradient = pow3( exp2( -atmoCameraDir.y / p_skyColour ),
//										 lerp( 15.5f, 1.5f, pow( p_sunHeightWeight, 0.5f ) ) );
const float3 skyColourGradient = pow3( exp2( -atmoCameraDir.y / p_skyColour ), 1.5f );

const float mie = LdotV360;

float3 atmoColour = float3( 0.0f, 0.0f, 0.0f );

const float3 sharedTerms = skyColourGradient * skyAbsorption;

atmoColour += antiMie * sharedTerms * p_sunAbsorption;
atmoColour += ( mie * ptDensity * p_lightDensity ) * sharedTerms * p_skyLightAbsorption;
atmoColour += mie * p_mieAbsorption;
atmoColour *= p_lightDensity;

atmoColour *= p_finalMultiplier;

outVs.fog.xyz = atmoColour;
// @end

// @end
